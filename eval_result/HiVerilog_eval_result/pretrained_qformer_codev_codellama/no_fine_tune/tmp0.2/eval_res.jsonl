{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3, lt0, lt1, lt2, lt3, eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\nassign prod = x * y;\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nwire [7:0] prod0, prod1, prod2, prod3;\n\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod0)\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod1)\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod2)\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod3)\n);\n\n// Combine the 4 products\nassign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\n// 8-bit multiplier module\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Selecting the result based on the mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(multiplication_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] rev_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(rev_din)\n    );\n\n    bit_reverse br2 (\n        .din(rev_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & ~gt_bits[0]) |\n                (gt_bits[3] & gt_bits[2] & ~gt_bits[1] & gt_bits[0]) | (gt_bits[3] & ~gt_bits[2] & gt_bits[1] & gt_bits[0]) |\n                (gt_bits[3] & ~gt_bits[2] & gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) |\n                (~gt_bits[3] & gt_bits[2] & gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & gt_bits[2] & ~gt_bits[1] & gt_bits[0]) |\n                (~gt_bits[3] & ~gt_bits[2] & gt_bits[1] & gt_bits[0]);\n\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & ~lt_bits[0]) |\n                (lt_bits[3] & lt_bits[2] & ~lt_bits[1] & lt_bits[0]) | (lt_bits[3] & ~lt_bits[2] & lt_bits[1] & lt_bits[0]) |\n                (lt_bits[3] & ~lt_bits[2] & lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) |\n                (~lt_bits[3] & lt_bits[2] & lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & lt_bits[2] & ~lt_bits[1] & lt_bits[0]) |\n                (~lt_bits[3] & ~lt_bits[2] & lt_bits[1] & lt_bits[0]);\n\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]) | (eq_bits[3] & eq_bits[2] & eq_bits[1] & ~eq_bits[0]) |\n                (eq_bits[3] & eq_bits[2] & ~eq_bits[1] & eq_bits[0]) | (eq_bits[3] & ~eq_bits[2] & eq_bits[1] & eq_bits[0]) |\n                (eq_bits[3] & ~eq_bits[2] & eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]) |\n                (~eq_bits[3] & eq_bits[2] & eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & eq_bits[2] & ~eq_bits[1] & eq_bits[0]) |\n                (~eq_bits[3] & ~eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A & ~B);\n    assign lt = (~A & B);\n    assign eq = (A & B);\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] sum_temp;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(sum_temp)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = sum_temp;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\nwire [7:0] result;\n\n// Instantiate the 8-bit adder\nmy_adder8 adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\n// Control logic to select output\nalways @(*) begin\n    if (ctrl) begin\n        sum = result;\n    end else begin\n        sum = 8'b0;\n    end\nend\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3;\n    wire lt0, lt1, lt2, lt3;\n    wire eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assign outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic to decide output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] sum_temp;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(sum_temp)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = sum_temp;\n        end else begin\n            sum = 0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Operation selection\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\n\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    reg_fetch_reg ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    reg_fetch_ram ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule reg_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule reg_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires to hold intermediate results\nwire [31:0] sum_result;\nwire [31:0] diff_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder, subtractor, AND, and OR modules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff_result)\n);\n\nand_module u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_module u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Selecting the operation based on the operation selector\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum_result;\n        2'b01: result <= diff_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND module\nmodule and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR module\nmodule or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selector logic\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    // Carry out and borrow out are determined by the operation\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule instruction_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule\n\nmodule instruction_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Instantiate the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\n// Select the operation based on the selector input\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= u_adder.sum;\n        2'b01: result <= u_subtractor.diff;\n        2'b10: result <= u_and.out;\n        2'b11: result <= u_or.out;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Select the operation based on the op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instance of the instruction fetcher for registers\n    instruction_fetch ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    // Instance of the instruction fetcher for RAM/ROM\n    instruction_fetch ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // Assign the outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad12;\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\n\nendmodule\n\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire pwm_25_out, pwm_50_out, pwm_75_out;\n\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    // Output assignments\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] counter;\n    reg pwm_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter < 10000000) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n                pwm_out <= 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_out;\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] counter;\n    reg pwm_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter < 5000000) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n                pwm_out <= 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_out;\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] counter;\n    reg pwm_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter < 7500000) begin\n                counter <= counter + 1;\n            end else begin\n                counter <= 0;\n                pwm_out <= 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_out;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(code_temp[0]));\n\n    // Assign output code and valid signal\n    assign code = code_temp;\n    assign valid = |code_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !highest;\n    assign valid = in;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Selecting the operation based on the op_sel input\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(highest[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest(highest[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest(highest[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest(highest[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest(highest[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest(highest[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest(highest[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest(highest[1]), .valid(valid));\n\n    // Assign the highest priority bit to the output code\n    assign code = highest;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n    wire highest_temp;\n\n    // Check if the input is '1' and if it is the highest order '1'\n    assign highest_temp = (in && !highest);\n\n    // Assign the highest priority bit to the output\n    assign highest = highest_temp;\n\n    // Set valid to '1' if the input is '1'\n    assign valid = in;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = |in;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !highest;\n    assign valid = highest | valid;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation result based on the op_sel signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// PWM module with 25% duty cycle\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// PWM module with 50% duty cycle\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// PWM module with 75% duty cycle\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest_bit;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest_bit(highest_bit[1]), .valid(valid));\n\n    // Assign the highest bit to the output code\n    assign code = highest_bit;\n\nendmodule\n\nmodule check_bit(in, highest_bit, valid);\n    input in;\n    output highest_bit;\n    output valid;\n\n    wire is_highest_bit;\n\n    // Check if the bit is the highest order '1'\n    assign is_highest_bit = (in && !highest_bit);\n\n    // Check if the bit is the highest order '1' and set the output\n    assign highest_bit = in ? 1'b1 : highest_bit;\n    assign valid = valid || is_highest_bit;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h20),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] add_result;\nwire [15:0] sub_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd64),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter DUTY_CYCLE = 25; // Duty cycle in percentage\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < (100000000 / DUTY_CYCLE)) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= 0;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < (100000000 / DUTY_CYCLE)) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= 0;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter DUTY_CYCLE = 75; // Duty cycle in percentage\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < (100000000 / DUTY_CYCLE)) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= 0;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [3:0] GPP0, GPP1, GPP2, GPP3;\n    wire [7:0] A4BS0, A4BS1, A4BS2;\n\n    // Generate partial products\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(1'b0), .sum(GPP0), .cout(A4BS0[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(A4BS0[0]), .sum(GPP1), .cout(A4BS1[0]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(A4BS1[0]), .sum(GPP2), .cout(A4BS2[0]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(A4BS2[0]), .sum(GPP3), .cout(A4BS2[7]));\n\n    // Generate the final product\n    assign product = {GPP3, GPP2, GPP1, GPP0};\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n            default: q <= 8'b00000000;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each nibble\n    nibble_adder add1(.A(A[1:1]), .B(B[1:1]), .C_in(1'b0), .S(S[1:1]), .C_out(c1));\n    nibble_adder add2(.A(A[2:2]), .B(B[2:2]), .C_in(c1), .S(S[2:2]), .C_out(c2));\n    nibble_adder add3(.A(A[3:3]), .B(B[3:3]), .C_in(c2), .S(S[3:3]), .C_out(c3));\n    nibble_adder add4(.A(A[4:4]), .B(B[4:4]), .C_in(c3), .S(S[4:4]), .C_out(c4));\n\n    // Carry-out is the carry out of the last adder\n    assign C_out = c4;\nendmodule\n\nmodule nibble_adder(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out wires\n\n    // Instantiate 2-bit full adders for each bit\n    full_adder fa1(.A(A[1:1]), .B(B[1:1]), .C_in(C_in), .S(S[1:1]), .C_out(c1));\n    full_adder fa2(.A(A[2:2]), .B(B[2:2]), .C_in(c1), .S(S[2:2]), .C_out(c2));\n\n    // Carry-out is the carry out of the last adder\n    assign C_out = c2;\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (A & C_in) | (B & C_in); // Carry-out calculation\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Select the output based on the sel input\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adders for each bit position\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(shifted_sum0[0]));\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(shifted_sum0[0]), .sum(sum1), .cout(shifted_sum1[1]));\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(shifted_sum1[1]), .sum(sum2), .cout(shifted_sum2[2]));\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(shifted_sum2[2]), .sum(sum3), .cout(shifted_sum3[3]));\n\n// Shift registers\nreg [7:0] shifted_sum0_reg, shifted_sum1_reg, shifted_sum2_reg, shifted_sum3_reg;\nalways @(*) begin\n    shifted_sum0_reg = {shifted_sum0[6:0], sum0};\n    shifted_sum1_reg = {shifted_sum1[6:0], sum1};\n    shifted_sum2_reg = {shifted_sum2[6:0], sum2};\n    shifted_sum3_reg = {shifted_sum3[6:0], sum3};\nend\n\nassign product = shifted_sum3_reg;\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nwire c1, c2;\n\nxor x1(a, b, sum);\nand a1(a, b, c1);\nand a2(a, ~b, c2);\nor o1(c1, cin, cout);\nor o2(c2, ~cin, c1);\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output the last flip-flop's output\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of cycles for 25% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 50; // Number of cycles for 50% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 25; // Number of cycles for 75% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry wire for each 4-bit block\n\n    // Instantiate 4-bit full adders for each 4-bit block\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(carry[1]),\n        .S(S[8:5]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(carry[2]),\n        .S(S[12:9]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(carry[3]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:2] sum;       // 4-bit sum\n    wire [3:2] carry;     // Carry wire for each bit\n\n    // 4-bit full adder for each bit\n    full_adder fa0(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(sum[1]),\n        .C_out(carry[1])\n    );\n\n    full_adder fa1(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(carry[1]),\n        .S(sum[2]),\n        .C_out(carry[2])\n    );\n\n    full_adder fa2(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(carry[2]),\n        .S(sum[3]),\n        .C_out(carry[3])\n    );\n\n    // Output sum and carry\n    assign S = {sum[3], sum[2], sum[1]};\n    assign C_out = carry[3];\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect the outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect the outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adder for A\ngp_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum1[0]), .cout(sum1[1]));\ngp_4bit GPP1(.a(a[1]), .b(b[1]), .cin(sum1[1]), .sum(sum1[2]), .cout(sum1[3]));\ngp_4bit GPP2(.a(a[2]), .b(b[2]), .cin(sum1[3]), .sum(sum1[4]), .cout(sum1[5]));\ngp_4bit GPP3(.a(a[3]), .b(b[3]), .cin(sum1[5]), .sum(sum1[6]), .cout(sum1[7]));\n\n// 4-bit full adder for B\ngp_4bit A4BS0(.a(b[0]), .b(0), .cin(0), .sum(sum2[0]), .cout(sum2[1]));\ngp_4bit A4BS1(.a(b[1]), .b(sum2[1]), .cin(0), .sum(sum2[2]), .cout(sum2[3]));\ngp_4bit A4BS2(.a(b[2]), .b(sum2[2]), .cin(0), .sum(sum2[4]), .cout(sum2[5]));\ngp_4bit A4BS3(.a(b[3]), .b(sum2[4]), .cin(0), .sum(sum2[6]), .cout(sum2[7]));\n\n// 4-bit full adder for A*B\ngp_4bit A4B0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum3[0]), .cout(sum3[1]));\ngp_4bit A4B1(.a(a[1]), .b(b[1]), .cin(sum3[1]), .sum(sum3[2]), .cout(sum3[3]));\ngp_4bit A4B2(.a(a[2]), .b(b[2]), .cin(sum3[3]), .sum(sum3[4]), .cout(sum3[5]));\ngp_4bit A4B3(.a(a[3]), .b(b[3]), .cin(sum3[5]), .sum(sum3[6]), .cout(sum3[7]));\n\n// 4-bit full adder for A*B+A\ngp_4bit A4BP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum4[0]), .cout(sum4[1]));\ngp_4bit A4BP1(.a(a[1]), .b(b[1]), .cin(sum4[1]), .sum(sum4[2]), .cout(sum4[3]));\ngp_4bit A4BP2(.a(a[2]), .b(b[2]), .cin(sum4[3]), .sum(sum4[4]), .cout(sum4[5]));\ngp_4bit A4BP3(.a(a[3]), .b(b[3]), .cin(sum4[5]), .sum(sum4[6]), .cout(sum4[7]));\n\nassign product = sum4;\n\nendmodule\n\nmodule gp_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign {cout, sum} = a + b + cin;\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each nibble\n    nibble_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .S(S[16:1]),\n        .C_out(carry[1])\n    );\n\n    nibble_adder add2(\n        .A(A[10:1]),\n        .B(B[10:1]),\n        .S(S[10:1]),\n        .C_out(carry[2])\n    );\n\n    nibble_adder add3(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .S(S[4:1]),\n        .C_out(carry[3])\n    );\n\n    nibble_adder add4(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .S(S[1:1]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry\n    assign C_out = carry[4];\nendmodule\n\nmodule nibble_adder(A, B, S, C_out);\n    input [4:1] A;         // 4-bit input A\n    input [4:1] B;         // 4-bit input B\n    output [4:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [5:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each bit\n    bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .S(S[4:1]),\n        .C_out(carry[1])\n    );\n\n    bit_adder add2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .S(S[2:1]),\n        .C_out(carry[2])\n    );\n\n    bit_adder add3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .S(S[1:1]),\n        .C_out(carry[3])\n    );\n\n    // Carry-out is the last carry\n    assign C_out = carry[3];\nendmodule\n\nmodule bit_adder(A, B, S, C_out);\n    input A, B;            // 2-bit input A and B\n    output S;              // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    assign {C_out, S} = A + B;\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adders for each bit of A and B\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(sum0), .sum(sum1), .cout(0));\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(sum1), .sum(sum2), .cout(0));\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(sum2), .sum(sum3), .cout(0));\n\n// Shift registers for each bit of the product\nshift_register_4bit A4BS0(.sum(sum0), .shifted_sum(shifted_sum0));\nshift_register_4bit A4BS1(.sum(sum1), .shifted_sum(shifted_sum1));\nshift_register_4bit A4BS2(.sum(sum2), .shifted_sum(shifted_sum2));\nshift_register_4bit A4BS3(.sum(sum3), .shifted_sum(shifted_sum3));\n\n// Output of the multiplier\nassign product = shifted_sum0 + shifted_sum1 + shifted_sum2 + shifted_sum3;\n\nendmodule\n\nmodule full_adder_4bit(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule shift_register_4bit(input [3:0] sum, output [7:0] shifted_sum);\n    assign shifted_sum = {sum, 4'b0000};\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles in a full cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else if (count == CYCLES / 4) begin\n                PWM_out <= 1;\n            end else begin\n                PWM_out <= 0;\n            end\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles in a full cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else if (count == CYCLES / 2) begin\n                PWM_out <= 1;\n            end else begin\n                PWM_out <= 0;\n            end\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles in a full cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else if (count == CYCLES * 3 / 4) begin\n                PWM_out <= 1;\n            end else begin\n                PWM_out <= 0;\n            end\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n  // Stage 1: Shift by 4\n  mux2X1 mux16 (stage1, in, in, ctrl[2]);\n  mux2X1 mux15 (stage2, stage1, stage1, ctrl[1]);\n  mux2X1 mux14 (stage3, stage2, stage2, ctrl[1]);\n  mux2X1 mux13 (stage4, stage3, stage3, ctrl[1]);\n  mux2X1 mux12 (stage5, stage4, stage4, ctrl[1]);\n  mux2X1 mux11 (stage6, stage5, stage5, ctrl[1]);\n  mux2X1 mux10 (stage7, stage6, stage6, ctrl[1]);\n  mux2X1 mux9 (stage8, stage7, stage7, ctrl[1]);\n\n  // Stage 2: Shift by 2\n  mux2X1 mux26 (stage1, in, stage1, ctrl[2]);\n  mux2X1 mux25 (stage2, stage1, stage2, ctrl[2]);\n  mux2X1 mux24 (stage3, stage2, stage3, ctrl[2]);\n  mux2X1 mux23 (stage4, stage3, stage4, ctrl[2]);\n  mux2X1 mux22 (stage5, stage4, stage5, ctrl[2]);\n  mux2X1 mux21 (stage6, stage5, stage6, ctrl[2]);\n  mux2X1 mux20 (stage7, stage6, stage7, ctrl[2]);\n  mux2X1 mux19 (stage8, stage7, stage8, ctrl[2]);\n\n  // Stage 3: Shift by 1\n  mux2X1 mux27 (stage1, in, stage1, ctrl[2]);\n  mux2X1 mux26 (stage2, stage1, stage2, ctrl[2]);\n  mux2X1 mux25 (stage3, stage2, stage3, ctrl[2]);\n  mux2X1 mux24 (stage4, stage3, stage4, ctrl[2]);\n  mux2X1 mux23 (stage5, stage4, stage5, ctrl[2]);\n  mux2X1 mux22 (stage6, stage5, stage6, ctrl[2]);\n  mux2X1 mux21 (stage7, stage6, stage7, ctrl[2]);\n  mux2X1 mux20 (stage8, stage7, stage8, ctrl[2]);\n\n  assign out = stage8;\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3;\n\n  // Stage 1: Shift by 4\n  mux2X1 mux16 (stage1, in, in, ctrl[2]);\n  mux2X1 mux15 (stage2, stage1, in, ctrl[2]);\n  mux2X1 mux14 (stage3, stage2, in, ctrl[2]);\n\n  // Stage 2: Shift by 2\n  mux2X1 mux13 (stage1, stage3, in, ctrl[1]);\n  mux2X1 mux12 (stage2, stage1, in, ctrl[1]);\n  mux2X1 mux11 (stage3, stage2, in, ctrl[1]);\n\n  // Stage 3: Shift by 1\n  mux2X1 mux10 (stage1, stage3, in, ctrl[0]);\n  mux2X1 mux09 (stage2, stage1, in, ctrl[0]);\n  mux2X1 mux08 (stage3, stage2, in, ctrl[0]);\n\n  assign out = stage3;\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(.A(A[1:0]), .B(B[1:0]), .C_in(1'b0), .S(S[1:0]), .C_out(c1));\n    four_bit_adder add2(.A(A[4:2]), .B(B[4:2]), .C_in(c1), .S(S[4:2]), .C_out(c2));\n    four_bit_adder add3(.A(A[8:6]), .B(B[8:6]), .C_in(c2), .S(S[8:6]), .C_out(c3));\n    four_bit_adder add4(.A(A[12:10]), .B(B[12:10]), .C_in(c3), .S(S[12:10]), .C_out(c4));\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(.A(A[1:0]), .B(B[1:0]), .C_in(C_in), .S(S[1:0]), .C_out(c1));\n    two_bit_adder add2(.A(A[3:2]), .B(B[3:2]), .C_in(c1), .S(S[3:2]), .C_out(c2));\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [1:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;              // Carry-out wire\n\n    // Instantiate 1-bit full adder for the last bit\n    full_adder fa(.A(A[0]), .B(B[0]), .C_in(C_in), .S(S[0]), .C_out(c1));\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c1;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (A & C_in) | (B & C_in); // Carry-out calculation\n\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out_reg <= 0;\n        end else begin\n            if (count == 100_000_000) begin\n                count <= 0;\n                PWM_out_reg <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out_reg <= 0;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_out_reg;\n\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out_reg <= 0;\n        end else begin\n            if (count == 50_000_000) begin\n                count <= 0;\n                PWM_out_reg <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out_reg <= 0;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_out_reg;\n\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out_reg <= 0;\n        end else begin\n            if (count == 75_000_000) begin\n                count <= 0;\n                PWM_out_reg <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out_reg <= 0;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_out_reg;\n\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Percentage of the PWM period\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_5;\n  wire [7:0] shifted_in_6;\n  wire [7:0] shifted_in_7;\n  wire [7:0] shifted_in_8;\n  wire [7:0] shifted_in_9;\n  wire [7:0] shifted_in_10;\n  wire [7:0] shifted_in_11;\n  wire [7:0] shifted_in_12;\n  wire [7:0] shifted_in_13;\n  wire [7:0] shifted_in_14;\n  wire [7:0] shifted_in_15;\n  wire [7:0] shifted_in_16;\n  wire [7:0] shifted_in_17;\n  wire [7:0] shifted_in_18;\n  wire [7:0] shifted_in_19;\n  wire [7:0] shifted_in_20;\n  wire [7:0] shifted_in_21;\n  wire [7:0] shifted_in_22;\n  wire [7:0] shifted_in_23;\n  wire [7:0] shifted_in_24;\n  wire [7:0] shifted_in_25;\n  wire [7:0] shifted_in_26;\n  wire [7:0] shifted_in_27;\n\n  mux2X1 ins_17(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_27));\n  mux2X1 ins_16(.sel(ctrl[1]), .in0(shifted_in_27), .in1(in), .out(shifted_in_26));\n  mux2X1 ins_15(.sel(ctrl[0]), .in0(shifted_in_26), .in1(shifted_in_27), .out(shifted_in_25));\n  mux2X1 ins_14(.sel(ctrl[2]), .in0(shifted_in_25), .in1(shifted_in_26), .out(shifted_in_24));\n  mux2X1 ins_13(.sel(ctrl[1]), .in0(shifted_in_24), .in1(shifted_in_25), .out(shifted_in_23));\n  mux2X1 ins_12(.sel(ctrl[0]), .in0(shifted_in_23), .in1(shifted_in_24), .out(shifted_in_22));\n  mux2X1 ins_11(.sel(ctrl[2]), .in0(shifted_in_22), .in1(shifted_in_23), .out(shifted_in_21));\n  mux2X1 ins_10(.sel(ctrl[1]), .in0(shifted_in_21), .in1(shifted_in_22), .out(shifted_in_20));\n  mux2X1 ins_07(.sel(ctrl[0]), .in0(shifted_in_20), .in1(shifted_in_21), .out(shifted_in_19));\n  mux2X1 ins_06(.sel(ctrl[2]), .in0(shifted_in_19), .in1(shifted_in_20), .out(shifted_in_18));\n  mux2X1 ins_05(.sel(ctrl[1]), .in0(shifted_in_18), .in1(shifted_in_19), .out(shifted_in_17));\n  mux2X1 ins_04(.sel(ctrl[0]), .in0(shifted_in_17), .in1(shifted_in_18), .out(shifted_in_16));\n  mux2X1 ins_03(.sel(ctrl[2]), .in0(shifted_in_16), .in1(shifted_in_17), .out(shifted_in_15));\n  mux2X1 ins_02(.sel(ctrl[1]), .in0(shifted_in_15), .in1(shifted_in_16), .out(shifted_in_14));\n  mux2X1 ins_01(.sel(ctrl[0]), .in0(shifted_in_14), .in1(shifted_in_15), .out(shifted_in_13));\n  mux2X1 ins_00(.sel(ctrl[2]), .in0(shifted_in_13), .in1(shifted_in_14), .out(shifted_in_12));\n\n  assign out = shifted_in_27;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_0;\n  wire [7:0] shifted_1;\n  wire [7:0] shifted_2;\n  wire [7:0] shifted_3;\n\n  wire [7:0] mux_0_out;\n  wire [7:0] mux_1_out;\n  wire [7:0] mux_2_out;\n  wire [7:0] mux_3_out;\n\n  // Stage 0\n  mux2X1 #(.WIDTH(8)) stage0(.sel(ctrl[2]), .in0(in), .in1(shifted_0), .out(mux_0_out));\n  assign shifted_0 = in << 2;\n\n  // Stage 1\n  mux2X1 #(.WIDTH(8)) stage1(.sel(ctrl[1]), .in0(mux_0_out), .in1(shifted_1), .out(mux_1_out));\n  mux2X1 #(.WIDTH(8)) stage2(.sel(ctrl[0]), .in0(mux_1_out), .in1(shifted_2), .out(mux_2_out));\n  assign shifted_1 = mux_0_out << 1;\n  assign shifted_2 = mux_1_out << 1;\n  assign shifted_3 = mux_2_out << 1;\n\n  // Final output\n  assign out = mux_2_out;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    wire [11:0] count_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(count_out)\n    );\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = MAX_COUNT * DUTY_CYCLE / 100;\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(count_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] count_out,\n    output reg pwm_out\n);\n\n    parameter DUTY_CYCLE_THRESHOLD = 500; // Duty cycle threshold\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (count_out < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  assign b1 = b0;\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delay b0 for pe1\n  reg [15:0] b1_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 500; // Threshold value for duty cycle\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (counter_out < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  assign b1 = rst ? 16'b0 : b0;\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = {a, 16'b0} * b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  assign b1 = b0;\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output comparator_out\n);\n\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    reg [7:0] duty_cycle_threshold;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            duty_cycle_threshold <= DUTY_CYCLE;\n        end else begin\n            duty_cycle_threshold <= DUTY_CYCLE;\n        end\n    end\n\n    assign comparator_out = (counter_out < duty_cycle_threshold);\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check for zero result\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the most and least significant bits\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check for zero result\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] pc;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc));\n  decode_stage decode (.clk(clk), .rst(rst), .pc(pc), .instr_mem(instr_mem), .reg_file(reg_file), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute (.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .op(op), .alu_result(alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(alu_result), .reg_file(reg_file), .rd(rd), .res_reg_file(res_reg_file));\n  writeback_stage writeback (.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .reg_file(reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr_mem[pc][25:20];\n      rs2 <= instr_mem[pc][20:15];\n      rd <= instr_mem[pc][11:7];\n      op <= instr_mem[pc][31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [5:0] op,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else begin\n      case (op)\n        6'b000000: alu_result <= reg_file[rs1] + reg_file[rs2];\n        6'b000010: alu_result <= reg_file[rs1] - reg_file[rs2];\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  input [4:0] rd,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file[rd] <= 0;\n    end else begin\n      res_reg_file[rd] <= alu_result;\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [31:0] reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      reg_file[0] <= 0;\n      reg_file[1] <= 0;\n      reg_file[2] <= 0;\n      reg_file[3] <= 0;\n      reg_file[4] <= 0;\n      reg_file[5] <= 0;\n      reg_file[6] <= 0;\n      reg_file[7] <= 0;\n      reg_file[8] <= 0;\n      reg_file[9] <= 0;\n      reg_file[10] <= 0;\n      reg_file[11] <= 0;\n      reg_file[12] <= 0;\n      reg_file[13] <= 0;\n      reg_file[14] <= 0;\n      reg_file[15] <= 0;\n      reg_file[16] <= 0;\n      reg_file[17] <= 0;\n      reg_file[18] <= 0;\n      reg_file[19] <= 0;\n      reg_file[20] <= 0;\n      reg_file[21] <= 0;\n      reg_file[22] <= 0;\n      reg_file[23] <= 0;\n      reg_file[24] <= 0;\n      reg_file[25] <= 0;\n      reg_file[26] <= 0;\n      reg_file[27] <= 0;\n      reg_file[28] <= 0;\n      reg_file[29] <= 0;\n      reg_file[30] <= 0;\n      reg_file[31] <= 0;\n    end else begin\n      reg_file[0] <= res_reg_file[0];\n      reg_file[1] <= res_reg_file[1];\n      reg_file[2] <= res_reg_file[2];\n      reg_file[3] <= res_reg_file[3];\n      reg_file[4] <= res_reg_file[4];\n      reg_file[5] <= res_reg_file[5];\n      reg_file[6] <= res_reg_file[6];\n      reg_file[7] <= res_reg_file[7];\n      reg_file[8] <= res_reg_file[8];\n      reg_file[9] <= res_reg_file[9];\n      reg_file[10] <= res_reg_file[10];\n      reg_file[11] <= res_reg_file[11];\n      reg_file[12] <= res_reg_file[12];\n      reg_file[13] <= res_reg_file[13];\n      reg_file[14] <= res_reg_file[14];\n      reg_file[15] <= res_reg_file[15];\n      reg_file[16] <= res_reg_file[16];\n      reg_file[17] <= res_reg_file[17];\n      reg_file[18] <= res_reg_file[18];\n      reg_file[19] <= res_reg_file[19];\n      reg_file[20] <= res_reg_file[20];\n      reg_file[21] <= res_reg_file[21];\n      reg_file[22] <= res_reg_file[22];\n      reg_file[23] <= res_reg_file[23];\n      reg_file[24] <= res_reg_file[24];\n      reg_file[25] <= res_reg_file[25];\n      reg_file[26] <= res_reg_file[26];\n      reg_file[27] <= res_reg_file[27];\n      reg_file[28] <= res_reg_file[28];\n      reg_file[29] <= res_reg_file[29];\n      reg_file[30] <= res_reg_file[30];\n      reg_file[31] <= res_reg_file[31];\n    end\n  end\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = (multc) ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check for zero result\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_int;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_int)\n    );\n\n    // Output the count and overflow flag\n    assign count_out = count;\n    assign overflow = overflow_int;\n\nendmodule\n\n// Count control module\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count_out <= 4'b0000;\n        else if (en)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\n// Overflow detection module\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow)\n    );\n\n    // Assign the output\n    assign count_out = count;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n    wire overflow_detected;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next),\n        .overflow(overflow_detected)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg [3:0]    count_out,\n    output reg          overflow\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n            overflow <= 1'b0;\n        end else if (en) begin\n            count_out <= count_out + 1;\n            overflow <= (count_out == 4'b1111);\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\n\n// Instantiate pipeline stages\nfetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc));\ndecode_stage decode (.clk(clk), .rst(rst), .pc(pc), .reg_file(reg_file), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd));\nexecute_stage execute (.clk(clk), .rst(rst), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd), .res(res));\nmemory_stage memory (.clk(clk), .rst(rst), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd), .res(res), .res_mem(res_mem));\nwriteback_stage writeback (.clk(clk), .rst(rst), .res_mem(res_mem), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\n// Pipeline register\nreg [5:0] pc_reg;\n\n// Output register\nreg [31:0] res_reg [0:31];\n\n// Pipeline register assignment\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    pc_reg <= 0;\n  end else begin\n    pc_reg <= pc;\n  end\nend\n\n// Output register assignment\nalways @(posedge clk or posedge rst) begin\n  if (rst) begin\n    res_reg <= 0;\n  end else begin\n    res_reg <= res_reg_file;\n  end\nend\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc\n);\n  reg [5:0] pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n    end else begin\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [5:0] pc,\n  input [31:0] reg_file [0:31],\n  output [5:0] op,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd\n);\n  reg [5:0] op_reg;\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      op_reg <= 0;\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n    end else begin\n      op_reg <= instr_mem[pc][31:26];\n      rs1_reg <= instr_mem[pc][25:21];\n      rs2_reg <= instr_mem[pc][20:16];\n      rd_reg <= instr_mem[pc][15:11];\n    end\n  end\n\n  assign op = op_reg;\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [5:0] op,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  output [31:0] res\n);\n  reg [31:0] res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: res_reg <= reg_file[rs1] + reg_file[rs2];\n        6'b000010: res_reg <= reg_file[rs1] - reg_file[rs2];\n        default: res_reg <= 0;\n      endcase\n    end\n  end\n\n  assign res = res_reg;\nendmodule\n\n// Memory stage\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [5:0] op,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [31:0] res,\n  output [31:0] res_mem\n);\n  reg [31:0] res_mem_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_mem_reg <= 0;\n    end else begin\n      res_mem_reg <= res;\n    end\n  end\n\n  assign res_mem = res_mem_reg;\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_mem,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[0] <= 0;\n      res_reg_file_reg[1] <= 0;\n      res_reg_file_reg[2] <= 0;\n      res_reg_file_reg[3] <= 0;\n      res_reg_file_reg[4] <= 0;\n      res_reg_file_reg[5] <= 0;\n      res_reg_file_reg[6] <= 0;\n      res_reg_file_reg[7] <= 0;\n      res_reg_file_reg[8] <= 0;\n      res_reg_file_reg[9] <= 0;\n      res_reg_file_reg[10] <= 0;\n      res_reg_file_reg[11] <= 0;\n      res_reg_file_reg[12] <= 0;\n      res_reg_file_reg[13] <= 0;\n      res_reg_file_reg[14] <= 0;\n      res_reg_file_reg[15] <= 0;\n      res_reg_file_reg[16] <= 0;\n      res_reg_file_reg[17] <= 0;\n      res_reg_file_reg[18] <= 0;\n      res_reg_file_reg[19] <= 0;\n      res_reg_file_reg[20] <= 0;\n      res_reg_file_reg[21] <= 0;\n      res_reg_file_reg[22] <= 0;\n      res_reg_file_reg[23] <= 0;\n      res_reg_file_reg[24] <= 0;\n      res_reg_file_reg[25] <= 0;\n      res_reg_file_reg[26] <= 0;\n      res_reg_file_reg[27] <= 0;\n      res_reg_file_reg[28] <= 0;\n      res_reg_file_reg[29] <= 0;\n      res_reg_file_reg[30] <= 0;\n      res_reg_file_reg[31] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= res_mem;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n    wire overflow_next;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next),\n        .overflow(overflow_next)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow_next)\n    );\n\n    // Assign the output values\n    assign count_out = count_next;\n    assign overflow = overflow_next;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg [3:0]   count_out,\n    output reg          overflow\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n            overflow <= 1'b0;\n        end else if (en) begin\n            count_out <= count_out + 1;\n            overflow <= (count_out == 4'b1111);\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add (\n    .a(operand_a),\n    .b(operand_b),\n    .result(add_result)\n);\n\nsubtract_module subtract (\n    .a(operand_a),\n    .b(operand_b),\n    .result(subtract_result)\n);\n\nbitwise_and_module bitwise_and (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_and_result)\n);\n\nbitwise_or_module bitwise_or (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_or_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [5:0] next_pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_res;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .next_pc(next_pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .op(op), .alu_res(alu_res));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .rd(rd), .res_reg_file(res_reg_file), .pc(pc), .next_pc(next_pc));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [5:0] next_pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [5:0] next_pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      next_pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      pc_reg <= next_pc_reg;\n      next_pc_reg <= pc_reg + 1;\n      instr_reg <= instr_mem[pc_reg];\n    end\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = next_pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[10:6];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_res\n);\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_res_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_res_reg <= rs1 + rs2;\n        6'b001010: alu_res_reg <= rs1 - rs2;\n        default: alu_res_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [4:0] rd_reg;\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rd_reg <= 0;\n      res_reg_file_reg <= 0;\n    end else begin\n      rd_reg <= 0;\n      res_reg_file_reg[rd_reg] <= alu_res;\n    end\n  end\n\n  assign rd = rd_reg;\n  assign res_reg_file = res_reg_file_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [4:0] rd,\n  input [31:0] res_reg_file [0:31],\n  input [5:0] pc,\n  input [5:0] next_pc\n);\n  reg [5:0] pc_reg;\n  reg [5:0] next_pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      next_pc_reg <= 0;\n    end else begin\n      pc_reg <= next_pc;\n      next_pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = next_pc_reg;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUB: result <= subtract_result;\n            `AND: result <= bitwise_and_result;\n            `OR: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [4:0] pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc),\n    .instruction(alu_result)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instruction(alu_result),\n    .rs1(alu_result[15:11]),\n    .rs2(alu_result[20:16]),\n    .rd(alu_result[25:21]),\n    .op(alu_result[31:26])\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .rs1(reg_file[alu_result[15:11]]),\n    .rs2(reg_file[alu_result[20:16]]),\n    .rd(alu_result[25:21]),\n    .op(alu_result[31:26]),\n    .result(alu_result)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .result(alu_result),\n    .result_reg(alu_result)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .result_reg(alu_result),\n    .reg_file(res_reg_file)\n  );\n\n  // Update pc\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [4:0] pc,\n  output [31:0] instruction\n);\n  assign instruction = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instruction,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign {rs1, rs2, rd, op} = instruction;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output [31:0] result\n);\n  reg [31:0] result_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      result_reg <= 0;\n    else begin\n      case (op)\n        6'b000000: result_reg <= rs1 + rs2; // Addition\n        6'b001000: result_reg <= rs1 - rs2; // Subtraction\n        default: result_reg <= 0;\n      endcase\n    end\n  end\n  assign result = result_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] result,\n  output [31:0] result_reg\n);\n  assign result_reg = result;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] result_reg,\n  output reg [31:0] reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      reg_file <= 0;\n    else\n      reg_file[result_reg[25:21]] <= result_reg;\n  end\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b_delayed;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_delayed <= 0;\n    end else begin\n      b_delayed <= b0;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b_reg1, b_reg2, b_reg3;\n\n  // Registers to hold delayed values\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n      b_reg3 <= 0;\n    end\n    else begin\n      b_reg1 <= b0;\n      b_reg2 <= b_reg1;\n      b_reg3 <= b_reg2;\n    end\n  end\n\n  // Delayed values\n  assign pe1.b_delayed = b_reg1;\n  assign pe2.b_delayed = b_reg2;\n  assign pe3.b_delayed = b_reg3;\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      product <= 0;\n    end\n    else begin\n      product <= a * b;\n    end\n  end\n\n  assign c = product;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold delayed inputs\n  reg [15:0] b_delayed;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_delayed <= 0;\n    end else begin\n      b_delayed <= b0;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry signals for each 4-bit block\n\n    // Instantiate 4-bit carry lookahead adders for each 4-bit block\n    add4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(carry[1])\n    );\n\n    add4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(carry[1]),\n        .S(S[8:5]),\n        .C_out(carry[2])\n    );\n\n    add4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(carry[2]),\n        .S(S[12:9]),\n        .C_out(carry[3])\n    );\n\n    add4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(carry[3]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\n\nendmodule\n\nmodule add4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] sum;       // 5-bit sum\n    wire c1, c2;           // Carry signals for each bit\n\n    // Instantiate a 5-bit carry lookahead adder for each bit\n    add1 add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(sum[1:1]),\n        .C_out(c1)\n    );\n\n    add1 add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(sum[2:2]),\n        .C_out(c2)\n    );\n\n    add1 add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2),\n        .S(sum[3:3]),\n        .C_out(c1)\n    );\n\n    add1 add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(c1),\n        .S(sum[4:4]),\n        .C_out(c2)\n    );\n\n    assign S = sum[4:1];\n    assign C_out = c2;\n\nendmodule\n\nmodule add1(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add2 add2(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add2 add3(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add2(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add3 add3(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add3 add4(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add3(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add4 add4(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add4 add5(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add4(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add5 add5(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add5 add6(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add5(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add6 add6(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add6 add7(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add6(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add7 add7(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add7 add8(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add7(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add8 add8(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add8 add9(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add8(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add9 add9(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add9 add10(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add9(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add10 add10(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add10 add11(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add10(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add11 add11(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add11 add12(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add11(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add12 add12(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add12 add13(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add12(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add13 add13(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add13 add14(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add13(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add14 add14(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add14 add15(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add14(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add15 add15(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add15 add16(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add15(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add16 add16(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add16 add17(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add16(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add17 add17(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add17 add18(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add17(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add18 add18(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add18 add19(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add18(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add19 add19(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add19 add20(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add19(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add20 add20(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add20 add21(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add20(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add21 add21(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add21 add22(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add21(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add22 add22(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add22 add23(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add22(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add23 add23(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add23 add24(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add23(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add24 add24(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add24 add25(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add24(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add25 add25(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add25 add26(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add25(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add26 add26(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add26 add27(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add26(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add27 add27(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add27 add28(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add27(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add28 add28(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add28 add29(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add28(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add29 add29(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add29 add30(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add29(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add30 add30(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add30 add31(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add30(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add31 add31(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add31 add32(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add31(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add32 add32(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add32 add33(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add32(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add33 add33(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add33 add34(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add33(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add34 add34(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add34 add35(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add34(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add35 add35(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add35 add36(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add35(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry signals for each bit\n\n    // Instantiate a 2-bit carry lookahead adder for each bit\n    add36 add36(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    add36 add37(\n        .A(A),\n        .B(B),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\n\nendmodule\n\nmodule add36(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n\n  // Registers to hold delayed values of b0, b1, b2, and b3\n  reg [15:0] b1, b2, b3;\n\n  // Update registers on clock edge\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  always @(posedge clk) begin\n    if (rst) begin\n      product <= 0;\n    end else begin\n      product <= a * b;\n    end\n  end\n  assign c = product;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine outputs from slices\nassign eq = &eq_slice1 & &eq_slice2 & &eq_slice3 & &eq_slice4;\nassign gt = &gt_slice1 & &gt_slice2 & &gt_slice3 & &gt_slice4;\nassign lt = &lt_slice1 & &lt_slice2 & &lt_slice3 & &lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine outputs from slices\nassign eq = &eq_slice1 & &eq_slice2;\nassign gt = &gt_slice1 & &gt_slice2;\nassign lt = &lt_slice1 & &lt_slice2;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\n// Instantiate 1-bit comparator\ncomparator_1bit comp_slice1(.a(a[0]), .b(b[0]), .eq(eq_bit), .gt(gt_bit), .lt(lt_bit));\n\n// Combine outputs from slices\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input operand A\n    input [16:1] B;       // 16-bit input operand B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry-out from each 4-bit adder\n\n    // Instantiate 4-bit carry lookahead adders for each 4-bit group\n    cla_4bit add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    cla_4bit add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    cla_4bit add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[2]),\n        .S(S[7:4]),\n        .C_out(carry[3])\n    );\n\n    cla_4bit add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[3]),\n        .S(S[11:8]),\n        .C_out(carry[4])\n    );\n\n    // Combine the carry-outs to get the final carry-out\n    assign C_out = carry[4];\nendmodule\n\nmodule cla_4bit(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input operand A\n    input [3:1] B;        // 4-bit input operand B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] c;         // Carry-out from each bit\n\n    // Instantiate 2-bit carry lookahead adders for each bit\n    cla_2bit add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c[1])\n    );\n\n    cla_2bit add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c[1]),\n        .S(S[3:2]),\n        .C_out(c[2])\n    );\n\n    // Combine the carry-outs to get the final carry-out\n    assign C_out = c[2];\nendmodule\n\nmodule cla_2bit(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input operand A\n    input [2:1] B;        // 2-bit input operand B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out from each bit\n\n    // Instantiate 1-bit carry lookahead adder for each bit\n    cla_1bit add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    cla_1bit add2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    // Combine the carry-outs to get the final carry-out\n    assign C_out = c2;\nendmodule\n\nmodule cla_1bit(A, B, C_in, S, C_out);\n    input A;              // 1-bit input operand A\n    input B;              // 1-bit input operand B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c;               // Carry-out from each bit\n\n    // Instantiate 1-bit carry lookahead adder\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n`define NOP 6'b000001\n`define HALT 6'b000011\n\n// Stage modules\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(out_reg_file)\n);\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_reg_file),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_reg_file),\n    .reg_file(out_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] out_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_instr <= 0;\n        else\n            out_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    reg [5:0] opcode;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [31:0] imm;\n    reg [31:0] op1;\n    reg [31:0] op2;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            opcode <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            imm <= 0;\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n        end\n        else begin\n            opcode <= instr[31:26];\n            rd <= instr[20:15];\n            rs1 <= instr[15:10];\n            rs2 <= instr[25:20];\n            imm <= instr[31:20];\n            op1 <= reg_file[rs1];\n            op2 <= reg_file[rs2];\n            case(opcode)\n                `ADD: result <= op1 + op2;\n                `SUB: result <= op1 - op2;\n                `NOP: result <= 0;\n                `HALT: result <= 0;\n                default: result <= 0;\n            endcase\n            out_reg_file <= result;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output reg [31:0] out_reg_file\n);\n    reg [5:0] opcode;\n    reg [4:0] rd;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            opcode <= 0;\n            rd <= 0;\n            result <= 0;\n        end\n        else begin\n            opcode <= instr[31:26];\n            rd <= instr[20:15];\n            result <= instr[31:20];\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    wire c;\n    sub8 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub8 (input a, b, bin, output diff, bout);\n    wire c;\n    sub9 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub9 (input a, b, bin, output diff, bout);\n    wire c;\n    sub10 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub10 (input a, b, bin, output diff, bout);\n    wire c;\n    sub11 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub11 (input a, b, bin, output diff, bout);\n    wire c;\n    sub12 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub12 (input a, b, bin, output diff, bout);\n    wire c;\n    sub13 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub13 (input a, b, bin, output diff, bout);\n    wire c;\n    sub14 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub14 (input a, b, bin, output diff, bout);\n    wire c;\n    sub15 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub15 (input a, b, bin, output diff, bout);\n    wire c;\n    sub16 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub16 (input a, b, bin, output diff, bout);\n    wire c;\n    sub17 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub17 (input a, b, bin, output diff, bout);\n    wire c;\n    sub18 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub18 (input a, b, bin, output diff, bout);\n    wire c;\n    sub19 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub19 (input a, b, bin, output diff, bout);\n    wire c;\n    sub20 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub20 (input a, b, bin, output diff, bout);\n    wire c;\n    sub21 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub21 (input a, b, bin, output diff, bout);\n    wire c;\n    sub22 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub22 (input a, b, bin, output diff, bout);\n    wire c;\n    sub23 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub23 (input a, b, bin, output diff, bout);\n    wire c;\n    sub24 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub24 (input a, b, bin, output diff, bout);\n    wire c;\n    sub25 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub25 (input a, b, bin, output diff, bout);\n    wire c;\n    sub26 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub26 (input a, b, bin, output diff, bout);\n    wire c;\n    sub27 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub27 (input a, b, bin, output diff, bout);\n    wire c;\n    sub28 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub28 (input a, b, bin, output diff, bout);\n    wire c;\n    sub29 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub29 (input a, b, bin, output diff, bout);\n    wire c;\n    sub30 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub30 (input a, b, bin, output diff, bout);\n    wire c;\n    sub31 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub31 (input a, b, bin, output diff, bout);\n    wire c;\n    sub32 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub32 (input a, b, bin, output diff, bout);\n    wire c;\n    sub33 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub33 (input a, b, bin, output diff, bout);\n    wire c;\n    sub34 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub34 (input a, b, bin, output diff, bout);\n    wire c;\n    sub35 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub35 (input a, b, bin, output diff, bout);\n    wire c;\n    sub36 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub36 (input a, b, bin, output diff, bout);\n    wire c;\n    sub37 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub37 (input a, b, bin, output diff, bout);\n    wire c;\n    sub38 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub38 (input a, b, bin, output diff, bout);\n    wire c;\n    sub39 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub39 (input a, b, bin, output diff, bout);\n    wire c;\n    sub40 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub40 (input a, b, bin, output diff, bout);\n    wire c;\n    sub41 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub41 (input a, b, bin, output diff, bout);\n    wire c;\n    sub42 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub42 (input a, b, bin, output diff, bout);\n    wire c;\n    sub43 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub43 (input a, b, bin, output diff, bout);\n    wire c;\n    sub44 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub44 (input a, b, bin, output diff, bout);\n    wire c;\n    sub45 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub45 (input a, b, bin, output diff, bout);\n    wire c;\n    sub46 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub46 (input a, b, bin, output diff, bout);\n    wire c;\n    sub47 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub47 (input a, b, bin, output diff, bout);\n    wire c;\n    sub48 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub48 (input a, b, bin, output diff, bout);\n    wire c;\n    sub49 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub49 (input a, b, bin, output diff, bout);\n    wire c;\n    sub50 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub50 (input a, b, bin, output diff, bout);\n    wire c;\n    sub51 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub51 (input a, b, bin, output diff, bout);\n    wire c;\n    sub52 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub52 (input a, b, bin, output diff, bout);\n    wire c;\n    sub53 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub53 (input a, b, bin, output diff, bout);\n    wire c;\n    sub54 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub54 (input a, b, bin, output diff, bout);\n    wire c;\n    sub55 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub55 (input a, b, bin, output diff, bout);\n    wire c;\n    sub56 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub56 (input a, b, bin, output diff, bout);\n    wire c;\n    sub57 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub57 (input a, b, bin, output diff, bout);\n    wire c;\n    sub58 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub58 (input a, b, bin, output diff, bout);\n    wire c;\n    sub59 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub59 (input a, b, bin, output diff, bout);\n    wire c;\n    sub60 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub60 (input a, b, bin, output diff, bout);\n    wire c;\n    sub61 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub61 (input a, b, bin, output diff, bout);\n    wire c;\n    sub62 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub62 (input a, b, bin, output diff, bout);\n    wire c;\n    sub63 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub63 (input a, b, bin, output diff, bout);\n    wire c;\n    sub64 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub64 (input a, b, bin, output diff, bout);\n    wire c;\n    sub65 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub65 (input a, b, bin, output diff, bout);\n    wire c;\n    sub66 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub66 (input a, b, bin, output diff, bout);\n    wire c;\n    sub67 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub67 (input a, b, bin, output diff, bout);\n    wire c;\n    sub68 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub68 (input a, b, bin, output diff, bout);\n    wire c;\n    sub69 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub69 (input a, b, bin, output diff, bout);\n    wire c;\n    sub70 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub70 (input a, b, bin, output diff, bout);\n    wire c;\n    sub71 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub71 (input a, b, bin, output diff, bout);\n    wire c;\n    sub72 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub72 (input a, b, bin, output diff, bout);\n    wire c;\n    sub73 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub73 (input a, b, bin, output diff, bout);\n    wire c;\n    sub74 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub74 (input a, b, bin, output diff, bout);\n    wire c;\n    sub75 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub75 (input a, b, bin, output diff, bout);\n    wire c;\n    sub76 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub76 (input a, b, bin, output diff, bout);\n    wire c;\n    sub77 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub77 (input a, b, bin, output diff, bout);\n    wire c;\n    sub78 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub78 (input a, b, bin, output diff, bout);\n    wire c;\n    sub79 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub79 (input a, b, bin, output diff, bout);\n    wire c;\n    sub80 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub80 (input a, b, bin, output diff, bout);\n    wire c;\n    sub81 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub81 (input a, b, bin, output diff, bout);\n    wire c;\n    sub82 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub82 (input a, b, bin, output diff, bout);\n    wire c;\n    sub83 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub83 (input a, b, bin, output diff, bout);\n    wire c;\n    sub84 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub84 (input a, b, bin, output diff, bout);\n    wire c;\n    sub85 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub85 (input a, b, bin, output diff, bout);\n    wire c;\n    sub86 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub86 (input a, b, bin, output diff, bout);\n    wire c;\n    sub87 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub87 (input a, b, bin, output diff, bout);\n    wire c;\n    sub88 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub88 (input a, b, bin, output diff, bout);\n    wire c;\n    sub89 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub89 (input a, b, bin, output diff, bout);\n    wire c;\n    sub90 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub90 (input a, b, bin, output diff, bout);\n    wire c;\n    sub91 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub91 (input a, b, bin, output diff, bout);\n    wire c;\n    sub92 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub92 (input a, b, bin, output diff, bout);\n    wire c;\n    sub93 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub93 (input a, b, bin, output diff, bout);\n    wire c;\n    sub94 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub94 (input a, b, bin, output diff, bout);\n    wire c;\n    sub95 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub95 (input a, b, bin, output diff, bout);\n    wire c;\n    sub96 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub96 (input a, b, bin, output diff, bout);\n    wire c;\n    sub97 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub97 (input a, b, bin, output diff, bout);\n    wire c;\n    sub98 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub98 (input a, b, bin, output diff, bout);\n    wire c;\n    sub99 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub99 (input a, b, bin, output diff, bout);\n    wire c;\n    sub100 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub100 (input a, b, bin, output diff, bout);\n    wire c;\n    sub101 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub101 (input a, b, bin, output diff, bout);\n    wire c;\n    sub102 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub102 (input a, b, bin, output diff, bout);\n    wire c;\n    sub103 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub103 (input a, b, bin, output diff, bout);\n    wire c;\n    sub104 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub104 (input a, b, bin, output diff, bout);\n    wire c;\n    sub105 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub105 (input a, b, bin, output diff, bout);\n    wire c;\n    sub106 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub106 (input a, b, bin, output diff, bout);\n    wire c;\n    sub107 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub107 (input a, b, bin, output diff, bout);\n    wire c;\n    sub108 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub108 (input a, b, bin, output diff, bout);\n    wire c;\n    sub109 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub109 (input a, b, bin, output diff, bout);\n    wire c;\n    sub110 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub110 (input a, b, bin, output diff, bout);\n    wire c;\n    sub111 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub111 (input a, b, bin, output diff, bout);\n    wire c;\n    sub112 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub112 (input a, b, bin, output diff, bout);\n    wire c;\n    sub113 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub113 (input a, b, bin, output diff, bout);\n    wire c;\n    sub114 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub114 (input a, b, bin, output diff, bout);\n    wire c;\n    sub115 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub115 (input a, b, bin, output diff, bout);\n    wire c;\n    sub116 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub116 (input a, b, bin, output diff, bout);\n    wire c;\n    sub117 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub117 (input a, b, bin, output diff, bout);\n    wire c;\n    sub118 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub118 (input a, b, bin, output diff, bout);\n    wire c;\n    sub119 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub119 (input a, b, bin, output diff, bout);\n    wire c;\n    sub120 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub120 (input a, b, bin, output diff, bout);\n    wire c;\n    sub121 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub121 (input a, b, bin, output diff, bout);\n    wire c;\n    sub122 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub122 (input a, b, bin, output diff, bout);\n    wire c;\n    sub123 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub123 (input a, b, bin, output diff, bout);\n    wire c;\n    sub124 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub124 (input a, b, bin, output diff, bout);\n    wire c;\n    sub125 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub125 (input a, b, bin, output diff, bout);\n    wire c;\n    sub126 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub126 (input a, b, bin, output diff, bout);\n    wire c;\n    sub127 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub127 (input a, b, bin, output diff, bout);\n    wire c;\n    sub128 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub128 (input a, b, bin, output diff, bout);\n    wire c;\n    sub129 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub129 (input a, b, bin, output diff, bout);\n    wire c;\n    sub130 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub130 (input a, b, bin, output diff, bout);\n    wire c;\n    sub131 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub131 (input a, b, bin, output diff, bout);\n    wire c;\n    sub132 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub132 (input a, b, bin, output diff, bout);\n    wire c;\n    sub133 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub133 (input a, b, bin, output diff, bout);\n    wire c;\n    sub134 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub134 (input a, b, bin, output diff, bout);\n    wire c;\n    sub135 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub135 (input a, b, bin, output diff, bout);\n    wire c;\n    sub136 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));\n    assign bout = c;\nendmodule\n\nmodule sub136 (input a, b, bin, output diff, bout);\n    wire c;\n    sub137 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c));"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_temp;\n\n    // Generate borrow for each bit\n    assign b_temp[0] = bin;\n    assign b_temp[1] = (a[0] & ~b[0]) | (a[0] & b[0] & bin);\n    assign b_temp[2] = (a[1] & ~b[1]) | (a[1] & b[1] & b_temp[1]);\n    assign b_temp[3] = (a[2] & ~b[2]) | (a[2] & b[2] & b_temp[2]);\n    assign b_temp[4] = (a[3] & ~b[3]) | (a[3] & b[3] & b_temp[3]);\n    assign b_temp[5] = (a[4] & ~b[4]) | (a[4] & b[4] & b_temp[4]);\n    assign b_temp[6] = (a[5] & ~b[5]) | (a[5] & b[5] & b_temp[5]);\n    assign b_temp[7] = (a[6] & ~b[6]) | (a[6] & b[6] & b_temp[6]);\n    assign b_temp[8] = (a[7] & ~b[7]) | (a[7] & b[7] & b_temp[7]);\n\n    // Generate difference output\n    assign diff = a ^ b;\n    assign bout = b_temp[8]; \nendmodule\n\nmodule one_bit_subtractor(\n    input a, b, bin,\n    output diff, bout);\n\n    assign diff = a ^ b;\n    assign bout = (a & ~b) | (a & b & bin);\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4;\nassign lt = lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = eq_slice1 & eq_slice2;\nassign gt = gt_slice1 & gt_slice2;\nassign lt = lt_slice1 & lt_slice2;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define OPCODE 5'd0\n`define RD 5'd0\n`define RS1 5'd0\n`define RS2 5'd0\n`define IMM 32'd0\n\n// Register file\n`define REG_FILE_SIZE 32\n\n// Instruction memory\n`define INSTR_MEM_SIZE 32\n\n// Pipeline stages\n`define FETCH_STAGE 0\n`define EXECUTE_STAGE 1\n`define WRITEBACK_STAGE 2\n\n// Stage outputs\n`define FETCH_OUT 32'd0\n`define EXECUTE_OUT 32'd0\n`define WRITEBACK_OUT 32'd0\n\n// Stage inputs\n`define FETCH_INSTR 32'd0\n`define EXECUTE_INSTR 32'd0\n`define WRITEBACK_INSTR 32'd0\n`define WRITEBACK_REG 5'd0\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    wire [31:0] fetch_out;\n    wire [31:0] execute_out;\n    wire [31:0] writeback_out;\n\n    // Instantiate pipeline stages\n    fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .out(fetch_out));\n    execute_stage execute (.clk(clk), .rst(rst), .instr(fetch_out), .out(execute_out));\n    writeback_stage writeback (.clk(clk), .rst(rst), .instr(execute_out), .reg_file(reg_file), .out(writeback_out));\n\n    // Output the register file\n    assign out_reg_file = writeback_out;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output [31:0] out\n);\n    reg [31:0] fetch_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            fetch_out <= 32'd0;\n        end else begin\n            fetch_out <= instr_mem[0];\n        end\n    end\n\n    assign out = fetch_out;\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [31:0] out\n);\n    reg [31:0] execute_out;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            execute_out <= 32'd0;\n        end else begin\n            case (instr[`OPCODE])\n                `ADD: execute_out <= instr[`RS1] + instr[`RS2];\n                `SUB: execute_out <= instr[`RS1] - instr[`RS2];\n                default: execute_out <= 32'd0;\n            endcase\n        end\n    end\n\n    assign out = execute_out;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out\n);\n    reg [31:0] writeback_out;\n    reg [4:0] reg_id;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            writeback_out <= 32'd0;\n            reg_id <= 5'd0;\n        end else begin\n            reg_id <= instr[`RD];\n            writeback_out <= instr[`RD];\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file[reg_id] <= 32'd0;\n        end else begin\n            reg_file[reg_id] <= writeback_out;\n        end\n    end\n\n    assign out = writeback_out;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:1] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1 (\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_adder add2 (\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1[1]),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_adder add3 (\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2[1]),\n        .S(S[3:3]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_adder add4 (\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(c3[1]),\n        .S(S[4:4]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = c4[1];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [3:1] A;       // 4-bit input A\n    input [3:1] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [3:1] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [4:1] c;\n\n    // Instantiate 4-bit full adder\n    full_adder fa (\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c[1])\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = c[4];\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 2-bit full adder\n    full_adder_2bit fa (\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    // Instantiate 2-bit full adder\n    full_adder_2bit fa2 (\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(c1),\n        .S(S[1:1]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = c2;\nendmodule\n\nmodule full_adder_2bit(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;\n\n    // Instantiate 1-bit full adder\n    full_adder_1bit fa (\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = c1;\nendmodule\n\nmodule full_adder_1bit(A, B, C_in, S, C_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine outputs from slices\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4;\nassign lt = lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\n// Comparator logic\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub_beh S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub_beh S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub_beh S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub_beh S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub_beh S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub_beh S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub_beh S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub_beh S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule sub_beh(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [7:1] Bout1, Bout2, Bout3, Bout4;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout1);\n    subtractor_8bit SUB2(A[32:18], B[32:18], Bout1, D[32:18], Bout2);\n    subtractor_8bit SUB3(A[32:12], B[32:12], Bout2, D[32:12], Bout3);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout3, D[32:6], Bout4);\n\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[4]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Combine carry-outs to get final carry-out\n    assign C_out = C1[1] | C2[2] | C3[4] | C4[16];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;     // Gates for carry and sum\n    wire [5:1] C;         // Carry-out for each bit\n\n    // Generate G and P\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Generate carry-out for each bit\n    assign C[1] = G[1] | (P[1] & C_in);\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign C[4] = G[4] | (P[4] & C[3]);\n    assign C[5] = G[5] | (P[5] & C[4]);\n\n    // Generate sum\n    assign S = P ^ C_in;\n\n    // Final carry-out\n    assign C_out = C[5];\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation to be performed\n`define ADD 4'b0000\n`define SUB 4'b1000\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2, result;\nwire [4:0] rd;\nwire [4:0] opcode;\nwire [31:0] op1_val, op2_val;\n\n// Instantiate the stages\nfetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(0), .fetched_instr(fetched_instr));\nexecute_stage execute (.clk(clk), .rst(rst), .opcode(fetched_instr[31:28]), .op1(op1), .op2(op2), .result(result));\nwriteback_stage writeback (.clk(clk), .rst(rst), .rd(fetched_instr[24:20]), .result(result), .reg_file(reg_file), .out_reg_file(out_reg_file));\n\n// Assign the operands and result\nassign op1_val = reg_file[fetched_instr[20:16]];\nassign op2_val = reg_file[fetched_instr[15:11]];\nassign op1 = (fetched_instr[28] == `ADD) ? op1_val : ~op1_val + 1;\nassign op2 = (fetched_instr[28] == `ADD) ? op2_val : ~op2_val + 1;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            fetched_instr <= 0;\n        else\n            fetched_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [4:0] opcode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else begin\n            case (opcode)\n                `ADD: result <= op1 + op2;\n                `SUB: result <= op1 - op2;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] rd,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file <= 0;\n        else\n            out_reg_file[rd] <= result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Output parity\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the parity of the combined 16 bits\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;      // 8-bit input\n    output p;           // Output parity\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of the input\n    assign p = ^x;\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D0, Bout0);\n    subtractor_8bit SUB2(A[32:18], B[32:18], Bout0, D1, Bout1);\n    subtractor_8bit SUB3(A[32:12], B[32:12], Bout1, D2, Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D3, Bout3);\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n\n    wire [4:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n    wire [4:0] D0, D1, D2, D3, D4, D5, D6, D7;\n\n    subtractor_4bit SUB1(A[7:4], B[7:4], Bin, D0, Bout0);\n    subtractor_4bit SUB2(A[7:2], B[7:2], Bout0, D1, Bout1);\n    subtractor_4bit SUB3(A[7:1], B[7:1], Bout1, D2, Bout2);\n    subtractor_4bit SUB4(A[7:0], B[7:0], Bout2, D3, Bout3);\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [4:0] A;\n    input [4:0] B;\n    input Bin;\n    output [4:0] D;\n    output Bout;\n\n    wire [2:0] Bout0, Bout1, Bout2;\n    wire [2:0] D0, D1, D2;\n\n    subtractor_2bit SUB1(A[4:2], B[4:2], Bin, D0, Bout0);\n    subtractor_2bit SUB2(A[4:1], B[4:1], Bout0, D1, Bout1);\n    subtractor_2bit SUB3(A[4:0], B[4:0], Bout1, D2, Bout2);\n\n    assign D = {D2, D1, D0};\n    assign Bout = Bout2;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [2:0] A;\n    input [2:0] B;\n    input Bin;\n    output [2:0] D;\n    output Bout;\n\n    wire [1:0] Bout0, Bout1;\n    wire [1:0] D0, D1;\n\n    subtractor_1bit SUB1(A[2:1], B[2:1], Bin, D0, Bout0);\n    subtractor_1bit SUB2(A[2:0], B[2:0], Bout0, D1, Bout1);\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Bout;\n\n    assign {Bout, D} = A - B - Bin;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define OPCODE 5:0\n`define RD 11:7\n`define RS1 19:15\n`define RS2 24:20\n`define FUNC 31:26\n\n// Register file\n`define REG_SIZE 32\n\n// Instruction memory\n`define INSTR_SIZE 32\n\n// Pipeline stages\nstage_fetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\nstage_execute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\nstage_writeback writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(execute.out_reg_file),\n    .out_reg_file(writeback.out_reg_file)\n);\n\nendmodule\n\nmodule stage_fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule stage_execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    wire [31:0] op1, op2, result;\n    wire [5:0] opcode;\n    wire [4:0] rd, rs1, rs2;\n    wire [5:0] func;\n\n    assign opcode = instr[`OPCODE];\n    assign rd = instr[`RD];\n    assign rs1 = instr[`RS1];\n    assign rs2 = instr[`RS2];\n    assign func = instr[`FUNC];\n\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[rd] <= 0;\n        end else begin\n            case (opcode)\n                `ADD: out_reg_file[rd] <= op1 + op2;\n                `SUB: out_reg_file[rd] <= op1 - op2;\n                default: out_reg_file[rd] <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule stage_writeback(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    assign out_reg_file = reg_file;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(x_parity)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(y_parity)\n    );\n\n    // Compute the parity of the combined 16 bits\n    assign P = (x_parity ^ y_parity);\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(\n        .X(X[3:0]),\n        .P(x_parity[3:0])\n    );\n\n    parity_4bit gen2(\n        .X(X[7:4]),\n        .P(x_parity[7:4])\n    );\n\n    // Compute the parity of the 8 bits\n    assign P = (x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3] ^ x_parity[4] ^ x_parity[5] ^ x_parity[6] ^ x_parity[7]);\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;      // 4-bit input X\n    output P;           // Parity output\n\n    wire [3:0] x_parity; // Parity of X\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(\n        .X(X[1:0]),\n        .P(x_parity[1:0])\n    );\n\n    parity_2bit gen2(\n        .X(X[3:2]),\n        .P(x_parity[3:2])\n    );\n\n    // Compute the parity of the 4 bits\n    assign P = (x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3]);\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;      // 2-bit input X\n    output P;           // Parity output\n\n    assign P = (X[0] ^ X[1]); // Compute the parity of the 2 bits\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] X_parity;\n    wire [7:0] Y_parity;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(X_parity));\n    parity_8bit gen2(.x(Y), .p(Y_parity));\n\n    // Compute the final parity\n    assign P = X_parity ^ Y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;      // 8-bit input\n    output p;           // Parity output\n\n    wire [7:0] x_parity;\n\n    // Compute the parity of the input\n    assign x_parity = ^x;\n\n    // Output the parity\n    assign p = x_parity;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    // Instantiate 8-bit subtractors\n    subtractor SUB1(A[32:24], B[32:24], Bin, D[32:24], Bout0);\n    subtractor SUB2(A[32:16], B[32:16], Bout0, D[32:16], Bout1);\n    subtractor SUB3(A[32:8], B[32:8], Bout1, D[32:8], Bout2);\n    subtractor SUB4(A[32:1], B[32:1], Bout2, D[32:1], Bout3);\n\n    // Output borrow-out\n    assign Bout = Bout3;\n\nendmodule\n\nmodule subtractor(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    // Instantiate 4-bit subtractor\n    subtractor_4bit SUB(A, B, Bin, D, Cout);\n\n    // Output borrow-out\n    assign Bout = Cout;\n\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Cout);\n    input [3:0] A;\n    input [3:0] B;\n    input Bin;\n    output [3:0] D;\n    output Cout;\n    wire Cout0, Cout1;\n\n    // Instantiate 2-bit subtractors\n    subtractor_2bit SUB1(A[3:2], B[3:2], Bin, D[3:2], Cout0);\n    subtractor_2bit SUB2(A[1:0], B[1:0], Cout0, D[1:0], Cout1);\n\n    // Output carry-out\n    assign Cout = Cout1;\n\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Cout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Cout;\n\n    // Instantiate 1-bit subtractor\n    subtractor_1bit SUB(A, B, Bin, D, Cout);\n\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Cout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Cout;\n\n    // Subtract\n    assign {Cout, D} = A - B - Bin;\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] p1, p2;  // Parity outputs from 8-bit generators\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(p1));\n    parity_8bit gen2(.X(Y), .P(p2));\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\n// 8-bit parity generator module\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input\n    output P;            // Parity output\n\n    wire [7:0] p1, p2;   // Parity outputs from 4-bit generators\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(.X(X[3:0]), .P(p1));\n    parity_4bit gen2(.X(X[7:4]), .P(p2));\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\n// 4-bit parity generator module\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input\n    output P;             // Parity output\n\n    assign P = X[0] ^ X[1] ^ X[2] ^ X[3];\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] temp0, temp1, temp2, temp3;\n\n    shift_left_add SAA0 (.a(a), .b(b[0]), .temp(temp0));\n    shift_left_add SAA1 (.a(temp0), .b(b[1]), .temp(temp1));\n    shift_left_add SAA2 (.a(temp1), .b(b[2]), .temp(temp2));\n    shift_left_add SAA3 (.a(temp2), .b(b[3]), .temp(temp3));\n\n    assign product = temp3;\n\nendmodule\n\nmodule shift_left_add(input [3:0] a, input b, output [7:0] temp);\n    assign temp = a << b | a;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    // Instantiate 8-bit subtractor blocks\n    subtractor SUB1(A[32:25], B[32:25], Bin, D0, Bout0);\n    subtractor SUB2(A[32:18], B[32:18], Bout0, D1, Bout1);\n    subtractor SUB3(A[32:12], B[32:12], Bout1, D2, Bout2);\n    subtractor SUB4(A[32:6], B[32:6], Bout2, D3, Bout3);\n\n    // Assign outputs\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\n\nendmodule\n\nmodule subtractor(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n\n    wire Cout;\n    assign {Cout, D} = A - B - Bin;\n    assign Bout = Cout;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0(.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [2:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0(.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_and_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_and_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_and_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_and_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule shift_and_add(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    assign product = a << b;\n\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the last carry-out of the 4-bit full adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the last carry-out of the 2-bit full adder\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out wire\n\n    // Instantiate 1-bit full adder for the final bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the last carry-out of the 1-bit full adder\n    assign C_out = c1;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in input\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .accumulated_data(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (valid_in) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accumulated_data <= 0;\n        end else if (valid_in) begin\n            accumulated_data <= accumulated_data + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end else if (count == 4) begin\n            valid_out <= 1;\n        end else begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\n\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        count_out <= count;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2, c3, c4; // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the last carry-out of the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;         // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the last carry-out of the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    input C_in;           // Carry-in\n    output [1:0] S;      // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;              // Carry-out wire\n\n    // Instantiate 1-bit full adder for the last bit\n    full_adder fa(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the last carry-out of the last adder\n    assign C_out = c1;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for counter initialization\n    wire [3:0] init_out;\n    initial_counter init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counter increment\n    wire [3:0] increment_out;\n    increment_counter increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(increment_out)\n    );\n\n    // Output the incremented value\n    assign out = increment_out;\n\nendmodule\n\n// Submodule for initializing the counter to zero\nmodule initial_counter (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end\n    end\nendmodule\n\n// Submodule for incrementing the counter\nmodule increment_counter (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            out <= init_out + 1;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [1:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    // Perform addition\n    assign {C_out, S} = A + B + C_in;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate wires and registers\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] shift_reg;\nwire [2:0] counter;\nwire [15:0] quotient;\nwire [7:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_mod_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .counter(counter),\n    .shift_reg(shift_reg)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\n// Assigning intermediate values\nassign remainder = abs_dividend % neg_divisor;\nassign quotient = abs_dividend / neg_divisor;\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 8'd0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negative value calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 8'd0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [2:0] counter,\n    output reg [7:0] shift_reg\n);\n\nreg [2:0] counter_next;\nreg [7:0] shift_reg_next;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 3'd0;\n        shift_reg <= 8'd0;\n    end else begin\n        counter <= counter_next;\n        shift_reg <= shift_reg_next;\n    end\nend\n\nalways @* begin\n    counter_next = counter;\n    shift_reg_next = shift_reg;\n\n    if (opn_valid && !res_ready) begin\n        if (counter == 3'd7) begin\n            counter_next = 3'd0;\n            shift_reg_next = 8'd0;\n        end else begin\n            counter_next = counter + 3'd1;\n            shift_reg_next = {shift_reg[6:0], 1'b0};\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [2:0] counter,\n    input wire [7:0] shift_reg,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [15:0] quotient,\n    input wire [7:0] remainder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg [15:0] quotient_reg;\nreg [7:0] remainder_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 1'b0;\n        result <= 16'd0;\n        quotient_reg <= 16'd0;\n        remainder_reg <= 8'd0;\n    end else begin\n        if (res_ready) begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n            quotient_reg <= 16'd0;\n            remainder_reg <= 8'd0;\n        end else begin\n            if (opn_valid && !res_ready) begin\n                res_valid <= 1'b1;\n                result <= {remainder, quotient};\n                quotient_reg <= quotient;\n                remainder_reg <= remainder;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodule instances\ncounter_logic u_counter_logic (\n    .current_count(count),\n    .next_count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .current_count(count),\n    .next_count(count)\n);\n\nendmodule\n\n// Submodule for counter logic\nmodule counter_logic (\n    input wire [15:0] current_count,\n    output reg [15:0] next_count,\n    input wire up_down\n);\n\nalways @(*) begin\n    if (up_down) begin\n        next_count = current_count + 1;\n    end else begin\n        next_count = current_count - 1;\n    end\nend\n\nendmodule\n\n// Submodule for counter register\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        next_count <= 0;\n    end else begin\n        next_count <= current_count;\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out signals\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the last carry-out of the 4-bit full adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out signals\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the last carry-out of the 2-bit full adder\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out signal\n\n    // Instantiate 1-bit full adder for the final 1-bit group\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the last carry-out of the 1-bit full adder\n    assign C_out = c1;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in input\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a & b;\n    end\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a | b;\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization submodule\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition submodule\n    state_transition transition (\n        .clk(clk),\n        .out(transition_out)\n    );\n\n    // Connect the outputs\n    assign out = init_out | transition_out;\n\nendmodule\n\n// Submodule for state initialization\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\n// Submodule for state transition\nmodule state_transition (\n    input wire clk,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= out >> 1;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    wire [8:0] temp_sum;\n    assign temp_sum = a + b;\n    assign sum = temp_sum;\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] next_counter;\n    wire [3:0] shift_reg;\n    wire [3:0] next_shift_reg;\n    wire [15:0] next_result;\n    wire [15:0] next_remainder;\n    wire [15:0] next_quotient;\n    wire [7:0] next_abs_dividend;\n    wire [7:0] next_neg_divisor;\n    wire [3:0] next_counter_ready;\n    wire [3:0] next_counter_valid;\n\n    // Absolute value calculation\n    abs_value abs_dividend_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    // Negative divisor calculation\n    neg_value neg_divisor_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    // Division control logic\n    divider_control div_ctrl_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .counter_ready(next_counter_ready),\n        .counter_valid(next_counter_valid),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Result management\n    result_management res_mgmt_module (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .result(result),\n        .remainder(remainder),\n        .quotient(quotient),\n        .counter(counter),\n        .counter_ready(next_counter_ready),\n        .counter_valid(next_counter_valid),\n        .res_valid(res_valid)\n    );\n\n    // Assign next state values\n    assign next_result = {remainder, quotient};\n    assign next_remainder = remainder;\n    assign next_quotient = quotient;\n    assign next_shift_reg = shift_reg;\n    assign next_counter_ready = counter_ready;\n    assign next_counter_valid = counter_valid;\n    assign next_abs_dividend = abs_dividend;\n    assign next_neg_divisor = neg_divisor;\n\nendmodule\n\n// Absolute value calculation module\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Negative value calculation module\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Division control logic module\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [3:0] counter,\n    output reg [3:0] shift_reg,\n    output reg [3:0] counter_ready,\n    output reg [3:0] counter_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [3:0] counter_reg;\n    reg [3:0] shift_reg_reg;\n    reg [3:0] counter_ready_reg;\n    reg [3:0] counter_valid_reg;\n    reg [15:0] quotient_reg;\n    reg [15:0] remainder_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_reg <= 0;\n            shift_reg_reg <= 0;\n            counter_ready_reg <= 0;\n            counter_valid_reg <= 0;\n            quotient_reg <= 0;\n            remainder_reg <= 0;\n        end else begin\n            counter_reg <= counter_ready_reg;\n            shift_reg_reg <= shift_reg;\n            counter_ready_reg <= counter_ready;\n            counter_valid_reg <= counter_valid;\n            quotient_reg <= quotient;\n            remainder_reg <= remainder;\n        end\n    end\n\n    always @(*) begin\n        counter = counter_reg;\n        shift_reg = shift_reg_reg;\n        counter_ready = counter_ready_reg;\n        counter_valid = counter_valid_reg;\n        quotient = quotient_reg;\n        remainder = remainder_reg;\n    end\n\n    always @(*) begin\n        if (counter_ready) begin\n            counter = counter + 1;\n            shift_reg = {shift_reg[6:0], dividend[7]};\n            remainder = remainder << 1;\n            if (shift_reg[7]) begin\n                remainder = remainder + divisor;\n            end\n            if (counter == 7) begin\n                quotient = quotient << 1;\n                if (shift_reg[7]) begin\n                    quotient = quotient + divisor;\n                end\n                counter_valid = 1;\n            end\n        end else begin\n            counter_valid = 0;\n        end\n    end\n\nendmodule\n\n// Result management module\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [15:0] result,\n    input wire [15:0] remainder,\n    input wire [15:0] quotient,\n    input wire [3:0] counter,\n    input wire [3:0] counter_ready,\n    input wire [3:0] counter_valid,\n    output reg res_valid\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end else begin\n            if (res_ready) begin\n                result <= 0;\n                res_valid <= 0;\n            end else if (opn_valid && counter_valid) begin\n                result <= {remainder, quotient};\n                res_valid <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_out;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_out(count_out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_out;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate wires for the submodules\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [7:0] remainder;\n\n// Instantiating submodules\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for calculating negative value\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for managing division control\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder\n);\n\nreg [3:0] counter;\nreg [7:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        res_valid <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else begin\n        if (opn_valid) begin\n            counter <= 0;\n            shift_reg <= dividend;\n            res_valid <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else if (counter < 8) begin\n            counter <= counter + 1;\n            shift_reg <= {shift_reg[6:0], 1'b0};\n            if (shift_reg[7:0] >= divisor) begin\n                shift_reg <= shift_reg - divisor;\n                quotient <= {quotient[14:0], 1'b1};\n            end else begin\n                quotient <= quotient;\n            end\n            remainder <= shift_reg[7:0];\n            res_valid <= 0;\n        end else begin\n            res_valid <= 1;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for managing result validity\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    input wire [15:0] quotient,\n    input wire [7:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        res_valid <= 0;\n    end else begin\n        if (res_ready) begin\n            if (sign) begin\n                result <= {remainder, quotient};\n            end else begin\n                result <= {remainder, quotient};\n            end\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n\n    assign xor_result = a ^ b;\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = rot_dir ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] shift_reg;\nwire [3:0] counter;\nwire [15:0] quotient;\n\n// Instantiate submodules\nabs_value abs_dividend (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .abs_value(abs_dividend)\n);\n\nneg_value neg_divisor_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .neg_value(neg_divisor)\n);\n\ndivider_control ctrl (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .shift_reg(shift_reg)\n);\n\nresult_management res_mgmt (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .quotient(quotient),\n    .result(result),\n    .res_valid(res_valid)\n);\n\n// Connect submodules\nassign result = {quotient, abs_dividend - (neg_divisor << shift_reg)};\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] abs_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        abs_value <= 0;\n    else if (sign)\n        abs_value <= -value;\n    else\n        abs_value <= value;\nend\n\nendmodule\n\n// Submodule for negative value calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] neg_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        neg_value <= 0;\n    else if (sign)\n        neg_value <= ~value + 1;\n    else\n        neg_value <= value;\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n    end else if (opn_valid) begin\n        counter <= 4;\n        shift_reg <= 0;\n    end else if (counter > 0) begin\n        counter <= counter - 1;\n        shift_reg <= shift_reg + 1;\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    input wire [15:0] quotient,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        result <= 0;\n    end else if (res_ready) begin\n        res_valid <= 0;\n        result <= 0;\n    end else if (counter == 0) begin\n        res_valid <= 1;\n        result <= quotient;\n    end\nend\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .out_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .out_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set zero flag if result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + (mode ? -1 : 1);\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n\n  // Instantiate the counter submodule\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the counter output based on mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (mode == 0);\n  end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_d (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [31:0] divisor  // 32-bit divisor\n);\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = {B, 16'b0};\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [31:0] divisor,  // 32-bit divisor\n    output reg [31:0] quotient,  // 32-bit quotient\n    output reg [31:0] remainder  // 32-bit remainder\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [4:0] shift_count;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        shift_count = 0;\n\n        while (shifted_dividend >= shifted_divisor) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            shift_count = shift_count + 1;\n        end\n\n        quotient = shift_count;\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .control(op_code[1])\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire control\n);\n    assign result = control ? (a & b) : (a | b);\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = (mode == 0) ? count_value : (~count_value + 1'b1);\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= (mode == 0) ? count + 1 : count - 1;\n  end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the count value based on mode\n  assign count = (mode == 0) ? count_value : (~count_value + 1'b1);\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= (mode == 0) ? count + 1 : count - 1;\n    end\n  end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q[0] <= Q[0];\n            next_Q[1] <= Q[0] ^ Q[1];\n            next_Q[2] <= Q[1] ^ Q[2];\n            next_Q[3] <= Q[2] ^ Q[3];\n            next_Q[4] <= Q[3] ^ Q[4];\n            next_Q[5] <= Q[4] ^ Q[5];\n            next_Q[6] <= Q[5] ^ Q[6];\n            next_Q[7] <= Q[6] ^ Q[7];\n            next_Q[8] <= Q[7] ^ Q[8];\n            next_Q[9] <= Q[8] ^ Q[9];\n            next_Q[10] <= Q[9] ^ Q[10];\n            next_Q[11] <= Q[10] ^ Q[11];\n            next_Q[12] <= Q[11] ^ Q[12];\n            next_Q[13] <= Q[12] ^ Q[13];\n            next_Q[14] <= Q[13] ^ Q[14];\n            next_Q[15] <= Q[14] ^ Q[15];\n            next_Q[16] <= Q[15] ^ Q[16];\n            next_Q[17] <= Q[16] ^ Q[17];\n            next_Q[18] <= Q[17] ^ Q[18];\n            next_Q[19] <= Q[18] ^ Q[19];\n            next_Q[20] <= Q[19] ^ Q[20];\n            next_Q[21] <= Q[20] ^ Q[21];\n            next_Q[22] <= Q[21] ^ Q[22];\n            next_Q[23] <= Q[22] ^ Q[23];\n            next_Q[24] <= Q[23] ^ Q[24];\n            next_Q[25] <= Q[24] ^ Q[25];\n            next_Q[26] <= Q[25] ^ Q[26];\n            next_Q[27] <= Q[26] ^ Q[27];\n            next_Q[28] <= Q[27] ^ Q[28];\n            next_Q[29] <= Q[28] ^ Q[29];\n            next_Q[30] <= Q[29] ^ Q[30];\n            next_Q[31] <= Q[30] ^ Q[31];\n            next_Q[32] <= Q[31] ^ Q[32];\n            next_Q[33] <= Q[32] ^ Q[33];\n            next_Q[34] <= Q[33] ^ Q[34];\n            next_Q[35] <= Q[34] ^ Q[35];\n            next_Q[36] <= Q[35] ^ Q[36];\n            next_Q[37] <= Q[36] ^ Q[37];\n            next_Q[38] <= Q[37] ^ Q[38];\n            next_Q[39] <= Q[38] ^ Q[39];\n            next_Q[40] <= Q[39] ^ Q[40];\n            next_Q[41] <= Q[40] ^ Q[41];\n            next_Q[42] <= Q[41] ^ Q[42];\n            next_Q[43] <= Q[42] ^ Q[43];\n            next_Q[44] <= Q[43] ^ Q[44];\n            next_Q[45] <= Q[44] ^ Q[45];\n            next_Q[46] <= Q[45] ^ Q[46];\n            next_Q[47] <= Q[46] ^ Q[47];\n            next_Q[48] <= Q[47] ^ Q[48];\n            next_Q[49] <= Q[48] ^ Q[49];\n            next_Q[50] <= Q[49] ^ Q[50];\n            next_Q[51] <= Q[50] ^ Q[51];\n            next_Q[52] <= Q[51] ^ Q[52];\n            next_Q[53] <= Q[52] ^ Q[53];\n            next_Q[54] <= Q[53] ^ Q[54];\n            next_Q[55] <= Q[54] ^ Q[55];\n            next_Q[56] <= Q[55] ^ Q[56];\n            next_Q[57] <= Q[56] ^ Q[57];\n            next_Q[58] <= Q[57] ^ Q[58];\n            next_Q[59] <= Q[58] ^ Q[59];\n            next_Q[60] <= Q[59] ^ Q[60];\n            next_Q[61] <= Q[60] ^ Q[61];\n            next_Q[62] <= Q[61] ^ Q[62];\n            next_Q[63] <= Q[62] ^ Q[63];\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control signal for the bitwise operator\n    wire [31:0] op_result;\n    assign op_result = (op_code == 2'b00) ? add_result :\n                       (op_code == 2'b01) ? sub_result :\n                       (op_code == 2'b10) ? and_result : or_result;\n\n    // Output the result based on the operation code\n    assign result = op_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire [1:0] op_code\n);\n\n    always @(a or b or op_code) begin\n        if (op_code == 2'b00) begin\n            result = a & b;\n        end else begin\n            result = a | b;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [31:0] dividend,\n    output reg [31:0] divisor\n);\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = {B, 16'b0};\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        temp_quotient = 0;\n        temp_remainder = 0;\n\n        for (i = 0; i < 16; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                temp_quotient[i] = 1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end\n            shifted_divisor = shifted_divisor << 1;\n        end\n\n        quotient = temp_quotient;\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    // Instantiating the two latches\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    // Output assignment\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\n\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .control(op_code[1])\n    );\n\n    // Control logic to determine the operation based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire control\n);\n\n    always @(a or b or control) begin\n        if (control) begin\n            result = a & b;\n        end else begin\n            result = a | b;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    assign dividend = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        quotient = 0;\n        remainder = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                quotient[i] = 1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end else begin\n                quotient[i] = 0;\n            end\n\n            shifted_divisor = shifted_divisor >> 1;\n        end\n\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b00000000;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0}; // Adjust dividend to 32 bits\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        // Implement division algorithm\n        quotient = dividend / divisor;\n        remainder = dividend % divisor;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] bitwise_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .bitwise_result(bitwise_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? bitwise_result :\n                    0;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] bitwise_result\n);\n    assign bitwise_result = (op_code == 2'b10) ? a & b :\n                            (op_code == 2'b11) ? a | b :\n                            0;\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for a single shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= {1'b0, out[7:1]};\n    end\nend\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state[0] <= Q[0];\n            next_state[1] <= Q[0] ^ Q[1];\n            next_state[2] <= Q[1] ^ Q[2];\n            next_state[3] <= Q[2] ^ Q[3];\n            next_state[4] <= Q[3] ^ Q[4];\n            next_state[5] <= Q[4] ^ Q[5];\n            next_state[6] <= Q[5] ^ Q[6];\n            next_state[7] <= Q[6] ^ Q[7];\n            next_state[8] <= Q[7] ^ Q[8];\n            next_state[9] <= Q[8] ^ Q[9];\n            next_state[10] <= Q[9] ^ Q[10];\n            next_state[11] <= Q[10] ^ Q[11];\n            next_state[12] <= Q[11] ^ Q[12];\n            next_state[13] <= Q[12] ^ Q[13];\n            next_state[14] <= Q[13] ^ Q[14];\n            next_state[15] <= Q[14] ^ Q[15];\n            next_state[16] <= Q[15] ^ Q[16];\n            next_state[17] <= Q[16] ^ Q[17];\n            next_state[18] <= Q[17] ^ Q[18];\n            next_state[19] <= Q[18] ^ Q[19];\n            next_state[20] <= Q[19] ^ Q[20];\n            next_state[21] <= Q[20] ^ Q[21];\n            next_state[22] <= Q[21] ^ Q[22];\n            next_state[23] <= Q[22] ^ Q[23];\n            next_state[24] <= Q[23] ^ Q[24];\n            next_state[25] <= Q[24] ^ Q[25];\n            next_state[26] <= Q[25] ^ Q[26];\n            next_state[27] <= Q[26] ^ Q[27];\n            next_state[28] <= Q[27] ^ Q[28];\n            next_state[29] <= Q[28] ^ Q[29];\n            next_state[30] <= Q[29] ^ Q[30];\n            next_state[31] <= Q[30] ^ Q[31];\n            next_state[32] <= Q[31] ^ Q[32];\n            next_state[33] <= Q[32] ^ Q[33];\n            next_state[34] <= Q[33] ^ Q[34];\n            next_state[35] <= Q[34] ^ Q[35];\n            next_state[36] <= Q[35] ^ Q[36];\n            next_state[37] <= Q[36] ^ Q[37];\n            next_state[38] <= Q[37] ^ Q[38];\n            next_state[39] <= Q[38] ^ Q[39];\n            next_state[40] <= Q[39] ^ Q[40];\n            next_state[41] <= Q[40] ^ Q[41];\n            next_state[42] <= Q[41] ^ Q[42];\n            next_state[43] <= Q[42] ^ Q[43];\n            next_state[44] <= Q[43] ^ Q[44];\n            next_state[45] <= Q[44] ^ Q[45];\n            next_state[46] <= Q[45] ^ Q[46];\n            next_state[47] <= Q[46] ^ Q[47];\n            next_state[48] <= Q[47] ^ Q[48];\n            next_state[49] <= Q[48] ^ Q[49];\n            next_state[50] <= Q[49] ^ Q[50];\n            next_state[51] <= Q[50] ^ Q[51];\n            next_state[52] <= Q[51] ^ Q[52];\n            next_state[53] <= Q[52] ^ Q[53];\n            next_state[54] <= Q[53] ^ Q[54];\n            next_state[55] <= Q[54] ^ Q[55];\n            next_state[56] <= Q[55] ^ Q[56];\n            next_state[57] <= Q[56] ^ Q[57];\n            next_state[58] <= Q[57] ^ Q[58];\n            next_state[59] <= Q[58] ^ Q[59];\n            next_state[60] <= Q[59] ^ Q[60];\n            next_state[61] <= Q[60] ^ Q[61];\n            next_state[62] <= Q[61] ^ Q[62];\n            next_state[63] <= Q[62] ^ Q[63];\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 8'b0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0; // Reset to zero\n        end else begin\n            Q <= 64'b0; // Reset to zero\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output reg [63:0]   next_state\n);\n\n    always @(*) begin\n        next_state = {Q[62:0], Q[63]}; // Update next state based on LSB\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the results\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 8'b0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the results to the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [3:0] i;\n\n    // Initialize the temporary variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n        i = 0;\n    end\n\n    // Perform the division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_quotient + (1 << i);\n            temp_dividend = temp_dividend - temp_divisor;\n        end\n        temp_remainder = temp_dividend;\n        i = i + 1;\n    end\n\n    // Assign the final results\n    always @(*) begin\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry; // Carry chain\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry chain\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry; // Carry chain\n\n    // Instantiate full adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(carry[0])\n    );\n\n    // Carry chain\n    assign Carry_out = carry[8];\n\nendmodule\n\nmodule full_adder(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Calculate sum and carry\n    assign Sum = X + Y;\n    assign Carry_out = (X[7] & Y[7]) | (X[7] & Sum[7]) | (Y[7] & Sum[7]);\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\n// Submodule for 50MHz frequency\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10MHz frequency\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 1MHz frequency\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiating the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\n// Assigning the results to the output ports\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [15:0] shifted_dividend;\nreg [15:0] shifted_dividend_remainder;\nreg [15:0] shifted_dividend_quotient;\nreg [15:0] shifted_dividend_remainder_temp;\nreg [15:0] shifted_dividend_quotient_temp;\nreg [15:0] shifted_dividend_remainder_temp_temp;\nreg [15:0] shifted_dividend_quotient_temp_temp;\nreg [15:0] remainder_temp;\nreg [15:0] quotient_temp;\nreg [15:0] remainder_temp_temp;\nreg [15:0] quotient_temp_temp;\n\n// Initializing the dividend and divisor\ninitial begin\n    dividend = A;\n    divisor = B;\nend\n\n// Shifting the dividend and comparing with the divisor\nalways @(*) begin\n    shifted_dividend = {dividend[14:0], 1'b0};\n    shifted_dividend_remainder = {shifted_dividend[14:0], shifted_dividend[15]};\n    shifted_dividend_quotient = {shifted_dividend_remainder[14:0], shifted_dividend_remainder[15]};\n    shifted_dividend_remainder_temp = {shifted_dividend_remainder[13:0], shifted_dividend_remainder[15:14]};\n    shifted_dividend_quotient_temp = {shifted_dividend_quotient[13:0], shifted_dividend_quotient[15:14]};\n    shifted_dividend_remainder_temp_temp = {shifted_dividend_remainder_temp[12:0], shifted_dividend_remainder_temp[15:13]};\n    shifted_dividend_quotient_temp_temp = {shifted_dividend_quotient_temp[12:0], shifted_dividend_quotient_temp[15:13]};\n    remainder_temp = shifted_dividend_remainder_temp_temp;\n    quotient_temp = shifted_dividend_quotient_temp_temp;\n    remainder_temp_temp = remainder_temp;\n    quotient_temp_temp = quotient_temp;\nend\n\n// Updating the quotient and remainder\nalways @(*) begin\n    remainder = remainder_temp_temp;\n    quotient = quotient_temp_temp;\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_part_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_part_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_part_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_part_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_part_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_part_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_part_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_part_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_part_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_part_product_bit GP0(.X(X), .Y(Y), .P(p0));\n    gen_part_product_bit GP1(.X(X), .Y(Y), .P(p1));\n    gen_part_product_bit GP2(.X(X), .Y(Y), .P(p2));\n    gen_part_product_bit GP3(.X(X), .Y(Y), .P(p3));\n    gen_part_product_bit GP4(.X(X), .Y(Y), .P(p4));\n    gen_part_product_bit GP5(.X(X), .Y(Y), .P(p5));\n    gen_part_product_bit GP6(.X(X), .Y(Y), .P(p6));\n    gen_part_product_bit GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_part_product_bit(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_part_product_bit_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_part_product_bit_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_part_product_bit_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_part_product_bit_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_part_product_bit_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_part_product_bit_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_part_product_bit_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_part_product_bit_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_part_product_bit_shift(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_part_product_bit_shift_add GP0(.X(X), .Y(Y), .P(p0));\n    gen_part_product_bit_shift_add GP1(.X(X), .Y(Y), .P(p1));\n    gen_part_product_bit_shift_add GP2(.X(X), .Y(Y), .P(p2));\n    gen_part_product_bit_shift_add GP3(.X(X), .Y(Y), .P(p3));\n    gen_part_product_bit_shift_add GP4(.X(X), .Y(Y), .P(p4));\n    gen_part_product_bit_shift_add GP5(.X(X), .Y(Y), .P(p5));\n    gen_part_product_bit_shift_add GP6(.X(X), .Y(Y), .P(p6));\n    gen_part_product_bit_shift_add GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_part_product_bit_shift_add(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X + (Y << 1);\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                counter <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                counter <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa (\n        .X(X[0]),\n        .Y(Y[0]),\n        .Sum(Sum[0]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\nmodule full_adder(\n    input X,    // First input operand\n    input Y,    // Second input operand\n    output Sum, // Output sum\n    output Carry_out  // Carry output\n);\n\n    wire carry_in;\n\n    assign Sum = X ^ Y;\n    assign Carry_out = (X & Y) | (X & carry_in) | (Y & carry_in);\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the difference of A and B\n    output B_out;       // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [8:0] sum;    // 9-bit sum\n    wire carry;        // Carry output from the full adder\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder module instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Assign the output\n    assign D = sum[7:0];\n    assign B_out = carry;\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [8:0] sum;  // 9-bit sum\n    output carry;       // Carry output indicating if a carry was generated during the addition\n\n    wire [8:0] temp_sum;\n    wire temp_carry;\n\n    // Full adder instantiation for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(0),\n        .Sum(temp_sum[0]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[1]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[2]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[3]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[4]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[5]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[6]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[7]),\n        .Cout(temp_carry)\n    );\n\n    assign sum = temp_sum;\n    assign carry = temp_carry;\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;           // Input A\n    input B;           // Input B\n    input Cin;         // Carry-in\n    output Sum;        // Sum output\n    output Cout;       // Carry-out\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for 50MHz clock\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10MHz clock\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 1MHz clock\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_generator #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MUL2_DIV_CLK(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_average(clk_average),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the two clock signals\n    assign clk_div = clk_adjusted[0] | clk_adjusted[1];\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_generator(\n    input clk,\n    input rst_n,\n    input [3:0] count,\n    output reg [3:0] clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average <= {count[2:0], 1'b0};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input rst_n,\n    input [3:0] clk_average,\n    output reg [3:0] clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted <= {clk_average[2:0], clk_average[3]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry; // Carry chain\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Carry_in(1'b0), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Carry_in(carry[0]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Carry_in(carry[1]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Carry_in(carry[2]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    assign Carry_out = carry[3]; // Output carry\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    input Carry_in,    // Carry input\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [8:0] carry; // Carry chain\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Carry_in(1'b0), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Carry_in(carry[0]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Carry_in(carry[1]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Carry_in(carry[2]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    assign Carry_out = carry[3]; // Output carry\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    input Carry_in,    // Carry input\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out   // Carry output\n);\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Carry_in(1'b0), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Carry_in(carry[0]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    assign Carry_out = carry[1]; // Output carry\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    input Carry_in,    // Carry input\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out   // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa(.X(X[0]), .Y(Y[0]), .Carry_in(Carry_in), .Sum(Sum[0]), .Carry_out(Carry_out));\n\nendmodule\n\nmodule full_adder(\n    input X,    // First input operand\n    input Y,    // Second input operand\n    input Carry_in,    // Carry input\n    output Sum, // Output sum\n    output Carry_out   // Carry output\n);\n\n    assign Sum = X ^ Y ^ Carry_in; // Sum calculation\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in); // Carry calculation\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product_bit GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_product_bit GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_product_bit GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_product_bit GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_product_bit GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_product_bit GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_product_bit GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_product_bit GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product_bit_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_shift(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product_bit_shift_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_shift_shift(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product_bit_shift_shift_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift_shift_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift_shift_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift_shift_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift_shift_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift_shift_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift_shift_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift_shift_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;    // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder module instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output assignment\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 8-bit output representing the sum of A and B\n    output [8:0] carry; // 9-bit output representing the carry out\n\n    wire [8:0] carry_temp; // Temporary carry\n\n    // Full adder module instantiation\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(1'b0),\n        .Sum(sum[0]),\n        .Cout(carry_temp[0])\n    );\n\n    // Full adder module instantiation\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry_temp[0]),\n        .Sum(sum[1]),\n        .Cout(carry_temp[1])\n    );\n\n    // Full adder module instantiation\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry_temp[1]),\n        .Sum(sum[2]),\n        .Cout(carry_temp[2])\n    );\n\n    // Full adder module instantiation\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry_temp[2]),\n        .Sum(sum[3]),\n        .Cout(carry_temp[3])\n    );\n\n    // Full adder module instantiation\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry_temp[3]),\n        .Sum(sum[4]),\n        .Cout(carry_temp[4])\n    );\n\n    // Full adder module instantiation\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry_temp[4]),\n        .Sum(sum[5]),\n        .Cout(carry_temp[5])\n    );\n\n    // Full adder module instantiation\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry_temp[5]),\n        .Sum(sum[6]),\n        .Cout(carry_temp[6])\n    );\n\n    // Full adder module instantiation\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry_temp[6]),\n        .Sum(sum[7]),\n        .Cout(carry[7])\n    );\n\n    // Carry out assignment\n    assign carry[8] = carry_temp[7];\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n    parameter CLK_FREQ = 100000000;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_gen #(.CLK_FREQ(CLK_FREQ)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.CLK_FREQ(CLK_FREQ)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the two clock signals\n    assign clk_div = clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 4'b0000;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule clk_average_gen(\n    input               clk,\n    input               rst_n,\n    input   [3:0]       counter_out,\n    output reg  [3:0]   clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_average <= 4'b0000;\n        else\n            clk_average <= {counter_out[3], counter_out[2], 1'b0, 1'b0};\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input   [3:0]       counter_out,\n    output reg  [3:0]   clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_adjusted <= 4'b0000;\n        else\n            clk_adjusted <= {counter_out[3], counter_out[2], 1'b0, 1'b0};\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;    // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output assignment\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;    // 9-bit sum\n    output [8:0] carry;  // 9-bit carry\n\n    wire [8:0] carry_temp; // Temporary carry\n\n    // Full adder instantiation for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(carry[0]),\n        .Sum(sum[0]),\n        .Cout(carry_temp[0])\n    );\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry_temp[1]),\n        .Sum(sum[1]),\n        .Cout(carry_temp[2])\n    );\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry_temp[2]),\n        .Sum(sum[2]),\n        .Cout(carry_temp[3])\n    );\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry_temp[3]),\n        .Sum(sum[3]),\n        .Cout(carry_temp[4])\n    );\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry_temp[4]),\n        .Sum(sum[4]),\n        .Cout(carry_temp[5])\n    );\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry_temp[5]),\n        .Sum(sum[5]),\n        .Cout(carry_temp[6])\n    );\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry_temp[6]),\n        .Sum(sum[6]),\n        .Cout(carry_temp[7])\n    );\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry_temp[7]),\n        .Sum(sum[7]),\n        .Cout(carry[8])\n    );\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    output Sum,\n    output Carry_out\n);\n\n    // Calculate sum\n    assign Sum = X ^ Y;\n\n    // Calculate carry\n    assign Carry_out = (X & Y) | (X & ~Y) | (~X & Y);\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] P0, P1, P2, P3, P4, P5, P6, P7;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y), .P(P0));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y), .P(P1));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y), .P(P2));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y), .P(P3));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y), .P(P4));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y), .P(P5));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y), .P(P6));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y), .P(P7));\n\n    // Assign the final product\n    assign P = P0 + P1 + P2 + P3 + P4 + P5 + P6 + P7;\n\nendmodule\n\nmodule add_shift(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n    wire [15:0] shifted_X;\n\n    // Shift the multiplicand X left by 0 positions\n    assign shifted_X = X;\n\n    // Add the shifted multiplicand to the accumulator\n    assign P = shifted_X + (Y[0] ? shifted_X << 1 : 0);\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n    parameter CLK_FREQ = 100000000;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_generator #(.CLK_FREQ(CLK_FREQ)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.CLK_FREQ(CLK_FREQ)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR to produce final clock output\n    assign clk_div = clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_generator(\n    input [3:0] clk,\n    input rst_n,\n    input [3:0] count,\n    output reg [3:0] clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average <= {clk[3], clk[2], clk[1], clk[0]};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk,\n    input rst_n,\n    input [3:0] count,\n    output reg [3:0] clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted <= {clk[3], clk[2], clk[1], clk[0]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire [7:0] carry;    // Carry output from full adder\n\n    // 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    full_adder adder_inst[7:0](\n        .a(A[7:0]),\n        .b(B_comp[7:0]),\n        .carry_in(0),\n        .sum(sum[7:0]),\n        .carry_out(carry[7:0])\n    );\n\n    // Output D and B_out\n    assign D = sum;\n    assign B_out = carry[7];\n\nendmodule\n\nmodule full_adder(a, b, carry_in, sum, carry_out);\n    input a;\n    input b;\n    input carry_in;\n    output sum;\n    output carry_out;\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (a & carry_in) | (b & carry_in);\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry wire\n    wire [31:0] sum_temp; // Declare sum wire\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0(.A(A[7:0]), .B(B[7:0]), .Cin(Cin), .Sum(sum_temp[7:0]), .Cout(carry[0]));\n    adder_8bit add1(.A(A[15:8]), .B(B[15:8]), .Cin(carry[0]), .Sum(sum_temp[15:8]), .Cout(carry[1]));\n    adder_8bit add2(.A(A[23:16]), .B(B[23:16]), .Cin(carry[1]), .Sum(sum_temp[23:16]), .Cout(carry[2]));\n    adder_8bit add3(.A(A[31:24]), .B(B[31:24]), .Cin(carry[2]), .Sum(sum_temp[31:24]), .Cout(carry[3]));\n\n    // Assign sum and carry\n    assign Sum = sum_temp;\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    // Perform addition\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] AS0, AS1, AS2, AS3, AS4, AS5, AS6, AS7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.X(X), .Y(Y), .shift(0), .accumulator(AS0));\n    add_shift AS1(.X(X), .Y(Y), .shift(1), .accumulator(AS1));\n    add_shift AS2(.X(X), .Y(Y), .shift(2), .accumulator(AS2));\n    add_shift AS3(.X(X), .Y(Y), .shift(3), .accumulator(AS3));\n    add_shift AS4(.X(X), .Y(Y), .shift(4), .accumulator(AS4));\n    add_shift AS5(.X(X), .Y(Y), .shift(5), .accumulator(AS5));\n    add_shift AS6(.X(X), .Y(Y), .shift(6), .accumulator(AS6));\n    add_shift AS7(.X(X), .Y(Y), .shift(7), .accumulator(AS7));\n\n    // Combine the accumulators\n    assign P = AS0 + AS1 + AS2 + AS3 + AS4 + AS5 + AS6 + AS7;\n\nendmodule\n\nmodule add_shift(X, Y, shift, accumulator);\n    input [7:0] X;\n    input [7:0] Y;\n    input [3:0] shift;\n    output [15:0] accumulator;\n\n    wire [15:0] shifted_X;\n\n    // Shift the multiplicand\n    assign shifted_X = X << shift;\n\n    // Add the shifted multiplicand to the accumulator\n    assign accumulator = shifted_X + (Y[shift] ? shifted_X : 0);\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry signals for each submodule\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3]; // Propagate carry out from the last submodule\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_gen #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the divided clock signals\n    assign clk_div = clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_gen(\n    input clk,\n    input rst_n,\n    input [3:0] count_out,\n    output reg [3:0] clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average <= {count_out[3], count_out[2], count_out[1], count_out[0]};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input rst_n,\n    input [3:0] count_out,\n    output reg [3:0] clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted <= {count_out[3], count_out[2], count_out[1], ~count_out[0]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.X(X), .Y(Y[0]), .A(A0));\n    add_shift AS1(.X(X), .Y(Y[1]), .A(A1));\n    add_shift AS2(.X(X), .Y(Y[2]), .A(A2));\n    add_shift AS3(.X(X), .Y(Y[3]), .A(A3));\n    add_shift AS4(.X(X), .Y(Y[4]), .A(A4));\n    add_shift AS5(.X(X), .Y(Y[5]), .A(A5));\n    add_shift AS6(.X(X), .Y(Y[6]), .A(A6));\n    add_shift AS7(.X(X), .Y(Y[7]), .A(A7));\n\n    // Assign the product\n    assign P = A7 + (A6 << 1) + (A5 << 2) + (A4 << 3) + (A3 << 4) + (A2 << 5) + (A1 << 6) + (A0 << 7);\n\nendmodule\n\nmodule add_shift(X, Y, A);\n    input [7:0] X;\n    input Y;\n    output [15:0] A;\n\n    wire [15:0] shifted_X;\n\n    assign shifted_X = X << Y;\n    assign A = shifted_X + shifted_X;\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [7:0] carry_out;\n\n    // Instantiate 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_out[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_out[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_out[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_out[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_out[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_out[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry_out[3])\n    );\n\n    assign Cout = carry_out[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR operation to generate the divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Value to divide the clock frequency\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Value to divide the clock frequency\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] acc;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y[0]), .acc(acc));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y[1]), .acc(acc));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y[2]), .acc(acc));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y[3]), .acc(acc));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y[4]), .acc(acc));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y[5]), .acc(acc));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y[6]), .acc(acc));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y[7]), .acc(acc));\n\n    // Output the product\n    assign P = acc;\nendmodule\n\nmodule add_shift(X, Y, acc);\n    input [7:0] X;\n    input Y;\n    output [15:0] acc;\n\n    wire [15:0] shifted_X;\n\n    assign shifted_X = (Y) ? (X << 1) : X;\n    assign acc = shifted_X + acc;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output [31:0] B_out;  // Borrow-out output\n\n    wire [15:0] A16, B16, Diff16, B_out16;\n\n    // Instantiate 16-bit subtractors for each 16-bit chunk\n    sub_16bit S1(.A(A[15:0]), .B(B[15:0]), .Diff(Diff16), .B_out(B_out16));\n    sub_16bit S2(.A(A[31:16]), .B(B[31:16]), .Diff(Diff[15:0]), .B_out(B_out[15:0]));\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;    // 16-bit output representing the difference of A and B\n    output [15:0] B_out;   // Borrow-out output\n\n    wire [7:0] A7, B7, Diff7, B_out7;\n\n    // Instantiate 8-bit subtractors for each 8-bit chunk\n    sub_8bit S1(.A(A[7:0]), .B(B[7:0]), .Diff(Diff7), .B_out(B_out7));\n    sub_8bit S2(.A(A[15:8]), .B(B[15:8]), .Diff(Diff[7:0]), .B_out(B_out[7:0]));\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input operand A\n    input [7:0] B;        // 8-bit input operand B\n    output [7:0] Diff;    // 8-bit output representing the difference of A and B\n    output [7:0] B_out;   // Borrow-out output\n\n    wire [3:0] A3, B3, Diff3, B_out3;\n\n    // Instantiate 4-bit subtractors for each 4-bit chunk\n    sub_4bit S1(.A(A[3:0]), .B(B[3:0]), .Diff(Diff3), .B_out(B_out3));\n    sub_4bit S2(.A(A[7:4]), .B(B[7:4]), .Diff(Diff[3:0]), .B_out(B_out[3:0]));\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;        // 4-bit input operand A\n    input [3:0] B;        // 4-bit input operand B\n    output [3:0] Diff;    // 4-bit output representing the difference of A and B\n    output [3:0] B_out;   // Borrow-out output\n\n    wire [1:0] A1, B1, Diff1, B_out1;\n\n    // Instantiate 2-bit subtractors for each 2-bit chunk\n    sub_2bit S1(.A(A[1:0]), .B(B[1:0]), .Diff(Diff1), .B_out(B_out1));\n    sub_2bit S2(.A(A[3:2]), .B(B[3:2]), .Diff(Diff[1:0]), .B_out(B_out[1:0]));\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;        // 2-bit input operand A\n    input [1:0] B;        // 2-bit input operand B\n    output [1:0] Diff;    // 2-bit output representing the difference of A and B\n    output [1:0] B_out;   // Borrow-out output\n\n    wire [0] A0, B0, Diff0, B_out0;\n\n    // Instantiate 1-bit subtractors for each bit\n    sub_1bit S1(.A(A[0]), .B(B[0]), .Diff(Diff0), .B_out(B_out0));\n    sub_1bit S2(.A(A[1]), .B(B[1]), .Diff(Diff[0]), .B_out(B_out[0]));\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;              // 1-bit input operand A\n    input B;              // 1-bit input operand B\n    output Diff;          // 1-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products[3:0];\n    wire [7:0] sum;\n\n    // Generate partial products\n    genvar i;\n    for (i = 0; i < 4; i = i + 1) begin\n        assign partial_products[i] = {4'b0, X[i]} & Y;\n    end\n\n    // Add partial products\n    assign sum = partial_products[0] + partial_products[1] + partial_products[2] + partial_products[3];\n\n    // Assign product\n    assign P = sum;\n\nendmodule\n\nmodule adder_8bit(a, b, c_in, sum, c_out);\n    input [7:0] a, b;      // Input operands\n    input c_in;            // Carry input\n    output [7:0] sum;     // Sum output\n    output c_out;          // Carry output\n\n    wire [8:0] temp_sum;\n\n    // Full adder implementation\n    assign temp_sum = a + b + c_in;\n    assign sum = temp_sum[7:0];\n    assign c_out = temp_sum[8];\n\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;      // Input operands\n    output sum, c_out;     // Sum and carry output\n\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | (a & c_in) | (b & c_in);\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result, sub_result, and_result;\n    wire add_carry, sub_carry;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule interfaces\n    wire clk_div1, clk_div2;\n\n    // Submodules\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_LIMIT = NUM_DIV - 1; // Count limit\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (clk_div == COUNT_LIMIT) begin\n                clk_div <= 0;\n            end else begin\n                clk_div <= clk_div + 1;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_LIMIT = NUM_DIV - 1; // Count limit\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (clk_div == COUNT_LIMIT) begin\n                clk_div <= 0;\n            end else begin\n                clk_div <= clk_div + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit input operand X\n    input [3:0] Y;       // 4-bit input operand Y\n    output [7:0] P;       // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products;\n\n    // Generate partial products\n    wire [3:0] p0, p1, p2, p3;\n    assign p0 = X[0] & Y;\n    assign p1 = X[1] & Y;\n    assign p2 = X[2] & Y;\n    assign p3 = X[3] & Y;\n\n    // Shift and add partial products\n    wire [7:0] pp0, pp1, pp2, pp3;\n    assign pp0 = {4'b0000, p0};\n    assign pp1 = {2'b00, p1, 2'b00, p0};\n    assign pp2 = {1'b0, p2, 3'b000, p1, 1'b0, p0};\n    assign pp3 = {p3, 3'b000, p2, 1'b0, p1, 1'b0, p0};\n\n    // Add partial products\n    wire [7:0] sum0, sum1, sum2, sum3;\n    assign sum0 = pp0 + pp1;\n    assign sum1 = pp2 + pp3;\n    assign sum2 = sum0 + sum1;\n    assign sum3 = sum2 + pp3;\n\n    // Assign output\n    assign P = sum3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n\n    wire [8:0] temp_sum;\n    assign temp_sum = {1'b0, a} + {1'b0, b} + c;\n    assign sum = temp_sum[7:0];\n\nendmodule\n\nmodule full_adder_8bit(a, b, c, sum, carry);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n    output carry;\n\n    wire [8:0] temp_sum;\n    assign temp_sum = {1'b0, a} + {1'b0, b} + c;\n    assign sum = temp_sum[7:0];\n    assign carry = temp_sum[8];\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result, sub_result, and_result;\n    wire add_carry, sub_carry;\n\n    // Instantiate the adder module\n    adder add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    // Instantiate the AND module\n    and_gate and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the result based on the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer to select the carry out based on the operation\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A + B;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A - B;\nendmodule\n\n// AND module\nmodule and_gate(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products[3:0];\n    wire [7:0] sum;\n\n    // Generate partial products\n    genvar i;\n    generate\n        for (i = 0; i < 4; i = i + 1) begin : partial_product\n            assign partial_products[i] = (X[i] & Y) << i;\n        end\n    endgenerate\n\n    // Add partial products\n    assign sum = partial_products[0] + partial_products[1] + partial_products[2] + partial_products[3];\n\n    // Assign product\n    assign P = sum;\n\nendmodule\n\nmodule adder_8bit(a, b, sum);\n    input [7:0] a;\n    input [7:0] b;\n    output [7:0] sum;\n\n    wire [8:0] temp_sum;\n\n    assign temp_sum = a + b;\n    assign sum = temp_sum[7:0];\n\nendmodule\n\nmodule full_adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a;\n    input [7:0] b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [8:0] temp_sum;\n\n    assign temp_sum = a + b + cin;\n    assign sum = temp_sum[7:0];\n    assign cout = temp_sum[8];\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Divisor value\n\n    // Submodule instances\n    wire clk_div1, clk_div2;\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;  // 16-bit difference from first subtractor\n\n    // Instantiate 16-bit subtractor for A[15:0] and B[15:0]\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    // Instantiate 16-bit subtractor for A[31:16] and B[31:16]\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[15:0]),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs\n    assign B_out = B_out_16 | B_out;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out from first subtractor\n    wire [7:0] Diff_8;    // 8-bit difference from first subtractor\n\n    // Instantiate 8-bit subtractor for A[7:0] and B[7:0]\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n\n    // Instantiate 8-bit subtractor for A[15:8] and B[15:8]\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[7:0]),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs\n    assign B_out = B_out_8 | B_out;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input A\n    input [7:0] B;        // 8-bit input B\n    output [7:0] Diff;    // 8-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:0] B_out_4;   // 4-bit borrow-out from first subtractor\n    wire [3:0] Diff_4;    // 4-bit difference from first subtractor\n\n    // Instantiate 4-bit subtractor for A[3:0] and B[3:0]\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff_4),\n        .B_out(B_out_4)\n    );\n\n    // Instantiate 4-bit subtractor for A[7:4] and B[7:4]\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[3:0]),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs\n    assign B_out = B_out_4 | B_out;\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    output [3:0] Diff;    // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [1:0] B_out_2;   // 2-bit borrow-out from first subtractor\n    wire [1:0] Diff_2;    // 2-bit difference from first subtractor\n\n    // Instantiate 2-bit subtractor for A[1:0] and B[1:0]\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff_2),\n        .B_out(B_out_2)\n    );\n\n    // Instantiate 2-bit subtractor for A[3:2] and B[3:2]\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff[1:0]),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs\n    assign B_out = B_out_2 | B_out;\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    output [1:0] Diff;    // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire B_out_1;         // 1-bit borrow-out from first subtractor\n    wire Diff_1;          // 1-bit difference from first subtractor\n\n    // Instantiate 1-bit subtractor for A[0] and B[0]\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff_1),\n        .B_out(B_out_1)\n    );\n\n    // Instantiate 1-bit subtractor for A[1] and B[1]\n    sub_1bit S2(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff[0]),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs\n    assign B_out = B_out_1 | B_out;\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output Diff;          // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    assign Diff = A ^ B;  // Difference\n    assign B_out = ~(A & B); // Borrow-out\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_carry;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting carry out\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter_even counter_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out),\n    .limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider clk_divider_module (\n    .clk_in(clk),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter submodule\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\nparameter NUM_DIV = 4; // Even number used for division\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_out <= 0;\n    end else begin\n        if (count_out == NUM_DIV / 2 - 1) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nend\n\nassign limit = (count_out == NUM_DIV / 2 - 1);\n\nendmodule\n\n// Clock divider submodule\nmodule clk_divider(\n    input clk_in,\n    input counter_limit,\n    output reg clk_div\n);\n\nalways @(posedge clk_in) begin\n    if (counter_limit) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_temp, p1_temp, p2_temp, p3_temp;\n\n    // Bitwise AND operations\n    and gate1(X[0], Y[0], p0_temp[0]);\n    and gate1(X[1], Y[1], p0_temp[1]);\n    and gate1(X[2], Y[2], p0_temp[2]);\n    and gate1(X[3], Y[3], p0_temp[3]);\n\n    // Shift operations\n    shift_left shift1(p0_temp, 1, p1_temp);\n    shift_left shift2(p1_temp, 2, p2_temp);\n    shift_left shift3(p2_temp, 4, p3_temp);\n\n    // Adders\n    adder_8bit add1(.a(p0_temp), .b(p1_temp), .c(1'b0), .p(p0));\n    adder_8bit add2(.a(p2_temp), .b(p3_temp), .c(1'b0), .p(p1));\n    adder_8bit add3(.a(p0), .b(p1), .c(1'b0), .p(p2));\n\nendmodule\n\nmodule and(a, b, out);\n    input a, b;\n    output out;\n    assign out = a & b;\nendmodule\n\nmodule shift_left(a, count, out);\n    input [3:0] a;\n    input [1:0] count;\n    output [7:0] out;\n    assign out = {a[3:0], count[1:0]};\nendmodule\n\nmodule adder_8bit(a, b, c, p);\n    input [7:0] a, b;\n    input c;\n    output [7:0] p;\n    full_adder fa0(.a(a[0]), .b(b[0]), .c(c), .sum(p[0]), .c_out(p[1]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c(p[0]), .sum(p[2]), .c_out(p[3]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c(p[1]), .sum(p[4]), .c_out(p[5]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c(p[2]), .sum(p[6]), .c_out(p[7]));\nendmodule\n\nmodule full_adder(a, b, c, sum, c_out);\n    input a, b, c;\n    output sum, c_out;\n    wire c1, c2;\n    xor x1(a, b, sum);\n    and a1(a, b, c1);\n    and a2(a, c, c2);\n    or o1(c1, c2, c_out);\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter_even counter_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .counter_limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider clk_divider_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter module\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out,\n    output counter_limit\n);\n\nlocalparam NUM_DIV = 8;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_out <= 0;\n    end else begin\n        if (counter_out == NUM_DIV / 2 - 1) begin\n            counter_out <= 0;\n        end else begin\n            counter_out <= counter_out + 1;\n        end\n    end\nend\n\nassign counter_limit = (counter_out == NUM_DIV / 2 - 1);\n\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input counter_limit,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else begin\n        if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select result based on operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is the carry out of the adder\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] count;\nwire toggle;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count),\n    .toggle(toggle)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .toggle(toggle),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count,\n    output toggle\n);\nparameter NUM_DIV = 8; // Even number for division\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n        toggle <= 0;\n    end else begin\n        if (count == NUM_DIV / 2 - 1) begin\n            count <= 0;\n            toggle <= ~toggle;\n        end else begin\n            count <= count + 1;\n            toggle <= toggle;\n        end\n    end\nend\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input toggle,\n    output reg clk_div\n);\n\nalways @(posedge clk) begin\n    clk_div <= toggle;\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit multiplicand\n    input [3:0] Y;       // 4-bit multiplier\n    output [7:0] P;      // 8-bit product\n\n    wire [3:0] x_shifted;\n    wire [3:0] y_shifted;\n\n    // Shift left X by 1\n    assign x_shifted = {X[2:0], 1'b0};\n\n    // Shift left Y by 1\n    assign y_shifted = {Y[2:0], 1'b0};\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(x_shifted), .y(Y), .sum(P[0]));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(X), .y(y_shifted), .sum(P[1]));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(x_shifted), .y(y_shifted), .sum(P[2]));\n\n    // Instantiate the fourth adder\n    adder_4bit adder_3(.x(X), .y(Y), .sum(P[3]));\n\n    // Instantiate the fifth adder\n    adder_4bit adder_4(.x(x_shifted), .y(Y), .sum(P[4]));\n\n    // Instantiate the sixth adder\n    adder_4bit adder_5(.x(X), .y(y_shifted), .sum(P[5]));\n\n    // Instantiate the seventh adder\n    adder_4bit adder_6(.x(x_shifted), .y(y_shifted), .sum(P[6]));\n\n    // Instantiate the eighth adder\n    adder_4bit adder_7(.x(X), .y(Y), .sum(P[7]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;\n    input [3:0] y;\n    output sum;\n\n    assign sum = x[0] ^ y[0] ? x[0] ^ y[0] : x[1] ^ y[1] ? x[1] ^ y[1] : x[2] ^ y[2] ? x[2] ^ y[2] : x[3] ^ y[3];\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Counter module\ncounter counter_module(\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Clock divider module\nclk_divider clk_divider_module(\n    .clk_in(clk),\n    .limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter module\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    localparam NUM_DIV = 8; // Even number to divide by\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\n    assign limit = (count_out == NUM_DIV / 2 - 1);\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk_in,\n    input limit,\n    output reg clk_div\n);\n    always @(posedge clk_in) begin\n        if (limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_diff; // 16-bit difference output from S1\n    wire [15:0] S2_diff; // 16-bit difference output from S2\n    wire [15:0] S1_borrow; // 16-bit borrow output from S1\n    wire [15:0] S2_borrow; // 16-bit borrow output from S2\n\n    // Instantiate 16-bit subtractors for 16-bit subtraction\n    sub_16bit S1(.A(A[15:0]), .B(B[15:0]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n    sub_16bit S2(.A(A[31:16]), .B(B[31:16]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Combine the outputs to get the final difference and borrow-out\n    assign Diff = {S2_diff, S1_diff};\n    assign B_out = S2_borrow;\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output Borrow_out;    // Borrow-out output\n\n    wire [15:0] S1_diff; // 16-bit difference output from S1\n    wire [15:0] S1_borrow; // 16-bit borrow output from S1\n\n    // Instantiate 16-bit subtractors for 16-bit subtraction\n    sub_8bit S1(.A(A[15:12]), .B(B[15:12]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Combine the outputs to get the final difference and borrow-out\n    assign Diff = {S1_diff, A[11:0] - B[11:0] - S1_borrow};\n    assign Borrow_out = S1_borrow;\nendmodule\n\nmodule sub_8bit(A, B, Diff, Borrow_out);\n    input [11:0] A;       // 11-bit input operand A\n    input [11:0] B;       // 11-bit input operand B\n    output [11:0] Diff;   // 11-bit output representing the difference of A and B\n    output Borrow_out;    // Borrow-out output\n\n    wire [7:0] S1_diff; // 8-bit difference output from S1\n    wire [7:0] S1_borrow; // 8-bit borrow output from S1\n\n    // Instantiate 8-bit subtractors for 8-bit subtraction\n    sub_4bit S1(.A(A[11:8]), .B(B[11:8]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Combine the outputs to get the final difference and borrow-out\n    assign Diff = {S1_diff, A[7:0] - B[7:0] - S1_borrow};\n    assign Borrow_out = S1_borrow;\nendmodule\n\nmodule sub_4bit(A, B, Diff, Borrow_out);\n    input [7:0] A;       // 7-bit input operand A\n    input [7:0] B;       // 7-bit input operand B\n    output [7:0] Diff;   // 7-bit output representing the difference of A and B\n    output Borrow_out;   // Borrow-out output\n\n    wire [3:0] S1_diff; // 4-bit difference output from S1\n    wire [3:0] S1_borrow; // 4-bit borrow output from S1\n\n    // Instantiate 4-bit subtractors for 4-bit subtraction\n    sub_2bit S1(.A(A[7:4]), .B(B[7:4]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Combine the outputs to get the final difference and borrow-out\n    assign Diff = {S1_diff, A[3:0] - B[3:0] - S1_borrow};\n    assign Borrow_out = S1_borrow;\nendmodule\n\nmodule sub_2bit(A, B, Diff, Borrow_out);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n    output Borrow_out;   // Borrow-out output\n\n    wire [1:0] S1_diff; // 2-bit difference output from S1\n    wire [1:0] S1_borrow; // 2-bit borrow output from S1\n\n    // Instantiate 2-bit subtractors for 2-bit subtraction\n    sub_1bit S1(.A(A[3:2]), .B(B[3:2]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Combine the outputs to get the final difference and borrow-out\n    assign Diff = {S1_diff, A[1:0] - B[1:0] - S1_borrow};\n    assign Borrow_out = S1_borrow;\nendmodule\n\nmodule sub_1bit(A, B, Diff, Borrow_out);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n    output Borrow_out;   // Borrow-out output\n\n    assign Diff = A - B;\n    assign Borrow_out = A[1] ^ B[1];\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 mux0 (\n        .clk(clk),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .sel(sel),\n        .out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .sel(sel),\n        .out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .sel(sel),\n        .out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for first data path\nmodule mux_path0 (\n    input clk,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [2:0] sel,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: out <= d0;\n            3'b001: out <= d1;\n            3'b010: out <= d2;\n            default: out <= 8'h00;\n        endcase\n    end\n\nendmodule\n\n// Submodule for second data path\nmodule mux_path1 (\n    input clk,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [2:0] sel,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: out <= d0;\n            3'b001: out <= d1;\n            3'b010: out <= d2;\n            default: out <= 8'h00;\n        endcase\n    end\n\nendmodule\n\n// Submodule for third data path\nmodule mux_path2 (\n    input clk,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [2:0] sel,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: out <= d0;\n            3'b001: out <= d1;\n            3'b010: out <= d2;\n            default: out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit multiplicand\n    input [3:0] Y;      // 4-bit multiplier\n    output [7:0] P;     // 8-bit product\n\n    wire [3:0] shifted_x;\n    wire [3:0] shifted_y;\n\n    // Shift X left by 0, 1, 2, and 3 positions\n    assign shifted_x[0] = X[0];\n    assign shifted_x[1] = X[0] | X[1];\n    assign shifted_x[2] = X[0] | X[1] | X[2];\n    assign shifted_x[3] = X[0] | X[1] | X[2] | X[3];\n\n    // Shift Y left by 0, 1, 2, and 3 positions\n    assign shifted_y[0] = Y[0];\n    assign shifted_y[1] = Y[0] | Y[1];\n    assign shifted_y[2] = Y[0] | Y[1] | Y[2];\n    assign shifted_y[3] = Y[0] | Y[1] | Y[2] | Y[3];\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(shifted_x), .y(shifted_y), .sum(P[0]));\n    adder_4bit adder_1(.x(shifted_x), .y(shifted_y), .sum(P[1]));\n    adder_4bit adder_2(.x(shifted_x), .y(shifted_y), .sum(P[2]));\n    adder_4bit adder_3(.x(shifted_x), .y(shifted_y), .sum(P[3]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;      // 4-bit input for X\n    input [3:0] y;      // 4-bit input for Y\n    output sum;         // Output sum\n\n    assign sum = x[0] ^ y[0];\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for a single data path\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output product\n\n    wire [3:0] x_shifted;\n    wire [3:0] y_shifted;\n\n    // Shift X left by 1 bit\n    assign x_shifted = {X[0], X[3:1]};\n\n    // Shift Y left by 1 bit\n    assign y_shifted = {Y[0], Y[3:1]};\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(x_shifted), .y(Y), .sum(P[0]));\n    adder_4bit adder_1(.x(x_shifted), .y(y_shifted), .sum(P[1]));\n    adder_4bit adder_2(.x(x_shifted), .y(y_shifted), .sum(P[2]));\n    adder_4bit adder_3(.x(x_shifted), .y(y_shifted), .sum(P[3]));\n\n    // Shift the sum of the 4 adders to the left by 1 bit\n    assign P[4:1] = {P[3:1], P[0]};\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;      // 4-bit input multiplicand\n    input [3:0] y;      // 4-bit input multiplier\n    output sum;         // 1-bit output sum\n\n    assign sum = x[3] ^ y[3] ? x[3] ^ y[3] : x[3] & y[3];\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selection logic\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'h00;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output product\n\n    wire [3:0] x_shifted;\n    wire [3:0] y_shifted;\n\n    // Shift X left by 1 bit\n    assign x_shifted = {X[0], X[3:1]};\n\n    // Shift Y left by 1 bit\n    assign y_shifted = {Y[0], Y[3:1]};\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(x_shifted), .y(Y), .sum(P[0]));\n    adder_4bit adder_1(.x(x_shifted), .y(y_shifted), .sum(P[1]));\n    adder_4bit adder_2(.x(x_shifted), .y(y_shifted << 1), .sum(P[2]));\n    adder_4bit adder_3(.x(x_shifted), .y(y_shifted << 2), .sum(P[3]));\n    adder_4bit adder_4(.x(x_shifted), .y(y_shifted << 3), .sum(P[4]));\n    adder_4bit adder_5(.x(x_shifted), .y(y_shifted << 4), .sum(P[5]));\n    adder_4bit adder_6(.x(x_shifted), .y(y_shifted << 5), .sum(P[6]));\n    adder_4bit adder_7(.x(x_shifted), .y(y_shifted << 6), .sum(P[7]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;      // 4-bit input multiplicand\n    input [3:0] y;      // 4-bit input multiplier\n    output sum;         // 1-bit output sum\n\n    assign sum = x + y; // Simple addition\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for one data path\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate adder, subtractor, and_logical, or_logical submodules\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND_RESULT\n);\n    assign AND_RESULT = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR_RESULT\n);\n    assign OR_RESULT = A | B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_out;\n    wire [7:0] hold0_in;\n    data_hold hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(hold0_out),\n        .in_hold(hold0_in)\n    );\n\n    // Submodule for holding data from input 1\n    wire [7:0] hold1_out;\n    wire [7:0] hold1_in;\n    data_hold hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(hold1_out),\n        .in_hold(hold1_in)\n    );\n\n    // Submodule for holding data from input 2\n    wire [7:0] hold2_out;\n    wire [7:0] hold2_in;\n    data_hold hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(hold2_out),\n        .in_hold(hold2_in)\n    );\n\n    // Submodule for holding data from input 3\n    wire [7:0] hold3_out;\n    wire [7:0] hold3_in;\n    data_hold hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(hold3_out),\n        .in_hold(hold3_in)\n    );\n\n    // Output assignment\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                  hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out,\n    output reg [7:0] in_hold\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            out <= in;\n            in_hold <= in;\n        end else begin\n            out <= out;\n            in_hold <= in_hold;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_diff; // 16-bit difference output from subtraction block S1\n    wire [15:0] S2_diff; // 16-bit difference output from subtraction block S2\n    wire [15:0] S1_borrow; // 16-bit borrow output from subtraction block S1\n    wire [15:0] S2_borrow; // 16-bit borrow output from subtraction block S2\n\n    // Instantiate subtraction blocks for 16-bit subtraction\n    sub_16bit S1(.A(A[31:16]), .B(B[31:16]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n    sub_16bit S2(.A(A[15:0]), .B(B[15:0]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Assemble the 32-bit difference and borrow-out\n    assign Diff = {S2_diff, S1_diff};\n    assign B_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output Borrow_out;    // Borrow-out output\n\n    wire [15:0] S1_diff; // 16-bit difference output from subtraction block S1\n    wire [15:0] S1_borrow; // 16-bit borrow output from subtraction block S1\n\n    // Instantiate subtraction blocks for 16-bit subtraction\n    sub_8bit S1(.A(A[15:8]), .B(B[15:8]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n    sub_8bit S2(.A(A[7:0]), .B(B[7:0]), .Diff(Diff), .Borrow_out(Borrow_out));\n\n    // Assemble the 16-bit difference and borrow-out\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_8bit(A, B, Diff, Borrow_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] Diff;   // 8-bit output representing the difference of A and B\n    output Borrow_out;   // Borrow-out output\n\n    wire [7:0] S1_diff; // 8-bit difference output from subtraction block S1\n    wire [7:0] S1_borrow; // 8-bit borrow output from subtraction block S1\n\n    // Instantiate subtraction blocks for 8-bit subtraction\n    sub_4bit S1(.A(A[7:4]), .B(B[7:4]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n    sub_4bit S2(.A(A[3:0]), .B(B[3:0]), .Diff(Diff), .Borrow_out(Borrow_out));\n\n    // Assemble the 8-bit difference and borrow-out\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_4bit(A, B, Diff, Borrow_out);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n    output Borrow_out;   // Borrow-out output\n\n    wire [3:0] S1_diff; // 4-bit difference output from subtraction block S1\n    wire [3:0] S1_borrow; // 4-bit borrow output from subtraction block S1\n\n    // Instantiate subtraction blocks for 4-bit subtraction\n    sub_2bit S1(.A(A[3:2]), .B(B[3:2]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n    sub_2bit S2(.A(A[1:0]), .B(B[1:0]), .Diff(Diff), .Borrow_out(Borrow_out));\n\n    // Assemble the 4-bit difference and borrow-out\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_2bit(A, B, Diff, Borrow_out);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n    output Borrow_out;   // Borrow-out output\n\n    wire [1:0] S1_diff; // 2-bit difference output from subtraction block S1\n    wire S1_borrow; // 1-bit borrow output from subtraction block S1\n\n    // Instantiate subtraction blocks for 2-bit subtraction\n    sub_1bit S1(.A(A[1]), .B(B[1]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n    sub_1bit S2(.A(A[0]), .B(B[0]), .Diff(Diff), .Borrow_out(Borrow_out));\n\n    // Assemble the 2-bit difference and borrow-out\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_1bit(A, B, Diff, Borrow_out);\n    input A;       // 1-bit input operand A\n    input B;       // 1-bit input operand B\n    output Diff;   // 1-bit output representing the difference of A and B\n    output Borrow_out; // Borrow-out output\n\n    wire S1_diff; // 1-bit difference output from subtraction block S1\n    wire S1_borrow; // 1-bit borrow output from subtraction block S1\n\n    // Instantiate subtraction blocks for 1-bit subtraction\n    assign Diff = A - B;\n    assign Borrow_out = A < B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Instantiate submodules\n    data_holder hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .selected(sel[0]),\n        .data_out(hold0)\n    );\n\n    data_holder hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .selected(sel[1]),\n        .data_out(hold1)\n    );\n\n    data_holder hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .selected(sel[0]),\n        .data_out(hold2)\n    );\n\n    data_holder hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .selected(sel[1]),\n        .data_out(hold3)\n    );\n\n    // Output assignment\n    assign out = sel[0] ? (sel[1] ? hold3 : hold2) : (sel[1] ? hold1 : hold0);\n\nendmodule\n\nmodule data_holder (\n    input clk,\n    input [7:0] data_in,\n    input selected,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (selected) begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical submodule\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical submodule\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Submodule for holding data from input 0\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    // Submodule for holding data from input 1\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    // Submodule for holding data from input 2\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    // Submodule for holding data from input 3\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output selection logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                  hold3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"sum\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"diff\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", operand_b, \"and_result\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", operand_b, \"or_result\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub32 sub1(.A(A[63:32]), .B(B[63:32]), .D(D[63:32]), .B_out(B_out_32));\n\n    sub16 sub2(.A(B_out_32[15:0]), .B(B_out_32[31:16]), .D(B_out_16), .B_out(B_out_8));\n    sub16 sub3(.A(B_out_32[63:48]), .B(B_out_32[95:64]), .D(B_out_16), .B_out(B_out_8));\n\n    sub8 sub4(.A(B_out_16[7:0]), .B(B_out_16[15:8]), .D(B_out_8), .B_out(B_out_8));\n    sub8 sub5(.A(B_out_16[23:16]), .B(B_out_16[31:24]), .D(B_out_8), .B_out(B_out_8));\n\n    sub8 sub6(.A(B_out_16[39:24]), .B(B_out_16[47:32]), .D(B_out_8), .B_out(B_out_8));\n    sub8 sub7(.A(B_out_16[55:40]), .B(B_out_16[63:48]), .D(B_out_8), .B_out(B_out_8));\n\n    assign B_out = B_out_8;\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub2(.A(B[15:0]), .B(B[31:16]), .D(B_out_16), .B_out(B_out_8));\n    sub16 sub3(.A(B[63:48]), .B(B[95:64]), .D(B_out_16), .B_out(B_out_8));\n\n    sub8 sub4(.A(B_out_16[7:0]), .B(B_out_16[15:8]), .D(B_out_8), .B_out(B_out_8));\n    sub8 sub5(.A(B_out_16[23:16]), .B(B_out_16[31:24]), .D(B_out_8), .B_out(B_out_8));\n\n    sub8 sub6(.A(B_out_16[39:24]), .B(B_out_16[47:32]), .D(B_out_8), .B_out(B_out_8));\n    sub8 sub7(.A(B_out_16[55:40]), .B(B_out_16[63:48]), .D(B_out_8), .B_out(B_out_8));\n\n    assign B_out = B_out_8;\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub2(.A(B[7:0]), .B(B[15:8]), .D(B_out_8), .B_out(B_out_8));\n    sub8 sub3(.A(B[23:16]), .B(B[31:24]), .D(B_out_8), .B_out(B_out_8));\n\n    sub8 sub4(.A(B_out_8[7:0]), .B(B_out_8[15:8]), .D(B_out_8), .B_out(B_out_8));\n    sub8 sub5(.A(B_out_8[23:16]), .B(B_out_8[31:24]), .D(B_out_8), .B_out(B_out_8));\n\n    assign B_out = B_out_8;\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from source 0\n    wire [7:0] hold0_data;\n    wire [7:0] hold0_prev_data;\n    wire hold0_sel;\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .prev_data(hold0_prev_data),\n        .data_out(hold0_data),\n        .sel(hold0_sel)\n    );\n\n    // Submodule for holding data from source 1\n    wire [7:0] hold1_data;\n    wire [7:0] hold1_prev_data;\n    wire hold1_sel;\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .prev_data(hold1_prev_data),\n        .data_out(hold1_data),\n        .sel(hold1_sel)\n    );\n\n    // Submodule for holding data from source 2\n    wire [7:0] hold2_data;\n    wire [7:0] hold2_prev_data;\n    wire hold2_sel;\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .prev_data(hold2_prev_data),\n        .data_out(hold2_data),\n        .sel(hold2_sel)\n    );\n\n    // Submodule for holding data from source 3\n    wire [7:0] hold3_data;\n    wire [7:0] hold3_prev_data;\n    wire hold3_sel;\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .prev_data(hold3_prev_data),\n        .data_out(hold3_data),\n        .sel(hold3_sel)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                  hold3_data;\n\nendmodule\n\n// Submodule for holding data from a single source\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    input [7:0] prev_data,\n    output reg [7:0] data_out,\n    output reg sel\n);\n\n    always @(posedge clk) begin\n        if (sel) begin\n            data_out <= prev_data;\n        end else begin\n            data_out <= data_in;\n            sel <= 1;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select result based on op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical submodule\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical submodule\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_result),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_result),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_result),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow)\n    );\n\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .zero(slt_zero),\n        .carry(slt_carry),\n        .negative(slt_negative),\n        .overflow(slt_overflow)\n    );\n\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_result),\n        .zero(sltu_zero),\n        .carry(sltu_carry),\n        .negative(sltu_negative),\n        .overflow(sltu_overflow)\n    );\n\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .zero(sll_zero),\n        .carry(sll_carry),\n        .negative(sll_negative),\n        .overflow(sll_overflow)\n    );\n\n    srl srl_inst(\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .zero(srl_zero),\n        .carry(srl_carry),\n        .negative(srl_negative),\n        .overflow(srl_overflow)\n    );\n\n    sra sra_inst(\n        .a(a),\n        .b(b),\n        .r(sra_result),\n        .zero(sra_zero),\n        .carry(sra_carry),\n        .negative(sra_negative),\n        .overflow(sra_overflow)\n    );\n\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(sllv_result),\n        .zero(sllv_zero),\n        .carry(sllv_carry),\n        .negative(sllv_negative),\n        .overflow(sllv_overflow)\n    );\n\n    srlv srlv_inst(\n        .a(a),\n        .b(b),\n        .r(srlv_result),\n        .zero(srlv_zero),\n        .carry(srlv_carry),\n        .negative(srlv_negative),\n        .overflow(srlv_overflow)\n    );\n\n    srav srav_inst(\n        .a(a),\n        .b(b),\n        .r(srav_result),\n        .zero(srav_zero),\n        .carry(srav_carry),\n        .negative(srav_negative),\n        .overflow(srav_overflow)\n    );\n\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .zero(lui_zero),\n        .carry(lui_carry),\n        .negative(lui_negative),\n        .overflow(lui_overflow)\n    );\n\n    // Select operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? add_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? sub_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  (aluc == 6'b001111) ? lui_zero : 1'b0;\n\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? add_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? sub_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 1'b0;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? add_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? sub_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      (aluc == 6'b001111) ? lui_negative : 1'b0;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? add_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? sub_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? slt_flag :\n                  (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count >= (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "`define ADD 2'b00\n`define SUBTRACT 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate adder, subtractor, and_module, or_module\nadder adder (\"+\", a, b, sum);\nsubtractor subtractor (\"-\", a, b, diff);\nand_module and_op (\"&\", a, b, and_result);\nor_module or_op (\"|\", a, b, or_result);\n\n// Multiplexer to select result based on op\nalways @(*) begin\n    case(op)\n        `ADD: result = sum;\n        `SUBTRACT: result = diff;\n        `AND: result = and_result;\n        `OR: result = or_result;\n        default: result = 4'b0000; // Default case\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = (operation == `ADD) ? a + b : 4'b0000;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = (operation == `SUBTRACT) ? a - b : 4'b0000;\nendmodule\n\nmodule and_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = (operation == `AND) ? a & b : 4'b0000;\nendmodule\n\nmodule or_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = (operation == `OR) ? a | b : 4'b0000;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n        if (counter == 255) begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] pulse_width;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            pulse_width <= duty_cycle;\n        end else begin\n            pwm_out <= 1'b0;\n            pulse_width <= 8'b0;\n        end\n\n        if (counter < duty_cycle + 1) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .B_out(B_out_32),\n        .B_out_8(B_out_8)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out_16),\n        .B_out_8(B_out_8)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out_8),\n        .B_out_4(B_out_16[7:0])\n    );\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub32(A, B, B_out, B_out_8);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] B_out;\n    output B_out_8;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8_1;\n    wire [7:0] B_out_8_2;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out_16),\n        .B_out_8(B_out_8_1)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out_16),\n        .B_out_8(B_out_8_2)\n    );\n\n    assign B_out = {B_out_8_1, B_out_8_2, B_out_16};\n    assign B_out_8 = B_out_8_1 ^ B_out_8_2;\nendmodule\n\nmodule sub16(A, B, B_out, B_out_8);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] B_out;\n    output B_out_8;\n\n    wire [7:0] B_out_8_1;\n    wire [7:0] B_out_8_2;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out_8_1),\n        .B_out_4(B_out_16[7:0])\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out_8_2),\n        .B_out_4(B_out_16[7:0])\n    );\n\n    assign B_out = {B_out_8_1, B_out_8_2, B_out_16};\n    assign B_out_8 = B_out_8_1 ^ B_out_8_2;\nendmodule\n\nmodule sub8(A, B, B_out, B_out_4);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] B_out;\n    output B_out_4;\n\n    wire [3:0] B_out_4_1;\n    wire [3:0] B_out_4_2;\n\n    sub4 sub0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out_4_1),\n        .B_out_2(B_out_16[3:0])\n    );\n\n    sub4 sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out_4_2),\n        .B_out_2(B_out_16[3:0])\n    );\n\n    assign B_out = {B_out_4_1, B_out_4_2, B_out_16[3:0]};\n    assign B_out_4 = B_out_4_1 ^ B_out_4_2;\nendmodule\n\nmodule sub4(A, B, B_out, B_out_2);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] B_out;\n    output B_out_2;\n\n    wire [1:0] B_out_2_1;\n    wire [1:0] B_out_2_2;\n\n    sub2 sub0(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .B_out(B_out_2_1),\n        .B_out_1(B_out_16[1:0])\n    );\n\n    sub2 sub1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .B_out(B_out_2_2),\n        .B_out_1(B_out_16[1:0])\n    );\n\n    assign B_out = {B_out_2_1, B_out_2_2, B_out_16[1:0]};\n    assign B_out_2 = B_out_2_1 ^ B_out_2_2;\nendmodule\n\nmodule sub2(A, B, B_out, B_out_1);\n    input [1:0] A;\n    input [1:0] B;\n    output [1:0] B_out;\n    output B_out_1;\n\n    wire B_out_1_1;\n    wire B_out_1_2;\n\n    sub1 sub0(\n        .A(A[0]),\n        .B(B[0]),\n        .B_out(B_out_1_1),\n        .B_out_1(B_out_16[0])\n    );\n\n    sub1 sub1(\n        .A(A[0]),\n        .B(B[0]),\n        .B_out(B_out_1_2),\n        .B_out_1(B_out_16[0])\n    );\n\n    assign B_out = {B_out_1_1, B_out_1_2, B_out_16[0]};\n    assign B_out_1 = B_out_1_1 ^ B_out_1_2;\nendmodule\n\nmodule sub1(A, B, B_out, B_out_1);\n    input A;\n    input B;\n    output B_out;\n    output B_out_1;\n\n    assign B_out = A ^ B;\n    assign B_out_1 = A;\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .pwm_out(pwm_out)\n    );\n\n    // Instance of duty cycle controller\n    duty_ctrl duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] adjusted_duty;\n\n    always @(posedge clk) begin\n        if (counter < adjusted_duty) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b; // Addition\n            2'b01: result = data_a - data_b; // Subtraction\n            2'b10: result = data_a & data_b; // AND\n            2'b11: result = data_a | data_b; // OR\n            default: result = 4'b0000; // Default case\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal_0, equal_1, equal_2, equal_3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_3)\n    );\n\n    assign equal = equal_0 & equal_1 & equal_2 & equal_3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] borrow;    // Borrow output from each subtraction block\n\n    // Instantiate 4-bit subtractors for each nibble\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .D(D[16:1]),\n        .borrow(borrow[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .D(D[12:4]),\n        .borrow(borrow[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .D(D[8:8]),\n        .borrow(borrow[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .D(D[4:4]),\n        .borrow(borrow[4:4])\n    );\n\n    // Output borrow-out\n    assign B_out = borrow[1:1] | borrow[2:2] | borrow[3:3] | borrow[4:4];\nendmodule\n\nmodule sub4(A, B, D, borrow);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    output [4:1] D;       // 4-bit difference output\n    output borrow;        // Borrow output\n\n    wire [4:1] diff;      // 4-bit difference\n    wire [3:1] borrow_n;  // 3-bit borrow-out from each subtraction block\n\n    // Instantiate 2-bit subtractors for each nibble\n    sub2 sub1(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .D(diff[4:2]),\n        .borrow(borrow_n[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(diff[2:1]),\n        .borrow(borrow_n[2:2])\n    );\n\n    // Output difference and borrow-out\n    assign D = diff;\n    assign borrow = borrow_n[1:1] | borrow_n[2:2];\nendmodule\n\nmodule sub2(A, B, D, borrow);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    output [2:1] D;       // 2-bit difference output\n    output borrow;        // Borrow output\n\n    wire [2:1] diff;      // 2-bit difference\n    wire [1:1] borrow_n;  // 1-bit borrow-out from each subtraction block\n\n    // Instantiate 1-bit subtractor for each nibble\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(diff[2:1]),\n        .borrow(borrow_n[1:1])\n    );\n\n    // Output difference and borrow-out\n    assign D = diff;\n    assign borrow = borrow_n[1:1];\nendmodule\n\nmodule sub1(A, B, D, borrow);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output D;             // 1-bit difference output\n    output borrow;        // Borrow output\n\n    assign D = A ^ B;     // XOR for subtraction\n    assign borrow = ~(A & B); // Borrow output\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal_0, equal_1, equal_2, equal_3;\n\n    // Instantiate 8-bit comparators\n    comparator_8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_0)\n    );\n    comparator_8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_1)\n    );\n    comparator_8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_2)\n    );\n    comparator_8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_3)\n    );\n\n    // Combine results\n    assign equal = equal_0 & equal_1 & equal_2 & equal_3;\nendmodule\n\nmodule comparator_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate the arithmetic operations\n    adder add_module(\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module(\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module(\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module(\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select operation based on opcode\n    always @(*) begin\n        case(opcode)\n            `ADD_OP: result = add_result;\n            `SUB_OP: result = sub_result;\n            `MUL_OP: result = mul_result;\n            `DIV_OP: result = div_result;\n            default: result = 16'b0;\n        endcase\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @(*) begin\n        if (b == 0) begin\n            valid = 0;\n            result = 16'b0;\n        end\n        else begin\n            valid = 1;\n            result = a / b;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal0, equal1, equal2, equal3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal3)\n    );\n\n    assign equal = equal0 & equal1 & equal2 & equal3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal_0, equal_1, equal_2, equal_3;\n\n    // Instantiate 8-bit comparators\n    comparator_8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_0)\n    );\n\n    comparator_8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_1)\n    );\n\n    comparator_8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_2)\n    );\n\n    comparator_8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_3)\n    );\n\n    // Combine results\n    assign equal = equal_0 & equal_1 & equal_2 & equal_3;\nendmodule\n\nmodule comparator_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate arithmetic operation modules\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result = 0;\n            valid = 0;\n        end else begin\n            result = a / b;\n            valid = 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out from each sub-block\n\n    // Instantiate 4-bit sub-blocks\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[1])\n    );\n\n    sub4 sub2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .C_in(b_out[1]),\n        .D(D[12:4]),\n        .B_out(b_out[2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .C_in(b_out[2]),\n        .D(D[8:4]),\n        .B_out(b_out[3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[3]),\n        .D(D[4:1]),\n        .B_out(b_out[4])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[4];\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out from each sub-block\n\n    // Instantiate 2-bit sub-blocks\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[1])\n    );\n\n    sub2 sub2(\n        .A(A[1:2]),\n        .B(B[1:2]),\n        .C_in(b_out[1]),\n        .D(D[1:2]),\n        .B_out(b_out[2])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[2];\n\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [1:1] b_out;     // 1-bit borrow-out from each sub-block\n\n    // Instantiate 1-bit sub-blocks\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .D(D[2:1]),\n        .B_out(b_out[1])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[1];\n\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output D;             // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    assign {B_out, D} = A - B - C_in;\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .result(add_result)\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result)\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case(opcode)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= sub_result;\n            `MUL_OP: result <= mul_result;\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= div_module.valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a / b;\n    assign valid = (b != 0);\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(16'b0),\n        .D(D[16:1]),\n        .B_out(b_out[3:0])\n    );\n\n    sub4 sub2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .C_in(b_out[3:0]),\n        .D(D[12:4]),\n        .B_out(b_out[2:0])\n    );\n\n    sub4 sub3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .C_in(b_out[2:0]),\n        .D(D[8:8]),\n        .B_out(b_out[1:0])\n    );\n\n    sub4 sub4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(b_out[1:0]),\n        .D(D[4:4]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[3];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input [2:0] C_in;     // 3-bit carry-in\n    output [4:1] D;       // 4-bit output D\n    output B_out;         // 1-bit borrow-out\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(C_in[2:0]),\n        .D(D[4:2]),\n        .B_out(b_out[3:2])\n    );\n\n    sub2 sub2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(b_out[3:2]),\n        .D(D[2:2]),\n        .B_out(b_out[1:1])\n    );\n\n    // Instantiate 1-bit full subtractor\n    sub1 sub3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[0];\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input [1:0] C_in;     // 2-bit carry-in\n    output [2:1] D;       // 2-bit output D\n    output B_out;         // 1-bit borrow-out\n\n    wire [1:0] b_out;     // 2-bit borrow-out\n\n    // Instantiate 1-bit full subtractor\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in[1:0]),\n        .D(D[1:1]),\n        .B_out(b_out[1])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[0];\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [1:1] A;         // 1-bit input A\n    input [1:1] B;         // 1-bit input B\n    input [0:0] C_in;      // 1-bit carry-in\n    output [1:1] D;        // 1-bit output D\n    output B_out;          // 1-bit borrow-out\n\n    // Instantiate 1-bit full subtractor\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in[0]),\n        .D(D[1:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // 1-bit carry-in\n    output D;              // 1-bit output D\n    output B_out;          // 1-bit borrow-out\n\n    // Subtract A and B with carry-in\n    assign {B_out, D} = A - B - C_in;\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n    wire add_valid, sub_valid, mul_valid, div_valid;\n\n    // Instantiate the arithmetic operation modules\n    adder add_module(\n        .clk(clk),\n        .rst(rst),\n        .a(data_a),\n        .b(data_b),\n        .result(add_result),\n        .valid(add_valid)\n    );\n\n    subtractor sub_module(\n        .clk(clk),\n        .rst(rst),\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result),\n        .valid(sub_valid)\n    );\n\n    multiplier mul_module(\n        .clk(clk),\n        .rst(rst),\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result),\n        .valid(mul_valid)\n    );\n\n    divider div_module(\n        .clk(clk),\n        .rst(rst),\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(div_valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                `ADD_OP: begin\n                    result <= add_result;\n                    valid <= add_valid;\n                end\n                `SUB_OP: begin\n                    result <= sub_result;\n                    valid <= sub_valid;\n                end\n                `MUL_OP: begin\n                    result <= mul_result;\n                    valid <= mul_valid;\n                end\n                `DIV_OP: begin\n                    result <= div_result;\n                    valid <= div_valid;\n                end\n                default: begin\n                    result <= 0;\n                    valid <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule adder(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a + b;\n            valid <= 1;\n        end\n    end\nendmodule\n\nmodule subtractor(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a - b;\n            valid <= 1;\n        end\n    end\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a * b;\n            valid <= 1;\n        end\n    end\nendmodule\n\nmodule divider(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            if (b == 0) begin\n                valid <= 0;\n            end else begin\n                result <= a / b;\n                valid <= 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .negative(add_negative), .zero(add_zero));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .negative(add_negative), .zero(add_zero));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .negative(sub_negative), .zero(sub_zero));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .negative(sub_negative), .zero(sub_zero));\n    and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .overflow(and_overflow), .negative(and_negative), .zero(and_zero));\n    or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .overflow(or_overflow), .negative(or_negative), .zero(or_zero));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .overflow(xor_overflow), .negative(xor_negative), .zero(xor_zero));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .overflow(nor_overflow), .negative(nor_negative), .zero(nor_zero));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .overflow(slt_overflow), .negative(slt_negative), .zero(slt_zero));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .overflow(sltu_overflow), .negative(sltu_negative), .zero(sltu_zero));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .overflow(sll_overflow), .negative(sll_negative), .zero(sll_zero));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .overflow(srl_overflow), .negative(srl_negative), .zero(srl_zero));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .overflow(sra_overflow), .negative(sra_negative), .zero(sra_zero));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .overflow(sllv_overflow), .negative(sllv_negative), .zero(sllv_zero));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .overflow(srlv_overflow), .negative(srlv_negative), .zero(srlv_zero));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .overflow(srav_overflow), .negative(srav_negative), .zero(srav_zero));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .overflow(lui_overflow), .negative(lui_negative), .zero(lui_zero));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? add_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? sub_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 1'b0;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? add_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? sub_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  (aluc == 6'b001111) ? lui_zero : 1'b0;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? add_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? sub_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      (aluc == 6'b001111) ? lui_negative : 1'b0;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? add_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? sub_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) ||\n                       ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) ||\n                       ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 0) && (b[31] == 1) && (r[31] == 0)) ||\n                       ((a[31] == 1) && (b[31] == 0) && (r[31] == 1)));\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 0) && (b[31] == 1) && (r[31] == 0)) ||\n                       ((a[31] == 1) && (b[31] == 0) && (r[31] == 1)));\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .D(D[16:1]),\n        .B_out(b_out[3:0])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out[3]),\n        .D(D[12:1]),\n        .B_out(b_out[2:0])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out[2]),\n        .D(D[8:1]),\n        .B_out(b_out[1:0])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[1]),\n        .D(D[4:1]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[3];\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] D;       // 4-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 3-bit borrow-out\n\n    // Instantiate 3-bit subtractors\n    sub3 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(C_in),\n        .D(D[4:1]),\n        .B_out(b_out[2:0])\n    );\n\n    sub3 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(b_out[2]),\n        .D(D[2:1]),\n        .B_out(b_out[1:0])\n    );\n\n    sub3 sub3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1]),\n        .D(D[1:1]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[2];\n\nendmodule\n\nmodule sub3(A, B, C_in, D, B_out);\n    input [3:1] A;        // 3-bit input A\n    input [3:1] B;        // 3-bit input B\n    input C_in;           // Carry-in\n    output [3:1] D;       // 3-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [2:0] b_out;     // 2-bit borrow-out\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .C_in(C_in),\n        .D(D[3:1]),\n        .B_out(b_out[1:0])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(b_out[1]),\n        .D(D[2:1]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1];\n\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] D;       // 2-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [1:0] b_out;     // 1-bit borrow-out\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .D(D[2:1]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[0];\n\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    input C_in;           // Carry-in\n    output [1:1] D;       // 1-bit output difference\n    output B_out;         // Borrow-out output\n\n    // Instantiate 1-bit subtractor\n    assign {B_out, D[1:1]} = A[1:1] - B[1:1] - C_in;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the greater, equal, or less\n    assign A_greater = (sub_result != 0);\n    assign A_equal = (sub_result == 0) && (borrow == 0);\n    assign A_less = (sub_result == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output borrow\n);\n\n    // Perform subtraction\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the output based on the subtraction result\n    assign A_greater = (sub_result != 0);\n    assign A_equal = (sub_result == 0) && (borrow == 0);\n    assign A_less = (sub_result == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output borrow\n);\n\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the result\n    assign A_greater = (sub_result != 0);\n    assign A_equal = (sub_result == 0 && borrow == 0);\n    assign A_less = (sub_result == 0 && borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output borrow       // Carry out\n);\n\n    // Perform subtraction\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the comparison results\n    assign A_greater = (sub_result == 32'd0) && (borrow == 1'b0);\n    assign A_equal = (sub_result == 32'd0) && (borrow == 1'b1);\n    assign A_less = (sub_result != 32'd0) && (borrow == 1'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output borrow\n);\n\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_out;\n\n    CLA CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C16[1])\n    );\n\n    CLA CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C16[1]),\n        .S(S[32:17]),\n        .Cout(C16_out)\n    );\n\n    assign C32 = C16_out;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2,C1;\n    wire [16:1] S16;\n    wire [8:1] S8;\n    wire [4:1] S4;\n    wire [2:1] S2;\n    wire [1:1] S1;\n\n    CLA1 CLA1 (.A(A[32:1]), .B(B[32:1]), .Cin(1'b0), .S(S16), .Cout(C16));\n    CLA2 CLA2 (.A(S16), .B(B[32:1]), .Cin(C16), .S(S8), .Cout(C8));\n    CLA1 CLA3 (.A(S8), .B(B[32:1]), .Cin(C8), .S(S4), .Cout(C4));\n    CLA2 CLA4 (.A(S4), .B(B[32:1]), .Cin(C4), .S(S2), .Cout(C2));\n    CLA1 CLA5 (.A(S2), .B(B[32:1]), .Cin(C2), .S(S1), .Cout(C1));\n\n    assign S = {S1,S2,S4,S8,S16};\n    assign C32 = C1;\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] sum;\n    wire [16:1] carry;\n\n    assign {Cout,sum} = A + B + Cin;\n    assign S = sum;\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [8:1] sum;\n    wire [8:1] carry;\n\n    assign {Cout,sum} = A + B + Cin;\n    assign S = sum;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16[32:1];\n    wire C16_0, C16_1, C16_2, C16_3, C16_4, C16_5, C16_6, C16_7, C16_8, C16_9, C16_10, C16_11, C16_12, C16_13, C16_14, C16_15, C16_16;\n\n    CLA_16bit CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C16[1])\n    );\n\n    CLA_16bit CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C16[1]),\n        .S(S[32:17]),\n        .Cout(C16[2])\n    );\n\n    assign C32 = C16[32];\nendmodule\n\nmodule CLA_16bit(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [8:1] C8[16:1];\n    wire C8_0, C8_1, C8_2, C8_3, C8_4, C8_5, C8_6, C8_7, C8_8;\n\n    CLA_8bit CLA1(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Cin(1'b0),\n        .S(S[8:1]),\n        .Cout(C8[1])\n    );\n\n    CLA_8bit CLA2(\n        .A(A[16:9]),\n        .B(B[16:9]),\n        .Cin(C8[1]),\n        .S(S[16:9]),\n        .Cout(C8[2])\n    );\n\n    assign Cout = C8[16];\nendmodule\n\nmodule CLA_8bit(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [4:1] C4[8:1];\n    wire C4_0, C4_1, C4_2, C4_3, C4_4, C4_5, C4_6, C4_7, C4_8;\n\n    CLA_4bit CLA1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Cin(1'b0),\n        .S(S[4:1]),\n        .Cout(C4[1])\n    );\n\n    CLA_4bit CLA2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .Cin(C4[1]),\n        .S(S[8:5]),\n        .Cout(C4[2])\n    );\n\n    assign Cout = C4[8];\nendmodule\n\nmodule CLA_4bit(A,B,Cin,S,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire [2:1] C2[4:1];\n    wire C2_0, C2_1, C2_2, C2_3, C2_4, C2_5, C2_6, C2_7;\n\n    CLA_2bit CLA1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .Cin(1'b0),\n        .S(S[2:1]),\n        .Cout(C2[1])\n    );\n\n    CLA_2bit CLA2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .Cin(C2[1]),\n        .S(S[4:3]),\n        .Cout(C2[2])\n    );\n\n    assign Cout = C2[4];\nendmodule\n\nmodule CLA_2bit(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire [1:1] C1[2:1];\n    wire C1_0, C1_1, C1_2, C1_3;\n\n    assign C1[1] = (A[1] & B[1]) | (A[1] & Cin) | (B[1] & Cin);\n    assign C1[2] = (A[2] & B[2]) | (A[2] & Cin) | (B[2] & Cin);\n\n    assign S = {C1[2], C1[1]};\n    assign Cout = C1[2] | C1[1];\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16[32:1];\n    wire C16_0, C16_1, C16_2, C16_3, C16_4, C16_5, C16_6, C16_7, C16_8, C16_9, C16_10, C16_11, C16_12, C16_13, C16_14, C16_15, C16_16;\n\n    CLA_16bit CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(C16_0), .S(S[16:1]), .Cout(C16[1]));\n    CLA_16bit CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16_1), .S(S[32:17]), .Cout(C16[2]));\n\n    assign C32 = C16_16;\nendmodule\n\nmodule CLA_16bit(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [8:1] C8[16:1];\n    wire C8_0, C8_1, C8_2, C8_3, C8_4, C8_5, C8_6, C8_7, C8_8;\n\n    CLA_8bit CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(C8_0), .S(S[8:1]), .Cout(C8[1]));\n    CLA_8bit CLA2 (.A(A[16:9]), .B(B[16:9]), .Cin(C8_1), .S(S[16:9]), .Cout(C8[2]));\n\n    assign Cout = C8_8;\nendmodule\n\nmodule CLA_8bit(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [4:1] C4[8:1];\n    wire C4_0, C4_1, C4_2, C4_3, C4_4, C4_5, C4_6, C4_7, C4_8;\n\n    CLA_4bit CLA1 (.A(A[4:1]), .B(B[4:1]), .Cin(C4_0), .S(S[4:1]), .Cout(C4[1]));\n    CLA_4bit CLA2 (.A(A[8:5]), .B(B[8:5]), .Cin(C4_1), .S(S[8:5]), .Cout(C4[2]));\n\n    assign Cout = C4_8;\nendmodule\n\nmodule CLA_4bit(A,B,Cin,S,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire [2:1] C2[4:1];\n    wire C2_0, C2_1, C2_2, C2_3, C2_4, C2_5, C2_6, C2_7;\n\n    CLA_2bit CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(C2_0), .S(S[2:1]), .Cout(C2[1]));\n    CLA_2bit CLA2 (.A(A[4:3]), .B(B[4:3]), .Cin(C2_1), .S(S[4:3]), .Cout(C2[2]));\n    CLA_2bit CLA3 (.A(A[8:6]), .B(B[8:6]), .Cin(C2_2), .S(S[8:6]), .Cout(C2[3]));\n\n    assign Cout = C2_6;\nendmodule\n\nmodule CLA_2bit(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire C1, C2, C3, C4, C5, C6, C7, C8;\n\n    assign Cout = C8;\n\n    assign C1 = (A[1] & B[1]) | (A[1] & Cin) | (B[1] & Cin);\n    assign C2 = (A[2] & B[2]) | (A[2] & C1) | (B[2] & C1);\n    assign C3 = (A[3] & B[3]) | (A[3] & C2) | (B[3] & C2);\n    assign C4 = (A[4] & B[4]) | (A[4] & C3) | (B[4] & C3);\n    assign C5 = (A[5] & B[5]) | (A[5] & C4) | (B[5] & C4);\n    assign C6 = (A[6] & B[6]) | (A[6] & C5) | (B[6] & C5);\n    assign C7 = (A[7] & B[7]) | (A[7] & C6) | (B[7] & C6);\n    assign C8 = (A[8] & B[8]) | (A[8] & C7) | (B[8] & C7);\n\n    assign S = {C8, C7, C6, C5, C4, C3, C2, C1};\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero), .negative(and_negative), .overflow(and_overflow));\n    or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero), .negative(or_negative), .overflow(or_overflow));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero), .negative(xor_negative), .overflow(xor_overflow));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero), .negative(nor_negative), .overflow(nor_overflow));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero), .negative(slt_negative), .overflow(slt_overflow));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero), .negative(sltu_negative), .overflow(sltu_overflow));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero), .negative(sll_negative), .overflow(sll_overflow));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero), .negative(srl_negative), .overflow(srl_overflow));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero), .negative(sra_negative), .overflow(sra_overflow));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .zero(sllv_zero), .negative(sllv_negative), .overflow(sllv_overflow));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .zero(srlv_zero), .negative(srlv_negative), .overflow(srlv_overflow));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero), .negative(srav_negative), .overflow(srav_overflow));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .zero(lui_zero), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? addu_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? subu_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 1'b0;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? addu_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? subu_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  (aluc == 6'b001111) ? lui_zero : 1'b0;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? addu_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? subu_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      (aluc == 6'b001111) ? lui_negative : 1'b0;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? addu_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? subu_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? slt_flag :\n                  (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] != b[31] && r[31] == a[31]);\nendmodule\n\nmodule subu(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] != b[31] && r[31] == a[31]);\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a & b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a | b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sllv(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srlv(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srav(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate the first 4-bit ripple carry adder\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n    // Instantiate the first carry select adder slice\n    carry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n    // Instantiate the second carry select adder slice\n    carry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n    // Instantiate the third carry select adder slice\n    carry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    // Assign the final carry-out\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    // Implement the ripple carry adder logic\n    assign sum = a ^ b ^ {4{cin}};\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate the first ripple carry adder\n    ripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n\n    // Instantiate the second ripple carry adder\n    ripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum[3:2]), .cout(carry[1]));\n\n    // Assign the final carry-out\n    assign cout = carry[1];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate 4-bit ripple carry adder for the first 4 bits\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n    // Instantiate 4-bit carry select adder slices for the next 4 bits\n    carry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n    carry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n    carry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    // Output the final carry out\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Perform 4-bit ripple carry adder\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate two ripple carry adders for the first two bits\n    ripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n    ripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum[3:2]), .cout(carry[1]));\n\n    // Select sum and carry based on carry-in\n    assign sum = (cin) ? {1'b0, a[3:2]} : {1'b0, b[3:2]};\n    assign cout = carry[1];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n    // Instantiate the first 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n    // Instantiate the second 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n    // Instantiate the third 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    // Output the final carry-out\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [4:0] temp_sum;\n\n    assign {cout, temp_sum} = a + b + cin;\n    assign sum = temp_sum[3:0];\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [4:0] temp_sum;\n\n    // Instantiate the first ripple carry adder\n    ripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(temp_sum[3:0]), .cout(temp_sum[4]));\n\n    // Instantiate the multiplexer to select the sum and carry-out\n    wire [3:0] mux_out;\n    assign mux_out = (temp_sum[4] == 1'b0) ? temp_sum[3:0] : a;\n    assign sum = mux_out;\n    assign cout = temp_sum[4];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First ripple carry adder\nripple_carry rca1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(cin),\n    .sum(sum[3:0]),\n    .cout(carry[0])\n);\n\n// First carry select adder slice\ncarry_select_adder_slice cs_slice1(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(carry[0]),\n    .sum(sum[7:4]),\n    .cout(carry[1])\n);\n\n// Second carry select adder slice\ncarry_select_adder_slice cs_slice2(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(carry[1]),\n    .sum(sum[11:8]),\n    .cout(carry[2])\n);\n\n// Third carry select adder slice\ncarry_select_adder_slice cs_slice3(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .cin(carry[2]),\n    .sum(sum[15:12]),\n    .cout(carry[3])\n);\n\nendmodule\n\n// Ripple carry adder module\nmodule ripple_carry(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\n\nassign temp_sum = a + b + cin;\nassign sum = temp_sum[3:0];\nassign cout = temp_sum[4];\n\nendmodule\n\n// Carry select adder slice module\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] temp_sum;\nwire temp_cout;\n\n// First ripple carry adder\nripple_carry rca2(\n    .a(a),\n    .b(b),\n    .cin(cin),\n    .sum(temp_sum),\n    .cout(temp_cout)\n);\n\n// Multiplexer\nassign sum = (temp_cout) ? temp_sum : a;\nassign cout = temp_cout;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // 8-bit adder for the lower 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the upper 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    // 8-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    // 8-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\n    // Carry-out from the 8-bit adders\n    assign Co = Co_8;\n\n    // Sum of the 8-bit adders\n    assign y = {y_8, y[15:8]};\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] temp;\n\n    // 8-bit adder\n    assign temp = a + b + Cin;\n\n    // Carry-out\n    assign Co = temp[8];\n\n    // Sum\n    assign y = temp[7:0];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] temp;\n\n    // 8-bit adder\n    assign temp = a + b + Cin;\n\n    // Carry-out\n    assign Co = temp[8];\n\n    // Sum\n    assign y = temp[7:0];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for first 4 bits\n    add4_inst1 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for last 4 bits\n    add4_inst2 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4_inst1 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for first 2 bits\n    add2_inst1 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for last 2 bits\n    add2_inst2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2_inst1 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for first bit\n    add1_inst1 add1_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co)\n    );\n\n    // 1-bit adder for last bit\n    add1_inst2 add1_inst2 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co),\n        .y(y[1]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add1_inst1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\n\nendmodule\n\nmodule add1_inst2 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\n\nendmodule\n\nmodule add2_inst2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\n\nendmodule\n\nmodule add4_inst2 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero), .negative(and_negative), .overflow(and_overflow));\n    or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero), .negative(or_negative), .overflow(or_overflow));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero), .negative(xor_negative), .overflow(xor_overflow));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero), .negative(nor_negative), .overflow(nor_overflow));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero), .negative(slt_negative), .overflow(slt_overflow));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero), .negative(sltu_negative), .overflow(sltu_overflow));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero), .negative(sll_negative), .overflow(sll_overflow));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero), .negative(srl_negative), .overflow(srl_overflow));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero), .negative(sra_negative), .overflow(sra_overflow));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .zero(sllv_zero), .negative(sllv_negative), .overflow(sllv_overflow));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .zero(srlv_zero), .negative(srlv_negative), .overflow(srlv_overflow));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero), .negative(srav_negative), .overflow(srav_overflow));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .zero(lui_zero), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? addu_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? subu_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 1'b0;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? addu_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? subu_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  (aluc == 6'b001111) ? lui_zero : 1'b0;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? addu_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? subu_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      (aluc == 6'b001111) ? lui_negative : 1'b0;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? addu_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? subu_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? slt_flag :\n                  (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) || ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) || ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 0) && (b[31] == 1) && (r[31] == 0)) || ((a[31] == 1) && (b[31] == 0) && (r[31] == 1)));\nendmodule\n\nmodule subu(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 0) && (b[31] == 1) && (r[31] == 0)) || ((a[31] == 1) && (b[31] == 0) && (r[31] == 1)));\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a & b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a | b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sllv(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srlv(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srav(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(input [31:0] a, input [4:0] b, output [31:0] r, output carry, output zero, output negative, output overflow);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n    wire [31:0] temp;       // Temporary product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a_in(ain),\n        .b_in(bin),\n        .m_out(m),\n        .a_out(a)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .m(m),\n        .product(temp)\n    );\n\n    // Assign product register\n    assign yout = product;\n    assign product = temp;\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n\n    reg [4:0] shift_count; // Shift count register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done <= 0;\n        end else if (start) begin\n            shift_count <= 5; // Set shift count to 5\n            done <= 0;\n        end else if (shift_count > 0) begin\n            shift_count <= shift_count - 1;\n            done <= 0;\n        end else begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a_in,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] b_in,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] m, // Multiplier register\n    output reg [15:0] a  // Multiplicand register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m <= 0;\n            a <= 0;\n        end else begin\n            m <= b_in;\n            a <= a_in;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    reg [31:0] temp;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            temp <= 0;\n            product <= 0;\n        end else begin\n            temp <= m << a[shift_count];\n            product <= product + temp;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift;\n    wire [31:0] product;\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift(shift)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift(shift),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output assignment\n    assign yout = product;\n\nendmodule\n\n// Control unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            done <= 0;\n        end else if (start) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n    end\nendmodule\n\n// Register unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift // Shift count register\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n        end else if (start) begin\n            shift <= 0;\n        end else begin\n            shift <= shift + 1;\n        end\n    end\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift,  // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            if (shift[0]) begin\n                product <= product + (bin << 0);\n            end\n            if (shift[1)) begin\n                product <= product + (bin << 1);\n            end\n            if (shift[2)) begin\n                product <= product + (bin << 2);\n            end\n            if (shift[3)) begin\n                product <= product + (bin << 3);\n            end\n            if (shift[4)) begin\n                product <= product + (bin << 4);\n            end\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n    wire [31:0] temp;       // Temporary product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(ain),\n        .m(bin),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .m(m),\n        .a(a),\n        .shift_count(shift_count),\n        .temp(temp)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start & !rst_n;\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 5'd0; // Reset shift count to 0\n        end else if (start) begin\n            shift_count <= 5'd16; // Set shift count to 16\n        end else if (shift_count > 0) begin\n            shift_count <= shift_count - 1; // Decrement shift count\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count register\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 32'd0; // Reset product register to 0\n        end else if (start) begin\n            product <= {16'd0, m}; // Load multiplier to product register\n        end else if (shift_count > 0) begin\n            product <= {product[30:0], product[31]}; // Shift left and update product\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count register\n    output reg [31:0] temp // Temporary product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            temp <= 32'd0; // Reset temporary product register to 0\n        end else if (start) begin\n            temp <= {16'd0, m}; // Load multiplier to temporary product register\n        end else if (shift_count > 0) begin\n            if (a[shift_count - 1]) begin\n                temp <= temp + {16'd0, m}; // Shift left and add multiplier\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    reg_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    mul_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = ctrl.done;\n\nendmodule\n\n// Submodule for Control Unit\nmodule reg_unit (\n    input clk,          // Clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, ain};\n        end\n    end\n\nendmodule\n\n// Submodule for Multiplier Unit\nmodule mul_unit (\n    input clk,          // Clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [31:0] product,  // Product register\n    output reg [31:0] product // Output product register.\n);\n\n    reg [15:0] shifted_bin; // Shifted multiplier register\n    reg [4:0] shift_count_reg; // Shift count register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shifted_bin <= 0;\n            shift_count_reg <= 0;\n            product <= 0;\n        end else if (start) begin\n            shifted_bin <= bin;\n            shift_count_reg <= shift_count;\n            product <= {16'b0, ain};\n        end else if (shift_count_reg > 0) begin\n            shifted_bin <= shifted_bin << 1;\n            shift_count_reg <= shift_count_reg - 1;\n            product <= product + (shifted_bin[0] ? bin : 0);\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires for addition and subtraction\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(op1),\n    .b(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(op1),\n    .b(op2),\n    .result(sub_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3, lt0, lt1, lt2, lt3, eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [7:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output logic based on mode\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [7:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(multiplication_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning the results\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0;\n    wire gt1, lt1, eq1;\n    wire gt2, lt2, eq2;\n    wire gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply x and y\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .current_value(multiplication_result[31:0]),\n    .new_value(multiplication_result[63:32]),\n    .result(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] current_value,\n    input [31:0] new_value,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning the results to the outputs\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\nwire [31:0] accum_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .accum_result(accum_result)\n);\n\n// Assigning the accumulator output to the output\nassign c = accum_result;\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] accum_result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accum_result <= 0;\n        end else begin\n            accum_result <= accum_result + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider submodule\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider submodule\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic to select output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output assignment\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    // Select the operation based on the op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetcher for register\n    inst_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetcher for RAM/ROM\n    inst_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetcher for register\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction fetcher for RAM/ROM\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= adder_result;\n        2'b01: result <= subtractor_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(sub_borrow));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry :\n                          (op == 2'b11) ? sub_borrow :\n                          0;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assign the outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Instantiate the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\n// Operation selection logic\nalways @(*) begin\n    case(op_sel)\n        2'b00: result = u_adder.sum;\n        2'b01: result = u_subtractor.diff;\n        2'b10: result = u_and.out;\n        2'b11: result = u_or.out;\n        default: result = 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest_bit;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest_bit(highest_bit[1]), .valid(valid));\n\n    // Output code is highest bit found\n    assign code = highest_bit;\n\nendmodule\n\nmodule check_bit(in, highest_bit, valid);\n    input in;\n    output highest_bit;\n    output valid;\n\n    reg highest_bit_reg;\n    reg highest_bit_valid_reg;\n\n    always @(in) begin\n        if (in) begin\n            highest_bit_reg = 1;\n            highest_bit_valid_reg = 1;\n        end else begin\n            highest_bit_reg = 0;\n            highest_bit_valid_reg = highest_bit_valid_reg;\n        end\n    end\n\n    assign highest_bit = highest_bit_reg;\n    assign valid = highest_bit_valid_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1_m (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2_m (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n    wire valid_temp;\n\n    // Instantiate check_bit modules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb4(.in(in[4]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb1(.in(in[1]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(valid_temp));\n\n    // Assign output\n    assign code = code_temp;\n    assign valid = valid_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in;\n    assign valid = in | highest;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires to hold submodule outputs\nwire [31:0] sum_result;\nwire [31:0] diff_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selector logic\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum_result;\n        2'b01: result <= diff_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 32'd10000000; // 25% threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 32'd0;\n            PWM_out <= 1'b0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 32'd0;\n            PWM_out <= 1'b1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 1'b0;\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 32'd5000000; // 50% threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 32'd0;\n            PWM_out <= 1'b0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 32'd0;\n            PWM_out <= 1'b1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 1'b0;\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 32'd7500000; // 75% threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 32'd0;\n            PWM_out <= 1'b0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 32'd0;\n            PWM_out <= 1'b1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest_bit;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest_bit(highest_bit[1]), .valid(valid));\n\n    // Output code based on highest_bit\n    assign code = highest_bit;\n\nendmodule\n\nmodule check_bit(in, highest_bit, valid);\n    input in;\n    output highest_bit;\n    output valid;\n\n    reg highest_bit_reg;\n    reg valid_reg;\n\n    always @(*) begin\n        if (in) begin\n            highest_bit_reg = 1;\n            valid_reg = 1;\n        end else begin\n            highest_bit_reg = 0;\n            valid_reg = 0;\n        end\n    end\n\n    assign highest_bit = highest_bit_reg;\n    assign valid = valid_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad12;\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n    wire valid_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb4(.in(in[4]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb1(.in(in[1]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(valid_temp));\n\n    // Assign output\n    assign code = code_temp;\n    assign valid = valid_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in;\n    assign valid = highest;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                PWM_out <= 1;\n                counter <= 0;\n            end else begin\n                PWM_out <= 0;\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                PWM_out <= 1;\n                counter <= 0;\n            end else begin\n                PWM_out <= 0;\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 25000000; // 25MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                PWM_out <= 1;\n                counter <= 0;\n            end else begin\n                PWM_out <= 0;\n                counter <= counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR gate\n    or_gate or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_gate (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h50),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR gate\n    or_gate or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_gate (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// PWM module with 25% duty cycle\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 25000000; // 25% duty cycle threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// PWM module with 50% duty cycle\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50% duty cycle threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// PWM module with 75% duty cycle\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 75000000; // 75% duty cycle threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'b10101010), // Threshold value for temperature\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between adder and subtractor outputs\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[1]),\n        .S(S[7:4]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[2]),\n        .S(S[11:8]),\n        .C_out(carry[3])\n    );\n\n    // Combine the carry outputs to get the final carry-out\n    assign C_out = carry[3];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:0] sum;       // 5-bit sum\n\n    // Perform addition\n    assign {C_out, sum} = A + B + C_in;\n\n    // Output sum\n    assign S = sum[3:0];\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES_25 = 100; // Number of cycles for 25% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES_25) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES_50 = 50; // Number of cycles for 50% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES_50) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES_75 = 25; // Number of cycles for 75% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES_75) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adders\ngp_4bit GPP0 (.a(a[0]), .b(b[0]), .sum(sum0));\ngp_4bit GPP1 (.a(a[1]), .b(b[1]), .sum(sum1));\ngp_4bit GPP2 (.a(a[2]), .b(b[2]), .sum(sum2));\ngp_4bit GPP3 (.a(a[3]), .b(b[3]), .sum(sum3));\n\n// 8-bit full adder\na4bs A4BS0 (.a(sum0), .b(sum1), .sum(sum4[0]));\na4bs A4BS1 (.a(sum2), .b(sum3), .sum(sum4[1]));\na4bs A4BS2 (.a(sum4[0]), .b(sum4[1]), .sum(sum4[2]));\n\nassign product = sum4;\n\nendmodule\n\nmodule gp_4bit(input a, b, output sum);\n    assign sum = a ^ b;\nendmodule\n\nmodule a4bs(input a, b, output sum);\n    assign sum = a ^ b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= state;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= wave;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodule instances\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == 100_000_000) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == 50_000_000) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == 75_000_000) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each nibble\n    four_bit_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the last carry-out of the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;         // Carry-out wires\n\n    // Instantiate 2-bit full adders for each nibble\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the last carry-out of the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    input C_in;          // Carry-in input\n    output [1:0] S;      // 2-bit sum output\n    output C_out;        // Carry-out output\n\n    // Perform addition\n    assign {C_out, S} = A + B + C_in;\n\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [3:0] a_reg;\n    wire [3:0] b_reg;\n    wire [7:0] product_reg;\n\n    // Registers to hold inputs\n    reg [3:0] a_reg;\n    reg [3:0] b_reg;\n    reg [7:0] product_reg;\n\n    // Instantiate full adders\n    ga_4bit GPP0 (.a(a_reg[0]), .b(b_reg[0]), .c_in(0), .sum(product_reg[0]), .c_out(0));\n    ga_4bit GPP1 (.a(a_reg[1]), .b(b_reg[1]), .c_in(product_reg[0]), .sum(product_reg[1]), .c_out(0));\n    ga_4bit GPP2 (.a(a_reg[2]), .b(b_reg[2]), .c_in(product_reg[1]), .sum(product_reg[2]), .c_out(0));\n    ga_4bit GPP3 (.a(a_reg[3]), .b(b_reg[3]), .c_in(product_reg[2]), .sum(product_reg[3]), .c_out(0));\n\n    // Instantiate 4-bit adder for product\n    ga_4bit A4BS0 (.a(a_reg[0]), .b(b_reg[0]), .c_in(0), .sum(product_reg[4]), .c_out(0));\n    ga_4bit A4BS1 (.a(a_reg[1]), .b(b_reg[1]), .c_in(product_reg[4]), .sum(product_reg[5]), .c_out(0));\n    ga_4bit A4BS2 (.a(a_reg[2]), .b(b_reg[2]), .c_in(product_reg[5]), .sum(product_reg[6]), .c_out(0));\n    ga_4bit A4BS3 (.a(a_reg[3]), .b(b_reg[3]), .c_in(product_reg[6]), .sum(product_reg[7]), .c_out(0));\n\n    // Assign output\n    assign product = product_reg;\n\nendmodule\n\nmodule ga_4bit(\n    input a, b, c_in,\n    output sum, c_out);\n\n    wire c_out_temp;\n\n    full_adder fa (.a(a), .b(b), .c_in(c_in), .sum(sum), .c_out(c_out_temp));\n\n    assign c_out = c_out_temp;\n\nendmodule\n\nmodule full_adder(\n    input a, b, c_in,\n    output sum, c_out);\n\n    wire c_out_temp;\n\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | (a & c_in) | (b & c_in);\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    // Select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] temp_a;\nwire [3:0] temp_b;\nwire [7:0] temp_product;\n\n// Shift registers for A and B\nshift_register GPP0(\n    .a(a),\n    .b(b),\n    .temp_a(temp_a),\n    .temp_b(temp_b));\n\n// Full adders for each bit of the product\nfull_adder A4BS0(\n    .a(temp_a[0]),\n    .b(temp_b[0]),\n    .cin(1'b0),\n    .sum(temp_product[0]),\n    .cout(temp_product[1]));\n\nfull_adder A4BS1(\n    .a(temp_a[1]),\n    .b(temp_b[1]),\n    .cin(temp_product[0]),\n    .sum(temp_product[2]),\n    .cout(temp_product[3]));\n\nfull_adder A4BS2(\n    .a(temp_a[2]),\n    .b(temp_b[2]),\n    .cin(temp_product[2]),\n    .sum(temp_product[4]),\n    .cout(temp_product[5]));\n\nfull_adder A4BS3(\n    .a(temp_a[3]),\n    .b(temp_b[3]),\n    .cin(temp_product[4]),\n    .sum(temp_product[6]),\n    .cout(temp_product[7]));\n\n// Output the product\nassign product = temp_product;\n\nendmodule\n\nmodule shift_register(\n    input [3:0] a, b,\n    output [3:0] temp_a, temp_b);\n\nreg [3:0] temp_a_reg;\nreg [3:0] temp_b_reg;\n\nalways @(*) begin\n    temp_a_reg = a;\n    temp_b_reg = b;\nend\n\nassign temp_a = temp_a_reg;\nassign temp_b = temp_b_reg;\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 32'd100_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 32'd50_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 32'd75_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out signals\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out signals\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [1:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    // Implement the 2-bit full adder logic\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Multiplexer to select the output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// Full adders for multiplication\ngad_4bit GPP0(.a(a[0]), .b(b[0]), .sum(sum0));\ngad_4bit GPP1(.a(a[1]), .b(b[1]), .sum(sum1));\ngad_4bit GPP2(.a(a[2]), .b(b[2]), .sum(sum2));\ngad_4bit GPP3(.a(a[3]), .b(b[3]), .sum(sum3));\n\n// Shift registers for multiplication\nreg [3:0] sum0_reg, sum1_reg, sum2_reg, sum3_reg;\nalways @(*) begin\n    sum0_reg = sum0;\n    sum1_reg = sum1;\n    sum2_reg = sum2;\n    sum3_reg = sum3;\nend\n\n// Final sum for multiplication\nassign sum4 = {sum3_reg, sum2_reg, sum1_reg, sum0_reg};\n\n// Output product\nassign product = sum4;\n\nendmodule\n\n// Full adder module\nmodule gad_4bit(input a, b, output sum);\n    assign sum = a ^ b ^ 1'b1;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= 0;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= 0;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 25000000; // 25MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= 0;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each nibble\n    nibble_adder add1(.A(A[1:1]), .B(B[1:1]), .C_in(1'b0), .S(S[1:1]), .C_out(c1));\n    nibble_adder add2(.A(A[2:2]), .B(B[2:2]), .C_in(c1), .S(S[2:2]), .C_out(c2));\n    nibble_adder add3(.A(A[3:3]), .B(B[3:3]), .C_in(c2), .S(S[3:3]), .C_out(c3));\n    nibble_adder add4(.A(A[4:4]), .B(B[4:4]), .C_in(c3), .S(S[4:4]), .C_out(C_out));\n\nendmodule\n\nmodule nibble_adder(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out wires\n\n    // Instantiate 2-bit full adders for each nibble\n    full_adder fa1(.A(A[1:1]), .B(B[1:1]), .C_in(C_in), .S(S[1:1]), .C_out(c1));\n    full_adder fa2(.A(A[2:2]), .B(B[2:2]), .C_in(c1), .S(S[2:2]), .C_out(c2));\n\n    // Carry-out from the last full adder\n    assign C_out = c2;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    reg [11:0] duty_cycle_threshold;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            duty_cycle_threshold <= 0;\n            pwm_out <= 0;\n        end else begin\n            duty_cycle_threshold <= (DUTY_CYCLE * MAX_COUNT) / 100;\n            pwm_out <= (counter_out < duty_cycle_threshold);\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit carry lookahead adders\n    cla_4bit add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .S(S[16:1]),\n        .C_out(carry[1])\n    );\n\n    cla_4bit add2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(carry[1]),\n        .S(S[12:1]),\n        .C_out(carry[2])\n    );\n\n    cla_4bit add3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(carry[2]),\n        .S(S[8:1]),\n        .C_out(carry[3])\n    );\n\n    cla_4bit add4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(carry[3]),\n        .S(S[4:1]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule cla_4bit(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] temp;      // Temporary sum\n\n    // Carry-lookahead adder logic\n    assign temp[1] = A[1] ^ B[1];\n    assign temp[2] = (A[1] & B[1]) | (A[1] & C_in) | (B[1] & C_in);\n    assign temp[3] = (A[2] ^ B[2]) | temp[2];\n    assign temp[4] = (A[3] ^ B[3]) | temp[3];\n    assign temp[5] = (A[4] ^ B[4]) | temp[4];\n\n    assign S = A ^ B;\n    assign C_out = temp[5];\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_8;\n\n  // Stage 1: Shift by 4\n  mux2X1 #(.WIDTH(8)) stage1_mux (.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_4));\n  mux2X1 #(.WIDTH(8)) stage2_mux (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_2), .out(shifted_in_8));\n  mux2X1 #(.WIDTH(8)) stage3_mux (.sel(ctrl[0]), .in0(shifted_in_8), .in1(shifted_in_4), .out(out));\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle of the PWM signal\n    parameter MAX_COUNT = 100; // Maximum count value for the counter\n\n    wire [7:0] counter_out;\n    wire [7:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_value(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [7:0] count_out\n);\n    parameter MAX_COUNT = 100; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [7:0] count_value,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 50; // Duty cycle threshold for the PWM signal\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (count_value < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] shifted;\n\n    // Stage 1: Shift by 4 positions\n    wire [7:0] stage1_sel = {ctrl[2], ctrl[2], ctrl[2], ctrl[2], ctrl[1], ctrl[1], ctrl[1], ctrl[1]};\n    mux2X1 stage1 (shifted, in, in, stage1_sel);\n\n    // Stage 2: Shift by 2 positions\n    wire [7:0] stage2_sel = {ctrl[2], ctrl[2], ctrl[1], ctrl[1], ctrl[0], ctrl[0], ctrl[0], ctrl[0]};\n    mux2X1 stage2 (shifted, shifted, in, stage2_sel);\n\n    // Stage 3: Shift by 1 position\n    wire [7:0] stage3_sel = {ctrl[2], ctrl[1], ctrl[0], ctrl[0], ctrl[0], ctrl[0], ctrl[0], ctrl[0]};\n    mux2X1 stage3 (shifted, shifted, in, stage3_sel);\n\n    assign out = shifted;\nendmodule\n\nmodule mux2X1 (out, in1, in2, sel);\n    input [7:0] in1, in2;\n    input [7:0] sel;\n    output [7:0] out;\n\n    assign out = sel[0] ? in2 : in1;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[3]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Output carry-out\n    assign C_out = C4[4];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G, P, and C\n    genvar i;\n    generate\n        for (i = 1; i < 5; i = i + 1) begin : gen_loop\n            assign G[i] = A[i] & B[i];\n            assign P[i] = A[i] ^ B[i];\n            assign C[i] = G[i] | (P[i] & C_in);\n        end\n    endgenerate\n\n    // Sum calculation\n    assign S = A ^ B;\n\n    // Carry-out calculation\n    assign C_out = C[5];\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\n\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n    // Stage 1: Shift by 4\n    mux2X1 mux1(stage1, in, in, ctrl[2]);\n    mux2X1 mux2(stage2, stage1, stage1, ctrl[2]);\n    mux2X1 mux3(stage3, stage2, stage2, ctrl[2]);\n    mux2X1 mux4(stage4, stage3, stage3, ctrl[2]);\n\n    // Stage 2: Shift by 2\n    mux2X1 mux5(stage5, stage4, stage4, ctrl[1]);\n    mux2X1 mux6(stage6, stage5, stage5, ctrl[1]);\n    mux2X1 mux7(stage7, stage6, stage6, ctrl[1]);\n    mux2X1 mux8(stage8, stage7, stage7, ctrl[1]);\n\n    // Stage 3: Shift by 1\n    mux2X1 mux9(out, stage8, stage8, ctrl[0]);\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n    input sel;\n    input [7:0] in0, in1;\n    output [7:0] out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Percentage of the PWM period\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Percentage of the PWM period\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:0] carry;    // Carry wire for each 4-bit block\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .S(S[16:1]),\n        .C_out(carry[0])\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(carry[0]),\n        .S(S[12:1]),\n        .C_out(carry[1])\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(carry[1]),\n        .S(S[8:1]),\n        .C_out(carry[2])\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(carry[2]),\n        .S(S[4:1]),\n        .C_out(carry[3])\n    );\n\n    // Output carry-out\n    assign C_out = carry[3];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;      // 4-bit input A\n    input [4:1] B;      // 4-bit input B\n    input C_in;         // Carry-in input\n    output [4:1] S;     // 4-bit sum output\n    output C_out;       // Carry-out output\n\n    wire [5:1] temp;    // Temporary sum\n    wire [3:1] carry;   // Carry wire for each bit\n\n    // Carry-lookahead adder logic\n    assign {C_out, temp} = A + B + C_in;\n    assign S = temp[4:1];\n    assign carry[1] = temp[5];\n    assign carry[2] = temp[5] ^ temp[4];\n    assign carry[3] = temp[5] ^ temp[4] ^ temp[3];\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out < MAX_COUNT) begin\n            count_out <= count_out + 1;\n        end else begin\n            count_out <= 0;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < (DUTY_CYCLE * MAX_COUNT / 100));\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the multiplication results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check for zero result\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed multiplication\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned multiplication\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    wire c;\n    assign {c, diff} = a - b - bin;\n    assign bout = c;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1[1]),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2[2]),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3[4]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] c;\n\n    // Carry logic\n    assign c[1] = A[1] & B[1];\n    assign c[2] = A[2] & B[2] | A[1] & B[2] | A[2] & B[1];\n    assign c[3] = A[3] & B[3] | A[2] & B[3] | A[3] & B[2] | A[3] & B[1];\n    assign c[4] = A[4] & B[4] | A[3] & B[4] | A[4] & B[3] | A[4] & B[2] | A[4] & B[1];\n    assign c[5] = A[5] & B[5] | A[4] & B[5] | A[5] & B[4] | A[5] & B[3] | A[5] & B[2] | A[5] & B[1];\n\n    // Sum logic\n    assign S[1] = A[1] ^ B[1];\n    assign S[2] = A[2] ^ B[2] ^ c[1];\n    assign S[3] = A[3] ^ B[3] ^ c[2];\n    assign S[4] = A[4] ^ B[4] ^ c[3];\n    assign S[5] = A[5] ^ B[5] ^ c[4];\n\n    // Carry-out logic\n    assign C_out = c[5] | (C_in & c[4]);\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Output parity\n\n    wire [7:0] gen1;     // Output of first generator\n    wire [7:0] gen2;     // Output of second generator\n\n    // Instantiate two 8-bit parity generators\n    parity_8bit gen1_inst(.X(X), .P(gen1));\n    parity_8bit gen2_inst(.X(Y), .P(gen2));\n\n    // Compute the final parity\n    assign P = gen1 ^ gen2;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Output parity\n\n    wire [7:0] gen1;     // Output of first generator\n    wire [7:0] gen2;     // Output of second generator\n\n    // Instantiate two 4-bit parity generators\n    parity_4bit gen1_inst(.X(X[3:0]), .P(gen1));\n    parity_4bit gen2_inst(.X(X[7:4]), .P(gen2));\n\n    // Compute the final parity\n    assign P = gen1 ^ gen2;\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output P;            // Output parity\n\n    wire [3:0] gen1;     // Output of first generator\n    wire [3:0] gen2;     // Output of second generator\n\n    // Instantiate two 2-bit parity generators\n    parity_2bit gen1_inst(.X(X[1:0]), .P(gen1));\n    parity_2bit gen2_inst(.X(X[3:2]), .P(gen2));\n\n    // Compute the final parity\n    assign P = gen1 ^ gen2;\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output P;            // Output parity\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the multc signal\nassign y = (multc) ? unsigned_result : signed_result;\n\n// Extract the msb and lsb of the result\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Determine if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    wire c_out;\n    sub6 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c_out));\n    sub5 S1 (.a(diff), .b(c_out), .diff(diff), .bout(bout));\nendmodule\n\nmodule sub6(input a, b, bin, output diff, bout);\n    wire c_out;\n    sub4 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c_out));\n    sub3 S1 (.a(diff), .b(c_out), .diff(diff), .bout(bout));\nendmodule\n\nmodule sub5(input a, b, bin, output diff, bout);\n    wire c_out;\n    sub2 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c_out));\n    sub1 S1 (.a(diff), .b(c_out), .diff(diff), .bout(bout));\nendmodule\n\nmodule sub4(input a, b, bin, output diff, bout);\n    wire c_out;\n    sub2 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c_out));\n    sub1 S1 (.a(diff), .b(c_out), .diff(diff), .bout(bout));\nendmodule\n\nmodule sub3(input a, b, bin, output diff, bout);\n    wire c_out;\n    sub1 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c_out));\n    sub1 S1 (.a(diff), .b(c_out), .diff(diff), .bout(bout));\nendmodule\n\nmodule sub2(input a, b, bin, output diff, bout);\n    wire c_out;\n    sub1 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .bout(c_out));\n    sub1 S1 (.a(diff), .b(c_out), .diff(diff), .bout(bout));\nendmodule\n\nmodule sub1(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Output parity\n\n    wire [7:0] x_parity;\n    wire [7:0] y_parity;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(x_parity));\n    parity_8bit gen2(.X(Y), .P(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\n// 8-bit parity generator module\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Output parity\n\n    wire [7:0] x_parity;\n\n    // Compute the parity of X\n    assign x_parity = X[0] ^ X[1] ^ X[2] ^ X[3] ^ X[4] ^ X[5] ^ X[6] ^ X[7];\n\n    // Output the parity\n    assign P = x_parity;\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output\n    assign count_out = count;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_signal;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_signal)\n    );\n\n    // Assign the output signals\n    assign count_out = count;\n    assign overflow = overflow_signal;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1'b1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(x_parity)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(y_parity)\n    );\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(\n        .X(X[3:0]),\n        .P(x_parity[3:0])\n    );\n\n    parity_4bit gen2(\n        .X(X[7:4]),\n        .P(x_parity[7:4])\n    );\n\n    // Compute the final parity\n    assign P = x_parity;\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output [3:0] P;      // Parity output\n\n    wire [3:0] x_parity; // Parity of X\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(\n        .X(X[1:0]),\n        .P(x_parity[1:0])\n    );\n\n    parity_2bit gen2(\n        .X(X[3:2]),\n        .P(x_parity[3:2])\n    );\n\n    // Compute the final parity\n    assign P = x_parity;\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output [1:0] P;      // Parity output\n\n    // Compute the parity\n    assign P = X[0] ^ X[1];\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_internal;\n    wire overflow_internal;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_internal)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_internal),\n        .overflow(overflow_internal)\n    );\n\n    // Assign the output\n    assign count_out = count_internal;\n    assign overflow = overflow_internal;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_1;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_5;\n  wire [7:0] shifted_in_6;\n  wire [7:0] shifted_in_7;\n  wire [7:0] shifted_in_8;\n  wire [7:0] shifted_in_9;\n  wire [7:0] shifted_in_10;\n  wire [7:0] shifted_in_11;\n  wire [7:0] shifted_in_12;\n  wire [7:0] shifted_in_13;\n  wire [7:0] shifted_in_14;\n  wire [7:0] shifted_in_15;\n  wire [7:0] shifted_in_16;\n  wire [7:0] shifted_in_17;\n  wire [7:0] shifted_in_18;\n  wire [7:0] shifted_in_19;\n  wire [7:0] shifted_in_20;\n  wire [7:0] shifted_in_21;\n  wire [7:0] shifted_in_22;\n  wire [7:0] shifted_in_23;\n  wire [7:0] shifted_in_24;\n  wire [7:0] shifted_in_25;\n  wire [7:0] shifted_in_26;\n  wire [7:0] shifted_in_27;\n\n  // Stage 1: Shift by 4\n  mux2X1 ins_27(ctrl[2], in, shifted_in_27, shifted_in_26);\n  mux2X1 ins_26(ctrl[2], shifted_in_27, shifted_in_26, shifted_in_25);\n  mux2X1 ins_25(ctrl[2], shifted_in_26, shifted_in_25, shifted_in_24);\n  mux2X1 ins_24(ctrl[2], shifted_in_25, shifted_in_24, shifted_in_23);\n  mux2X1 ins_23(ctrl[2], shifted_in_24, shifted_in_23, shifted_in_22);\n  mux2X1 ins_22(ctrl[2], shifted_in_23, shifted_in_22, shifted_in_21);\n  mux2X1 ins_21(ctrl[2], shifted_in_22, shifted_in_21, shifted_in_20);\n  mux2X1 ins_20(ctrl[2], shifted_in_21, shifted_in_20, shifted_in_19);\n  mux2X1 ins_19(ctrl[2], shifted_in_20, shifted_in_19, shifted_in_18);\n  mux2X1 ins_18(ctrl[2], shifted_in_19, shifted_in_18, shifted_in_17);\n  mux2X1 ins_17(ctrl[2], shifted_in_18, shifted_in_17, shifted_in_16);\n  mux2X1 ins_16(ctrl[2], shifted_in_17, shifted_in_16, shifted_in_15);\n  mux2X1 ins_15(ctrl[2], shifted_in_16, shifted_in_15, shifted_in_14);\n  mux2X1 ins_14(ctrl[2], shifted_in_15, shifted_in_14, shifted_in_13);\n  mux2X1 ins_13(ctrl[2], shifted_in_14, shifted_in_13, shifted_in_12);\n  mux2X1 ins_12(ctrl[2], shifted_in_13, shifted_in_12, shifted_in_11);\n  mux2X1 ins_11(ctrl[2], shifted_in_12, shifted_in_11, shifted_in_10);\n  mux2X1 ins_10(ctrl[2], shifted_in_11, shifted_in_10, shifted_in_9);\n  mux2X1 ins_9(ctrl[2], shifted_in_10, shifted_in_9, shifted_in_8);\n  mux2X1 ins_8(ctrl[2], shifted_in_9, shifted_in_8, shifted_in_7);\n  mux2X1 ins_7(ctrl[2], shifted_in_8, shifted_in_7, shifted_in_6);\n  mux2X1 ins_6(ctrl[2], shifted_in_7, shifted_in_6, shifted_in_5);\n  mux2X1 ins_5(ctrl[2], shifted_in_6, shifted_in_5, shifted_in_4);\n  mux2X1 ins_4(ctrl[2], shifted_in_5, shifted_in_4, shifted_in_3);\n  mux2X1 ins_3(ctrl[2], shifted_in_4, shifted_in_3, shifted_in_2);\n  mux2X1 ins_2(ctrl[2], shifted_in_3, shifted_in_2, shifted_in_1);\n  mux2X1 ins_1(ctrl[2], shifted_in_2, shifted_in_1, in);\n\n  // Stage 2: Shift by 2\n  mux2X1 ins_27(ctrl[1], shifted_in_27, shifted_in_26, shifted_in_25);\n  mux2X1 ins_26(ctrl[1], shifted_in_26, shifted_in_25, shifted_in_24);\n  mux2X1 ins_25(ctrl[1], shifted_in_25, shifted_in_24, shifted_in_23);\n  mux2X1 ins_24(ctrl[1], shifted_in_24, shifted_in_23, shifted_in_22);\n  mux2X1 ins_23(ctrl[1], shifted_in_23, shifted_in_22, shifted_in_21);\n  mux2X1 ins_22(ctrl[1], shifted_in_22, shifted_in_21, shifted_in_20);\n  mux2X1 ins_21(ctrl[1], shifted_in_21, shifted_in_20, shifted_in_19);\n  mux2X1 ins_20(ctrl[1], shifted_in_20, shifted_in_19, shifted_in_18);\n  mux2X1 ins_19(ctrl[1], shifted_in_19, shifted_in_18, shifted_in_17);\n  mux2X1 ins_18(ctrl[1], shifted_in_18, shifted_in_17, shifted_in_16);\n  mux2X1 ins_17(ctrl[1], shifted_in_17, shifted_in_16, shifted_in_15);\n  mux2X1 ins_16(ctrl[1], shifted_in_16, shifted_in_15, shifted_in_14);\n  mux2X1 ins_15(ctrl[1], shifted_in_15, shifted_in_14, shifted_in_13);\n  mux2X1 ins_14(ctrl[1], shifted_in_14, shifted_in_13, shifted_in_12);\n  mux2X1 ins_13(ctrl[1], shifted_in_13, shifted_in_12, shifted_in_11);\n  mux2X1 ins_12(ctrl[1], shifted_in_12, shifted_in_11, shifted_in_10);\n  mux2X1 ins_11(ctrl[1], shifted_in_11, shifted_in_10, shifted_in_9);\n  mux2X1 ins_10(ctrl[1], shifted_in_10, shifted_in_9, shifted_in_8);\n  mux2X1 ins_9(ctrl[1], shifted_in_9, shifted_in_8, shifted_in_7);\n  mux2X1 ins_8(ctrl[1], shifted_in_8, shifted_in_7, shifted_in_6);\n  mux2X1 ins_7(ctrl[1], shifted_in_7, shifted_in_6, shifted_in_5);\n  mux2X1 ins_6(ctrl[1], shifted_in_6, shifted_in_5, shifted_in_4);\n  mux2X1 ins_5(ctrl[1], shifted_in_5, shifted_in_4, shifted_in_3);\n  mux2X1 ins_4(ctrl[1], shifted_in_4, shifted_in_3, shifted_in_2);\n  mux2X1 ins_3(ctrl[1], shifted_in_3, shifted_in_2, shifted_in_1);\n  mux2X1 ins_2(ctrl[1], shifted_in_2, shifted_in_1, shifted_in);\n\n  // Stage 3: Shift by 1\n  mux2X1 ins_27(ctrl[0], shifted_in_27, shifted_in_26, shifted_in_25);\n  mux2X1 ins_26(ctrl[0], shifted_in_26, shifted_in_25, shifted_in_24);\n  mux2X1 ins_25(ctrl[0], shifted_in_25, shifted_in_24, shifted_in_23);\n  mux2X1 ins_24(ctrl[0], shifted_in_24, shifted_in_23, shifted_in_22);\n  mux2X1 ins_23(ctrl[0], shifted_in_23, shifted_in_22, shifted_in_21);\n  mux2X1 ins_22(ctrl[0], shifted_in_22, shifted_in_21, shifted_in_20);\n  mux2X1 ins_21(ctrl[0], shifted_in_21, shifted_in_20, shifted_in_19);\n  mux2X1 ins_20(ctrl[0], shifted_in_20, shifted_in_19, shifted_in_18);\n  mux2X1 ins_19(ctrl[0], shifted_in_19, shifted_in_18, shifted_in_17);\n  mux2X1 ins_18(ctrl[0], shifted_in_18, shifted_in_17, shifted_in_16);\n  mux2X1 ins_17(ctrl[0], shifted_in_17, shifted_in_16, shifted_in_15);\n  mux2X1 ins_16(ctrl[0], shifted_in_16, shifted_in_15, shifted_in_14);\n  mux2X1 ins_15(ctrl[0], shifted_in_15, shifted_in_14, shifted_in_13);\n  mux2X1 ins_14(ctrl[0], shifted_in_14, shifted_in_13, shifted_in_12);\n  mux2X1 ins_13(ctrl[0], shifted_in_13, shifted_in_12, shifted_in_11);\n  mux2X1 ins_12(ctrl[0], shifted_in_12, shifted_in_11, shifted_in_10);\n  mux2X1 ins_11(ctrl[0], shifted_in_11, shifted_in_10, shifted_in_9);\n  mux2X1 ins_10(ctrl[0], shifted_in_10, shifted_in_9, shifted_in_8);\n  mux2X1 ins_9(ctrl[0], shifted_in_9, shifted_in_8, shifted_in_7);\n  mux2X1 ins_8(ctrl[0], shifted_in_8, shifted_in_7, shifted_in_6);\n  mux2X1 ins_7(ctrl[0], shifted_in_7, shifted_in_6, shifted_in_5);\n  mux2X1 ins_6(ctrl[0], shifted_in_6, shifted_in_5, shifted_in_4);\n  mux2X1 ins_5(ctrl[0], shifted_in_5, shifted_in_4, shifted_in_3);\n  mux2X1 ins_4(ctrl[0], shifted_in_4, shifted_in_3, shifted_in_2);\n  mux2X1 ins_3(ctrl[0], shifted_in_3, shifted_in_2, shifted_in_1);\n  mux2X1 ins_2(ctrl[0], shifted_in_2, shifted_in_1, shifted_in);\n\n  assign out = shifted_in;\n\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate two 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(x_parity));\n    parity_8bit gen2(.X(Y), .P(y_parity));\n\n    // Compute the parity of the combined 16 bits\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Instantiate a 4-bit parity generator\n    parity_4bit gen1(.X(X[3:0]), .P(x_parity[3:0]));\n    parity_4bit gen2(.X(X[7:4]), .P(x_parity[7:4]));\n\n    // Compute the parity of the 8 bits\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3] ^ x_parity[4] ^ x_parity[5] ^ x_parity[6] ^ x_parity[7];\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output P;            // Parity output\n\n    wire [3:0] x_parity; // Parity of X\n\n    // Instantiate a 2-bit parity generator\n    parity_2bit gen1(.X(X[1:0]), .P(x_parity[1:0]));\n    parity_2bit gen2(.X(X[3:2]), .P(x_parity[3:2]));\n\n    // Compute the parity of the 4 bits\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3];\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output P;            // Parity output\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed b0 for pe1\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed version of b0\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0(.a(a), .b(b[0]), .p(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .p(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .p(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .p(p3));\n\n    assign product = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] p);\n    assign p = {8{b}} & {8{a}};\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delayed version of b0\n  assign b1 = (rst) ? 0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0(.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .S(S[16:1]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .C_in(carry[0]),\n        .S(S[12:4]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .C_in(carry[1]),\n        .S(S[8:8]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(carry[2]),\n        .S(S[4:4]),\n        .C_out(carry[3])\n    );\n\n    // Combine the carry outputs to get the final carry-out\n    assign C_out = carry[3];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry output from each bit\n\n    // Instantiate 2-bit full adders for each bit\n    two_bit_adder add1(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(C_in),\n        .S(S[4:3]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    two_bit_adder add3(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(carry[2]),\n        .S(S[2:1]),\n        .C_out(carry[3])\n    );\n\n    // Combine the carry outputs to get the final carry-out\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry outputs from each bit\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(C1)\n    );\n\n    // Combine the carry outputs to get the final carry-out\n    assign C_out = C1 | C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd add_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(add_result)\n);\n\nsubtract subtract_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(subtract_result)\n);\n\nbitwise_and bitwise_and_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_and_result)\n);\n\nbitwise_or bitwise_or_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_or_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUB: result <= subtract_result;\n            `AND: result <= bitwise_and_result;\n            `OR: result <= bitwise_or_result;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a + b;\nendmodule\n\nmodule subtract(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a | b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  assign b1 = b0;\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0(.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .next_count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] next_count\n);\n    always @(*) begin\n        if (toggle) begin\n            next_count = 32'b1;\n        end else begin\n            next_count = 32'b0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 32'b0;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(control_signal),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit adders for each 4-bit chunk\n    four_bit_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .S(S[16:1]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .C_in(carry[0]),\n        .S(S[12:4]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .C_in(carry[1]),\n        .S(S[8:8]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(carry[2]),\n        .S(S[4:4]),\n        .C_out(carry[3])\n    );\n\n    // Carry-out is the last carry output\n    assign C_out = carry[3];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry output from each bit\n\n    // Instantiate 2-bit adders for each bit\n    two_bit_adder add1(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(C_in),\n        .S(S[4:3]),\n        .C_out(carry[0])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add3(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(carry[1]),\n        .S(S[2:1]),\n        .C_out(carry[2])\n    );\n\n    two_bit_adder add4(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(carry[2]),\n        .S(S[1:1]),\n        .C_out(carry[3])\n    );\n\n    // Carry-out is the last carry output\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry outputs from each bit\n\n    // Instantiate 1-bit adder for each bit\n    one_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C1),\n        .S(S[1:1]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry output\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A, B;           // Inputs\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] pc;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc));\n  decode_stage decode (.clk(clk), .rst(rst), .pc(pc), .instr_mem(instr_mem), .reg_file(reg_file), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute (.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .op(op), .alu_result(alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(alu_result), .reg_file(reg_file), .rd(rd), .res_reg_file(res_reg_file));\n  writeback_stage writeback (.clk(clk), .rst(rst), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr_mem[pc][24:20];\n      rs2 <= instr_mem[pc][20:16];\n      rd <= instr_mem[pc][11:7];\n      op <= instr_mem[pc][31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [5:0] op,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else begin\n      case (op)\n        6'b000000: alu_result <= reg_file[rs1] + reg_file[rs2];\n        6'b001010: alu_result <= reg_file[rs1] - reg_file[rs2];\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  input [4:0] rd,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file[rd] <= 0;\n    end else begin\n      res_reg_file[rd] <= alu_result;\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      // Reset all registers\n      $write(\"[WRITEBACK] Resetting all registers\\n\");\n      $dumpvars;\n    end else begin\n      $write(\"[WRITEBACK] Writing back result to register %0d\\n\", res_reg_file[0]);\n      $dumpvars;\n    end\n  end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        count_out <= count;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit full adders for each 4-bit chunk\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[1]),\n        .S(S[7:4]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[2]),\n        .S(S[11:8]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add5(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .C_in(carry[3]),\n        .S(S[15:12]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:0] sum;      // 5-bit sum\n\n    assign {C_out, sum} = A + B + C_in;\n    assign S = sum[3:0];\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiating 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combining the 4-bit comparator outputs to deduce the overall relationship\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiating 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combining the 2-bit comparator outputs to deduce the overall relationship\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\n// Instantiating 1-bit comparator\ncomparator_1bit comp_slice1(.a(a[0]), .b(b[0]), .eq(eq_bit), .gt(gt_bit), .lt(lt_bit));\n\n// Combining the 1-bit comparator outputs to deduce the overall relationship\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] alu_result;\n  wire [31:0] pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(pc)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .reg_file(reg_file),\n    .alu_result(alu_result)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .alu_result(alu_result)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .alu_result(alu_result)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .res_reg_file(res_reg_file)\n  );\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else begin\n      case (instr_mem[pc][31:28])\n        4'b0000: alu_result <= reg_file[instr_mem[pc][25:21]] + reg_file[instr_mem[pc][20:16]];\n        4'b0010: alu_result <= reg_file[instr_mem[pc][25:21]] - reg_file[instr_mem[pc][20:16]];\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else\n      alu_result <= alu_result;\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else\n      alu_result <= alu_result;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      res_reg_file <= 0;\n    else\n      res_reg_file <= alu_result;\n  end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, sub, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .sub(sub)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? sub :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sub\n);\n\n    assign sub = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1[1]),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2[1]),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3[1]),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the last carry out from the last adder\n    assign C_out = c4[1];\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [4:1] c;\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c[2]),\n        .S(S[3:2]),\n        .C_out(c[3])\n    );\n\n    // Carry-out is the last carry out from the last adder\n    assign C_out = c[4];\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    input C_in;          // Carry-in\n    output [1:0] S;      // 2-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 1-bit full adder for each bit\n    full_adder fa(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    // Carry-out is the last carry out from the last adder\n    assign C_out = c1;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;             // Input A\n    input B;             // Input B\n    input C_in;          // Carry-in\n    output S;            // Sum output\n    output C_out;        // Carry-out output\n\n    wire c;\n\n    assign {C_out, S} = A + B + C_in;\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine outputs from slices to determine overall relationship\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine outputs from slices to determine overall relationship\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a;\ninput [1:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 1-bit comparator slices\ncomparator_1bit comp_slice1(.a(a[1]), .b(b[1]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_1bit comp_slice2(.a(a[0]), .b(b[0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine outputs from slices to determine overall relationship\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a;\ninput b;\noutput eq;\noutput gt;\noutput lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [5:0] next_pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_result;\n\n// Instantiating pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op), .alu_result(alu_result));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .next_pc(next_pc));\nwriteback_stage writeback(.clk(clk), .rst(rst), .next_pc(next_pc), .alu_result(alu_result), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\n// Pipeline stages\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [5:0] pc,\n  output reg [31:0] instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      instr <= 0;\n    end else begin\n      instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[20:16];\n      rs2 <= instr[15:11];\n      rd <= instr[10:6];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_result <= rs1 + rs2;\n        6'b001000: alu_result <= rs1 - rs2;\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [5:0] next_pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc <= 0;\n    end else begin\n      next_pc <= alu_result[5:0];\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [5:0] next_pc,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[rd] <= alu_result;\n      next_pc <= next_pc + 1;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result : or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\nassign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\nassign sum = a + b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, gt_slice1, lt_slice1;\nwire [3:0] eq_slice2, gt_slice2, lt_slice2;\nwire [3:0] eq_slice3, gt_slice3, lt_slice3;\nwire [3:0] eq_slice4, gt_slice4, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, gt_slice1, lt_slice1;\nwire [1:0] eq_slice2, gt_slice2, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a & b;\n    end\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a | b;\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output [15:0] p\n);\nreg [15:0] p_reg;\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        p_reg <= 0;\n    else\n        p_reg <= x * y;\nend\nassign p = p_reg;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check for zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine the outputs of the slices to determine the overall relationship\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine the outputs of the slices to determine the overall relationship\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\n// Instantiate 1-bit comparator\ncomparator_1bit comp_slice(.a(a[1]), .b(b[1]), .eq(eq_bit), .gt(gt_bit), .lt(lt_bit));\n\n// Combine the outputs of the slices to determine the overall relationship\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:1] Bout1, Bout2, Bout3, Bout4;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout1);\n    subtractor_8bit SUB2(A[24:17], B[24:17], Bout1, D[24:17], Bout2);\n    subtractor_8bit SUB3(A[16:10], B[16:10], Bout2, D[16:10], Bout3);\n    subtractor_8bit SUB4(A[9:3], B[9:3], Bout3, D[9:3], Bout4);\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .product(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .product(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .product(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .product(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] product\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            product <= 0;\n        else\n            product <= x * y;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n    wire [31:0] zero_check;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero_check = result;\n    assign zero = |zero_check;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = rot_dir ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[32:17], B[32:17], Bout0, D[32:17], Bout1);\n    subtractor_8bit SUB3(A[32:11], B[32:11], Bout1, D[32:11], Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D[32:6], Bout3);\n    subtractor_8bit SUB5(A[32:1], B[32:1], Bout3, D[32:1], Bout4);\n    subtractor_8bit SUB6(A[32:25], B[32:25], Bout4, D[32:25], Bout5);\n    subtractor_8bit SUB7(A[32:17], B[32:17], Bout5, D[32:17], Bout6);\n    subtractor_8bit SUB8(A[32:11], B[32:11], Bout6, D[32:11], Bout7);\n    subtractor_8bit SUB9(A[32:6], B[32:6], Bout7, D[32:6], Bout);\n    subtractor_8bit SUB10(A[32:1], B[32:1], Bout, D[32:1], Bout);\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire [8:0] temp;\n\n    assign {Bout, temp} = A - B - Bin;\n    assign D = temp[7:0];\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_out;\nwire [3:0] right_out;\n\nleft_rotate lr(.data(in_data), .rot(rot_dir), .out(left_out));\nright_rotate rr(.data(in_data), .rot(rot_dir), .out(right_out));\n\nassign out_data = (rot_dir) ? left_out : right_out;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot,\n  output [3:0] out\n);\nassign out = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot,\n  output [3:0] out\n);\nassign out = {data[2:0], data[3]};\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] rot_left, rot_right;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(rot_left));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(rot_right));\n\nassign out_data = rot_dir ? rot_right : rot_left;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] b;\n\n    // Instantiate 8-bit subtractor blocks\n    subtractor SUB1(A[32:25], B[32:25], Bin, D[32:25], b);\n    subtractor SUB2(A[32:18], B[32:18], b, D[32:18], b);\n    subtractor SUB3(A[32:12], B[32:12], b, D[32:12], b);\n    subtractor SUB4(A[32:6], B[32:6], b, D[32:6], b);\n    subtractor SUB5(A[32:1], B[32:1], b, D[32:1], Bout);\n\nendmodule\n\nmodule subtractor(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire c;\n\n    // Subtract A and B with borrow-in Bin\n    assign {Bout, D} = A - B - Bin;\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check for zero result\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = rot_dir ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (~mode);\n  end\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] alu_result;\n  wire [31:0] next_reg_file [0:31];\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .next_pc(next_pc));\n  decode_stage decode (.clk(clk), .rst(rst), .pc(pc), .alu_result(alu_result));\n  execute_stage execute (.clk(clk), .rst(rst), .alu_result(alu_result), .next_pc(next_pc), .next_reg_file(next_reg_file));\n  memory_stage memory (.clk(clk), .rst(rst), .reg_file(reg_file), .next_reg_file(next_reg_file), .alu_result(alu_result));\n  writeback_stage writeback (.clk(clk), .rst(rst), .next_reg_file(next_reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc\n);\n  reg [31:0] pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc_reg <= 0;\n    else\n      pc_reg <= pc_reg + 1;\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = pc_reg + 1;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  output [31:0] alu_result\n);\n  reg [31:0] alu_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result_reg <= 0;\n    else begin\n      case (instr_mem[pc][31:28])\n        4'b0000: alu_result_reg <= instr_mem[pc][24:19] + instr_mem[pc][14:10];\n        4'b0100: alu_result_reg <= instr_mem[pc][24:19] - instr_mem[pc][14:10];\n        default: alu_result_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_result = alu_result_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] next_pc,\n  output [31:0] next_reg_file [0:31]\n);\n  reg [31:0] next_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_reg_file_reg[0] <= 0;\n      next_reg_file_reg[1] <= 0;\n      next_reg_file_reg[2] <= 0;\n      next_reg_file_reg[3] <= 0;\n      next_reg_file_reg[4] <= 0;\n      next_reg_file_reg[5] <= 0;\n      next_reg_file_reg[6] <= 0;\n      next_reg_file_reg[7] <= 0;\n      next_reg_file_reg[8] <= 0;\n      next_reg_file_reg[9] <= 0;\n      next_reg_file_reg[10] <= 0;\n      next_reg_file_reg[11] <= 0;\n      next_reg_file_reg[12] <= 0;\n      next_reg_file_reg[13] <= 0;\n      next_reg_file_reg[14] <= 0;\n      next_reg_file_reg[15] <= 0;\n      next_reg_file_reg[16] <= 0;\n      next_reg_file_reg[17] <= 0;\n      next_reg_file_reg[18] <= 0;\n      next_reg_file_reg[19] <= 0;\n      next_reg_file_reg[20] <= 0;\n      next_reg_file_reg[21] <= 0;\n      next_reg_file_reg[22] <= 0;\n      next_reg_file_reg[23] <= 0;\n      next_reg_file_reg[24] <= 0;\n      next_reg_file_reg[25] <= 0;\n      next_reg_file_reg[26] <= 0;\n      next_reg_file_reg[27] <= 0;\n      next_reg_file_reg[28] <= 0;\n      next_reg_file_reg[29] <= 0;\n      next_reg_file_reg[30] <= 0;\n      next_reg_file_reg[31] <= 0;\n    end else begin\n      next_reg_file_reg[0] <= alu_result;\n      next_reg_file_reg[1] <= alu_result;\n      next_reg_file_reg[2] <= alu_result;\n      next_reg_file_reg[3] <= alu_result;\n      next_reg_file_reg[4] <= alu_result;\n      next_reg_file_reg[5] <= alu_result;\n      next_reg_file_reg[6] <= alu_result;\n      next_reg_file_reg[7] <= alu_result;\n      next_reg_file_reg[8] <= alu_result;\n      next_reg_file_reg[9] <= alu_result;\n      next_reg_file_reg[10] <= alu_result;\n      next_reg_file_reg[11] <= alu_result;\n      next_reg_file_reg[12] <= alu_result;\n      next_reg_file_reg[13] <= alu_result;\n      next_reg_file_reg[14] <= alu_result;\n      next_reg_file_reg[15] <= alu_result;\n      next_reg_file_reg[16] <= alu_result;\n      next_reg_file_reg[17] <= alu_result;\n      next_reg_file_reg[18] <= alu_result;\n      next_reg_file_reg[19] <= alu_result;\n      next_reg_file_reg[20] <= alu_result;\n      next_reg_file_reg[21] <= alu_result;\n      next_reg_file_reg[22] <= alu_result;\n      next_reg_file_reg[23] <= alu_result;\n      next_reg_file_reg[24] <= alu_result;\n      next_reg_file_reg[25] <= alu_result;\n      next_reg_file_reg[26] <= alu_result;\n      next_reg_file_reg[27] <= alu_result;\n      next_reg_file_reg[28] <= alu_result;\n      next_reg_file_reg[29] <= alu_result;\n      next_reg_file_reg[30] <= alu_result;\n      next_reg_file_reg[31] <= alu_result;\n    end\n  end\n\n  assign next_reg_file = next_reg_file_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] reg_file [0:31],\n  input [31:0] next_reg_file [0:31],\n  input [31:0] alu_result\n);\n  // Nothing to do here\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] next_reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[0] <= 0;\n      res_reg_file_reg[1] <= 0;\n      res_reg_file_reg[2] <= 0;\n      res_reg_file_reg[3] <= 0;\n      res_reg_file_reg[4] <= 0;\n      res_reg_file_reg[5] <= 0;\n      res_reg_file_reg[6] <= 0;\n      res_reg_file_reg[7] <= 0;\n      res_reg_file_reg[8] <= 0;\n      res_reg_file_reg[9] <= 0;\n      res_reg_file_reg[10] <= 0;\n      res_reg_file_reg[11] <= 0;\n      res_reg_file_reg[12] <= 0;\n      res_reg_file_reg[13] <= 0;\n      res_reg_file_reg[14] <= 0;\n      res_reg_file_reg[15] <= 0;\n      res_reg_file_reg[16] <= 0;\n      res_reg_file_reg[17] <= 0;\n      res_reg_file_reg[18] <= 0;\n      res_reg_file_reg[19] <= 0;\n      res_reg_file_reg[20] <= 0;\n      res_reg_file_reg[21] <= 0;\n      res_reg_file_reg[22] <= 0;\n      res_reg_file_reg[23] <= 0;\n      res_reg_file_reg[24] <= 0;\n      res_reg_file_reg[25] <= 0;\n      res_reg_file_reg[26] <= 0;\n      res_reg_file_reg[27] <= 0;\n      res_reg_file_reg[28] <= 0;\n      res_reg_file_reg[29] <= 0;\n      res_reg_file_reg[30] <= 0;\n      res_reg_file_reg[31] <= 0;\n    end else begin\n      res_reg_file_reg[0] <= next_reg_file[0];\n      res_reg_file_reg[1] <= next_reg_file[1];\n      res_reg_file_reg[2] <= next_reg_file[2];\n      res_reg_file_reg[3] <= next_reg_file[3];\n      res_reg_file_reg[4] <= next_reg_file[4];\n      res_reg_file_reg[5] <= next_reg_file[5];\n      res_reg_file_reg[6] <= next_reg_file[6];\n      res_reg_file_reg[7] <= next_reg_file[7];\n      res_reg_file_reg[8] <= next_reg_file[8];\n      res_reg_file_reg[9] <= next_reg_file[9];\n      res_reg_file_reg[10] <= next_reg_file[10];\n      res_reg_file_reg[11] <= next_reg_file[11];\n      res_reg_file_reg[12] <= next_reg_file[12];\n      res_reg_file_reg[13] <= next_reg_file[13];\n      res_reg_file_reg[14] <= next_reg_file[14];\n      res_reg_file_reg[15] <= next_reg_file[15];\n      res_reg_file_reg[16] <= next_reg_file[16];\n      res_reg_file_reg[17] <= next_reg_file[17];\n      res_reg_file_reg[18] <= next_reg_file[18];\n      res_reg_file_reg[19] <= next_reg_file[19];\n      res_reg_file_reg[20] <= next_reg_file[20];\n      res_reg_file_reg[21] <= next_reg_file[21];\n      res_reg_file_reg[22] <= next_reg_file[22];\n      res_reg_file_reg[23] <= next_reg_file[23];\n      res_reg_file_reg[24] <= next_reg_file[24];\n      res_reg_file_reg[25] <= next_reg_file[25];\n      res_reg_file_reg[26] <= next_reg_file[26];\n      res_reg_file_reg[27] <= next_reg_file[27];\n      res_reg_file_reg[28] <= next_reg_file[28];\n      res_reg_file_reg[29] <= next_reg_file[29];\n      res_reg_file_reg[30] <= next_reg_file[30];\n      res_reg_file_reg[31] <= next_reg_file[31];\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[32:17], B[32:17], Bout0, D[32:17], Bout1);\n    subtractor_8bit SUB3(A[32:11], B[32:11], Bout1, D[32:11], Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D[32:6], Bout3);\n    subtractor_8bit SUB5(A[32:1], B[32:1], Bout3, D[32:1], Bout4);\n    subtractor_8bit SUB6(A[32:25], B[32:25], Bout4, D[32:25], Bout5);\n    subtractor_8bit SUB7(A[32:17], B[32:17], Bout5, D[32:17], Bout6);\n    subtractor_8bit SUB8(A[32:11], B[32:11], Bout6, D[32:11], Bout7);\n    subtractor_8bit SUB9(A[32:6], B[32:6], Bout7, D[32:6], Bout);\n\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    full_subtractor FSUB(A, B, Bin, D, Cout);\n\n    assign Bout = Cout;\nendmodule\n\nmodule full_subtractor(A, B, Bin, D, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Cout;\n\n    assign {Cout, D} = A - B - Bin;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Generate count values based on mode\n  assign count_value_up = mode ? 8'd0 : count_value + 1;\n  assign count_value_down = mode ? count_value - 1 : 8'd0;\n\n  // Select count value based on mode\n  assign count = mode ? count_value_down : count_value_up;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 8'd0;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b_delayed;\n  always @(posedge clk) begin\n    if (rst) begin\n      b_delayed <= 0;\n    end else begin\n      b_delayed <= b0;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] sum\n);\n    always @(*) begin\n        sum = a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] diff\n);\n    always @(*) begin\n        diff = a - b;\n    end\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(*) begin\n        result = a & b;\n    end\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(*) begin\n        result = a | b;\n    end\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(*) begin\n        result = a ^ b;\n    end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 1'b0;\n        end else if (t) begin\n            q <= ~q;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count_value(count_value),\n    .count_value_up(count_value_up),\n    .count_value_down(count_value_down)\n  );\n\n  // Select the output value based on the mode\n  assign count = (mode == 0) ? count_value_up : count_value_down;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count_value,\n  output reg [7:0] count_value_up,\n  output reg [7:0] count_value_down\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count_value <= 0;\n      count_value_up <= 0;\n      count_value_down <= 0;\n    end else if (enable) begin\n      if (count_value == 255) begin\n        count_value <= 0;\n        count_value_up <= count_value_up + 1;\n        count_value_down <= count_value_down - 1;\n      end else begin\n        count_value <= count_value + 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  reg [15:0] b1, b2, b3;\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the count value based on mode\n  assign count = (mode == 0) ? count_value : (~count_value + 1'b1);\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else if (mode == 0) begin\n        count <= count + 1;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control logic to determine the operation based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire [1:0] op_code\n);\n    assign result = (op_code == 2'b00) ? a & b :\n                    (op_code == 2'b01) ? a | b :\n                    32'b0;\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  reg [15:0] b1, b2, b3;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst)\n      c <= 0;\n    else\n      c <= a * b;\n  end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result,\n    output wire [31:0] or_result\n);\n    assign and_result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_counter init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .count_out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_counter (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= init_out;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "// Intermediate registers\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  \n  // Instantiating processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0_reg)\n  );\n  \n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1_reg)\n  );\n  \n  processing_element pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2_reg)\n  );\n  \n  processing_element pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3_reg)\n  );\n  \n  // Delaying b0 to b1, b1 to b2, b2 to b3\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n  \n  // Outputs\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n  \nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 0;\n    end\n    else begin\n      c_reg <= a * b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_count(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\n// Submodule for initialization\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\n// Submodule for counting\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            out <= init_count + 1;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .control(op_code[1])\n    );\n\n    // Control logic to determine the operation based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire control\n);\n\n    always @(a or b or control) begin\n        if (control) begin\n            result = a & b;\n        end else begin\n            result = a | b;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out, latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_count(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_count;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Fetch stage\nfetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\n// Execute stage\nexecute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\n// Writeback stage\nwriteback writeback (\n    .clk(clk),\n    .rst(rst),\n    .out_reg_file(execute.out_reg_file),\n    .reg_file(reg_file)\n);\n\n// Output the register file\nassign out_reg_file = reg_file[31];\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] op1, op2, result;\n    reg [5:0] opcode;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            opcode <= 0;\n        end\n        else begin\n            op1 <= reg_file[instr[25:21]];\n            op2 <= reg_file[instr[20:16]];\n            opcode <= instr[31:26];\n            case (opcode)\n                `ADD: result <= op1 + op2;\n                `SUB: result <= op1 - op2;\n                default: result <= 0;\n            endcase\n        end\n    end\n\n    assign out_reg_file = result;\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file,\n    input [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file[31] <= 0;\n        end\n        else begin\n            reg_file[31] <= out_reg_file;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 8'b00000000;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    output reg [31:0] or_result\n);\n\n    always @(a or b) begin\n        result = a & b;\n        or_result = a | b;\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodule instances\ncounter_logic u_counter_logic (\n    .count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count)\n);\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\nassign next_count = up_down ? count + 1 : count - 1;\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 0;\n    else\n        count <= next_count;\nend\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodules\nshift_register sr0(.clk(clk), .rst(rst), .load(load0), .data(data0), .shift(shift0), .out(out0));\nshift_register sr1(.clk(clk), .rst(rst), .load(load1), .data(data1), .shift(shift1), .out(out1));\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Module instance\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] rd;\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [31:0] writeback_result;\n\n    // Instantiate the pipeline stages\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(0),\n        .fetched_instr(fetched_instr)\n    );\n\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .reg_file(reg_file),\n        .op1(op1),\n        .op2(op2),\n        .result(result),\n        .rd(rd),\n        .opcode(opcode),\n        .funct(funct)\n    );\n\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .rd(rd),\n        .reg_file(reg_file),\n        .writeback_result(writeback_result)\n    );\n\n    // Connect outputs\n    assign out_reg_file = writeback_result;\n\nendmodule\n\n// Submodules\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result,\n    output [4:0] rd,\n    output [5:0] opcode,\n    output [5:0] funct\n);\n    assign {opcode, funct} = fetched_instr;\n    assign {op1, rd} = reg_file[funct[4:0]];\n    assign op2 = reg_file[opcode[4:0]];\n    assign result = (opcode == 6'b000000) ? op1 + op2 : op1 - op2;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output [31:0] writeback_result\n);\n    assign writeback_result = result;\n    assign reg_file[rd] = result;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        out <= 0;\n    else if (load)\n        out <= data;\n    else if (shift)\n        out <= {1'b0, out[7:1]};\nend\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    cyclic_state transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(transition_out)\n    );\n\n    // Output is the result of the state transition\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule cyclic_state (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Fetch stage\nfetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\n// Execute stage\nexecute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\n// Writeback stage\nwriteback writeback (\n    .clk(clk),\n    .rst(rst),\n    .out_reg_file(execute.out_reg_file),\n    .reg_file(reg_file)\n);\n\n// Output register file\nassign out_reg_file = reg_file[31]; // Output the value of the last register\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] op1, op2, result;\n    reg [5:0] opcode;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            opcode <= 0;\n        end else begin\n            op1 <= reg_file[instr[20:16]];\n            op2 <= reg_file[instr[15:11]];\n            opcode <= instr[31:26];\n            if (opcode == `ADD) begin\n                result <= op1 + op2;\n            end else if (opcode == `SUB) begin\n                result <= op1 - op2;\n            end\n        end\n    end\n\n    assign out_reg_file = result;\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file,\n    input [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file[31] <= 0;\n        end else begin\n            reg_file[31] <= out_reg_file;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .out(transition_out)\n    );\n\n    // Combine the two outputs\n    assign out = init_out | transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= out >> 1;\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry; // Carry chain\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Carry_in(1'b0), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Carry_in(carry[0]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Carry_in(carry[1]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Carry_in(carry[2]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    input Carry_in,   // Carry input\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry; // Carry chain\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Carry_in(Carry_in), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Carry_in(carry[0]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Carry_in(carry[1]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Carry_in(carry[2]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    input Carry_in,   // Carry input\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry; // Carry chain\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Carry_in(Carry_in), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Carry_in(carry[0]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    input Carry_in,   // Carry input\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa(.X(X), .Y(Y), .Carry_in(Carry_in), .Sum(Sum), .Carry_out(Carry_out));\n\nendmodule\n\nmodule full_adder(\n    input X,    // First input operand\n    input Y,    // Second input operand\n    input Carry_in,   // Carry input\n    output Sum, // Output sum\n    output Carry_out  // Carry output\n);\n\n    // Calculate sum and carry\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product PP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product PP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product PP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product PP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product PP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product PP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product PP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product PP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define INSTR_WIDTH 32\n`define OPCODE_WIDTH 6\n\n// Register file width\n`define REG_WIDTH 5\n\n// Instruction format\n`define INSTR_WIDTH 32\n`define OPCODE_WIDTH 6\n\n// Register file width\n`define REG_WIDTH 5\n\n// Instruction format\n`define INSTR_WIDTH 32\n`define OPCODE_WIDTH 6\n\n// Register file width\n`define REG_WIDTH 5\n\n// Instance declarations\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .out_instr(.out_instr));\nexecute_stage execute(.clk(clk), .rst(rst), .instr_mem(instr_mem), .out_instr(out_instr), .reg_file(reg_file), .out_reg_file(.out_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .out_reg_file(out_reg_file));\n\n// Outputs\nassign out_reg_file = writeback.out_reg_file;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output [31:0] out_instr\n);\n    reg [31:0] instr_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            instr_reg <= 0;\n        else\n            instr_reg <= instr_mem[0];\n    end\n    assign out_instr = instr_reg;\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] out_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] op1, op2, result;\n    reg [5:0] rd;\n    reg [5:0] rs1, rs2;\n    reg [5:0] rt;\n    reg [5:0] opcode;\n    reg [1:0] funct;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            rt <= 0;\n            opcode <= 0;\n            funct <= 0;\n        end\n        else begin\n            op1 <= reg_file[rs1];\n            op2 <= reg_file[rs2];\n            opcode <= out_instr[5:0];\n            funct <= out_instr[11:6];\n            case (opcode)\n                `ADD: begin\n                    result <= op1 + op2;\n                    rd <= out_instr[15:11];\n                end\n                `SUB: begin\n                    result <= op1 - op2;\n                    rd <= out_instr[15:11];\n                end\n                default: begin\n                    result <= 0;\n                    rd <= 0;\n                end\n            endcase\n        end\n    end\n    assign out_reg_file = result;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file\n);\n    reg [31:0] out_reg_file_reg;\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file_reg <= 0;\n        else\n            out_reg_file_reg <= out_reg_file;\n    end\n    assign out_reg_file = out_reg_file_reg;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_value(count_value)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [30:0] carry;\n\n    // Instantiate 4 8-bit full adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit full adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[4];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit full adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    // Carry out\n    assign Carry_out = carry[2];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit full adder\n    full_adder fa(.X(X), .Y(Y), .Sum(Sum), .Carry_out(Carry_out));\n\nendmodule\n\nmodule full_adder(\n    input X,    // First input operand\n    input Y,    // Second input operand\n    output Sum, // Output sum\n    output Carry_out  // Carry output\n);\n\n    wire C_in;\n\n    // Carry in\n    assign C_in = X & Y;\n\n    // Sum\n    assign Sum = X ^ Y;\n\n    // Carry out\n    assign Carry_out = X | Y | C_in;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.x(X), .y(Y), .shift(0), .acc(A0));\n    add_shift AS1(.x(X), .y(Y), .shift(1), .acc(A1));\n    add_shift AS2(.x(X), .y(Y), .shift(2), .acc(A2));\n    add_shift AS3(.x(X), .y(Y), .shift(3), .acc(A3));\n    add_shift AS4(.x(X), .y(Y), .shift(4), .acc(A4));\n    add_shift AS5(.x(X), .y(Y), .shift(5), .acc(A5));\n    add_shift AS6(.x(X), .y(Y), .shift(6), .acc(A6));\n    add_shift AS7(.x(X), .y(Y), .shift(7), .acc(A7));\n\n    // Assign the product to the output\n    assign P = A0 + A1 + A2 + A3 + A4 + A5 + A6 + A7;\n\nendmodule\n\nmodule add_shift(x, y, shift, acc);\n    input [7:0] x;\n    input [7:0] y;\n    input [2:0] shift;\n    output [15:0] acc;\n\n    wire [15:0] x_shifted;\n\n    assign x_shifted = x << shift;\n\n    // Add the shifted value to the accumulator\n    assign acc = acc + (x_shifted & y);\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (valid_in) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n        end else if (valid_in) begin\n            data_out <= data_out + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [2:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end else if (count == 4) begin\n            valid_out <= 1;\n        end else begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Output the product\n    assign P = accumulator;\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input [7:0] Y;\n    output reg [15:0] accumulator;\n\n    always @(*) begin\n        if (Y[0])\n            accumulator = accumulator + (X << 0);\n        if (Y[1])\n            accumulator = accumulator + (X << 1);\n        if (Y[2])\n            accumulator = accumulator + (X << 2);\n        if (Y[3])\n            accumulator = accumulator + (X << 3);\n        if (Y[4])\n            accumulator = accumulator + (X << 4);\n        if (Y[5])\n            accumulator = accumulator + (X << 5);\n        if (Y[6])\n            accumulator = accumulator + (X << 6);\n        if (Y[7])\n            accumulator = accumulator + (X << 7);\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output [63:0]       next_Q\n);\n\n    assign next_Q = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output [63:0]       next_Q\n);\n\n    assign next_Q = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Cin,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Cin;\n    assign Carry_out = (X & Y) | (Y & Cin) | (X & Cin);\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate add_shift submodules\n    add_shift AS0(.x(X), .y(Y[0]), .shift(0), .accumulator(accumulator));\n    add_shift AS1(.x(X), .y(Y[1]), .shift(1), .accumulator(accumulator));\n    add_shift AS2(.x(X), .y(Y[2]), .shift(2), .accumulator(accumulator));\n    add_shift AS3(.x(X), .y(Y[3]), .shift(3), .accumulator(accumulator));\n    add_shift AS4(.x(X), .y(Y[4]), .shift(4), .accumulator(accumulator));\n    add_shift AS5(.x(X), .y(Y[5]), .shift(5), .accumulator(accumulator));\n    add_shift AS6(.x(X), .y(Y[6]), .shift(6), .accumulator(accumulator));\n    add_shift AS7(.x(X), .y(Y[7]), .shift(7), .accumulator(accumulator));\n\n    // Assign the product to the output\n    assign P = accumulator;\nendmodule\n\nmodule add_shift(x, y, shift, accumulator);\n    input [7:0] x;\n    input y;\n    input [3:0] shift;\n    output [15:0] accumulator;\n\n    wire [15:0] shifted_x;\n    wire [15:0] shifted_accumulator;\n\n    // Shift the multiplicand left by the specified number of positions\n    assign shifted_x = x << shift;\n\n    // Add the shifted multiplicand to the accumulator\n    assign shifted_accumulator = accumulator + shifted_x;\n\n    // Assign the shifted accumulator to the output\n    assign accumulator = (y) ? shifted_accumulator : accumulator;\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n    wire [63:0] current_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(current_state)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .current_state(current_state),\n        .next_state(next_state)\n    );\n\n    // Assign the output\n    assign Q = next_state;\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0] current_state,\n    output reg [63:0] next_state\n);\n\n    always @(*) begin\n        next_state = current_state ^ (current_state >> 1);\n    end\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] acc;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the second add_shift module\n    add_shift AS1(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the third add_shift module\n    add_shift AS2(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(\n        .X(X),\n        .Y(Y),\n        .acc(acc)\n    );\n\n    // Output the product\n    assign P = acc;\n\nendmodule\n\nmodule add_shift(X, Y, acc);\n    input [7:0] X;\n    input [7:0] Y;\n    output reg [15:0] acc;\n\n    always @(*) begin\n        if (Y[0])\n            acc = acc + (X << 0);\n        if (Y[1])\n            acc = acc + (X << 1);\n        if (Y[2])\n            acc = acc + (X << 2);\n        if (Y[3])\n            acc = acc + (X << 3);\n        if (Y[4])\n            acc = acc + (X << 4);\n        if (Y[5])\n            acc = acc + (X << 5);\n        if (Y[6])\n            acc = acc + (X << 6);\n        if (Y[7])\n            acc = acc + (X << 7);\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    // Instantiate the frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit full adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Cin,\n    output Sum,\n    output Carry_out\n);\n\n    wire Cout;\n\n    assign Sum = X ^ Y ^ Cin;\n    assign Cout = (X & Y) | (Cin & (X ^ Y));\n    assign Carry_out = Cout;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                CLK_out <= ~CLK_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                CLK_out <= ~CLK_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Instantiate submodules\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for calculating negative value\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for divider control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient <= 0;\n        remainder <= 0;\n        res_valid <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            counter <= 0;\n            shift_reg <= {8'b0, dividend};\n            quotient <= 0;\n            remainder <= 0;\n            res_valid <= 1;\n        end else if (res_ready) begin\n            res_valid <= 0;\n        end else begin\n            if (counter < 8) begin\n                shift_reg <= {shift_reg[14:0], 1'b0};\n                counter <= counter + 1;\n            end else begin\n                if (shift_reg[15:8] >= divisor) begin\n                    shift_reg <= shift_reg - {1'b0, divisor};\n                    quotient <= quotient + 1;\n                end\n                remainder <= shift_reg[7:0];\n                counter <= 0;\n            end\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= 0;\n        end else begin\n            if (res_valid) begin\n                result <= {remainder, quotient};\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry;\n\n    // 8-bit addition\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift and AND operations\n    assign p1_0 = X & Y;\n    assign p1_1 = X >> 1 & Y;\n    assign p1_2 = X >> 2 & Y;\n    assign p1_3 = X >> 3 & Y;\n\n    assign p2_0 = X & Y >> 1;\n    assign p2_1 = X >> 1 & Y >> 1;\n    assign p2_2 = X >> 2 & Y >> 2;\n    assign p2_3 = X >> 3 & Y >> 3;\n\n    assign p3_0 = X & Y >> 2;\n    assign p3_1 = X >> 1 & Y >> 2;\n    assign p3_2 = X >> 2 & Y >> 3;\n    assign p3_3 = X >> 3 & Y >> 3;\n\n    // Adders\n    adder_8bit add1(.a(p1_0), .b(p1_1), .c(p1_2), .d(p1_3), .sum(p1));\n    adder_8bit add2(.a(p2_0), .b(p2_1), .c(p2_2), .d(p2_3), .sum(p2));\n    adder_8bit add3(.a(p3_0), .b(p3_1), .c(p3_2), .d(p3_3), .sum(p3));\n\n    // Final sum\n    assign P = p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, d, sum);\n    input [3:0] a, b, c, d;\n    output [7:0] sum;\n    wire [7:0] s1, s2, s3;\n\n    // Full adder\n    full_adder fa1(.a(a[0]), .b(b[0]), .c(c[0]), .sum(s1[0]), .carry(s1[1]));\n    full_adder fa2(.a(a[1]), .b(b[1]), .c(c[1]), .sum(s1[2]), .carry(s1[3]));\n    full_adder fa3(.a(a[2]), .b(b[2]), .c(c[2]), .sum(s1[4]), .carry(s1[5]));\n    full_adder fa4(.a(a[3]), .b(b[3]), .c(c[3]), .sum(s1[6]), .carry(s1[7]));\n\n    // Carry chain\n    full_adder fa5(.a(s1[1]), .b(s1[3]), .c(s1[5]), .sum(s2[0]), .carry(s2[1]));\n    full_adder fa6(.a(s1[2]), .b(s1[4]), .c(s1[6]), .sum(s2[2]), .carry(s2[3]));\n    full_adder fa7(.a(s1[5]), .b(s1[7]), .c(1'b0), .sum(s2[4]), .carry(s2[5]));\n\n    // Final sum\n    full_adder fa8(.a(s2[0]), .b(s2[2]), .c(s2[4]), .sum(s3[0]), .carry(s3[1]));\n    full_adder fa9(.a(s2[1]), .b(s2[3]), .c(s2[5]), .sum(s3[2]), .carry(s3[3]));\n    full_adder fa10(.a(s2[4]), .b(s2[6]), .c(1'b0), .sum(s3[4]), .carry(s3[5]));\n\n    // Final carry\n    full_adder fa11(.a(s3[1]), .b(s3[3]), .c(1'b0), .sum(s3[6]), .carry(s3[7]));\n\n    assign sum = {s3[6:0], s3[7]};\nendmodule\n\nmodule full_adder(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n    assign {carry, sum} = a + b + c;\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry wire for each submodule\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3]; // Output carry from the highest submodule\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    // 8-bit adder logic\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50, clk_10, clk_1;\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50)\n    );\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10)\n    );\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 4) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 49) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry;\n\n    // 8-bit addition with carry\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\n\n// Submodule instances\nabs_value abs_dividend (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control ctrl (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .ready(res_ready),\n    .result_valid(res_valid),\n    .quotient(quotient)\n);\n\nresult_management res_mgmt (\n    .clk(clk),\n    .rst(rst),\n    .ready(res_ready),\n    .result_valid(res_valid),\n    .quotient(quotient),\n    .abs_dividend(abs_dividend),\n    .neg_divisor(neg_divisor),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for calculating negative divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for managing division control\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire ready,\n    output reg result_valid,\n    output reg [15:0] quotient\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        result_valid <= 0;\n        quotient <= 0;\n    end else begin\n        if (opn_valid && !result_valid) begin\n            counter <= 4;\n            shift_reg <= 0;\n            result_valid <= 1;\n        end else if (ready && result_valid) begin\n            counter <= counter - 1;\n            shift_reg <= {shift_reg[6:0], 1'b0};\n            if (counter == 0) begin\n                result_valid <= 0;\n            end\n        end\n    end\nend\n\nendmodule\n\n// Submodule for managing result validity and calculation\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire ready,\n    input wire result_valid,\n    input wire [15:0] quotient,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (ready && result_valid) begin\n            result <= {quotient[7:0], abs_dividend - (neg_divisor << quotient[3:0])};\n        end\n    end\nend\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products;\n\n    // Partial products\n    wire [3:0] pp0, pp1, pp2, pp3;\n    assign pp0 = X[0] & Y;\n    assign pp1 = X[1] & Y;\n    assign pp2 = X[2] & Y;\n    assign pp3 = X[3] & Y;\n\n    // Shift and add\n    wire [7:0] p0, p1, p2, p3;\n    assign p0 = {pp0, 1'b0};\n    assign p1 = {pp1, 1'b0};\n    assign p2 = {pp2, 1'b0};\n    assign p3 = {pp3, 1'b0};\n\n    // Full adder for each partial product\n    adder_8bit add1(.a(p0), .b(p1), .c_in(1'b0), .sum(P[0]), .c_out(P[1]));\n    adder_8bit add2(.a(p2), .b(p3), .c_in(P[1]), .sum(P[2]), .c_out(P[3]));\n    adder_8bit add3(.a(p0), .b(p2), .c_in(P[3]), .sum(P[4]), .c_out(P[5]));\n    adder_8bit add4(.a(p1), .b(p3), .c_in(P[5]), .sum(P[6]), .c_out(P[7]));\n\nendmodule\n\nmodule adder_8bit(a, b, c_in, sum, c_out);\n    input [7:0] a, b;\n    input c_in;\n    output [7:0] sum;\n    output c_out;\n\n    wire c_out_temp;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .c_in(c_in), .sum(sum[0]), .c_out(c_out_temp));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c_in(c_out_temp), .sum(sum[1]), .c_out(c_out_temp));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c_in(c_out_temp), .sum(sum[2]), .c_out(c_out_temp));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c_in(c_out_temp), .sum(sum[3]), .c_out(c_out_temp));\n    full_adder fa4(.a(a[4]), .b(b[4]), .c_in(c_out_temp), .sum(sum[4]), .c_out(c_out_temp));\n    full_adder fa5(.a(a[5]), .b(b[5]), .c_in(c_out_temp), .sum(sum[5]), .c_out(c_out_temp));\n    full_adder fa6(.a(a[6]), .b(b[6]), .c_in(c_out_temp), .sum(sum[6]), .c_out(c_out_temp));\n    full_adder fa7(.a(a[7]), .b(b[7]), .c_in(c_out_temp), .sum(sum[7]), .c_out(c_out));\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n\n    wire c_out_temp;\n\n    xor xor0(.a(a), .b(b), .out(sum));\n    and and0(.a(sum), .b(c_in), .out(c_out_temp));\n    xor xor1(.a(a), .b(b), .out(c_out));\n    and and1(.a(sum), .b(c_in), .out(c_out_temp));\n    xor xor2(.a(a), .b(b), .out(c_out));\n    and and2(.a(sum), .b(c_in), .out(c_out_temp));\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry chain\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3]; // Output carry from the most significant bit\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    // Perform addition\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    assign clk_average[0] = counter_out[0];\n    assign clk_average[1] = counter_out[1];\n    assign clk_average[2] = counter_out[2];\n    assign clk_average[3] = counter_out[3];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = counter_out[0];\n    assign clk_adjusted[1] = counter_out[1];\n    assign clk_adjusted[2] = counter_out[2];\n    assign clk_adjusted[3] = counter_out[3];\n\n    // Output clock signal\n    assign clk_div = clk_adjusted[0] | clk_adjusted[1] | clk_adjusted[2] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_generator(\n    input [3:0] clk_count,\n    output [3:0] clk_average\n);\n    assign clk_average[0] = clk_count[0];\n    assign clk_average[1] = clk_count[1];\n    assign clk_average[2] = clk_count[2];\n    assign clk_average[3] = clk_count[3];\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk_count,\n    output [3:0] clk_adjusted\n);\n    assign clk_adjusted[0] = clk_count[0];\n    assign clk_adjusted[1] = clk_count[1];\n    assign clk_adjusted[2] = clk_count[2];\n    assign clk_adjusted[3] = clk_count[3];\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate the adder module\n    adder add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_gate and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the output based on the operation selector\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is the carry out of the adder\n    assign carry_out = (op == 2'b00) ? add_carry : 1'b0;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A + B;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n    assign {borrow_out, result} = A - B;\nendmodule\n\n// AND module\nmodule and_gate(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [7:0] quotient;\nwire [7:0] remainder;\nwire [3:0] counter;\nwire [3:0] shift;\nwire [15:0] shifted_quotient;\n\n// Absolute value calculation\nabs_value abs_dividend_module (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\n// Negative divisor calculation\nneg_value neg_divisor_module (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\n// Division control logic\ndivider_control div_ctrl_module (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .shift(shift),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Result management\nresult_management res_mgmt_module (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .counter(counter),\n    .shift(shift),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result),\n    .res_valid(res_valid)\n);\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [3:0] shift,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder\n);\n\nreg [7:0] shifted_divisor;\nreg [7:0] shifted_dividend;\nreg [3:0] counter_limit;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift <= 0;\n        quotient <= 0;\n        remainder <= 0;\n        shifted_divisor <= 0;\n        shifted_dividend <= 0;\n        counter_limit <= 0;\n    end else begin\n        if (opn_valid) begin\n            counter <= 0;\n            shift <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            shifted_divisor <= 0;\n            shifted_dividend <= 0;\n            counter_limit <= 0;\n        end else begin\n            if (counter < counter_limit) begin\n                shifted_divisor <= {divisor[6:0], 1'b0};\n                shifted_dividend <= {dividend[6:0], 1'b0};\n                if (shifted_dividend >= shifted_divisor) begin\n                    shifted_dividend <= shifted_dividend - shifted_divisor;\n                    quotient <= quotient + 1;\n                end\n                shift <= shift + 1;\n                counter <= counter + 1;\n            end else begin\n                remainder <= shifted_dividend;\n                res_valid <= 1;\n            end\n        end\n    end\nend\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [3:0] shift,\n    input wire [7:0] quotient,\n    input wire [7:0] remainder,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        res_valid <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= 0;\n            res_valid <= 0;\n        end else begin\n            if (counter == 0) begin\n                result <= {remainder, quotient};\n                res_valid <= 1;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate the adder\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting the carry/borrow output\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift and AND operations\n    and_4bit and0(X[0], Y, p0_0);\n    and_4bit and1(X[1], Y, p0_1);\n    and_4bit and2(X[2], Y, p0_2);\n    and_4bit and3(X[3], Y, p0_3);\n\n    and_4bit and4(X, Y[0], p1_0);\n    and_4bit and5(X, Y[1], p1_1);\n    and_4bit and6(X, Y[2], p1_2);\n    and_4bit and7(X, Y[3], p1_3);\n\n    and_4bit and8(X[0], Y[0], p2_0);\n    and_4bit and9(X[1], Y[1], p2_1);\n    and_4bit and10(X[2], Y[2], p2_2);\n    and_4bit and11(X[3], Y[3], p2_3);\n\n    and_4bit and12(X[0], Y[0], p3_0);\n    and_4bit and13(X[1], Y[1], p3_1);\n    and_4bit and14(X[2], Y[2], p3_2);\n    and_4bit and15(X[3], Y[3], p3_3);\n\n    // Adder operations\n    adder_8bit adder0(p0_0, p0_1, p0_2, p0_3, p1_0, p1_1, p1_2, p1_3, p2_0, p2_1, p2_2, p2_3, p3_0, p3_1, p3_2, p3_3, p);\n\nendmodule\n\nmodule and_4bit(a, b, p);\n    input a, b;\n    output p;\n    assign p = a & b;\nendmodule\n\nmodule adder_8bit(a0, a1, a2, a3, b0, b1, b2, b3, c0, c1, c2, c3, p);\n    input a0, a1, a2, a3, b0, b1, b2, b3, c0, c1, c2, c3;\n    output p;\n\n    wire c1_0, c1_1, c1_2, c1_3;\n    wire c2_0, c2_1, c2_2, c2_3;\n    wire c3_0, c3_1, c3_2, c3_3;\n\n    full_adder fa0(a0, b0, c0, p, c1_0);\n    full_adder fa1(a1, b1, c1_0, p, c1_1);\n    full_adder fa2(a2, b2, c1_1, p, c1_2);\n    full_adder fa3(a3, b3, c1_2, p, c1_3);\n\n    full_adder fa4(a0, b0, c2_0, p, c2_0);\n    full_adder fa5(a1, b1, c2_0, p, c2_1);\n    full_adder fa6(a2, b2, c2_1, p, c2_2);\n    full_adder fa7(a3, b3, c2_2, p, c2_3);\n\n    full_adder fa8(a0, b0, c3_0, p, c3_0);\n    full_adder fa9(a1, b1, c3_0, p, c3_1);\n    full_adder fa10(a2, b2, c3_1, p, c3_2);\n    full_adder fa11(a3, b3, c3_2, p, c3_3);\nendmodule\n\nmodule full_adder(a, b, c_in, p, c_out);\n    input a, b, c_in;\n    output p, c_out;\n    wire s, c1;\n\n    xor x1(s, a, b);\n    xor x2(p, s, c_in);\n    and a1(c_out, a, b);\n    or o1(c1, c_in, c1);\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the divided clock signals\n    assign clk_div = clk_average[0] | clk_adjusted[0];\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input rst_n,\n    input [3:0] count_out,\n    output reg [3:0] clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average[0] <= count_out[0];\n            clk_average[1] <= count_out[1];\n            clk_average[2] <= count_out[2];\n            clk_average[3] <= count_out[3];\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input rst_n,\n    input [3:0] count_out,\n    output reg [3:0] clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted[0] <= count_out[0];\n            clk_adjusted[1] <= count_out[1];\n            clk_adjusted[2] <= count_out[2];\n            clk_adjusted[3] <= count_out[3];\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit input operand X\n    input [3:0] Y;       // 4-bit input operand Y\n    output [7:0] P;       // 8-bit output representing the product of X and Y\n\n    wire [7:0] pp1, pp2, pp3;\n\n    // Partial products\n    partial_product p1(\n        .x(X),\n        .y(Y),\n        .pp(pp1)\n    );\n\n    partial_product p2(\n        .x(X),\n        .y(Y),\n        .pp(pp2)\n    );\n\n    partial_product p3(\n        .x(X),\n        .y(Y),\n        .pp(pp3)\n    );\n\n    // Shift and add\n    adder_8bit add1(\n        .a(pp1),\n        .b(pp2),\n        .c(0),\n        .sum(P[7:0])\n    );\n\n    adder_8bit add2(\n        .a(pp3),\n        .b(0),\n        .c(P[7]),\n        .sum(P[6:0])\n    );\n\n    adder_8bit add3(\n        .a(0),\n        .b(P[6:0]),\n        .c(P[7]),\n        .sum(P)\n    );\nendmodule\n\nmodule partial_product(x, y, pp);\n    input [3:0] x;\n    input [3:0] y;\n    output [7:0] pp;\n\n    assign pp = x & y;\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a;\n    input [7:0] b;\n    input c;\n    output [7:0] sum;\n\n    wire [8:0] temp_sum;\n\n    assign temp_sum = a + b + c;\n    assign sum = temp_sum[7:0];\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .Cin(1'b0),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .BorrowIn(1'b0),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting the result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting the carry out\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? 1'b0 :\n                       sub_borrow;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B + Cin;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input BorrowIn,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B - BorrowIn;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj_neg;\n    wire clk_adj_pos;\n\n    // Submodule instances\n    counter #(.COUNT_LIMIT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(clk_4)\n    );\n\n    clk_average u_clk_average (\n        .clk_4(clk_4),\n        .clk_3(clk_3),\n        .clk_avg(clk_avg)\n    );\n\n    clk_adjustment #(.MUL2_DIV_CLK(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk_avg(clk_avg),\n        .clk_adj_neg(clk_adj_neg),\n        .clk_adj_pos(clk_adj_pos)\n    );\n\n    // Logic to generate fractional clock\n    assign clk_div = clk_adj_neg | clk_adj_pos;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MUL2_DIV_CLK) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk_4,\n    input clk_3,\n    output reg clk_avg\n);\n    always @(posedge clk_4 or posedge clk_3) begin\n        if (clk_4) begin\n            clk_avg <= 1;\n        end else if (clk_3) begin\n            clk_avg <= 0;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk_avg,\n    input clk_adj_neg,\n    input clk_adj_pos,\n    output reg clk_adj_neg_reg,\n    output reg clk_adj_pos_reg\n);\n    always @(posedge clk_avg) begin\n        clk_adj_neg_reg <= clk_adj_neg;\n        clk_adj_pos_reg <= clk_adj_pos;\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the 4-bit adder for the first bit of Y\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the 4-bit adder for the second bit of Y\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n\n    // Instantiate the 4-bit adder for the third bit of Y\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Instantiate the 4-bit adder for the fourth bit of Y\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the results\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [3:0] p;     // 4-bit output representing the sum of x and y\n\n    wire [3:0] sum;     // Intermediate sum\n\n    // Calculate the sum\n    assign sum = x + y;\n\n    // Assign the output\n    assign p = sum;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate wires and registers\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\nwire [3:0] counter;\nwire [15:0] shift_reg;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_mod_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .counter(counter),\n    .shift_reg(shift_reg)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .result(result),\n    .res_valid(res_valid)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -dividend;\n        end else begin\n            result <= dividend;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= dividend;\n        end else begin\n            result <= -dividend;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [3:0] counter,\n    output reg [15:0] shift_reg\n);\n\nreg [7:0] quotient_reg;\nreg [7:0] remainder_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient_reg <= 0;\n        remainder_reg <= 0;\n    end else begin\n        if (counter == 4'd15) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient_reg <= 0;\n            remainder_reg <= 0;\n        end else begin\n            counter <= counter + 1;\n            shift_reg <= shift_reg << 1;\n            quotient_reg <= quotient_reg << 1;\n            remainder_reg <= remainder_reg << 1;\n            if (shift_reg[15]) begin\n                quotient_reg[0] <= 1;\n                remainder_reg[0] <= dividend[0];\n            end else begin\n                quotient_reg[0] <= 0;\n                remainder_reg[0] <= dividend[0];\n            end\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [15:0] shift_reg,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        res_valid <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= 0;\n            res_valid <= 0;\n        end else begin\n            if (opn_valid) begin\n                if (sign) begin\n                    result <= {shift_reg[15:8], -shift_reg[7:0]};\n                end else begin\n                    result <= {shift_reg[15:8], shift_reg[7:0]};\n                end\n                res_valid <= 1;\n            end else begin\n                res_valid <= 0;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate adders and subtractors\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op[0]),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtraction_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op[1]),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for carry/borrow\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = (op) ? B + A : A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtraction_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = (op) ? B - A : A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output product\n\n    wire [3:0] shifted_x;\n    wire [3:0] shifted_y;\n\n    // Shift X left by 1 bit\n    assign shifted_x[0] = X[0];\n    assign shifted_x[1] = X[0];\n    assign shifted_x[2] = X[0];\n    assign shifted_x[3] = X[0];\n\n    // Shift Y left by 1 bit\n    assign shifted_y[0] = Y[0];\n    assign shifted_y[1] = Y[0];\n    assign shifted_y[2] = Y[0];\n    assign shifted_y[3] = Y[0];\n\n    // Instantiate 4 adder_4bit modules\n    adder_4bit adder_0(.x(X), .y(shifted_y), .sum(P[0]));\n    adder_4bit adder_1(.x(shifted_x), .y(Y), .sum(P[1]));\n    adder_4bit adder_2(.x(X), .y(Y), .sum(P[2]));\n    adder_4bit adder_3(.x(shifted_x), .y(shifted_y), .sum(P[3]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;\n    input [3:0] y;\n    output sum;\n\n    assign sum = x[0] ^ y[0];\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.limit(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_generator #(.limit(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.limit(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR operation for final output\n    assign clk_div = clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule clk_average_generator(\n    input               clk,\n    input               rst_n,\n    input   [3:0]       count_out,\n    output reg  [3:0]   clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_average <= 0;\n        else begin\n            clk_average[0] <= count_out[0];\n            clk_average[1] <= count_out[1];\n            clk_average[2] <= count_out[2];\n            clk_average[3] <= count_out[3];\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input   [3:0]       count_out,\n    output reg  [3:0]   clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_adjusted <= 0;\n        else begin\n            clk_adjusted[0] <= count_out[0];\n            clk_adjusted[1] <= count_out[1];\n            clk_adjusted[2] <= count_out[2];\n            clk_adjusted[3] <= count_out[3];\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    // Instantiate the submodules\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux0_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux1_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(mux2_out)\n    );\n\n    // Output selection\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for a single data path\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel) begin\n            data_out <= d1;\n        end else begin\n            data_out <= d0;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the dividend preparation module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the division operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    assign dividend = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = {16'b0, divisor};\n        quotient = 32'b0;\n        remainder = 32'b0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                quotient[i] = 1'b1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end else begin\n                quotient[i] = 1'b0;\n            end\n\n            shifted_divisor = shifted_divisor >> 1;\n        end\n\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Parameter for odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR operation to generate the divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIVISOR = NUM_DIV - 1; // Parameter for divisor value\n\n    reg [DIVISOR - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIVISOR) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIVISOR = NUM_DIV - 1; // Parameter for divisor value\n\n    reg [DIVISOR - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIVISOR) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(p0), .y(Y[1]), .p(p1));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(p1), .y(Y[2]), .p(p2));\n\n    // Assign the final product\n    assign P = {p2, p1, p0};\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_2bit adder_1(.x(p0), .y(x[1]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_1bit adder_1(.x(p0), .y(x[2]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of X and Y\n\n    assign p = x + (y << 4);\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for a single data path\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the dividend preparation module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the division operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepare dividend\n        divisor = B;           // Prepare divisor\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        quotient = dividend >>> divisor; // Shift and divide\n        remainder = dividend - (quotient * divisor); // Compute remainder\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR operation to generate the divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1;\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1;\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output product\n\n    wire [3:0] shifted_x;\n    wire [3:0] shifted_y;\n\n    // Shift X left by 0, 1, 2, and 3\n    assign shifted_x[0] = X[0];\n    assign shifted_x[1] = X[0] | X[1];\n    assign shifted_x[2] = X[0] | X[1] | X[2];\n    assign shifted_x[3] = X[0] | X[1] | X[2] | X[3];\n\n    // Shift Y left by 0, 1, 2, and 3\n    assign shifted_y[0] = Y[0];\n    assign shifted_y[1] = Y[0] | Y[1];\n    assign shifted_y[2] = Y[0] | Y[1] | Y[2];\n    assign shifted_y[3] = Y[0] | Y[1] | Y[2] | Y[3];\n\n    // Instantiate 4 adder_4bit modules\n    adder_4bit adder_0(.x(shifted_x), .y(shifted_y), .p(P[0]));\n    adder_4bit adder_1(.x(shifted_x), .y(shifted_y), .p(P[1]));\n    adder_4bit adder_2(.x(shifted_x), .y(shifted_y), .p(P[2]));\n    adder_4bit adder_3(.x(shifted_x), .y(shifted_y), .p(P[3]));\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input [3:0] y;      // 4-bit input multiplier\n    output [0:0] p;     // 1-bit output product\n\n    assign p = x[0] & y[0] | x[1] & y[1] | x[2] & y[2] | x[3] & y[3];\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the dividend preparation module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the division operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepare dividend\n        divisor = B; // Prepare divisor\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    always @(*) begin\n        quotient = 0; // Initialize quotient\n        remainder = dividend; // Initialize remainder\n        for (i = 0; i < 16; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = quotient << 1;\n                quotient[0] = 1; // Set the quotient bit\n            end else begin\n                quotient = quotient << 1;\n            end\n            divisor = divisor << 1; // Shift divisor\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 mux0 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d2),\n        .data_out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for path 0\nmodule mux_path0 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 3'b000) begin\n            data_out <= d0;\n        end else begin\n            data_out <= d1;\n        end\n    end\n\nendmodule\n\n// Submodule for path 1\nmodule mux_path1 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 3'b001) begin\n            data_out <= d0;\n        end else begin\n            data_out <= d1;\n        end\n    end\n\nendmodule\n\n// Submodule for path 2\nmodule mux_path2 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 3'b010) begin\n            data_out <= d0;\n        end else begin\n            data_out <= d1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule for counting positive edges\n    wire clk_div1;\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Submodule for counting negative edges\n    wire clk_div2;\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff;\nwire [3:0] and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND\n);\n    assign AND = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR\n);\n    assign OR = A | B;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepare dividend\n        divisor = B; // Prepare divisor\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        // Shift dividend and compare with divisor\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            remainder = remainder - divisor;\n            quotient = quotient + 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND_RESULT\n);\n    assign AND_RESULT = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR_RESULT\n);\n    assign OR_RESULT = A | B;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd number used for division\n\n    // Submodule instances\n    wire clk_div1, clk_div2;\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 mux0 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .data_out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for the first data path\nmodule mux_path0 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: data_out <= d0;\n            3'b001: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule\n\n// Submodule for the second data path\nmodule mux_path1 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: data_out <= d0;\n            3'b001: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule\n\n// Submodule for the third data path\nmodule mux_path2 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: data_out <= d0;\n            3'b001: data_out <= d1;\n            3'b010: data_out <= d2;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wire to hold the divided clock signal\nwire divided_clk;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(divided_clk)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .divided_clk(divided_clk),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter module\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == ((2**4) / 2 - 1)) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input divided_clk,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (divided_clk) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND\n);\n    assign AND = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR\n);\n    assign OR = A | B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Submodule for holding data from input 0\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    // Submodule for holding data from input 1\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    // Submodule for holding data from input 2\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    // Submodule for holding data from input 3\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output selection based on the sel signal\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                  hold3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 10) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 5) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", operand_a, operand_b, sum);\nsubtractor subtractor (\"-\", operand_a, operand_b, diff);\nand_logical and_logical (\"&\", operand_a, operand_b, and_result);\nor_logical or_logical (\"|\", operand_a, operand_b, or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] sum\n);\n    assign sum = operand_a + operand_b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] diff\n);\n    assign diff = operand_a - operand_b;\nendmodule\n\nmodule and_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] and_result\n);\n    assign and_result = operand_a & operand_b;\nendmodule\n\nmodule or_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] or_result\n);\n    assign or_result = operand_a | operand_b;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                 hold3_out;\n\nendmodule\n\n// Submodule for data holding\nmodule data_hold (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (out == in) begin\n            out <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\nparameter NUM_DIV = 4; // Even number for division\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_out <= 0;\n    end else begin\n        if (count_out == (NUM_DIV / 2 - 1)) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nend\n\nassign limit = (count_out == (NUM_DIV / 2 - 1));\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input counter_limit,\n    output reg clk_div\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else begin\n        if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    // Output selection\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                 hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "`define ADD 2'b00\n`define SUBTRACT 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", a, b, sum);\nsubtractor subtractor (\"-\", a, b, diff);\nand_module and_op (\"AND\", a, b, and_result);\nor_module or_op (\"OR\", a, b, or_result);\n\nalways @(*) begin\n    case(op)\n        `ADD: result = sum;\n        `SUBTRACT: result = diff;\n        `AND_OP: result = and_result;\n        `OR_OP: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Counter module\ncounter counter_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Clock divider module\nclk_divider clk_divider_module (\n    .clk_in(clk),\n    .clk_div(clk_div),\n    .counter_limit(counter_limit)\n);\n\nendmodule\n\n// Counter module\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    localparam NUM_DIV = 8;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\n    assign limit = (count_out == NUM_DIV / 2 - 1);\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk_in,\n    output reg clk_div,\n    input counter_limit\n);\n    always @(posedge clk_in) begin\n        if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the outputs\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] shifted_dividend;\n    reg [7:0] shifted_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_remainder_shifted;\n    reg [15:0] temp_quotient_shifted;\n    reg [15:0] temp_quotient_shifted_remainder;\n    reg [15:0] temp_quotient_shifted_remainder_shifted;\n    reg [15:0] temp_quotient_shifted_remainder_shifted_shifted;\n    reg [15:0] temp_quotient_shifted_remainder_shifted_shifted_shifted;\n    reg [15:0] temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted;\n    reg [15:0] temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted;\n    reg [15:0] temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted_shifted;\n\n    // Initialize variables\n    initial begin\n        dividend = A;\n        divisor = B;\n        shifted_dividend = {15'b0, dividend[15]};\n        shifted_divisor = {8'b0, divisor[7]};\n        temp_quotient = 16'b0;\n        temp_remainder = 16'b0;\n        temp_remainder_shifted = 16'b0;\n        temp_quotient_shifted = 16'b0;\n        temp_quotient_shifted_remainder = 16'b0;\n        temp_quotient_shifted_remainder_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted_shifted = 16'b0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        temp_remainder = dividend - divisor;\n        temp_quotient = 16'b0;\n        temp_quotient_shifted = 16'b0;\n        temp_quotient_shifted_remainder = 16'b0;\n        temp_quotient_shifted_remainder_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted = 16'b0;\n        temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted_shifted = 16'b0;\n\n        if (temp_remainder < divisor) begin\n            temp_quotient = 1;\n            temp_remainder_shifted = {15'b0, temp_remainder[15]};\n            temp_quotient_shifted = {15'b0, temp_quotient[15]};\n            temp_quotient_shifted_remainder = {15'b0, temp_quotient_shifted[15]};\n            temp_quotient_shifted_remainder_shifted = {15'b0, temp_quotient_shifted_remainder[15]};\n            temp_quotient_shifted_remainder_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted[15]};\n        end\n\n        while (temp_remainder >= divisor) begin\n            temp_quotient = temp_quotient + 1;\n            temp_remainder = temp_remainder - divisor;\n            temp_remainder_shifted = {15'b0, temp_remainder[15]};\n            temp_quotient_shifted = {15'b0, temp_quotient[15]};\n            temp_quotient_shifted_remainder = {15'b0, temp_quotient_shifted[15]};\n            temp_quotient_shifted_remainder_shifted = {15'b0, temp_quotient_shifted_remainder[15]};\n            temp_quotient_shifted_remainder_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted[15]};\n            temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted_shifted = {15'b0, temp_quotient_shifted_remainder_shifted_shifted_shifted_shifted_shifted[15]};\n        end\n\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case (op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_data;\n    wire [7:0] hold0_prev_data;\n    wire hold0_sel;\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .prev_data_out(hold0_prev_data),\n        .data_out(hold0_data),\n        .sel(hold0_sel)\n    );\n\n    // Submodule for holding data from input 1\n    wire [7:0] hold1_data;\n    wire [7:0] hold1_prev_data;\n    wire hold1_sel;\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .prev_data_out(hold1_prev_data),\n        .data_out(hold1_data),\n        .sel(hold1_sel)\n    );\n\n    // Submodule for holding data from input 2\n    wire [7:0] hold2_data;\n    wire [7:0] hold2_prev_data;\n    wire hold2_sel;\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .prev_data_out(hold2_prev_data),\n        .data_out(hold2_data),\n        .sel(hold2_sel)\n    );\n\n    // Submodule for holding data from input 3\n    wire [7:0] hold3_data;\n    wire [7:0] hold3_prev_data;\n    wire hold3_sel;\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .prev_data_out(hold3_prev_data),\n        .data_out(hold3_data),\n        .sel(hold3_sel)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                  hold3_data;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] prev_data_out,\n    output reg [7:0] data_out,\n    output reg sel\n);\n\n    always @(posedge clk) begin\n        prev_data_out <= data_out;\n        data_out <= (sel) ? data_in : prev_data_out;\n        sel <= (sel) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiating the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\nreg [15:0] temp_dividend;\nreg [7:0] temp_divisor;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\n\n// Initializing variables\ninitial begin\n    temp_dividend = A;\n    temp_divisor = B;\n    temp_quotient = 0;\n    temp_remainder = 0;\nend\n\n// Performing division algorithm\nalways @(*) begin\n    if (temp_dividend >= temp_divisor) begin\n        temp_quotient = temp_dividend / temp_divisor;\n        temp_remainder = temp_dividend % temp_divisor;\n    end else begin\n        temp_quotient = 0;\n        temp_remainder = temp_dividend;\n    end\nend\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the results to the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [3:0] shift_count;\n\n    // Initialize variables\n    initial begin\n        dividend = A;\n        divisor = B;\n        shift_count = 0;\n        quotient = 0;\n        remainder = 0;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (shift_count < 16) begin\n            // Shift dividend\n            dividend = {dividend[14:0], 1'b0};\n            shift_count = shift_count + 1;\n        end else begin\n            // Compare divisor with shifted dividend\n            if (dividend >= divisor) begin\n                // Subtract divisor from shifted dividend\n                dividend = dividend - divisor;\n                // Add 1 to quotient\n                temp_quotient = temp_quotient + 1;\n            end\n            // Shift dividend\n            dividend = {dividend[14:0], 1'b0};\n            shift_count = shift_count + 1;\n        end\n    end\n\n    // Update quotient and remainder\n    always @(*) begin\n        temp_remainder = dividend;\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b; // Addition\n            2'b01: result = data_a - data_b; // Subtraction\n            2'b10: result = data_a & data_b; // AND\n            2'b11: result = data_a | data_b; // OR\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .result(temp_quotient),\n        .odd(temp_remainder)\n    );\n\n    // Assign the results to the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_remainder;\n\n    // Initialize the temporary variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            result = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n            temp_dividend = temp_remainder << 1;\n        end else begin\n            result = 0;\n            temp_remainder = temp_dividend;\n            temp_dividend = 0;\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b; // Addition\n            2'b01: result = data_a - data_b; // Subtraction\n            2'b10: result = data_a & data_b; // AND\n            2'b11: result = data_a | data_b; // OR\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output zero\n);\n    assign zero = (result == 4'b0000);\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire carry;          // Carry output from the full adder\n\n    // 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Subtraction operation\n    assign {carry, sum} = A + B_comp;\n\n    // Outputs\n    assign D = sum;\n    assign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, carry, sum);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input carry;         // Carry input from the previous bit\n    output [7:0] sum;    // 8-bit output representing the sum of A and B\n    output carry_out;    // Carry output indicating if a carry was generated during the addition\n\n    wire [7:0] sum_temp; // Temporary sum output\n\n    // Full adder for each bit\n    full_adder fa0(.A(A[0]), .B(B[0]), .Cin(carry), .Sum(sum_temp[0]), .Cout(carry_out));\n    full_adder fa1(.A(A[1]), .B(B[1]), .Cin(carry_out), .Sum(sum_temp[1]), .Cout(carry_out));\n    full_adder fa2(.A(A[2]), .B(B[2]), .Cin(carry_out), .Sum(sum_temp[2]), .Cout(carry_out));\n    full_adder fa3(.A(A[3]), .B(B[3]), .Cin(carry_out), .Sum(sum_temp[3]), .Cout(carry_out));\n    full_adder fa4(.A(A[4]), .B(B[4]), .Cin(carry_out), .Sum(sum_temp[4]), .Cout(carry_out));\n    full_adder fa5(.A(A[5]), .B(B[5]), .Cin(carry_out), .Sum(sum_temp[5]), .Cout(carry_out));\n    full_adder fa6(.A(A[6]), .B(B[6]), .Cin(carry_out), .Sum(sum_temp[6]), .Cout(carry_out));\n    full_adder fa7(.A(A[7]), .B(B[7]), .Cin(carry_out), .Sum(sum_temp[7]), .Cout(carry_out));\n\n    // Output sum\n    assign sum = sum_temp;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;             // Input A\n    input B;             // Input B\n    input Cin;           // Carry input\n    output Sum;          // Sum output\n    output Cout;         // Carry output\n\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_temp;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_temp)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_temp),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b; // Addition\n            2'b01: result = data_a - data_b; // Subtraction\n            2'b10: result = data_a & data_b; // AND\n            2'b11: result = data_a | data_b; // OR\n            default: result = 4'b0000; // Default case\n        endcase\n    end\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        if(result == 4'b0000)\n            zero = 1'b1;\n        else\n            zero = 1'b0;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl duty_ctrl_inst (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen_inst (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire carry;          // Carry output from the full adder\n\n    // 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    full_adder adder_inst (.a(A[0]), .b(B_comp[0]), .c_in(0), .sum(sum[0]), .c_out(carry));\n    full_adder adder_inst (.a(A[1]), .b(B_comp[1]), .c_in(carry), .sum(sum[1]), .c_out(carry));\n    full_adder adder_inst (.a(A[2]), .b(B_comp[2]), .c_in(carry), .sum(sum[2]), .c_out(carry));\n    full_adder adder_inst (.a(A[3]), .b(B_comp[3]), .c_in(carry), .sum(sum[3]), .c_out(carry));\n    full_adder adder_inst (.a(A[4]), .b(B_comp[4]), .c_in(carry), .sum(sum[4]), .c_out(carry));\n    full_adder adder_inst (.a(A[5]), .b(B_comp[5]), .c_in(carry), .sum(sum[5]), .c_out(carry));\n    full_adder adder_inst (.a(A[6]), .b(B_comp[6]), .c_in(carry), .sum(sum[6]), .c_out(carry));\n    full_adder adder_inst (.a(A[7]), .b(B_comp[7]), .c_in(carry), .sum(sum[7]), .c_out(B_out));\n\n    // Assign the sum to the output\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;    // Inputs\n    output sum, c_out;   // Outputs\n\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | (a & c_in) | (b & c_in);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .result(add_result),\n    .valid(valid)\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result),\n    .valid(valid)\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result),\n    .valid(valid)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a + b;\n    assign valid = 1;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a - b;\n    assign valid = 1;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a * b;\n    assign valid = 1;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a / b;\n    assign valid = (b != 0);\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire carry_out;      // Carry out from the full adder\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    full_adder adder_inst[7:0];\n    assign sum = {carry_out, adder_inst[7].sum};\n    assign B_out = adder_inst[7].carry_out;\n\n    // Generate the sum\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin: bit_adder\n            assign adder_inst[i].sum = A[i] ^ B_comp[i] ^ carry_out;\n            assign adder_inst[i].carry_out = (A[i] & B_comp[i]) | (A[i] & carry_out) | (B_comp[i] & carry_out);\n        end\n    endgenerate\n\n    // Assign the difference to output\n    assign D = sum[7:0];\n\nendmodule\n\nmodule full_adder(a, b, ci, sum, carry_out);\n    input a, b, ci;\n    output sum, carry_out;\n    assign sum = a ^ b ^ ci;\n    assign carry_out = (a & b) | (b & ci) | (a & ci);\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire carry;           // Carry output from the full adder\n\n    // Calculate the 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Perform subtraction using full adder\n    full_adder adder_inst (.a(A), .b(B_comp), .carry_in(0), .sum(sum), .carry_out(carry));\n\n    // Assign the output\n    assign D = sum;\n    assign B_out = carry;\n\nendmodule\n\nmodule full_adder(a, b, carry_in, sum, carry_out);\n    input a, b, carry_in;\n    output sum, carry_out;\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (carry_in & (a ^ b));\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate the arithmetic modules\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each section of the inputs\n    comp8 comp8_inst1 (.a(a_lo), .b(b_lo), .equal(equal_lo));\n    comp8 comp8_inst2 (.a(a_hi), .b(b_hi), .equal(equal_hi));\n    comp8 comp8_inst3 (.a(a[15:8]), .b(b[15:8]), .equal(equal_lo));\n    comp8 comp8_inst4 (.a(a[23:16]), .b(b[23:16]), .equal(equal_hi));\n\n    // Combine results from each section\n    assign equal = equal_lo & equal_hi;\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal0, equal1, equal2, equal3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal3)\n    );\n\n    assign equal = equal0 & equal1 & equal2 & equal3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module (\n    .a(data_a),\n    .b(data_b),\n    .sum(add_result),\n    .carry_out(valid)\n);\n\nsubtractor sub_module (\n    .a(data_a),\n    .b(data_b),\n    .diff(sub_result),\n    .carry_out(valid)\n);\n\nmultiplier mul_module (\n    .a(data_a),\n    .b(data_b),\n    .product(mul_result)\n);\n\ndivider div_module (\n    .a(data_a),\n    .b(data_b),\n    .quotient(div_result),\n    .remainder(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= sub_result;\n            `MUL_OP: result <= mul_result;\n            `DIV_OP: result <= div_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] diff,\n    output carry_out\n);\n    assign {carry_out, diff} = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] quotient,\n    output remainder\n);\n    assign {remainder, quotient} = a / b;\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal0, equal1, equal2, equal3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal3)\n    );\n\n    assign equal = equal0 & equal1 & equal2 & equal3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n\n    wire [7:0] equal_8;\n\n    // Instantiate 8-bit comparators\n    comparator_8 comp8_inst1 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_8[0])\n    );\n\n    comparator_8 comp8_inst2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_8[1])\n    );\n\n    comparator_8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_8[2])\n    );\n\n    comparator_8 comp8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_8[3])\n    );\n\n    // Combine results\n    assign equal = equal_8[0] & equal_8[1] & equal_8[2] & equal_8[3];\n\nendmodule\n\nmodule comparator_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n\n    assign equal = (a == b);\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate arithmetic modules\n    adder add_module(.a(data_a), .b(data_b), .result(add_result));\n    subtractor sub_module(.a(data_a), .b(data_b), .result(sub_result));\n    multiplier mul_module(.a(data_a), .b(data_b), .result(mul_result));\n    divider div_module(.a(data_a), .b(data_b), .result(div_result), .valid(valid));\n\n    // Select operation based on opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            valid = 0;\n            result = 0;\n        end else begin\n            valid = 1;\n            result = a / b;\n        end\n    end\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(add_carry),\n        .zero(add_zero),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    adddu adddu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(add_carry),\n        .zero(add_zero),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    subdu subdu_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .carry(and_carry),\n        .zero(and_zero),\n        .negative(and_negative)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_result),\n        .carry(or_carry),\n        .zero(or_zero),\n        .negative(or_negative)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_result),\n        .carry(xor_carry),\n        .zero(xor_zero),\n        .negative(xor_negative)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_result),\n        .carry(nor_carry),\n        .zero(nor_zero),\n        .negative(nor_negative)\n    );\n\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .carry(slt_carry),\n        .zero(slt_zero),\n        .negative(slt_negative)\n    );\n\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_result),\n        .carry(sltu_carry),\n        .zero(sltu_zero),\n        .negative(sltu_negative)\n    );\n\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .carry(sll_carry),\n        .zero(sll_zero),\n        .negative(sll_negative)\n    );\n\n    srl srl_inst(\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .carry(srl_carry),\n        .zero(srl_zero),\n        .negative(srl_negative)\n    );\n\n    sra sra_inst(\n        .a(a),\n        .b(b),\n        .r(sra_result),\n        .carry(sra_carry),\n        .zero(sra_zero),\n        .negative(sra_negative)\n    );\n\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(sllv_result),\n        .carry(sllv_carry),\n        .zero(sllv_zero),\n        .negative(sllv_negative)\n    );\n\n    srlv srlv_inst(\n        .a(a),\n        .b(b),\n        .r(srlv_result),\n        .carry(srlv_carry),\n        .zero(srlv_zero),\n        .negative(srlv_negative)\n    );\n\n    srav srav_inst(\n        .a(a),\n        .b(b),\n        .r(srav_result),\n        .carry(srav_carry),\n        .zero(srav_zero),\n        .negative(srav_negative)\n    );\n\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .carry(lui_carry),\n        .zero(lui_zero),\n        .negative(lui_negative)\n    );\n\n    // Select operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 0;\n\n    // Compute flags\n    assign zero = (r == 0) ? 1 : 0;\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? add_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? sub_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 0;\n\n    assign negative = (r[31]) ? 1 : 0;\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? add_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? sub_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 0;\n\n    assign flag = (aluc == 6'b101010) ? slt_flag :\n                  (aluc == 6'b101011) ? sltu_flag : 0;\n\n    // Submodules\n    submodule add add_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative,\n        output overflow\n    );\n\n        assign r = a + b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n        assign overflow = (a[31] == b[31] && r[31] != a[31]) ? 1 : 0;\n    endmodule\n\n    submodule adddu adddu_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative,\n        output overflow\n    );\n\n        assign r = a + b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n        assign overflow = (a[31] == b[31] && r[31] != a[31]) ? 1 : 0;\n    endmodule\n\n    submodule sub sub_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative,\n        output overflow\n    );\n\n        assign r = a - b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n        assign overflow = (a[31] != b[31] && r[31] == a[31]) ? 1 : 0;\n    endmodule\n\n    submodule subdu subdu_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative,\n        output overflow\n    );\n\n        assign r = a - b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n        assign overflow = (a[31] != b[31] && r[31] == a[31]) ? 1 : 0;\n    endmodule\n\n    submodule and and_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a & b;\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule or or_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a | b;\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule xor xor_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a ^ b;\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule nor nor_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = ~(a | b);\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule slt slt_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = (a < b) ? 1 : 0;\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule sltu sltu_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = (a < b) ? 1 : 0;\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule sll sll_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a << b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule srl srl_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a >> b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule sra sra_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = $signed(a) >>> b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule sllv sllv_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a << b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule srlv srlv_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = a >> b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule srav srav_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = $signed(a) >>> b;\n        assign carry = (r[32]) ? 1 : 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\n    submodule lui lui_inst(\n        input [31:0] a,\n        input [31:0] b,\n        output [31:0] r,\n        output carry,\n        output zero,\n        output negative\n    );\n\n        assign r = {b[30:20], 12'b0};\n        assign carry = 0;\n        assign zero = (r == 0) ? 1 : 0;\n        assign negative = (r[31]) ? 1 : 0;\n    endmodule\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_diff; // 16-bit difference output from submodule S1\n    wire [15:0] S2_diff; // 16-bit difference output from submodule S2\n    wire [15:0] S1_borrow; // 16-bit borrow output from submodule S1\n    wire [15:0] S2_borrow; // 16-bit borrow output from submodule S2\n\n    // Instantiate 16-bit subtractor for A[15:0] and B[15:0]\n    sub_16bit S1(.A(A[15:0]), .B(B[15:0]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Instantiate 16-bit subtractor for A[31:16] and B[31:16]\n    sub_16bit S2(.A(A[31:16]), .B(B[31:16]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Combine the differences and borrow outputs\n    assign Diff = {S2_diff, S1_diff};\n    assign B_out = S2_borrow[15] | S1_borrow[15]; // Combine borrow outputs\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output Borrow_out;     // Borrow-out output\n\n    wire [7:0] S1_diff;   // 8-bit difference output from submodule S1\n    wire [7:0] S2_diff;   // 8-bit difference output from submodule S2\n    wire [7:0] S1_borrow; // 8-bit borrow output from submodule S1\n    wire [7:0] S2_borrow; // 8-bit borrow output from submodule S2\n\n    // Instantiate 8-bit subtractor for A[7:0] and B[7:0]\n    sub_8bit S1(.A(A[7:0]), .B(B[7:0]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Instantiate 8-bit subtractor for A[15:8] and B[15:8]\n    sub_8bit S2(.A(A[15:8]), .B(B[15:8]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Combine the differences and borrow outputs\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = S2_borrow[7] | S1_borrow[7]; // Combine borrow outputs\nendmodule\n\nmodule sub_8bit(A, B, Diff, Borrow_out);\n    input [7:0] A;         // 8-bit input operand A\n    input [7:0] B;         // 8-bit input operand B\n    output [7:0] Diff;     // 8-bit output representing the difference of A and B\n    output Borrow_out;     // Borrow-out output\n\n    wire [3:0] S1_diff;    // 4-bit difference output from submodule S1\n    wire [3:0] S2_diff;    // 4-bit difference output from submodule S2\n    wire [3:0] S1_borrow;  // 4-bit borrow output from submodule S1\n    wire [3:0] S2_borrow;  // 4-bit borrow output from submodule S2\n\n    // Instantiate 4-bit subtractor for A[3:0] and B[3:0]\n    sub_4bit S1(.A(A[3:0]), .B(B[3:0]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Instantiate 4-bit subtractor for A[7:4] and B[7:4]\n    sub_4bit S2(.A(A[7:4]), .B(B[7:4]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Combine the differences and borrow outputs\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = S2_borrow[3] | S1_borrow[3]; // Combine borrow outputs\nendmodule\n\nmodule sub_4bit(A, B, Diff, Borrow_out);\n    input [3:0] A;          // 4-bit input operand A\n    input [3:0] B;          // 4-bit input operand B\n    output [3:0] Diff;      // 4-bit output representing the difference of A and B\n    output Borrow_out;      // Borrow-out output\n\n    wire [1:0] S1_diff;     // 2-bit difference output from submodule S1\n    wire [1:0] S2_diff;     // 2-bit difference output from submodule S2\n    wire [1:0] S1_borrow;   // 2-bit borrow output from submodule S1\n    wire [1:0] S2_borrow;   // 2-bit borrow output from submodule S2\n\n    // Instantiate 2-bit subtractor for A[1:0] and B[1:0]\n    sub_2bit S1(.A(A[1:0]), .B(B[1:0]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Instantiate 2-bit subtractor for A[3:2] and B[3:2]\n    sub_2bit S2(.A(A[3:2]), .B(B[3:2]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Combine the differences and borrow outputs\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = S2_borrow[1] | S1_borrow[1]; // Combine borrow outputs\nendmodule\n\nmodule sub_2bit(A, B, Diff, Borrow_out);\n    input [1:0] A;          // 2-bit input operand A\n    input [1:0] B;          // 2-bit input operand B\n    output [1:0] Diff;      // 2-bit output representing the difference of A and B\n    output Borrow_out;      // Borrow-out output\n\n    wire [0:0] S1_diff;     // 1-bit difference output from submodule S1\n    wire [0:0] S2_diff;     // 1-bit difference output from submodule S2\n    wire [0:0] S1_borrow;   // 1-bit borrow output from submodule S1\n    wire [0:0] S2_borrow;   // 1-bit borrow output from submodule S2\n\n    // Instantiate 1-bit subtractor for A[0] and B[0]\n    sub_1bit S1(.A(A[0]), .B(B[0]), .Diff(S1_diff), .Borrow_out(S1_borrow));\n\n    // Instantiate 1-bit subtractor for A[1] and B[1]\n    sub_1bit S2(.A(A[1]), .B(B[1]), .Diff(S2_diff), .Borrow_out(S2_borrow));\n\n    // Combine the differences and borrow outputs\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow_out = S2_borrow[0] | S1_borrow[0]; // Combine borrow outputs\nendmodule\n\nmodule sub_1bit(A, B, Diff, Borrow_out);\n    input A;                // 1-bit input operand A\n    input B;                // 1-bit input operand B\n    output Diff;            // 1-bit output representing the difference of A and B\n    output Borrow_out;      // Borrow-out output\n\n    assign Diff = A ^ B;    // Difference\n    assign Borrow_out = A & B; // Borrow-out\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output [31:0] B_out;  // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out output\n    wire [15:0] Diff_16;  // 16-bit difference output\n\n    // Instantiate 16-bit subtractors\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .B_out(B_out_16),\n        .Diff(Diff_16)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Assign outputs\n    assign Diff = {Diff_16, B_out_16};\n\nendmodule\n\nmodule sub_16bit(A, B, B_out, Diff);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] B_out;  // 16-bit borrow-out output\n    output [15:0] Diff;   // 16-bit difference output\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out output\n    wire [7:0] Diff_8;    // 8-bit difference output\n\n    // Instantiate 8-bit subtractors\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .B_out(B_out_8),\n        .Diff(Diff_8)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Assign outputs\n    assign Diff = {Diff_8, B_out_8};\n\nendmodule\n\nmodule sub_8bit(A, B, B_out, Diff);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] B_out;  // 8-bit borrow-out output\n    output [7:0] Diff;   // 8-bit difference output\n\n    wire [3:0] B_out_4; // 4-bit borrow-out output\n    wire [3:0] Diff_4;  // 4-bit difference output\n\n    // Instantiate 4-bit subtractors\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .B_out(B_out_4),\n        .Diff(Diff_4)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Assign outputs\n    assign Diff = {Diff_4, B_out_4};\n\nendmodule\n\nmodule sub_4bit(A, B, B_out, Diff);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output [3:0] B_out;  // 4-bit borrow-out output\n    output [3:0] Diff;   // 4-bit difference output\n\n    // Calculate difference and borrow-out\n    assign {B_out, Diff} = A - B;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output [31:0] B_out;  // 32-bit output representing the borrow-out\n\n    wire [15:0] B_out_16; // 16-bit borrow-out\n    wire [15:0] Diff_16;   // 16-bit difference\n\n    // Instantiate 16-bit subtractor for the high 16 bits\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .B_out(B_out_16),\n        .Diff(Diff_16)\n    );\n\n    // Instantiate 16-bit subtractor for the low 16 bits\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine the borrow-outs\n    assign B_out = {B_out_16, B_out};\n\nendmodule\n\nmodule sub_16bit(A, B, B_out, Diff);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] B_out;  // 16-bit borrow-out\n    output [15:0] Diff;   // 16-bit difference\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out\n    wire [7:0] Diff_8;    // 8-bit difference\n\n    // Instantiate 8-bit subtractor for the high 8 bits\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .B_out(B_out_8),\n        .Diff(Diff_8)\n    );\n\n    // Instantiate 8-bit subtractor for the low 8 bits\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine the borrow-outs\n    assign B_out = {B_out_8, B_out};\n    assign Diff = {Diff_8, Diff};\n\nendmodule\n\nmodule sub_8bit(A, B, B_out, Diff);\n    input [7:0] A;        // 8-bit input operand A\n    input [7:0] B;        // 8-bit input operand B\n    output [7:0] B_out;   // 8-bit borrow-out\n    output [7:0] Diff;    // 8-bit difference\n\n    wire [3:0] B_out_4;   // 4-bit borrow-out\n    wire [3:0] Diff_4;    // 4-bit difference\n\n    // Instantiate 4-bit subtractor for the high 4 bits\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .B_out(B_out_4),\n        .Diff(Diff_4)\n    );\n\n    // Instantiate 4-bit subtractor for the low 4 bits\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine the borrow-outs\n    assign B_out = {B_out_4, B_out};\n    assign Diff = {Diff_4, Diff};\n\nendmodule\n\nmodule sub_4bit(A, B, B_out, Diff);\n    input [3:0] A;        // 4-bit input operand A\n    input [3:0] B;        // 4-bit input operand B\n    output [3:0] B_out;   // 4-bit borrow-out\n    output [3:0] Diff;    // 4-bit difference\n\n    wire [1:0] B_out_2;   // 2-bit borrow-out\n    wire [1:0] Diff_2;    // 2-bit difference\n\n    // Instantiate 2-bit subtractor for the high 2 bits\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .B_out(B_out_2),\n        .Diff(Diff_2)\n    );\n\n    // Instantiate 2-bit subtractor for the low 2 bits\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine the borrow-outs\n    assign B_out = {B_out_2, B_out};\n    assign Diff = {Diff_2, Diff};\n\nendmodule\n\nmodule sub_2bit(A, B, B_out, Diff);\n    input [1:0] A;        // 2-bit input operand A\n    input [1:0] B;        // 2-bit input operand B\n    output [1:0] B_out;   // 2-bit borrow-out\n    output [1:0] Diff;    // 2-bit difference\n\n    wire [0:0] B_out_1;   // 1-bit borrow-out\n    wire [0:0] Diff_1;    // 1-bit difference\n\n    // Instantiate 1-bit subtractor for the high bit\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .B_out(B_out_1),\n        .Diff(Diff_1)\n    );\n\n    // Instantiate 1-bit subtractor for the low bit\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine the borrow-outs\n    assign B_out = {B_out_1, B_out};\n    assign Diff = {Diff_1, Diff};\n\nendmodule\n\nmodule sub_1bit(A, B, B_out, Diff);\n    input A;              // 1-bit input operand A\n    input B;              // 1-bit input operand B\n    output B_out;         // 1-bit borrow-out\n    output Diff;          // 1-bit difference\n\n    assign B_out = A - B; // Subtraction\n    assign Diff = A - B;  // Subtraction\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;  // 16-bit difference from first subtractor\n\n    // Instantiate 16-bit subtractor for A[15:0] and B[15:0]\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    // Instantiate 16-bit subtractor for A[31:16] and B[31:16]\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[31:16]),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out for entire 32-bit subtractor\n    assign B_out = B_out_16;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;  // 16-bit difference from first subtractor\n\n    // Instantiate 16-bit subtractor for A[15:0] and B[15:0]\n    sub_16bit_core S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out for entire 16-bit subtractor\n    assign B_out = B_out_16;\n\nendmodule\n\nmodule sub_16bit_core(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;  // 16-bit difference from first subtractor\n\n    // Perform subtraction\n    assign Diff_16 = A - B;\n\n    // Calculate borrow-out\n    assign B_out_16 = (A[15] & ~B[15]) | (Diff_16[15] & ~B[15]);\n\n    // Assign difference\n    assign Diff = Diff_16;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero), .negative(and_negative), .overflow(and_overflow), .flag(and_flag));\n    or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero), .negative(or_negative), .overflow(or_overflow), .flag(or_flag));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero), .negative(xor_negative), .overflow(xor_overflow), .flag(xor_flag));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero), .negative(nor_negative), .overflow(nor_overflow), .flag(nor_flag));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero), .negative(slt_negative), .overflow(slt_overflow), .flag(slt_flag));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero), .negative(sltu_negative), .overflow(sltu_overflow), .flag(sltu_flag));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero), .negative(sll_negative), .overflow(sll_overflow), .flag(sll_flag));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero), .negative(srl_negative), .overflow(srl_overflow), .flag(srl_flag));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero), .negative(sra_negative), .overflow(sra_overflow), .flag(sra_flag));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .zero(sllv_zero), .negative(sllv_negative), .overflow(sllv_overflow), .flag(sllv_flag));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .zero(srlv_zero), .negative(srlv_negative), .overflow(srlv_overflow), .flag(srlv_flag));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero), .negative(srav_negative), .overflow(srav_overflow), .flag(srav_flag));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .zero(lui_zero), .negative(lui_negative), .overflow(lui_overflow), .flag(lui_flag));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 0);\n    assign carry = (add_carry || sub_carry);\n    assign negative = (r[31]);\n    assign overflow = (add_overflow || sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_flag : (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] != b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] != b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = {b[3:0], 28'b0} | a;\n    assign zero = (r == 0);\n    assign negative = (r[31]);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8[7];\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A, B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A, B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B[7:0]};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A, B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_32, B_32_borrow;\n    wire [15:0] B_16, B_16_borrow;\n    wire [7:0] B_8, B_8_borrow;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_32_borrow), .D(B_32));\n    sub32 sub1(.A(A[31:0]), .B(B[31:0]), .B_out(B_32), .D(B_32));\n\n    sub16 sub2(.A(B_32), .B(B[15:0]), .B_out(B_16_borrow), .D(B_16));\n    sub16 sub3(.A(B_32), .B(B[15:0]), .B_out(B_16), .D(B_16));\n\n    sub8 sub4(.A(B_16), .B(B[7:0]), .B_out(B_8_borrow), .D(B_8));\n    sub8 sub5(.A(B_16), .B(B[7:0]), .B_out(B_8), .D(B_8));\n\n    assign D = {B_8, B_16, B_32};\n    assign B_out = B_8_borrow;\nendmodule\n\nmodule sub32(A, B, B_out, D);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_16, B_16_borrow;\n    wire [7:0] B_8, B_8_borrow;\n\n    sub16 sub2(.A(B), .B(B[15:0]), .B_out(B_16_borrow), .D(B_16));\n    sub16 sub3(.A(B), .B(B[15:0]), .B_out(B_16), .D(B_16));\n\n    sub8 sub4(.A(B_16), .B(B[7:0]), .B_out(B_8_borrow), .D(B_8));\n    sub8 sub5(.A(B_16), .B(B[7:0]), .B_out(B_8), .D(B_8));\n\n    assign D = {B_8, B_16};\n    assign B_out = B_8_borrow;\nendmodule\n\nmodule sub16(A, B, B_out, D);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_8, B_8_borrow;\n\n    sub8 sub2(.A(B), .B(B[7:0]), .B_out(B_8_borrow), .D(B_8));\n    sub8 sub3(.A(B), .B(B[7:0]), .B_out(B_8), .D(B_8));\n\n    assign D = {B_8, B_8_borrow};\n    assign B_out = B_8_borrow;\nendmodule\n\nmodule sub8(A, B, B_out, D);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(B_out_32), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A, B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A, B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_8};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A, B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub_32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub_16 sub1_1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub_16 sub1_2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_16)\n    );\n\n    sub_8 sub2_1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_2(\n        .A(A[31:8]),\n        .B(B[31:8]),\n        .D(D[31:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_3(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_4(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_32, B_out_16, B_out_8};\nendmodule\n\nmodule sub_32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub_16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub_16 sub1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_16)\n    );\n\n    sub_8 sub2_1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_2(\n        .A(A[31:8]),\n        .B(B[31:8]),\n        .D(D[31:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_3(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_4(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_16, B_out_8};\nendmodule\n\nmodule sub_16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub_8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub_8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] D;     // 16-bit difference output\n    output B_out;        // Borrow-out output\n\n    wire [3:0] borrow;   // Borrow wire\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .D(D[16:1]),\n        .borrow(borrow)\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .D(D[12:1]),\n        .borrow(borrow)\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .D(D[8:1]),\n        .borrow(borrow)\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .borrow(borrow)\n    );\n\n    // Output borrow-out\n    assign B_out = borrow[3];\nendmodule\n\nmodule sub4(A, B, D, borrow);\n    input [4:1] A;      // 4-bit input A\n    input [4:1] B;      // 4-bit input B\n    output [4:1] D;     // 4-bit difference output\n    output borrow;      // Borrow output\n\n    wire [2:0] borrow_temp;  // Temporary borrow wire\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .borrow(borrow_temp[0])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .borrow(borrow_temp[1])\n    );\n\n    sub2 sub3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .D(D[1:1]),\n        .borrow(borrow_temp[2])\n    );\n\n    // Output borrow\n    assign borrow = borrow_temp[2];\nendmodule\n\nmodule sub2(A, B, D, borrow);\n    input [2:1] A;      // 2-bit input A\n    input [2:1] B;      // 2-bit input B\n    output [2:1] D;     // 2-bit difference output\n    output borrow;      // Borrow output\n\n    wire [1:0] borrow_temp;  // Temporary borrow wire\n\n    // Instantiate 1-bit full subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .borrow(borrow_temp[0])\n    );\n\n    sub1 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .D(D[1:1]),\n        .borrow(borrow_temp[1])\n    );\n\n    // Output borrow\n    assign borrow = borrow_temp[1];\nendmodule\n\nmodule sub1(A, B, D, borrow);\n    input [1:1] A;      // 1-bit input A\n    input [1:1] B;      // 1-bit input B\n    output [1:1] D;     // 1-bit difference output\n    output borrow;      // Borrow output\n\n    // Instantiate 1-bit full subtractor\n    assign {borrow, D} = A - B;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add_sub add(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow));\n    add_sub addu(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow));\n    and_or andor(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow));\n    and_or oror(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow));\n    and_or xoror(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow));\n    and_or noror(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow));\n    slt_sltu slt(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow));\n    slt_sltu sltu(.a(a), .b(b), .r(sltu_result), .zero(sltu_zero), .carry(sltu_carry), .negative(sltu_negative), .overflow(sltu_overflow));\n    sll_srl sll(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow));\n    sll_srl srl(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow));\n    sll_srl sra(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow));\n    sll_srl sllv(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow));\n    sll_srl srlv(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow));\n    sll_srl srav(.a(a), .b(b), .r(srav_result), .zero(srav_zero), .carry(srav_carry), .negative(srav_negative), .overflow(srav_overflow));\n    lui lui(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select result based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow || sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] : (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule and_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt_sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll_srl(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b[4:0] == 0) ? a : (b[4:0] == 32) ? 32'b0 : (b[4:0] == 1) ? {a[31], a[31:1]} : (b[4:0] == 31) ? {a[30:0], 1'b0} : (b[4:0] == 30) ? {a[29:0], 2'b00} : (b[4:0] == 29) ? {a[28:0], 3'b000} : (b[4:0] == 28) ? {a[27:0], 4'b0000} : (b[4:0] == 27) ? {a[26:0], 5'b00000} : (b[4:0] == 26) ? {a[25:0], 6'b000000} : (b[4:0] == 25) ? {a[24:0], 7'b0000000} : (b[4:0] == 24) ? {a[23:0], 8'b00000000} : (b[4:0] == 23) ? {a[22:0], 9'b000000000} : (b[4:0] == 22) ? {a[21:0], 10'b0000000000} : (b[4:0] == 21) ? {a[20:0], 11'b00000000000} : (b[4:0] == 20) ? {a[19:0], 12'b000000000000} : (b[4:0] == 19) ? {a[18:0], 13'b0000000000000} : (b[4:0] == 18) ? {a[17:0], 14'b00000000000000} : (b[4:0] == 17) ? {a[16:0], 15'b000000000000000} : (b[4:0] == 16) ? {a[15:0], 16'b0000000000000000} : (b[4:0] == 15) ? {a[14:0], 17'b00000000000000000} : (b[4:0] == 14) ? {a[13:0], 18'b000000000000000000} : (b[4:0] == 13) ? {a[12:0], 19'b0000000000000000000} : (b[4:0] == 12) ? {a[11:0], 20'b00000000000000000000} : (b[4:0] == 11) ? {a[10:0], 21'b000000000000000000000} : (b[4:0] == 10) ? {a[9:0], 22'b0000000000000000000000} : (b[4:0] == 9) ? {a[8:0], 23'b00000000000000000000000} : (b[4:0] == 8) ? {a[7:0], 24'b000000000000000000000000} : (b[4:0] == 7) ? {a[6:0], 25'b0000000000000000000000000} : (b[4:0] == 6) ? {a[5:0], 26'b0000000000000000000000000} : (b[4:0] == 5) ? {a[4:0], 27'b00000000000000000000000000} : (b[4:0] == 4) ? {a[3:0], 28'b000000000000000000000000000} : (b[4:0] == 3) ? {a[2:0], 29'b000000000000000000000000000} : (b[4:0] == 2) ? {a[1:0], 30'b0000000000000000000000000000} : (b[4:0] == 1) ? {a[0], 31'b00000000000000000000000000000} : 32'b0;\n    assign zero = (r == 32'b0);\n    assign carry = (b[4:0] == 0) ? 1 : 0;\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[31:12], a};\n    assign zero = (r == 32'b0);\n    assign carry = (b[11:0] == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] D;     // 16-bit output D\n    output B_out;        // Borrow-out output\n\n    wire [4:1] b_out_4;  // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .D(D[16:1]),\n        .B_out(b_out_4)\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .D(D[12:1]),\n        .B_out(b_out_4)\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .D(D[8:1]),\n        .B_out(b_out_4)\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out_4)\n    );\n\n    // Output borrow-out\n    assign B_out = b_out_4[4];\n\nendmodule\n\nmodule sub4(A, B, D, B_out);\n    input [4:1] A;       // 4-bit input A\n    input [4:1] B;       // 4-bit input B\n    output [4:1] D;      // 4-bit output D\n    output B_out;        // Borrow-out output\n\n    wire [2:1] b_out_2;  // 2-bit borrow-out\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out_2)\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out_2)\n    );\n\n    // Output borrow-out\n    assign B_out = b_out_2[2];\n\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [2:1] A;       // 2-bit input A\n    input [2:1] B;       // 2-bit input B\n    output [2:1] D;      // 2-bit output D\n    output B_out;        // Borrow-out output\n\n    wire [1:1] b_out_1;  // 1-bit borrow-out\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out_1)\n    );\n\n    // Output borrow-out\n    assign B_out = b_out_1[1];\n\nendmodule\n\nmodule sub1(A, B, D, B_out);\n    input A;             // 1-bit input A\n    input B;             // 1-bit input B\n    output D;            // 1-bit output D\n    output B_out;        // Borrow-out output\n\n    assign D = A - B;    // Subtraction\n    assign B_out = (A < B); // Borrow-out\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [4:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit submodules\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .D(D[16:1]),\n        .B_out(b_out[4:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .D(D[12:1]),\n        .B_out(b_out[3:1])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .D(D[8:1]),\n        .B_out(b_out[2:1])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out[4];\n\nendmodule\n\nmodule sub4(A, B, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    output [4:1] D;       // 4-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 2-bit submodules\n    sub2 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out[2:1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out[2];\n\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    output [2:1] D;       // 2-bit output D\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out\n\n    // Instantiate 1-bit submodule\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out)\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out;\n\nendmodule\n\nmodule sub1(A, B, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    output [1:1] D;       // 1-bit output D\n    output B_out;         // Borrow-out output\n\n    // Subtract A and B\n    assign D = A - B;\n    assign B_out = (A < B);\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, add_carry, add_negative, add_overflow;\n    wire sub_zero, sub_carry, sub_negative, sub_overflow;\n    wire and_zero, and_carry, and_negative, and_overflow;\n    wire or_zero, or_carry, or_negative, or_overflow;\n    wire xor_zero, xor_carry, xor_negative, xor_overflow;\n    wire nor_zero, nor_carry, nor_negative, nor_overflow;\n    wire slt_zero, slt_carry, slt_negative, slt_overflow;\n    wire sltu_zero, sltu_carry, sltu_negative, sltu_overflow;\n    wire sll_zero, sll_carry, sll_negative, sll_overflow;\n    wire srl_zero, srl_carry, srl_negative, srl_overflow;\n    wire sra_zero, sra_carry, sra_negative, sra_overflow;\n    wire sllv_zero, sllv_carry, sllv_negative, sllv_overflow;\n    wire srlv_zero, srlv_carry, srlv_negative, srlv_overflow;\n    wire srav_zero, srav_carry, srav_negative, srav_overflow;\n    wire lui_zero, lui_carry, lui_negative, lui_overflow;\n\n    // Instantiate submodules\n    add_sub addu(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow));\n    add_sub subu(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow));\n    logic_op andu(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow));\n    logic_op oru(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow));\n    logic_op xoru(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow));\n    logic_op noru(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow));\n    slt_op sltu(.a(a), .b(b), .r(sltu_result), .zero(sltu_zero), .carry(sltu_carry), .negative(sltu_negative), .overflow(sltu_overflow));\n    slt_op slt(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow));\n    shift_op sllv(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow));\n    shift_op srlv(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow));\n    shift_op srav(.a(a), .b(b), .r(srav_result), .zero(srav_zero), .carry(srav_carry), .negative(srav_negative), .overflow(srav_overflow));\n    shift_op sll(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow));\n    shift_op srl(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow));\n    shift_op sra(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select result based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? sub_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow || sub_overflow);\n    assign flag = (aluc == 6'b101010) ? sltu_result[31] : (aluc == 6'b101011) ? slt_result[31] : 1'b0;\n\nendmodule\n\nmodule add_sub(input [31:0] a, input [31:0] b, output [31:0] r, output zero, output carry, output negative, output overflow);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule logic_op(input [31:0] a, input [31:0] b, output [31:0] r, output zero, output carry, output negative, output overflow);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt_op(input [31:0] a, input [31:0] b, output [31:0] r, output zero, output carry, output negative, output overflow);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule shift_op(input [31:0] a, input [5:0] b, output [31:0] r, output zero, output carry, output negative, output overflow);\n    assign {carry, r} = (b[5] == 1) ? {a[31:0], b[4:0]} : {b[4:0], a[31:b[5]]};\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(input [31:0] a, input [5:0] b, output [31:0] r, output zero, output carry, output negative, output overflow);\n    assign {carry, r} = {b[5:0], a[31:0]};\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .C_in(b_out[3:3]),\n        .D(D[12:8]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .C_in(b_out[2:2]),\n        .D(D[8:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[1:1]),\n        .D(D[4:1]),\n        .B_out(b_out[0:0])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[3:1];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:1] D;        // 4-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [3:1] b_out;      // 4-bit borrow-out\n\n    // Instantiate full subtractor\n    full_subtractor sub(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .D(D),\n        .B_out(b_out)\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[3:1];\nendmodule\n\nmodule full_subtractor(A, B, C_in, D, B_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:1] D;        // 4-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [3:1] b_out;      // 4-bit borrow-out\n\n    // Perform subtraction\n    assign D = A - B - C_in;\n    assign B_out = (A[3] & B[3]) | (A[3] & ~B[3] & C_in) | (~A[3] & B[3] & C_in);\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the greater, equal, or less\n    assign A_greater = (sub_result != 0);\n    assign A_equal = (sub_result == 0 && borrow == 0);\n    assign A_less = (sub_result == 0 && borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output borrow\n);\n\n    // Perform subtraction\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Carry generation\n    assign A_greater = (diff != 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0) && (borrow == 1'b0);\n    assign A_less = (diff == 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the output based on the borrow and diff\n    assign A_greater = (diff != 0) && (borrow == 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff, // Difference between A and B\n    output borrow     // Borrow output\n);\n\n    // Perform subtraction\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction module instantiation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Carry generation\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Subtraction operation\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_0, C16_1, C16_2, C16_3;\n\n    // Instantiate 16-bit CLA blocks\n    carry_lookahead CLA1 (.A(A[16:1]), .B(B[16:1]), .C_in(0), .S(S[16:1]), .C_out(C16_0));\n    carry_lookahead CLA2 (.A(A[32:17]), .B(B[32:17]), .C_in(C16_0), .S(S[32:17]), .C_out(C16_1));\n\n    // Combine C16_0 and C16_1 to get C32_0\n    assign C32 = C16_0 | C16_1;\n\nendmodule\n\nmodule carry_lookahead(A,B,C_in,S,C_out);\n    input [16:1] A,B;\n    input C_in;\n    output [16:1] S;\n    output C_out;\n\n    wire [8:1] C8;\n    wire C8_0, C8_1, C8_2, C8_3;\n\n    // Instantiate 8-bit CLA blocks\n    carry_lookahead CLA1 (.A(A[8:1]), .B(B[8:1]), .C_in(0), .S(S[8:1]), .C_out(C8_0));\n    carry_lookahead CLA2 (.A(A[16:9]), .B(B[16:9]), .C_in(C8_0), .S(S[16:9]), .C_out(C8_1));\n\n    // Combine C8_0 and C8_1 to get C16_0\n    assign C16_0 = C8_0 | C8_1;\n\n    // Instantiate 8-bit CLA blocks\n    carry_lookahead CLA3 (.A(A[8:1]), .B(B[8:1]), .C_in(0), .S(S[8:1]), .C_out(C8_2));\n    carry_lookahead CLA4 (.A(A[16:9]), .B(B[16:9]), .C_in(C8_2), .S(S[16:9]), .C_out(C8_3));\n\n    // Combine C8_2 and C8_3 to get C16_1\n    assign C16_1 = C8_2 | C8_3;\n\n    // Instantiate 8-bit CLA blocks\n    carry_lookahead CLA5 (.A(A[8:1]), .B(B[8:1]), .C_in(0), .S(S[8:1]), .C_out(C8_0));\n    carry_lookahead CLA6 (.A(A[16:9]), .B(B[16:9]), .C_in(C8_0), .S(S[16:9]), .C_out(C8_1));\n\n    // Combine C8_0 and C8_1 to get C16_2\n    assign C16_2 = C8_0 | C8_1;\n\n    // Instantiate 8-bit CLA blocks\n    carry_lookahead CLA7 (.A(A[8:1]), .B(B[8:1]), .C_in(0), .S(S[8:1]), .C_out(C8_2));\n    carry_lookahead CLA8 (.A(A[16:9]), .B(B[16:9]), .C_in(C8_2), .S(S[16:9]), .C_out(C8_3));\n\n    // Combine C8_2 and C8_3 to get C16_3\n    assign C16_3 = C8_2 | C8_3;\n\nendmodule\n\nmodule carry_lookahead(A,B,C_in,S,C_out);\n    input [8:1] A,B;\n    input C_in;\n    output [8:1] S;\n    output C_out;\n\n    wire [4:1] C4;\n    wire C4_0, C4_1, C4_2, C4_3;\n\n    // Instantiate 4-bit CLA blocks\n    carry_lookahead CLA1 (.A(A[4:1]), .B(B[4:1]), .C_in(0), .S(S[4:1]), .C_out(C4_0));\n    carry_lookahead CLA2 (.A(A[8:5]), .B(B[8:5]), .C_in(C4_0), .S(S[8:5]), .C_out(C4_1));\n\n    // Combine C4_0 and C4_1 to get C8_0\n    assign C8_0 = C4_0 | C4_1;\n\n    // Instantiate 4-bit CLA blocks\n    carry_lookahead CLA3 (.A(A[4:1]), .B(B[4:1]), .C_in(0), .S(S[4:1]), .C_out(C4_2));\n    carry_lookahead CLA4 (.A(A[8:5]), .B(B[8:5]), .C_in(C4_2), .S(S[8:5]), .C_out(C4_3));\n\n    // Combine C4_2 and C4_3 to get C8_1\n    assign C8_1 = C4_2 | C4_3;\n\n    // Instantiate 4-bit CLA blocks\n    carry_lookahead CLA5 (.A(A[4:1]), .B(B[4:1]), .C_in(0), .S(S[4:1]), .C_out(C4_0));\n    carry_lookahead CLA6 (.A(A[8:5]), .B(B[8:5]), .C_in(C4_0), .S(S[8:5]), .C_out(C4_1));\n\n    // Combine C4_0 and C4_1 to get C8_2\n    assign C8_2 = C4_0 | C4_1;\n\n    // Instantiate 4-bit CLA blocks\n    carry_lookahead CLA7 (.A(A[4:1]), .B(B[4:1]), .C_in(0), .S(S[4:1]), .C_out(C4_2));\n    carry_lookahead CLA8 (.A(A[8:5]), .B(B[8:5]), .C_in(C4_2), .S(S[8:5]), .C_out(C4_3));\n\n    // Combine C4_2 and C4_3 to get C8_3\n    assign C8_3 = C4_2 | C4_3;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_1;\n\n    CLA16 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16_1));\n    CLA16 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16_1), .S(S[32:17]), .Cout(C16[16]));\n\n    assign C32 = C16[16];\nendmodule\n\nmodule CLA16(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [8:1] C8;\n    wire C8_1;\n\n    CLA8 CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(1'b0), .S(S[8:1]), .Cout(C8_1));\n    CLA8 CLA2 (.A(A[16:9]), .B(B[16:9]), .Cin(C8_1), .S(S[16:9]), .Cout(C8[8]));\n\n    assign Cout = C8[8];\nendmodule\n\nmodule CLA8(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [4:1] C4;\n    wire C4_1;\n\n    CLA4 CLA1 (.A(A[4:1]), .B(B[4:1]), .Cin(1'b0), .S(S[4:1]), .Cout(C4_1));\n    CLA4 CLA2 (.A(A[8:5]), .B(B[8:5]), .Cin(C4_1), .S(S[8:5]), .Cout(C4[4]));\n\n    assign Cout = C4[4];\nendmodule\n\nmodule CLA4(A,B,Cin,S,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire [2:1] C2;\n    wire C2_1;\n\n    CLA2 CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(1'b0), .S(S[2:1]), .Cout(C2_1));\n    CLA2 CLA2 (.A(A[4:3]), .B(B[4:3]), .Cin(C2_1), .S(S[4:3]), .Cout(C2[2]));\n\n    assign Cout = C2[2];\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire C1;\n\n    assign {Cout,S} = A[2:1] + B[2:1] + Cin;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_out;\n\n    CLA16 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16[1]));\n    CLA16 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16[1]), .S(S[32:17]), .Cout(C16_out));\n\n    assign C32 = C16_out;\nendmodule\n\nmodule CLA16(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [8:1] C8;\n    wire C8_out;\n\n    CLA8 CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(1'b0), .S(S[8:1]), .Cout(C8[1]));\n    CLA8 CLA2 (.A(A[16:9]), .B(B[16:9]), .Cin(C8[1]), .S(S[16:9]), .Cout(C8_out));\n\n    assign Cout = C8_out;\nendmodule\n\nmodule CLA8(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [4:1] C4;\n    wire C4_out;\n\n    CLA4 CLA1 (.A(A[4:1]), .B(B[4:1]), .Cin(1'b0), .S(S[4:1]), .Cout(C4[1]));\n    CLA4 CLA2 (.A(A[8:5]), .B(B[8:5]), .Cin(C4[1]), .S(S[8:5]), .Cout(C4_out));\n\n    assign Cout = C4_out;\nendmodule\n\nmodule CLA4(A,B,Cin,S,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire [2:1] C2;\n    wire C2_out;\n\n    CLA2 CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(1'b0), .S(S[2:1]), .Cout(C2[1]));\n    CLA2 CLA2 (.A(A[4:3]), .B(B[4:3]), .Cin(C2[1]), .S(S[4:3]), .Cout(C2_out));\n\n    assign Cout = C2_out;\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire [1:1] C1;\n    wire C1_out;\n\n    CLA1 CLA1 (.A(A[1:1]), .B(B[1:1]), .Cin(1'b0), .S(S[1:1]), .Cout(C1[1]));\n    CLA1 CLA2 (.A(A[2:2]), .B(B[2:2]), .Cin(C1[1]), .S(S[2:2]), .Cout(C1_out));\n\n    assign Cout = C1_out;\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input A,B;\n    input Cin;\n    output S;\n    output Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire C16;\n    \n    // Instantiate 16 CLA blocks\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA2 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16), .S(S[32:17]), .Cout(C32));\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n    wire [16:1] G,P;\n    wire [16:1] C;\n    \n    assign G = A & B;\n    assign P = A ^ B;\n    assign C[1] = Cin;\n    assign C[2:17] = C[1:16] | (G[17] & P[17]);\n    assign S = P ^ C[16:1];\n    assign Cout = C[16];\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [32:1] A,B;\n    input Cin;\n    output [32:1] S;\n    output Cout;\n    wire [32:1] G,P;\n    wire [32:1] C;\n    \n    assign G = A & B;\n    assign P = A ^ B;\n    assign C[1] = Cin;\n    assign C[2:33] = C[1:32] | (G[32] & P[32]);\n    assign S = P ^ C[32:1];\n    assign Cout = C[32];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// First 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Second 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Third 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Multiplexer to select sum\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n\n// Multiplexer to select carry out\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [3:0] temp_carry;\n\n// Sum calculation\nassign temp_sum[0] = a[0] ^ b[0];\nassign temp_sum[1] = a[1] ^ b[1];\nassign temp_sum[2] = a[2] ^ b[2];\nassign temp_sum[3] = a[3] ^ b[3];\nassign temp_sum[4] = a[0] & b[0] | a[1] & b[1] | a[2] & b[2] | a[3] & b[3] | cin;\n\n// Carry calculation\nassign temp_carry[0] = a[0] & b[0] | cin;\nassign temp_carry[1] = a[1] & b[1] | temp_carry[0];\nassign temp_carry[2] = a[2] & b[2] | temp_carry[1];\nassign temp_carry[3] = a[3] & b[3] | temp_carry[2];\n\n// Output assignments\nassign sum = temp_sum[3:0];\nassign cout = temp_carry[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Second ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Multiplexer to select sum\nassign sum = {sum_slice[1], sum_slice[0]};\n\n// Multiplexer to select carry out\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Second 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Third 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Fourth 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Output sum and carry\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit ripple carry adder\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First adder\nfull_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n\n// Second adder\nfull_adder fa2(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n\n// Third adder\nfull_adder fa3(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n\n// Fourth adder\nfull_adder fa4(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n\n// Output carry\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit carry select adder slice\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Third 4-bit ripple carry adder\nripple_carry_adder rca3(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Fourth 4-bit ripple carry adder\nripple_carry_adder rca4(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Output sum and carry\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\nassign cout = carry[3];\n\nendmodule\n\n// Full adder module\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (b & cin) | (a & cin);\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] c1, c2, c3;\nwire [15:0] s1, s2, s3;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(c1[0]), .sum(s1[3:0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(c1[0]), .cout(c1[1]), .sum(s1[7:4]));\n\n// Third 4-bit ripple carry adder\nripple_carry_adder rca3(.a(a[11:8]), .b(b[11:8]), .cin(c1[1]), .cout(c1[2]), .sum(s1[11:8]));\n\n// Fourth 4-bit ripple carry adder\nripple_carry_adder rca4(.a(a[15:12]), .b(b[15:12]), .cin(c1[2]), .cout(c1[3]), .sum(s1[15:12]));\n\n// Carry select adder slice 1\ncarry_select_adder_slice cs_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(s2[3:0]), .cout(c2[0]));\n\n// Carry select adder slice 2\ncarry_select_adder_slice cs_slice2(.a(a[7:4]), .b(b[7:4]), .cin(c1[0]), .sum(s2[7:4]), .cout(c2[1]));\n\n// Carry select adder slice 3\ncarry_select_adder_slice cs_slice3(.a(a[11:8]), .b(b[11:8]), .cin(c1[1]), .sum(s2[11:8]), .cout(c2[2]));\n\n// Carry select adder slice 4\ncarry_select_adder_slice cs_slice4(.a(a[15:12]), .b(b[15:12]), .cin(c1[2]), .sum(s2[15:12]), .cout(c2[3]));\n\n// Output sum and carry-out\nassign sum = s1;\nassign cout = c2[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, cout, sum);\ninput [3:0] a, b;\ninput cin;\noutput cout;\noutput [3:0] sum;\n\nwire [4:0] c;\n\n// Carry-out from the first bit\nassign c[0] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n// Carry-out from the second bit\nassign c[1] = (a[1] & b[1]) | (a[1] & c[0]) | (b[1] & c[0]);\n\n// Carry-out from the third bit\nassign c[2] = (a[2] & b[2]) | (a[2] & c[1]) | (b[2] & c[1]);\n\n// Carry-out from the fourth bit\nassign c[3] = (a[3] & b[3]) | (a[3] & c[2]) | (b[3] & c[2]);\n\n// Sum output\nassign sum = a ^ b ^ {4{cin}};\n\n// Carry-out output\nassign cout = c[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] c1, c2;\nwire [7:0] s1;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .cout(c1[0]), .sum(s1[3:0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(c1[0]), .cout(c1[1]), .sum(s1[7:4]));\n\n// Carry select adder\nassign {cout, sum} = cin ? {4'b0000, s1[7:4]} : {c1[1], s1[7:4]};\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_sum1, csa_sum2, csa_sum3;\nwire [3:0] csa_cout1, csa_cout2, csa_cout3;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(csa_sum1), .cout(csa_cout1));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(csa_cout1[0]), .sum(csa_sum2), .cout(csa_cout2));\n\n// Third 4-bit ripple carry adder\nripple_carry_adder rca3(.a(a[11:8]), .b(b[11:8]), .cin(csa_cout2[0]), .sum(csa_sum3), .cout(csa_cout3));\n\n// Fourth 4-bit ripple carry adder\nripple_carry_adder rca4(.a(a[15:12]), .b(b[15:12]), .cin(csa_cout3[0]), .sum(sum[15:12]), .cout(cout));\n\n// Carry select adder slices\ncarry_select_adder_slice csaslice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(csa_sum1), .cout(csa_cout1));\ncarry_select_adder_slice csaslice2(.a(a[7:4]), .b(b[7:4]), .cin(csa_cout1[0]), .sum(csa_sum2), .cout(csa_cout2));\ncarry_select_adder_slice csaslice3(.a(a[11:8]), .b(b[11:8]), .cin(csa_cout2[0]), .sum(csa_sum3), .cout(csa_cout3));\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [4:0] temp_cout;\n\nassign temp_sum[0] = a[0] ^ b[0] ^ cin;\nassign temp_sum[1] = a[1] ^ b[1] ^ temp_sum[0];\nassign temp_sum[2] = a[2] ^ b[2] ^ temp_sum[1];\nassign temp_sum[3] = a[3] ^ b[3] ^ temp_sum[2];\nassign temp_sum[4] = a[4] ^ b[4] ^ temp_sum[3];\nassign temp_sum[5] = a[5] ^ b[5] ^ temp_sum[4];\nassign temp_sum[6] = a[6] ^ b[6] ^ temp_sum[5];\nassign temp_sum[7] = a[7] ^ b[7] ^ temp_sum[6];\nassign temp_sum[8] = a[8] ^ b[8] ^ temp_sum[7];\nassign temp_sum[9] = a[9] ^ b[9] ^ temp_sum[8];\nassign temp_sum[10] = a[10] ^ b[10] ^ temp_sum[9];\nassign temp_sum[11] = a[11] ^ b[11] ^ temp_sum[10];\nassign temp_sum[12] = a[12] ^ b[12] ^ temp_sum[11];\nassign temp_sum[13] = a[13] ^ b[13] ^ temp_sum[12];\nassign temp_sum[14] = a[14] ^ b[14] ^ temp_sum[13];\nassign temp_sum[15] = a[15] ^ b[15] ^ temp_sum[14];\n\nassign temp_cout[0] = a[0] & b[0] | a[0] & cin | b[0] & cin;\nassign temp_cout[1] = a[1] & b[1] | a[1] & temp_cout[0] | b[1] & temp_cout[0];\nassign temp_cout[2] = a[2] & b[2] | a[2] & temp_cout[1] | b[2] & temp_cout[1];\nassign temp_cout[3] = a[3] & b[3] | a[3] & temp_cout[2] | b[3] & temp_cout[2];\nassign temp_cout[4] = a[4] & b[4] | a[4] & temp_cout[3] | b[4] & temp_cout[3];\nassign temp_cout[5] = a[5] & b[5] | a[5] & temp_cout[4] | b[5] & temp_cout[4];\nassign temp_cout[6] = a[6] & b[6] | a[6] & temp_cout[5] | b[6] & temp_cout[5];\nassign temp_cout[7] = a[7] & b[7] | a[7] & temp_cout[6] | b[7] & temp_cout[6];\nassign temp_cout[8] = a[8] & b[8] | a[8] & temp_cout[7] | b[8] & temp_cout[7];\nassign temp_cout[9] = a[9] & b[9] | a[9] & temp_cout[8] | b[9] & temp_cout[8];\nassign temp_cout[10] = a[10] & b[10] | a[10] & temp_cout[9] | b[10] & temp_cout[9];\nassign temp_cout[11] = a[11] & b[11] | a[11] & temp_cout[10] | b[11] & temp_cout[10];\nassign temp_cout[12] = a[12] & b[12] | a[12] & temp_cout[11] | b[12] & temp_cout[11];\nassign temp_cout[13] = a[13] & b[13] | a[13] & temp_cout[12] | b[13] & temp_cout[12];\nassign temp_cout[14] = a[14] & b[14] | a[14] & temp_cout[13] | b[14] & temp_cout[13];\nassign temp_cout[15] = a[15] & b[15] | a[15] & temp_cout[14] | b[15] & temp_cout[14];\n\nassign sum = temp_sum[15:0];\nassign cout = temp_cout[15];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] rca_sum1, rca_sum2;\nwire [3:0] rca_cout1, rca_cout2;\n\n// First ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(rca_sum1), .cout(rca_cout1));\n\n// Second ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(rca_cout1[0]), .sum(rca_sum2), .cout(rca_cout2));\n\n// Multiplexer\nassign sum = rca_cout2[0] ? rca_sum2 : rca_sum1;\nassign cout = rca_cout2[0];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8bit;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8bit)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n    wire c9, c10, c11, c12, c13, c14, c15, c16;\n\n    // Instantiate 8-bit adders\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(c1)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(c1),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire c2, c3, c4, c5, c6, c7, c8;\n\n    // Instantiate 4-bit adders\n    add4_inst1 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(c1)\n    );\n\n    add4_inst2 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(c1),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4_inst1 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    wire c2, c3, c4, c5;\n\n    // Instantiate 2-bit adders\n    add2_inst1 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(c1)\n    );\n\n    add2_inst2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(c1),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2_inst1 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 2-bit adder logic\n    assign y = a + b + Cin;\n    assign Co = (a[1] & b[1]) | (a[1] & Cin) | (b[1] & Cin);\n\nendmodule\n\nmodule add2_inst2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 2-bit adder logic\n    assign y = a + b + Cin;\n    assign Co = (a[1] & b[1]) | (a[1] & Cin) | (b[1] & Cin);\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\n    // 16-bit adder\n    assign y = {y_8, y[15:8]};\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    // 8-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 8-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co7;\n    wire [7:0] y7;\n\n    // 8-bit adder for first 8 bits\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co7)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co7),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift;    // Shift count register\n    wire [15:0] m;       // Multiplicand register\n    wire [15:0] n;       // Multiplier register\n    wire [31:0] p;       // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift(shift),\n        .m(m),\n        .n(n)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift(shift),\n        .m(m),\n        .n(n),\n        .p(p)\n    );\n\n    // Output Assignment\n    assign yout = p;\n    assign done = (shift == 5'd15);\n\nendmodule\n\n// Submodule for Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 5'd0;\n        end else if (start) begin\n            shift <= 5'd15;\n        end else begin\n            shift <= shift + 1'b1;\n        end\n    end\n\nendmodule\n\n// Submodule for Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift,  // Shift count register\n    input [15:0] m,     // Multiplicand register\n    input [15:0] n,     // Multiplier register\n    output reg [15:0] m_reg, // Multiplicand register\n    output reg [15:0] n_reg  // Multiplier register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m_reg <= 16'd0;\n            n_reg <= 16'd0;\n        end else begin\n            m_reg <= m;\n            n_reg <= n;\n        end\n    end\n\nendmodule\n\n// Submodule for Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift,  // Shift count register\n    input [15:0] m,     // Multiplicand register\n    input [15:0] n,     // Multiplier register\n    output reg [31:0] p // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            p <= 32'd0;\n        end else begin\n            if (shift == 5'd0) begin\n                p <= m * n;\n            end else begin\n                p <= p + (n << (shift - 1));\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a_in(ain),\n        .m_in(bin),\n        .a_out(a),\n        .m_out(m)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .m(m),\n        .product(product)\n    );\n\n    // Output assignment\n    assign yout = product;\n    assign done = (shift_count == 16);\n\nendmodule\n\n// Submodule for control unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Submodule for register unit\nmodule reg_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a_in,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m_in,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a_out, // Multiplicand register\n    output reg [15:0] m_out  // Multiplier register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_out <= 0;\n            m_out <= 0;\n        end else begin\n            a_out <= a_in;\n            m_out <= m_in;\n        end\n    end\n\nendmodule\n\n// Submodule for multiplier unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            product <= product + (a[0] ? m : 0);\n            product <= product << 1;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .a(a),\n        .m(m)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .a(a),\n        .m(m),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start;\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] a,     // Multiplicand register\n    input [15:0] m      // Multiplier register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            a <= 0;\n            m <= 0;\n        end else if (start) begin\n            shift_count <= shift_count;\n            a <= a;\n            m <= m;\n        end else begin\n            shift_count <= shift_count;\n            a <= a;\n            m <= m;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] a,     // Multiplicand register\n    input [15:0] m,     // Multiplier register\n    output reg [31:0] product // Product register\n);\n\n    reg [15:0] shifted_m;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shifted_m <= 0;\n            product <= 0;\n        end else if (start) begin\n            shifted_m <= m;\n            product <= 0;\n        end else if (shift_count > 0) begin\n            shifted_m <= {shifted_m[14:0], 1'b0};\n            product <= product + (a & shifted_m);\n        end else begin\n            shifted_m <= shifted_m;\n            product <= product;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n    wire [31:0] temp;       // Temporary product register\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(ain),\n        .m(bin),\n        .shift_count(shift_count),\n        .product(product),\n        .a_reg(a),\n        .m_reg(m)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(a),\n        .m(m),\n        .temp(temp)\n    );\n\n    // Assign product register to output\n    assign yout = product;\n    assign done = start & ~rst_n; // Done signal\n\nendmodule\n\n// Control unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count register\n    output reg [31:0] product, // Product register\n    output reg [15:0] a_reg,  // Multiplicand register\n    output reg [15:0] m_reg  // Multiplier register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n            a_reg <= 0;\n            m_reg <= 0;\n        end else if (start) begin\n            product <= 0;\n            a_reg <= a;\n            m_reg <= m;\n        end else begin\n            product <= product + (m_reg << shift_count);\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] temp // Temporary product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            temp <= 0;\n        end else if (start) begin\n            temp <= 0;\n        end else begin\n            temp <= temp + (m << (a[shift_count] ? shift_count : 0));\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Selecting the result based on the mode input\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0;\n    wire gt1, lt1, eq1;\n    wire gt2, lt2, eq2;\n    wire gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output logic\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0, gt1, lt1, eq1, gt2, lt2, eq2, gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\n// 8-bit multiplier module\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wires to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .product(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(multiplication_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 0;\n        else\n            current_value <= current_value + new_value;\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic to decide output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_carry;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .carry_out(sub_carry));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    // Select carry/borrow based on op signal\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_carry;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiating the AND module\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR module\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Selecting the operation based on the op_sel input\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(\n        .in(in[7]),\n        .highest(code_temp[2]),\n        .valid(code_temp[1])\n    );\n    check_bit cb6(\n        .in(in[6]),\n        .highest(code_temp[1]),\n        .valid(code_temp[0])\n    );\n    check_bit cb5(\n        .in(in[5]),\n        .highest(code_temp[0]),\n        .valid(code_temp[0])\n    );\n    check_bit cb4(\n        .in(in[4]),\n        .highest(code_temp[0]),\n        .valid(code_temp[0])\n    );\n    check_bit cb3(\n        .in(in[3]),\n        .highest(code_temp[0]),\n        .valid(code_temp[0])\n    );\n    check_bit cb2(\n        .in(in[2]),\n        .highest(code_temp[0]),\n        .valid(code_temp[0])\n    );\n    check_bit cb1(\n        .in(in[1]),\n        .highest(code_temp[0]),\n        .valid(code_temp[0])\n    );\n    check_bit cb0(\n        .in(in[0]),\n        .highest(code_temp[0]),\n        .valid(code_temp[0])\n    );\n\n    // Assign output code and valid\n    assign code = code_temp;\n    assign valid = |in;\n\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    reg highest_temp;\n    reg valid_temp;\n\n    always @(*) begin\n        highest_temp = in & ~highest_temp;\n        valid_temp = in | valid_temp;\n    end\n\n    assign highest = highest_temp;\n    assign valid = valid_temp;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instance of the instruction fetcher for registers\n    instruction_fetch_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    // Instance of the instruction fetcher for RAM/ROM\n    instruction_fetch_ram ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // Assign outputs based on the selected instruction source\n    assign ins = (fetch[0]) ? ins1 : ins2;\n    assign ad1 = (fetch[0]) ? ad11 : ad12;\n    assign ad2 = (fetch[0]) ? ad21 : ad22;\n\nendmodule\n\n// Instruction fetcher for registers\nmodule instruction_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule\n\n// Instruction fetcher for RAM/ROM\nmodule instruction_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Selecting the operation based on the operation selector\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) == 0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[2]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[2]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(code_temp[0]));\n\n    // Combine outputs from check_bit submodules\n    assign code = code_temp;\n    assign valid = |in;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !valid;\n    assign valid = valid | in;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] adder_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation based on the op_sel signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodules\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= 100_000_000) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= 50_000_000) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= 75_000_000) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] GPP0, GPP1, GPP2, GPP3;\nwire [3:0] A4BS0, A4BS1, A4BS2;\n\n// Generate partial products\nfull_adder_4bit GPP0_inst (.a(a[0]), .b(b[0]), .cin(0), .sum(GPP0), .cout(A4BS0));\nfull_adder_4bit GPP1_inst (.a(a[1]), .b(b[1]), .cin(GPP0), .sum(GPP1), .cout(A4BS1));\nfull_adder_4bit GPP2_inst (.a(a[2]), .b(b[2]), .cin(GPP1), .sum(GPP2), .cout(A4BS2));\nfull_adder_4bit GPP3_inst (.a(a[3]), .b(b[3]), .cin(GPP2), .sum(product[3:0]), .cout(product[7]));\n\n// Generate the product\nfull_adder_4bit A4BS0_inst (.a(0), .b(GPP0), .cin(0), .sum(product[0]), .cout(product[1]));\nfull_adder_4bit A4BS1_inst (.a(0), .b(GPP1), .cin(product[1]), .sum(product[2]), .cout(product[3]));\nfull_adder_4bit A4BS2_inst (.a(0), .b(GPP2), .cin(product[3]), .sum(product[4]), .cout(product[5]));\nfull_adder_4bit A4BS3_inst (.a(0), .b(GPP3), .cin(product[5]), .sum(product[6]), .cout(product[7]));\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Instantiate 1-bit full adder for the final carry\n    one_bit_adder add3(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(carry[2]),\n        .S(S[4]),\n        .C_out(carry[3])\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = carry[3];\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;     // Inputs\n    output S, C_out;      // Outputs\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A, B;     // Inputs\n    input C_in;           // Carry-in\n    output [1:0] S;       // Outputs\n    output C_out;         // Carry-out\n\n    wire c1, c2;          // Carry chain\n\n    // Instantiate 1-bit full adder for the first bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(1'b0),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Instantiate 1-bit full adder for the second bit\n    one_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(c1),\n        .S(S[1]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = c2;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [3:0] a_reg, b_reg;\n    wire [7:0] sum;\n\n    // Registers to hold inputs\n    reg [3:0] a_reg, b_reg;\n\n    // Full adders for multiplication\n    full_adder_4bit GPP0 (.a(a_reg[0]), .b(b_reg[0]), .cin(0), .sum(sum[0]), .cout(sum[1]));\n    full_adder_4bit GPP1 (.a(a_reg[1]), .b(b_reg[1]), .cin(sum[0]), .sum(sum[2]), .cout(sum[3]));\n    full_adder_4bit GPP2 (.a(a_reg[2]), .b(b_reg[2]), .cin(sum[2]), .sum(sum[4]), .cout(sum[5]));\n    full_adder_4bit GPP3 (.a(a_reg[3]), .b(b_reg[3]), .cin(sum[4]), .sum(sum[6]), .cout(sum[7]));\n\n    // Shift registers for inputs\n    always @(*) begin\n        a_reg <= a;\n        b_reg <= b;\n    end\n\n    // Output product\n    assign product = sum;\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\n    wire c1, c2;\n\n    // Full adder logic\n    assign {c1, sum} = a + b + cin;\n    assign cout = c1;\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count < 62500000) begin\n                count <= count + 1;\n                PWM_state <= 1;\n            end else begin\n                count <= 0;\n                PWM_state <= 0;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count < 31250000) begin\n                count <= count + 1;\n                PWM_state <= 1;\n            end else begin\n                count <= 0;\n                PWM_state <= 0;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count < 18750000) begin\n                count <= count + 1;\n                PWM_state <= 1;\n            end else begin\n                count <= 0;\n                PWM_state <= 0;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output from the last flip-flop\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each nibble\n    nibble_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(carry[1])\n    );\n\n    nibble_adder add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(carry[1]),\n        .S(S[2:2]),\n        .C_out(carry[2])\n    );\n\n    nibble_adder add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(carry[2]),\n        .S(S[3:3]),\n        .C_out(carry[3])\n    );\n\n    nibble_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(carry[3]),\n        .S(S[4:4]),\n        .C_out(carry[4])\n    );\n\n    // Combine the carry bits to get the final carry-out\n    assign C_out = carry[4];\nendmodule\n\nmodule nibble_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;     // 4-bit inputs\n    output S, C_out;      // 4-bit sum output\n\n    wire c1, c2;          // Carry bits\n\n    full_adder fa1(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(S),\n        .B(1'b0),\n        .C_in(c1),\n        .S(S),\n        .C_out(c2)\n    );\n\n    assign C_out = c2;\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;     // 4-bit inputs\n    output S, C_out;      // 4-bit sum output\n\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n    wire [7:0] shifted_in_2;\n    wire [7:0] shifted_in_3;\n    wire [7:0] shifted_in_4;\n\n    // Stage 1: Shift by 4\n    mux2X1 #(.WIDTH(8)) stage1_mux (.sel(ctrl[2]), .in1(in), .in2(shifted_in), .out(shifted_in_2));\n    assign shifted_in = in << 2;\n\n    // Stage 2: Shift by 2\n    mux2X1 #(.WIDTH(8)) stage2_mux (.sel(ctrl[1]), .in1(shifted_in_2), .in2(shifted_in_3), .out(shifted_in_3));\n    mux2X1 #(.WIDTH(8)) stage3_mux (.sel(ctrl[1]), .in1(in), .in2(shifted_in_4), .out(shifted_in_4));\n    assign shifted_in_3 = shifted_in_2 >> 2;\n    assign shifted_in_4 = in >> 2;\n\n    // Stage 3: Shift by 1\n    mux2X1 #(.WIDTH(8)) stage4_mux (.sel(ctrl[0]), .in1(shifted_in_3), .in2(shifted_in_4), .out(out));\n\nendmodule\n\nmodule mux2X1 (sel, in1, in2, out);\n    parameter WIDTH = 8;\n    input sel;\n    input [WIDTH-1:0] in1, in2;\n    output [WIDTH-1:0] out;\n\n    assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 10000; // Maximum count value\n\n    wire [15:0] counter_out;\n    wire [15:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_value(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [15:0] count_out\n);\n    parameter MAX_COUNT = 10000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == MAX_COUNT) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [15:0] count_value,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 5000; // Duty cycle threshold\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else begin\n            if (count_value < DUTY_CYCLE_THRESHOLD) begin\n                pwm_out <= 1;\n            end else begin\n                pwm_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n    wire [7:0] shifted;\n\n    // Stage 1: Shift by 4\n    wire [7:0] shifted_4;\n    mux2X1 mux4 (shifted_4, in, shifted_4, 4'b0001);\n    mux2X1 mux2_4 (shifted, shifted_4, in, 4'b0010);\n    mux2X1 mux1_4 (shifted, shifted, shifted_4, 4'b0100);\n\n    // Stage 2: Shift by 2\n    wire [7:0] shifted_2;\n    mux2X1 mux4_2 (shifted_2, shifted, shifted_2, 4'b0001);\n    mux2X1 mux2_2 (shifted, shifted_2, shifted_2, 4'b0010);\n    mux2X1 mux1_2 (shifted, shifted, shifted_2, 4'b0100);\n\n    // Stage 3: Shift by 1\n    wire [7:0] shifted_1;\n    mux2X1 mux4_1 (shifted_1, shifted, shifted_1, 4'b0001);\n    mux2X1 mux2_1 (shifted, shifted_1, shifted_1, 4'b0010);\n    mux2X1 mux1_1 (shifted, shifted, shifted_1, 4'b0100);\n\n    assign out = shifted;\n\nendmodule\n\nmodule mux2X1 (out, in1, in2, sel);\n    input [7:0] in1, in2;\n    input [3:0] sel;\n    output [7:0] out;\n    assign out = sel[0] ? in1 : in2;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed version of b0\n  assign b1 = rst ? 16'b0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out signals\n\n    // Instantiate 4-bit CLA adders\n    cla_4bit add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    cla_4bit add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    cla_4bit add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    cla_4bit add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the final carry-out from the 4-bit CLA adders\n    assign C_out = c4;\n\nendmodule\n\nmodule cla_4bit(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out signals\n\n    // Instantiate 2-bit CLA adders\n    cla_2bit add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    cla_2bit add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c1),\n        .S(S[4:3]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the final carry-out from the 2-bit CLA adders\n    assign C_out = c2;\n\nendmodule\n\nmodule cla_2bit(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;              // Carry-out signal\n\n    // Instantiate 1-bit CLA adder\n    cla_1bit add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the final carry-out from the 1-bit CLA adder\n    assign C_out = c1;\n\nendmodule\n\nmodule cla_1bit(A, B, C_in, S, C_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] mult_signed_result;\nwire [63:0] mult_unsigned_result;\n\n// Instantiate the submodules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(mult_signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(mult_unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = (multc) ? mult_unsigned_result : mult_signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Submodule for signed multiplication\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Submodule for unsigned multiplication\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed version of b0\n  assign b1 = (rst) ? 0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub_1bit S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub_1bit S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub_1bit S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub_1bit S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub_1bit S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub_1bit S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub_1bit S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub_1bit S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub_1bit(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Output the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Output the most and least significant bits\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Output the zero flag\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1[1]),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2[2]),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3[4]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] g, p;\n    wire [5:1] c;\n\n    // Generate G and P signals\n    assign g[1] = A[1] & B[1];\n    assign g[2] = A[2] & B[2];\n    assign g[3] = A[3] & B[3];\n    assign g[4] = A[4] & B[4];\n    assign g[5] = A[5] & B[5];\n\n    assign p[1] = A[1] ^ B[1];\n    assign p[2] = A[2] ^ B[2];\n    assign p[3] = A[3] ^ B[3];\n    assign p[4] = A[4] ^ B[4];\n    assign p[5] = A[5] ^ B[5];\n\n    // Generate C signals\n    assign c[1] = g[1] | (p[1] & C_in);\n    assign c[2] = g[2] | (p[2] & c[1]);\n    assign c[3] = g[3] | (p[3] & c[2]);\n    assign c[4] = g[4] | (p[4] & c[3]);\n    assign c[5] = g[5] | (p[5] & c[4]);\n\n    // Generate sum\n    assign S[1] = A[1] ^ B[1];\n    assign S[2] = A[2] ^ B[2];\n    assign S[3] = A[3] ^ B[3];\n    assign S[4] = A[4] ^ B[4];\n    assign S[5] = A[5] ^ B[5];\n\n    // Carry-out\n    assign C_out = c[5];\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output values\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] SAA0, SAA1, SAA2, SAA3;\n\n    shift_add SAA0(.a(a), .b(b[0]), .product(SAA0));\n    shift_add SAA1(.a(a), .b(b[1]), .product(SAA1));\n    shift_add SAA2(.a(a), .b(b[2]), .product(SAA2));\n    shift_add SAA3(.a(a), .b(b[3]), .product(SAA3));\n\n    assign product = SAA0 + (SAA1 << 1) + (SAA2 << 2) + (SAA3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_increment;\n    wire [3:0] count_next;\n    wire overflow_next;\n\n    // Count Control Module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_increment(count_increment)\n    );\n\n    // Overflow Detection Module\n    overflow_detection u_overflow_detection (\n        .count_current(count_out),\n        .count_increment(count_increment),\n        .overflow(overflow_next)\n    );\n\n    // Assign output values\n    assign count_out = count_next;\n    assign overflow = overflow_next;\n\n    // Assign next count value\n    assign count_next = (rst) ? 4'b0000 : (count_out + count_increment);\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_increment\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count_increment <= 4'b0000;\n        else if (en)\n            count_increment <= 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0] count_current,\n    input   [3:0] count_increment,\n    output  reg    overflow\n);\n\n    always @(*) begin\n        overflow = (count_current + count_increment) == 4'b0000;\n    end\n\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Output parity\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(x_parity)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(y_parity)\n    );\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Output parity\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(\n        .X(X[3:0]),\n        .P(x_parity[3:0])\n    );\n\n    parity_4bit gen2(\n        .X(X[7:4]),\n        .P(x_parity[7:4])\n    );\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3] ^ x_parity[4] ^ x_parity[5] ^ x_parity[6] ^ x_parity[7];\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output P;            // Output parity\n\n    wire [3:0] x_parity; // Parity of X\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(\n        .X(X[1:0]),\n        .P(x_parity[1:0])\n    );\n\n    parity_2bit gen2(\n        .X(X[3:2]),\n        .P(x_parity[3:2])\n    );\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3];\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output P;            // Output parity\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_res;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .op(op), .alu_res(alu_res));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .rd(rd), .pc(pc));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      instr_reg <= instr_mem[pc_reg];\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[10:6];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_res\n);\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_res_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_res_reg <= rs1 + rs2;\n        6'b001010: alu_res_reg <= rs1 - rs2;\n        default: alu_res_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= alu_res;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [4:0] rd,\n  output [5:0] pc\n);\n  reg [5:0] pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n    end else begin\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (control_signal) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(x_parity));\n    parity_8bit gen2(.X(Y), .P(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [3:0] x_parity; // Parity of X\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(.X(X[3:0]), .P(x_parity[0]));\n    parity_4bit gen2(.X(X[7:4]), .P(x_parity[1]));\n    parity_4bit gen3(.X(X[3:0]), .P(x_parity[2]));\n    parity_4bit gen4(.X(X[7:4]), .P(x_parity[3]));\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3];\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output P;            // Parity output\n\n    wire [1:0] x_parity; // Parity of X\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(.X(X[1:0]), .P(x_parity[0]));\n    parity_2bit gen2(.X(X[3:2]), .P(x_parity[1]));\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1];\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output P;            // Parity output\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] next_pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(next_pc));\n  decode_stage decode(.clk(clk), .rst(rst), .instr(instr_mem[next_pc]), .reg_file(reg_file), .alu_result(alu_result));\n  execute_stage execute(.clk(clk), .rst(rst), .alu_result(alu_result), .alu_result(alu_result));\n  memory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .alu_result(alu_result));\n  writeback_stage writeback(.clk(clk), .rst(rst), .alu_result(alu_result), .reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else begin\n      // Decode instruction\n      alu_result <= reg_file[instr[20:16]] + reg_file[instr[15:11]];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else\n      alu_result <= alu_result;\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else\n      alu_result <= alu_result;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      reg_file <= 0;\n    else\n      reg_file[0] <= alu_result;\n  end\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        count_out <= count;\n    end\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b_delayed;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_delayed <= 0;\n    end else begin\n      b_delayed <= b0;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(c2),\n        .S(S[7:4]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(c3),\n        .S(S[11:8]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry out of the last adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:0] sum;       // 5-bit sum\n\n    // Calculate sum and carry out\n    assign sum = A + B + C_in;\n    assign S = sum[3:0];\n    assign C_out = sum[4];\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd add_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(add_result)\n);\n\nsubtract subtract_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(subtract_result)\n);\n\nbitwise_and bitwise_and_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_and_result)\n);\n\nbitwise_or bitwise_or_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_or_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a + b;\nendmodule\n\nmodule subtract(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a | b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b1, b2, b3;\n\n  // Assign delayed values\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      product <= 0;\n    end else begin\n      product <= a * b;\n    end\n  end\n\n  assign c = product;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[1]),\n        .S(S[7:4]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[2]),\n        .S(S[11:8]),\n        .C_out(carry[3])\n    );\n\n    // Combine carry outputs to get final carry-out\n    assign C_out = carry[3];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:0] sum;        // 5-bit sum\n\n    // Perform addition\n    assign {C_out, sum} = A + B + C_in;\n\n    // Output sum\n    assign S = sum[3:0];\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Combine the results based on the op_code\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction structure\nstruct instruction {\n    reg_t rd;\n    reg_t ra;\n    reg_t rb;\n    op_t op;\n};\n\n// Register type\ntypedef reg_t [4:0] reg_t;\n\n// Register file\nreg [31:0] reg_file [0:31];\n\n// Program counter\nreg [4:0] pc;\n\n// Instruction memory\nreg [31:0] instr_mem [0:31];\n\n// Instruction register\nreg [31:0] instr;\n\n// Instruction decoder\nwire [5:0] opcode;\nwire [4:0] rd;\nwire [4:0] ra;\nwire [4:0] rb;\nwire [31:0] result;\n\n// Fetch stage\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .pc(pc),\n    .instr_mem(instr_mem),\n    .instr(instr)\n);\n\n// Execute stage\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(instr),\n    .reg_file(reg_file),\n    .result(result)\n);\n\n// Writeback stage\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .result(result),\n    .rd(rd),\n    .reg_file(reg_file)\n);\n\n// Instruction decoder\nassign opcode = instr[31:26];\nassign rd = instr[20:15];\nassign ra = instr[15:10];\nassign rb = instr[4:0];\n\n// Instruction execution\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        instr <= 32'b0;\n    end else begin\n        instr <= instr_mem[pc];\n    end\nend\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [4:0] pc,\n    input [31:0] instr_mem [0:31],\n    output [31:0] instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            instr <= 32'b0;\n        end else begin\n            instr <= instr_mem[pc];\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] result\n);\n    wire [31:0] a, b;\n    wire [5:0] opcode;\n    wire [4:0] rd, ra, rb;\n\n    assign opcode = instr[31:26];\n    assign rd = instr[20:15];\n    assign ra = instr[15:10];\n    assign rb = instr[4:0];\n\n    assign a = reg_file[ra];\n    assign b = reg_file[rb];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 32'b0;\n        end else begin\n            case (opcode)\n                `ADD: result <= a + b;\n                `SUB: result <= a - b;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd,\n    output reg [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file[rd] <= 32'b0;\n        end else begin\n            reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine outputs from slices to determine overall relationship\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine outputs from slices to determine overall relationship\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\n// Instantiate 1-bit comparator\ncomparator_1bit comp_slice1(.a(a[0]), .b(b[0]), .eq(eq_bit), .gt(gt_bit), .lt(lt_bit));\n\n// Combine outputs from slices to determine overall relationship\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n\n    assign xor_result = a ^ b;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000001\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000001\n\n// Instructions\n`define R_TYPE 6'b000000\n`define I_TYPE 6'b000001\n`define J_TYPE 6'b000010\n\n// Registers\n`define ZERO 5'b00000\n`define RA 5'b00001\n`define RB 5'b00010\n`define RC 5'b00011\n\n// Instruction memory\n`define PC_INIT 5'b00000\n\n// Register file\n`define REG_INIT 32'b00000000000000000000000000000000\n\n// Fetch stage\nfetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(5'b00000),\n    .out_instr(fetch.out_instr)\n);\n\n// Execute stage\nexecute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\n// Writeback stage\nwriteback writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(execute.out_reg_file),\n    .out_reg_file(writeback.out_reg_file)\n);\n\n// Output register file\nassign out_reg_file = writeback.out_reg_file;\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output reg [31:0] out_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_instr <= 32'b0;\n        else\n            out_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    reg [5:0] opcode;\n    reg [4:0] rd;\n    reg [4:0] ra;\n    reg [4:0] rb;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            opcode <= 6'b0;\n            rd <= 5'b0;\n            ra <= 5'b0;\n            rb <= 5'b0;\n            result <= 32'b0;\n            out_reg_file <= 32'b0;\n        end\n        else begin\n            opcode <= instr[31:26];\n            rd <= instr[11:7];\n            ra <= instr[19:15];\n            rb <= instr[24:20];\n\n            case (opcode)\n                `ADD: result <= reg_file[ra] + reg_file[rb];\n                `SUB: result <= reg_file[ra] - reg_file[rb];\n                default: result <= 32'b0;\n            endcase\n\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file <= 32'b0;\n        else\n            out_reg_file <= reg_file;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data_in(in_data), .rot_dir(rot_dir), .rot_out(left_rot));\nright_rotate rr(.data_in(in_data), .rot_dir(rot_dir), .rot_out(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data_in,\n  input rot_dir,\n  output [3:0] rot_out\n);\n  assign rot_out = {data_in[0], data_in[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data_in,\n  input rot_dir,\n  output [3:0] rot_out\n);\n  assign rot_out = {data_in[2:0], data_in[3]};\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slices, gt_slices, lt_slices;\n\ncomparator_4bit comp_slice1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .eq(eq_slices[0]),\n    .gt(gt_slices[0]),\n    .lt(lt_slices[0])\n);\n\ncomparator_4bit comp_slice2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .eq(eq_slices[1]),\n    .gt(gt_slices[1]),\n    .lt(lt_slices[1])\n);\n\ncomparator_4bit comp_slice3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .eq(eq_slices[2]),\n    .gt(gt_slices[2]),\n    .lt(lt_slices[2])\n);\n\ncomparator_4bit comp_slice4(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .eq(eq_slices[3]),\n    .gt(gt_slices[3]),\n    .lt(lt_slices[3])\n);\n\nassign eq = &eq_slices;\nassign gt = |gt_slices;\nassign lt = |lt_slices;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire eq_0, eq_1, eq_2, eq_3;\nwire gt_0, gt_1, gt_2, gt_3;\nwire lt_0, lt_1, lt_2, lt_3;\n\nassign eq_0 = (a[0] == b[0]);\nassign eq_1 = (a[1] == b[1]);\nassign eq_2 = (a[2] == b[2]);\nassign eq_3 = (a[3] == b[3]);\n\nassign gt_0 = (a[0] > b[0]);\nassign gt_1 = (a[1] > b[1]);\nassign gt_2 = (a[2] > b[2]);\nassign gt_3 = (a[3] > b[3]);\n\nassign lt_0 = (a[0] < b[0]);\nassign lt_1 = (a[1] < b[1]);\nassign lt_2 = (a[2] < b[2]);\nassign lt_3 = (a[3] < b[3]);\n\nassign eq = eq_0 & eq_1 & eq_2 & eq_3;\nassign gt = gt_0 | gt_1 | gt_2 | gt_3;\nassign lt = lt_0 | lt_1 | lt_2 | lt_3;\n\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (~mode);\n  end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Generate the count value based on the mode\n  assign count_value_up = count_value + 1;\n  assign count_value_down = count_value - 1;\n  assign count_value = (mode == 0) ? count_value_up : count_value_down;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result, or_result)\n    );\n\n    // Control signal for the bitwise operation\n    wire bitwise_op;\n    assign bitwise_op = op_code[1];\n\n    // Control signal for the operation\n    wire [1:0] operation;\n    assign operation = op_code[0] ? 2'b11 : op_code[1] ? 2'b10 : 2'b00;\n\n    // Result assignment\n    assign result = operation == 2'b00 ? add_result :\n                    operation == 2'b01 ? sub_result :\n                    bitwise_op ? or_result : and_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(a or b) begin\n        result = a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(a or b) begin\n        result = a - b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] and_result,\n    output reg [31:0] or_result\n);\n    always @(a or b) begin\n        and_result = a & b;\n        or_result = a | b;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation to perform\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result,\n    output wire [31:0] or_result\n);\n    assign and_result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    // Instantiate the two latches\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    // Output the latch outputs\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Shift register module\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input [7:0] X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input [7:0] X;\n    input Y;\n    output [15:0] P;\n\n    reg [15:0] p;\n\n    always @(*) begin\n        p = X * Y;\n    end\n\n    assign P = p;\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Bin(Bin),\n        .D(D0),\n        .Bout(Bout0)\n    );\n\n    subtractor_8bit SUB2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Bin(Bout0),\n        .D(D1),\n        .Bout(Bout1)\n    );\n\n    subtractor_8bit SUB3(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Bin(Bout1),\n        .D(D2),\n        .Bout(Bout2)\n    );\n\n    subtractor_8bit SUB4(\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Bin(Bout2),\n        .D(D3),\n        .Bout(Bout3)\n    );\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n\n    wire [4:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n    wire [4:0] D0, D1, D2, D3, D4, D5, D6, D7;\n\n    subtractor_4bit SUB1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Bin(Bin),\n        .D(D0),\n        .Bout(Bout0)\n    );\n\n    subtractor_4bit SUB2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Bin(Bout0),\n        .D(D1),\n        .Bout(Bout1)\n    );\n\n    subtractor_4bit SUB3(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .Bin(Bout1),\n        .D(D2),\n        .Bout(Bout2)\n    );\n\n    subtractor_4bit SUB4(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .Bin(Bout2),\n        .D(D3),\n        .Bout(Bout3)\n    );\n\n    subtractor_4bit SUB5(\n        .A(A[19:16]),\n        .B(B[19:16]),\n        .Bin(Bout3),\n        .D(D4),\n        .Bout(Bout4)\n    );\n\n    subtractor_4bit SUB6(\n        .A(A[23:20]),\n        .B(B[23:20]),\n        .Bin(Bout4),\n        .D(D5),\n        .Bout(Bout5)\n    );\n\n    subtractor_4bit SUB7(\n        .A(A[27:24]),\n        .B(B[27:24]),\n        .Bin(Bout5),\n        .D(D6),\n        .Bout(Bout6)\n    );\n\n    subtractor_4bit SUB8(\n        .A(A[31:28]),\n        .B(B[31:28]),\n        .Bin(Bout6),\n        .D(D7),\n        .Bout(Bout7)\n    );\n\n    assign D = {D7, D6, D5, D4, D3, D2, D1, D0};\n    assign Bout = Bout7;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [3:0] A;\n    input [3:0] B;\n    input Bin;\n    output [3:0] D;\n    output Bout;\n\n    wire [2:0] Bout0, Bout1, Bout2;\n    wire [2:0] D0, D1, D2;\n\n    subtractor_2bit SUB1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Bin(Bin),\n        .D(D0),\n        .Bout(Bout0)\n    );\n\n    subtractor_2bit SUB2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Bin(Bout0),\n        .D(D1),\n        .Bout(Bout1)\n    );\n\n    subtractor_2bit SUB3(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Bin(Bout1),\n        .D(D2),\n        .Bout(Bout2)\n    );\n\n    assign D = {D2, D1, D0};\n    assign Bout = Bout2;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Bout;\n\n    wire Bout0, Bout1;\n    wire D0, D1;\n\n    subtractor_1bit SUB1(\n        .A(A[0]),\n        .B(B[0]),\n        .Bin(Bin),\n        .D(D0),\n        .Bout(Bout0)\n    );\n\n    subtractor_1bit SUB2(\n        .A(A[1]),\n        .B(B[1]),\n        .Bin(Bout0),\n        .D(D1),\n        .Bout(Bout1)\n    );\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n\n    assign {Bout, D} = A - B - Bin;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n\n    // Submodule instances\n    abs_value abs_dividend (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result),\n        .counter(counter),\n        .remainder(remainder),\n        .quotient(quotient)\n    );\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for calculating negative value\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for managing division control\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [7:0] quotient,\n    output reg [7:0] remainder\n);\n\n    reg [7:0] divisor;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            divisor <= 0;\n        end else begin\n            if (opn_valid) begin\n                divisor <= $signed(shift_reg);\n                if (divisor == 0) begin\n                    counter <= 0;\n                    shift_reg <= 0;\n                    quotient <= 0;\n                    remainder <= 0;\n                end else begin\n                    counter <= 4;\n                    shift_reg <= dividend;\n                    quotient <= 0;\n                    remainder <= dividend;\n                end\n            end else begin\n                if (counter > 0) begin\n                    counter <= counter - 1;\n                    shift_reg <= {shift_reg[6:0], 1'b0};\n                    quotient <= quotient << 1;\n                    remainder <= remainder - divisor;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for managing result validity\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    output reg res_valid,\n    input wire [15:0] result,\n    input wire [3:0] counter,\n    input wire [7:0] remainder,\n    input wire [7:0] quotient\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n        end else begin\n            if (res_ready) begin\n                res_valid <= 0;\n            end else begin\n                if (opn_valid) begin\n                    res_valid <= 1;\n                end else begin\n                    if (counter == 0) begin\n                        res_valid <= 0;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 2 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 2-bit adder\n    adder_2bit adder (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X[0]),\n        .Y(Y[0]),\n        .Sum(Sum[0]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Carry_in,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    // Instantiate 8-bit subtractors\n    subtractor SUB1(A[32:24], B[32:24], Bin, D[32:24], Bout0);\n    subtractor SUB2(A[32:16], B[32:16], Bout0, D[32:16], Bout1);\n    subtractor SUB3(A[32:8], B[32:8], Bout1, D[32:8], Bout2);\n    subtractor SUB4(A[32:1], B[32:1], Bout2, D[32:1], Bout3);\n\n    // Output borrow-out\n    assign Bout = Bout3;\n\nendmodule\n\nmodule subtractor(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    // Instantiate 4-bit subtractor\n    subtractor_4bit SUB(A, B, Bin, D, Cout, Bout);\n\n    // Output borrow-out\n    assign Bout = Cout;\n\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Cout, Bout);\n    input [3:0] A;\n    input [3:0] B;\n    input Bin;\n    output [3:0] D;\n    output Cout;\n    output Bout;\n    wire Cout0, Cout1;\n\n    // Instantiate 2-bit subtractors\n    subtractor_2bit SUB1(A[3:2], B[3:2], Bin, D[3:2], Cout0);\n    subtractor_2bit SUB2(A[1:0], B[1:0], Cout0, D[1:0], Cout1, Bout);\n\n    // Output carry-out\n    assign Cout = Cout1;\n\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Cout, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Cout;\n    output Bout;\n    wire Cout0;\n\n    // Instantiate 1-bit subtractor\n    subtractor_1bit SUB(A, B, Bin, D, Cout0, Bout);\n\n    // Output carry-out\n    assign Cout = Cout0;\n\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Cout, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Cout;\n    output Bout;\n\n    // Subtract and output borrow\n    assign {Bout, D} = A - B - Bin;\n\n    // Output carry-out\n    assign Cout = (A < B) || (A == B && Bin);\n\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_product_bit GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_product_bit GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_product_bit GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_product_bit GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_product_bit GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_product_bit GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_product_bit GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_shift(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_shift_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_shift_shift(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_shift_shift_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift_shift_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift_shift_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift_shift_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift_shift_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift_shift_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift_shift_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift_shift_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate wires and registers\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\nwire [3:0] counter;\nwire [3:0] shift_reg;\nwire [15:0] shifted_quotient;\nwire [15:0] shifted_remainder;\nwire [15:0] final_result;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .abs_value(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .neg_value(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .shifted_quotient(shifted_quotient),\n    .shifted_remainder(shifted_remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .counter(counter),\n    .shifted_quotient(shifted_quotient),\n    .shifted_remainder(shifted_remainder),\n    .final_result(final_result),\n    .result(result),\n    .res_valid(res_valid)\n);\n\n// Assigning the final result\nassign remainder = (sign) ? (dividend - shifted_remainder) : (dividend + shifted_remainder);\nassign quotient = shifted_quotient;\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] abs_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        abs_value <= 8'd0;\n    end else begin\n        if (sign) begin\n            abs_value <= -value;\n        end else begin\n            abs_value <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negating the divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] neg_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        neg_value <= 8'd0;\n    end else begin\n        if (sign) begin\n            neg_value <= value;\n        end else begin\n            neg_value <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [3:0] shift_reg,\n    output reg [15:0] shifted_quotient,\n    output reg [15:0] shifted_remainder\n);\n\nreg [3:0] counter_reg;\nreg [3:0] shift_reg_reg;\nreg [15:0] shifted_quotient_reg;\nreg [15:0] shifted_remainder_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter_reg <= 4'd0;\n        shift_reg_reg <= 4'd0;\n        shifted_quotient_reg <= 16'd0;\n        shifted_remainder_reg <= 16'd0;\n    end else begin\n        if (opn_valid) begin\n            counter_reg <= 4'd0;\n            shift_reg_reg <= 4'd0;\n            shifted_quotient_reg <= 16'd0;\n            shifted_remainder_reg <= 16'd0;\n        end else begin\n            if (counter_reg < 4'd10) begin\n                counter_reg <= counter_reg + 4'd1;\n                shift_reg_reg <= shift_reg_reg + 4'd1;\n                shifted_quotient_reg <= shifted_quotient_reg + (1 << shift_reg_reg);\n                shifted_remainder_reg <= shifted_remainder_reg - (1 << shift_reg_reg);\n            end\n        end\n    end\nend\n\nassign counter = counter_reg;\nassign shift_reg = shift_reg_reg;\nassign shifted_quotient = shifted_quotient_reg;\nassign shifted_remainder = shifted_remainder_reg;\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [15:0] shifted_quotient,\n    input wire [15:0] shifted_remainder,\n    input wire [15:0] final_result,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 16'd0;\n        res_valid <= 1'b0;\n    end else begin\n        if (res_ready) begin\n            result <= 16'd0;\n            res_valid <= 1'b0;\n        end else begin\n            if (counter == 4'd10) begin\n                result <= final_result;\n                res_valid <= 1'b1;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] AS0, AS1, AS2, AS3, AS4, AS5, AS6, AS7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.X(X), .Y(Y[0]), .shift(0), .accumulator(AS0));\n    add_shift AS1(.X(X), .Y(Y[1]), .shift(1), .accumulator(AS1));\n    add_shift AS2(.X(X), .Y(Y[2]), .shift(2), .accumulator(AS2));\n    add_shift AS3(.X(X), .Y(Y[3]), .shift(3), .accumulator(AS3));\n    add_shift AS4(.X(X), .Y(Y[4]), .shift(4), .accumulator(AS4));\n    add_shift AS5(.X(X), .Y(Y[5]), .shift(5), .accumulator(AS5));\n    add_shift AS6(.X(X), .Y(Y[6]), .shift(6), .accumulator(AS6));\n    add_shift AS7(.X(X), .Y(Y[7]), .shift(7), .accumulator(AS7));\n\n    // Assign the product\n    assign P = AS0 + AS1 + AS2 + AS3 + AS4 + AS5 + AS6 + AS7;\n\nendmodule\n\nmodule add_shift(X, Y, shift, accumulator);\n    input [7:0] X;\n    input Y;\n    input [3:0] shift;\n    output [15:0] accumulator;\n\n    wire [15:0] shifted_X;\n\n    assign shifted_X = X << shift;\n\n    // Add the shifted X to the accumulator\n    assign accumulator = shifted_X + (Y << shift);\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Carry_in(1'b0), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Carry_in(carry[0]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Carry_in(carry[1]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Carry_in(carry[2]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    input Carry_in,   // Carry input\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Carry_in(Carry_in), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Carry_in(carry[0]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Carry_in(carry[1]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Carry_in(carry[2]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    input Carry_in,   // Carry input\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Carry_in(Carry_in), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Carry_in(carry[0]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    input Carry_in,   // Carry input\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa(.X(X), .Y(Y), .Carry_in(Carry_in), .Sum(Sum), .Carry_out(Carry_out));\n\nendmodule\n\nmodule full_adder(\n    input X,    // First input operand\n    input Y,    // Second input operand\n    input Carry_in,   // Carry input\n    output Sum, // Output sum\n    output Carry_out  // Carry output\n);\n\n    wire c1, c2;\n\n    // Perform addition\n    assign Sum = X ^ Y ^ Carry_in;\n    assign c1 = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n    assign Carry_out = c1 | (X & Y);\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodules\n    wire [3:0] init_out;\n    wire [3:0] increment_out;\n\n    // Instantiate the initialization submodule\n    initializer init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the increment submodule\n    incrementer increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .increment_out(increment_out)\n    );\n\n    // Assign the output\n    assign out = increment_out;\n\nendmodule\n\n// Submodule for initialization\nmodule initializer (\n    input wire reset,\n    output reg [3:0] out\n);\n\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\n\nendmodule\n\n// Submodule for incrementing\nmodule incrementer (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] increment_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            increment_out <= 4'b0000;\n        end else begin\n            increment_out <= init_out + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the results\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepend 16 zeros to the dividend\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        remainder = dividend; // Initialize remainder\n        quotient = 0; // Initialize quotient\n\n        // Perform division algorithm\n        // ...\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry_chain;\n\n    // Instantiate 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_chain[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_chain[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_chain[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_chain[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_chain[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_chain[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_counter init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    increment_counter increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .count_out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_counter (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end\n    end\nendmodule\n\nmodule increment_counter (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= init_out;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [31:0] divisor  // 32-bit divisor\n);\n    // Adjust the bit widths of dividend and divisor\n    assign dividend = { {16{1'b0}}, A };\n    assign divisor = { {16{1'b0}}, B };\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [31:0] divisor, // 32-bit divisor\n    output reg [31:0] quotient, // 32-bit quotient\n    output reg [31:0] remainder  // 32-bit remainder\n);\n    integer i;\n\n    // Perform division operation\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        for (i = 0; i < 32; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = quotient << 1;\n                quotient = quotient | 1'b1;\n            end else begin\n                quotient = quotient << 1;\n                quotient = quotient | 1'b0;\n            end\n            divisor = divisor << 1;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .current_count(count),\n        .next_count(next_count),\n        .up_down(up_down)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    output wire [15:0] next_count,\n    input wire up_down\n);\n    assign next_count = up_down ? current_count + 1 : current_count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 0;\n        end else begin\n            next_count <= current_count;\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiate the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [15:0] shifted_dividend;\nreg [7:0] shifted_divisor;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\n\ninteger i;\n\nalways @(*) begin\n    // Initialize variables\n    dividend = A;\n    divisor = B;\n    shifted_dividend = {16{1'b0}};\n    shifted_divisor = {8{1'b0}};\n    temp_quotient = {16{1'b0}};\n    temp_remainder = {16{1'b0}};\n\n    // Shift dividend and divisor\n    for (i = 0; i < 16; i = i + 1) begin\n        shifted_dividend[i] = dividend[15 - i];\n        shifted_divisor[i] = divisor[7 - i];\n    end\n\n    // Perform division\n    for (i = 0; i < 16; i = i + 1) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            temp_quotient[i] = 1;\n            temp_remainder = shifted_dividend - shifted_divisor;\n        end else begin\n            temp_quotient[i] = 0;\n            temp_remainder = shifted_dividend;\n        end\n\n        shifted_dividend = temp_remainder;\n    end\n\n    // Update quotient and remainder\n    quotient = temp_quotient;\n    remainder = temp_remainder;\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for output\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       sub_borrow;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    initial_state init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate add_shift modules\n    add_shift AS0(.A0(A0), .A1(A1), .A2(A2), .A3(A3), .A4(A4), .A5(A5), .A6(A6), .A7(A7), .X(X), .Y(Y));\n\n    // Assign the product\n    assign P = A7;\n\nendmodule\n\nmodule add_shift(A0, A1, A2, A3, A4, A5, A6, A7, X, Y);\n    input [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n    input [7:0] X, Y;\n\n    wire [15:0] A0_out, A1_out, A2_out, A3_out, A4_out, A5_out, A6_out, A7_out;\n\n    // Instantiate shift_left modules\n    shift_left SL0(.A0(A0), .A1(A1), .A2(A2), .A3(A3), .A4(A4), .A5(A5), .A6(A6), .A7(A7), .X(X), .Y(Y[0]));\n    shift_left SL1(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A0), .Y(Y[1]));\n    shift_left SL2(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A1), .Y(Y[2]));\n    shift_left SL3(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A2), .Y(Y[3]));\n    shift_left SL4(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A3), .Y(Y[4]));\n    shift_left SL5(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A4), .Y(Y[5]));\n    shift_left SL6(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A5), .Y(Y[6]));\n    shift_left SL7(.A0(A0_out), .A1(A1_out), .A2(A2_out), .A3(A3_out), .A4(A4_out), .A5(A5_out), .A6(A6_out), .A7(A7_out), .X(A6), .Y(Y[7]));\n\n    // Assign the final product\n    assign A7_out = A7;\n\nendmodule\n\nmodule shift_left(A0, A1, A2, A3, A4, A5, A6, A7, X, Y);\n    input [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n    input [7:0] X, Y;\n\n    wire [15:0] A0_out, A1_out, A2_out, A3_out, A4_out, A5_out, A6_out, A7_out;\n\n    // Instantiate add_shift_bit modules\n    add_shift_bit AS0(.A0(A0), .A1(A1), .A2(A2), .A3(A3), .A4(A4), .A5(A5), .A6(A6), .A7(A7), .X(X), .Y(Y));\n\n    // Assign the final product\n    assign A0_out = A0;\n    assign A1_out = A1;\n    assign A2_out = A2;\n    assign A3_out = A3;\n    assign A4_out = A4;\n    assign A5_out = A5;\n    assign A6_out = A6;\n    assign A7_out = A7;\n\nendmodule\n\nmodule add_shift_bit(A0, A1, A2, A3, A4, A5, A6, A7, X, Y);\n    input [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n    input [7:0] X, Y;\n\n    wire [15:0] A0_out, A1_out, A2_out, A3_out, A4_out, A5_out, A6_out, A7_out;\n\n    // Instantiate add_shift_bit_core modules\n    add_shift_bit_core AS0(.A0(A0), .A1(A1), .A2(A2), .A3(A3), .A4(A4), .A5(A5), .A6(A6), .A7(A7), .X(X), .Y(Y));\n\n    // Assign the final product\n    assign A0_out = A0;\n    assign A1_out = A1;\n    assign A2_out = A2;\n    assign A3_out = A3;\n    assign A4_out = A4;\n    assign A5_out = A5;\n    assign A6_out = A6;\n    assign A7_out = A7;\n\nendmodule\n\nmodule add_shift_bit_core(A0, A1, A2, A3, A4, A5, A6, A7, X, Y);\n    input [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n    input [7:0] X, Y;\n\n    wire [15:0] A0_out, A1_out, A2_out, A3_out, A4_out, A5_out, A6_out, A7_out;\n\n    // Perform addition based on Y bit\n    assign A0_out = (Y) ? (A0 + X) : A0;\n    assign A1_out = (Y) ? (A1 + X) : A1;\n    assign A2_out = (Y) ? (A2 + X) : A2;\n    assign A3_out = (Y) ? (A3 + X) : A3;\n    assign A4_out = (Y) ? (A4 + X) : A4;\n    assign A5_out = (Y) ? (A5 + X) : A5;\n    assign A6_out = (Y) ? (A6 + X) : A6;\n    assign A7_out = (Y) ? (A7 + X) : A7;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate the adder and subtractor modules\n    adder add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry(add_carry)\n    );\n\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow(sub_borrow)\n    );\n\n    and_gate and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry\n);\n    assign {carry, result} = A + B;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow\n);\n    assign {borrow, result} = A - B;\nendmodule\n\n// Bitwise AND module\nmodule and_gate(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Assign the output\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire carry;          // Carry output from the full adder\n\n    // Generate the 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Perform subtraction using full adder\n    full_adder adder_inst (\n        .a(A),\n        .b(B_comp),\n        .carry_in(1'b0),\n        .sum(sum),\n        .carry_out(carry)\n    );\n\n    // Assign the output\n    assign D = sum;\n    assign B_out = carry;\n\nendmodule\n\nmodule full_adder(a, b, carry_in, sum, carry_out);\n    input a, b, carry_in;\n    output sum, carry_out;\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (carry_in & (a ^ b));\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for a single data path\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            1'b0: data_out <= data_in;\n            1'b1: data_out <= data_in;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_out;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .count_out(count_out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_out == 4'd11) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n    always @(posedge rst_n or negedge valid_count) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out, mux1_out, mux2_out;\n\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .out(mux0_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .out(mux1_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .out(mux2_out)\n    );\n\n    // Output selection\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'b00000000;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            1'b0: out <= d0;\n            1'b1: out <= d1;\n            default: out <= 8'b00000000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the difference of A and B\n    output B_out;       // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;    // Intermediate sum\n    wire carry_out;     // Carry output from the full adder\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder module instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry_out(carry_out)\n    );\n\n    // Output assignment\n    assign D = sum[7:0];\n    assign B_out = carry_out;\nendmodule\n\nmodule adder_8bit(A, B, sum, carry_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [8:0] sum;   // 9-bit sum output\n    output carry_out;   // Carry output indicating if a carry was generated\n\n    wire [8:0] temp_sum; // Temporary sum\n\n    // Full adder instantiation\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(1'b0),\n        .Sum(temp_sum[0]),\n        .Cout(temp_sum[1])\n    );\n\n    // Additional full adders for the remaining bits\n    genvar i;\n    generate\n        for (i = 1; i < 8; i = i + 1) begin: adder_loop\n            full_adder fa_inst(\n                .A(A[i]),\n                .B(B[i]),\n                .Cin(temp_sum[i-1]),\n                .Sum(temp_sum[i]),\n                .Cout(temp_sum[i+1])\n            );\n        end\n    endgenerate\n\n    // Final carry out\n    assign carry_out = temp_sum[8];\n\n    // Assign sum\n    assign sum = temp_sum;\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift and AND operations\n    assign p0_0 = X[0] & Y[0];\n    assign p0_1 = X[0] & Y[1];\n    assign p0_2 = X[0] & Y[2];\n    assign p0_3 = X[0] & Y[3];\n\n    assign p1_0 = X[1] & Y[0];\n    assign p1_1 = X[1] & Y[1];\n    assign p1_2 = X[1] & Y[2];\n    assign p1_3 = X[1] & Y[3];\n\n    assign p2_0 = X[2] & Y[0];\n    assign p2_1 = X[2] & Y[1];\n    assign p2_2 = X[2] & Y[2];\n    assign p2_3 = X[2] & Y[3];\n\n    assign p3_0 = X[3] & Y[0];\n    assign p3_1 = X[3] & Y[1];\n    assign p3_2 = X[3] & Y[2];\n    assign p3_3 = X[3] & Y[3];\n\n    // Adders\n    adder_8bit add1(.a(p0_0), .b(p0_1), .c(p0_2), .d(p0_3), .sum(p0));\n    adder_8bit add2(.a(p1_0), .b(p1_1), .c(p1_2), .d(p1_3), .sum(p1));\n    adder_8bit add3(.a(p2_0), .b(p2_1), .c(p2_2), .d(p2_3), .sum(p2));\n    adder_8bit add4(.a(p3_0), .b(p3_1), .c(p3_2), .d(p3_3), .sum(p3));\n\n    // Final sum\n    assign P = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, d, sum);\n    input [3:0] a, b, c, d;\n    output [7:0] sum;\n    wire [7:0] sum_0, sum_1, sum_2;\n\n    // Full adder\n    full_adder fa0(.a(a[0]), .b(b[0]), .c(c[0]), .sum(sum_0[0]), .carry(sum_0[1]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c(c[1]), .sum(sum_0[2]), .carry(sum_0[3]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c(c[2]), .sum(sum_0[4]), .carry(sum_0[5]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c(c[3]), .sum(sum_0[6]), .carry(sum_0[7]));\n\n    // Carry chain\n    full_adder fa4(.a(sum_0[1]), .b(sum_0[3]), .c(sum_0[5]), .sum(sum_1[0]), .carry(sum_1[1]));\n    full_adder fa5(.a(sum_0[2]), .b(sum_0[4]), .c(sum_0[6]), .sum(sum_1[2]), .carry(sum_1[3]));\n    full_adder fa6(.a(sum_0[5]), .b(sum_0[7]), .c(1'b0), .sum(sum_2[0]), .carry(sum_2[1]));\n\n    // Final sum\n    assign sum = {sum_2[1:0], sum_1[1:0], sum_0[1:0]};\n\nendmodule\n\nmodule full_adder(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n    assign {carry, sum} = a + b + c;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_out;\n    wire [7:0] hold0_in;\n    data_hold hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(hold0_out),\n        .in_hold(hold0_in)\n    );\n\n    // Submodule for holding data from input 1\n    wire [7:0] hold1_out;\n    wire [7:0] hold1_in;\n    data_hold hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(hold1_out),\n        .in_hold(hold1_in)\n    );\n\n    // Submodule for holding data from input 2\n    wire [7:0] hold2_out;\n    wire [7:0] hold2_in;\n    data_hold hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(hold2_out),\n        .in_hold(hold2_in)\n    );\n\n    // Submodule for holding data from input 3\n    wire [7:0] hold3_out;\n    wire [7:0] hold3_in;\n    data_hold hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(hold3_out),\n        .in_hold(hold3_in)\n    );\n\n    // Output assignment\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                 hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out,\n    output reg [7:0] in_hold\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            out <= in;\n            in_hold <= in;\n        end else begin\n            out <= out;\n            in_hold <= in_hold;\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]       next_Q\n);\n\n    assign next_Q = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift operations\n    assign p0_0 = X[0] & Y[0];\n    assign p0_1 = X[0] & Y[1];\n    assign p0_2 = X[0] & Y[2];\n    assign p0_3 = X[0] & Y[3];\n\n    assign p1_0 = X[1] & Y[0];\n    assign p1_1 = X[1] & Y[1];\n    assign p1_2 = X[1] & Y[2];\n    assign p1_3 = X[1] & Y[3];\n\n    assign p2_0 = X[2] & Y[0];\n    assign p2_1 = X[2] & Y[1];\n    assign p2_2 = X[2] & Y[2];\n    assign p2_3 = X[2] & Y[3];\n\n    assign p3_0 = X[3] & Y[0];\n    assign p3_1 = X[3] & Y[1];\n    assign p3_2 = X[3] & Y[2];\n    assign p3_3 = X[3] & Y[3];\n\n    // Adders\n    adder_8bit add1(.a(p0_0), .b(p0_1), .c(p0_2), .d(p0_3), .sum(p0));\n    adder_8bit add2(.a(p1_0), .b(p1_1), .c(p1_2), .d(p1_3), .sum(p1));\n    adder_8bit add3(.a(p2_0), .b(p2_1), .c(p2_2), .d(p2_3), .sum(p2));\n    adder_8bit add4(.a(p3_0), .b(p3_1), .c(p3_2), .d(p3_3), .sum(p3));\n\n    // Final sum\n    assign P = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, d, sum);\n    input a, b, c, d;\n    output sum;\n    assign sum = a ^ b ^ c ^ d;\nendmodule\n\nmodule full_adder_8bit(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n    assign {carry, sum} = a + b + c;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                 hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= in;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input           clk,\n    input           rst_n,\n    output reg [63:0] Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input   [63:0] Q,\n    output  reg [63:0] Q_next\n);\n\n    always @(*) begin\n        Q_next = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_diff;\n    wire [15:0] S2_diff;\n    wire S1_borrow;\n    wire S2_borrow;\n\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_diff),\n        .Borrow_out(S1_borrow)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_diff),\n        .Borrow_out(S2_borrow)\n    );\n\n    assign Diff = {S2_diff, S1_diff};\n    assign B_out = S2_borrow;\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output Borrow_out;    // Borrow-out output\n\n    wire [14:0] S_diff;\n    wire S_borrow;\n\n    sub_8bit S1(\n        .A(A[14:0]),\n        .B(B[14:0]),\n        .Diff(S_diff),\n        .Borrow_out(S_borrow)\n    );\n\n    assign Diff = {S_diff, A[15] ^ B[15]};\n    assign Borrow_out = S_borrow;\nendmodule\n\nmodule sub_8bit(A, B, Diff, Borrow_out);\n    input [7:0] A;        // 8-bit input A\n    input [7:0] B;        // 8-bit input B\n    output [7:0] Diff;    // 8-bit difference output\n    output Borrow_out;    // Borrow-out output\n\n    wire [6:0] S_diff;\n    wire S_borrow;\n\n    sub_4bit S1(\n        .A(A[6:0]),\n        .B(B[6:0]),\n        .Diff(S_diff),\n        .Borrow_out(S_borrow)\n    );\n\n    assign Diff = {S_diff, A[7] ^ B[7]};\n    assign Borrow_out = S_borrow;\nendmodule\n\nmodule sub_4bit(A, B, Diff, Borrow_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    output [3:0] Diff;    // 4-bit difference output\n    output Borrow_out;    // Borrow-out output\n\n    wire [2:0] S_diff;\n    wire S_borrow;\n\n    sub_2bit S1(\n        .A(A[2:0]),\n        .B(B[2:0]),\n        .Diff(S_diff),\n        .Borrow_out(S_borrow)\n    );\n\n    assign Diff = {S_diff, A[3] ^ B[3]};\n    assign Borrow_out = S_borrow;\nendmodule\n\nmodule sub_2bit(A, B, Diff, Borrow_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    output [1:0] Diff;    // 2-bit difference output\n    output Borrow_out;    // Borrow-out output\n\n    wire [0] S_diff;\n    wire S_borrow;\n\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S_diff),\n        .Borrow_out(S_borrow)\n    );\n\n    assign Diff = {S_diff, A[1] ^ B[1]};\n    assign Borrow_out = S_borrow;\nendmodule\n\nmodule sub_1bit(A, B, Diff, Borrow_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output Diff;          // 1-bit difference output\n    output Borrow_out;    // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign Borrow_out = 0;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [3:0] shifted_X;\n    wire [3:0] shifted_Y;\n\n    // Shift X left by 0, 1, 2, and 3 positions\n    shift_left shift_0(\n        .x(X),\n        .shift(0),\n        .y(shifted_X)\n    );\n    shift_left shift_1(\n        .x(X),\n        .shift(1),\n        .y(shifted_X)\n    );\n    shift_left shift_2(\n        .x(X),\n        .shift(2),\n        .y(shifted_X)\n    );\n    shift_left shift_3(\n        .x(X),\n        .shift(3),\n        .y(shifted_X)\n    );\n\n    // Shift Y left by 0, 1, 2, and 3 positions\n    shift_left shift_y_0(\n        .x(Y),\n        .shift(0),\n        .y(shifted_Y)\n    );\n    shift_left shift_y_1(\n        .x(Y),\n        .shift(1),\n        .y(shifted_Y)\n    );\n    shift_left shift_y_2(\n        .x(Y),\n        .shift(2),\n        .y(shifted_Y)\n    );\n    shift_left shift_y_3(\n        .x(Y),\n        .shift(3),\n        .y(shifted_Y)\n    );\n\n    // Adders\n    adder_4bit adder_0(\n        .x(shifted_X),\n        .y(shifted_Y),\n        .sum(P[0])\n    );\n    adder_4bit adder_1(\n        .x(shifted_X),\n        .y(shifted_y_1),\n        .sum(P[1])\n    );\n    adder_4bit adder_2(\n        .x(shifted_x_2),\n        .y(shifted_y_2),\n        .sum(P[2])\n    );\n    adder_4bit adder_3(\n        .x(shifted_x_3),\n        .y(shifted_y_3),\n        .sum(P[3])\n    );\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;\n    input [3:0] y;\n    output sum;\n    assign sum = x[0] ^ y[0];\nendmodule\n\nmodule shift_left(x, shift, y);\n    input [3:0] x;\n    input [1:0] shift;\n    output [3:0] y;\n    assign y = (shift == 0) ? x : (shift == 1) ? {x[2:0], 1'b0} : (shift == 2) ? {x[1:0], 2'b00} : {x[0], 3'b000};\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignment\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [3:0] shifted_X;\n    wire [3:0] shifted_Y;\n\n    // Shift X left by 1 bit\n    assign shifted_X[0] = X[0];\n    assign shifted_X[1] = X[0];\n    assign shifted_X[2] = X[0];\n    assign shifted_X[3] = X[0];\n\n    // Shift Y left by 1 bit\n    assign shifted_Y[0] = Y[0];\n    assign shifted_Y[1] = Y[0];\n    assign shifted_Y[2] = Y[0];\n    assign shifted_Y[3] = Y[0];\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(X), .y(Y), .sum(P[0]));\n    adder_4bit adder_1(.x(shifted_X), .y(Y), .sum(P[1]));\n    adder_4bit adder_2(.x(shifted_X), .y(shifted_Y), .sum(P[2]));\n    adder_4bit adder_3(.x(shifted_X), .y(shifted_Y), .sum(P[3]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;\n    input [3:0] y;\n    output sum;\n\n    assign sum = x[0] ^ y[0];\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            counter <= counter + 1;\n        end else begin\n            pwm_out <= 1'b0;\n            counter <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    // Instantiate the frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical submodule\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical submodule\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] comp8_out1, comp8_out2, comp8_out3, comp8_out4;\n\n    // Instantiate 8-bit comparators\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(comp8_out1)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(comp8_out2)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(comp8_out3)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(comp8_out4)\n    );\n\n    // Combine outputs\n    assign equal = comp8_out1 & comp8_out2 & comp8_out3 & comp8_out4;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] A15, B15, Diff15, B_out15;\n    wire [15:0] A14, B14, Diff14, B_out14;\n\n    // Instantiate 16-bit subtractors for the high and low 16-bit parts\n    sub_16bit S1 (.A(A[31:16]), .B(B[31:16]), .Diff(Diff15), .B_out(B_out15));\n    sub_16bit S2 (.A(A[15:0]), .B(B[15:0]), .Diff(Diff14), .B_out(B_out14));\n\n    // Combine the outputs\n    assign Diff = {Diff15, Diff14};\n    assign B_out = {B_out15, B_out14};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [7:0] A7, B7, Diff7, B_out7;\n    wire [7:0] A6, B6, Diff6, B_out6;\n    wire [7:0] A5, B5, Diff5, B_out5;\n    wire [7:0] A4, B4, Diff4, B_out4;\n    wire [7:0] A3, B3, Diff3, B_out3;\n    wire [7:0] A2, B2, Diff2, B_out2;\n    wire [7:0] A1, B1, Diff1, B_out1;\n\n    // Instantiate 8-bit subtractors for the high and low 8-bit parts\n    sub_8bit S1 (.A(A[15:8]), .B(B[15:8]), .Diff(Diff7), .B_out(B_out7));\n    sub_8bit S2 (.A(A[7:0]), .B(B[7:0]), .Diff(Diff6), .B_out(B_out6));\n    sub_8bit S3 (.A(A[13:8]), .B(B[13:8]), .Diff(Diff5), .B_out(B_out5));\n    sub_8bit S4 (.A(A[11:8]), .B(B[11:8]), .Diff(Diff4), .B_out(B_out4));\n    sub_8bit S5 (.A(A[9:8]), .B(B[9:8]), .Diff(Diff3), .B_out(B_out3));\n    sub_8bit S6 (.A(A[7:8]), .B(B[7:8]), .Diff(Diff2), .B_out(B_out2));\n    sub_8bit S7 (.A(A[5:8]), .B(B[5:8]), .Diff(Diff1), .B_out(B_out1));\n\n    // Combine the outputs\n    assign Diff = {Diff7, Diff6, Diff5, Diff4, Diff3, Diff2, Diff1};\n    assign B_out = {B_out7, B_out6, B_out5, B_out4, B_out3, B_out2, B_out1};\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input A\n    input [7:0] B;        // 8-bit input B\n    output [7:0] Diff;    // 8-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:0] A3, B3, Diff3, B_out3;\n    wire [3:0] A2, B2, Diff2, B_out2;\n    wire [3:0] A1, B1, Diff1, B_out1;\n\n    // Instantiate 4-bit subtractors for the high and low 4-bit parts\n    sub_4bit S1 (.A(A[7:4]), .B(B[7:4]), .Diff(Diff3), .B_out(B_out3));\n    sub_4bit S2 (.A(A[3:0]), .B(B[3:0]), .Diff(Diff2), .B_out(B_out2));\n    sub_4bit S3 (.A(A[6:4]), .B(B[6:4]), .Diff(Diff1), .B_out(B_out1));\n\n    // Combine the outputs\n    assign Diff = {Diff3, Diff2, Diff1};\n    assign B_out = {B_out3, B_out2, B_out1};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [1:0] A1, B1, Diff1, B_out1;\n    wire [1:0] A0, B0, Diff0, B_out0;\n\n    // Instantiate 2-bit subtractors for the high and low 2-bit parts\n    sub_2bit S1 (.A(A[3:2]), .B(B[3:2]), .Diff(Diff1), .B_out(B_out1));\n    sub_2bit S2 (.A(A[1:0]), .B(B[1:0]), .Diff(Diff0), .B_out(B_out0));\n\n    // Combine the outputs\n    assign Diff = {Diff1, Diff0};\n    assign B_out = {B_out1, B_out0};\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [0:0] A0, B0, Diff0, B_out0;\n    wire [0:0] A1, B1, Diff1, B_out1;\n\n    // Instantiate 1-bit subtractors for the high and low 1-bit parts\n    sub_1bit S1 (.A(A[1]), .B(B[1]), .Diff(Diff1), .B_out(B_out1));\n    sub_1bit S2 (.A(A[0]), .B(B[0]), .Diff(Diff0), .B_out(B_out0));\n\n    // Combine the outputs\n    assign Diff = {Diff1, Diff0};\n    assign B_out = {B_out1, B_out0};\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    output Diff;           // 1-bit difference output\n    output B_out;          // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator\n    assign clk_average[0] = counter_out[0];\n    assign clk_average[1] = counter_out[1];\n    assign clk_average[2] = counter_out[2];\n    assign clk_average[3] = counter_out[3];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = ~counter_out[0];\n    assign clk_adjusted[1] = ~counter_out[1];\n    assign clk_adjusted[2] = ~counter_out[2];\n    assign clk_adjusted[3] = ~counter_out[3];\n\n    // Logical OR operation for final output\n    assign clk_div = clk_average[0] | clk_adjusted[0] | clk_average[1] | clk_adjusted[1] | clk_average[2] | clk_adjusted[2] | clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else\n            count_out <= count_out + 1;\n    end\nendmodule\n\nmodule clk_average(\n    input [3:0] clk_in,\n    output [3:0] clk_out\n);\n    assign clk_out[0] = clk_in[0];\n    assign clk_out[1] = clk_in[1];\n    assign clk_out[2] = clk_in[2];\n    assign clk_out[3] = clk_in[3];\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk_in,\n    output [3:0] clk_out\n);\n    assign clk_out[0] = ~clk_in[0];\n    assign clk_out[1] = ~clk_in[1];\n    assign clk_out[2] = ~clk_in[2];\n    assign clk_out[3] = ~clk_in[3];\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND_RESULT\n);\n    assign AND_RESULT = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR_RESULT\n);\n    assign OR_RESULT = A | B;\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_low, a_high, b_low, b_high;\n    wire [7:0] a_low_equal, a_high_equal, b_low_equal, b_high_equal;\n\n    // Split 32-bit inputs into 8-bit sections\n    assign a_low = a[7:0];\n    assign a_high = a[15:8];\n    assign b_low = b[7:0];\n    assign b_high = b[15:8];\n\n    // Instantiate 8-bit comparators\n    comparator_8bit comp8_inst1 (.a(a_low), .b(b_low), .equal(a_low_equal));\n    comparator_8bit comp8_inst2 (.a(a_high), .b(b_high), .equal(a_high_equal));\n    comparator_8bit comp8_inst3 (.a(a_low), .b(b_high), .equal(b_low_equal));\n    comparator_8bit comp8_inst4 (.a(a_high), .b(b_low), .equal(b_high_equal));\n\n    // Combine results\n    assign equal = a_low_equal & a_high_equal & b_low_equal & b_high_equal;\n\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "`define ADD 2'b00\n`define SUBTRACT 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", a, b, sum);\nsubtractor subtractor (\"-\", a, b, diff);\nand_module and_op (\"AND\", a, b, and_result);\nor_module or_op (\"OR\", a, b, or_result);\n\nalways @(*) begin\n    case(op)\n        `ADD: result = sum;\n        `SUBTRACT: result = diff;\n        `AND: result = and_result;\n        `OR: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4, clk_3;\n    reg [2:0] counter;\n    wire [2:0] counter_limit = MUL2_DIV_CLK - 1;\n\n    // Counter module\n    counter_module u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter)\n    );\n\n    // Clock average generator module\n    clk_average u_clk_average (\n        .clk(clk),\n        .counter_value(counter),\n        .clk_4(clk_4),\n        .clk_3(clk_3)\n    );\n\n    // Clock adjustment module\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .clk_4(clk_4),\n        .clk_3(clk_3)\n    );\n\n    // Logical OR for final output\n    assign clk_div = clk_4 | clk_3;\n\nendmodule\n\n// Counter module\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg [2:0] counter_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_out <= 0;\n        end else begin\n            if (counter_out == counter_limit) begin\n                counter_out <= 0;\n            end else begin\n                counter_out <= counter_out + 1;\n            end\n        end\n    end\nendmodule\n\n// Clock average generator module\nmodule clk_average(\n    input clk,\n    input [2:0] counter_value,\n    output reg clk_4,\n    output reg clk_3\n);\n    always @(posedge clk) begin\n        case(counter_value)\n            0: begin\n                clk_4 <= 0;\n                clk_3 <= 0;\n            end\n            1: begin\n                clk_4 <= 1;\n                clk_3 <= 0;\n            end\n            2: begin\n                clk_4 <= 1;\n                clk_3 <= 1;\n            end\n            3: begin\n                clk_4 <= 0;\n                clk_3 <= 1;\n            end\n            4: begin\n                clk_4 <= 1;\n                clk_3 <= 0;\n            end\n            5: begin\n                clk_4 <= 1;\n                clk_3 <= 1;\n            end\n            6: begin\n                clk_4 <= 0;\n                clk_3 <= 1;\n            end\n            default: begin\n                clk_4 <= 0;\n                clk_3 <= 0;\n            end\n        endcase\n    end\nendmodule\n\n// Clock adjustment module\nmodule clk_adjustment(\n    input clk,\n    input clk_4,\n    input clk_3\n);\n    assign clk_4 = clk_4 ^ clk;\n    assign clk_3 = clk_3 ^ clk;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub32 sub1(.A(A[63:32]), .B(B[63:32]), .B_out(B_out_32));\n\n    sub16 sub2(.A(B_out_32[15:0]), .B(B_out_32[31:16]), .B_out(B_out_16));\n    sub16 sub3(.A(B_out_32[63:48]), .B(B_out_32[95:64]), .B_out(B_out_16));\n\n    sub8 sub4(.A(B_out_16[7:0]), .B(B_out_16[15:8]), .B_out(B_out_8));\n    sub8 sub5(.A(B_out_16[23:16]), .B(B_out_16[31:24]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_32, B_out_32, B_out_32, B_out_32, B_out_32, B_out_32, B_out_32, B_out_32};\n    assign B_out = B_out_32[31];\n\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub2(.A(B[15:0]), .B(B[31:16]), .B_out(B_out_16));\n    sub16 sub3(.A(B[63:48]), .B(B[95:64]), .B_out(B_out_16));\n\n    sub8 sub4(.A(B_out_16[7:0]), .B(B_out_16[15:8]), .B_out(B_out_8));\n    sub8 sub5(.A(B_out_16[23:16]), .B(B_out_16[31:24]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub2(.A(B[7:0]), .B(B[15:8]), .B_out(B_out_8));\n    sub8 sub3(.A(B[23:16]), .B(B[31:24]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8, B_out_8};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result\n);\n    assign result = (op_code == `ADD_OP) ? data_a + data_b :\n                    (op_code == `SUB_OP) ? data_a - data_b :\n                    (op_code == `AND_OP) ? data_a & data_b :\n                    (op_code == `OR_OP) ? data_a | data_b : 4'b0000;\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output zero\n);\n    assign zero = (result == 4'b0000);\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule instances\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Generate the divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\n// Result manager\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter_4bit u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk_in(clk),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 4'b1111) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk) begin\n        if (counter_out == 4'b1111) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate the arithmetic modules\n    adder add_module(\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module(\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module(\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module(\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select the operation based on the opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case(opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out[1:1]),\n        .D(D[12:1]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out[2:2]),\n        .D(D[8:1]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[3:3]),\n        .D(D[4:1]),\n        .B_out(b_out[4:4])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[4:4];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out[2:2])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[2:2];\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 1-bit full subtractors\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1:1];\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in\n    output D;             // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out\n\n    // Subtraction operation\n    assign D = A - B - C_in;\n    assign B_out = (A < B) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] count;\nwire count_limit;\n\n// Instantiate the counter module\ncounter_even u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count),\n    .count_limit(count_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count,\n    output count_limit\n);\n    parameter NUM_DIV = 4; // Even number divisor\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else begin\n            if (count == NUM_DIV / 2 - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign count_limit = (count == NUM_DIV / 2 - 1);\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] count,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (count == 0) begin\n                clk_div <= 1;\n            end else begin\n                clk_div <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .result(add_result),\n    .valid(valid)\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result),\n    .valid(valid)\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result),\n    .valid(valid)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a + b;\n    assign valid = 1;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a - b;\n    assign valid = 1;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a * b;\n    assign valid = 1;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a / b;\n    assign valid = (b != 0);\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .D(D[16:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .D(D[12:8]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .D(D[8:4]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out[4:4])\n    );\n\n    // Combine borrow-out signals\n    assign B_out = {b_out[3:1], b_out[4:4]};\n\nendmodule\n\nmodule sub4(A, B, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    output [3:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(b_out[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out[2:2])\n    );\n\n    // Combine borrow-out signals\n    assign B_out = {b_out[2:1], b_out[2:2]};\n\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out\n\n    // Instantiate 1-bit subtractor\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out)\n    );\n\n    // Combine borrow-out signals\n    assign B_out = {b_out, b_out};\n\nendmodule\n\nmodule sub1(A, B, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output D;             // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out\n\n    // Subtract A and B\n    assign D = A - B;\n    assign B_out = (A < B);\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the greater, equal, or less\n    assign A_greater = (diff != 32'b0);\n    assign A_equal = (diff == 32'b0) && (borrow == 1'b0);\n    assign A_less = (diff == 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff, // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Perform subtraction\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff == 0 && borrow == 0);\n    assign A_equal = (diff == 0 && borrow == 1);\n    assign A_less = (diff != 0 && borrow == 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output borrow\n);\n\n    // Subtraction operation\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "alu", "response": "wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result;\n    wire [31:0] sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result;\n    wire [31:0] lui_result;\n    wire [31:0] result;\n    wire [31:0] carry_out;\n    wire [31:0] overflow_out;\n    wire [31:0] flag_out;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result));\n    addu addu_inst(.a(a), .b(b), .r(add_result));\n    sub sub_inst(.a(a), .b(b), .r(sub_result));\n    subu subu_inst(.a(a), .b(b), .r(sub_result));\n    and and_inst(.a(a), .b(b), .r(and_result));\n    or or_inst(.a(a), .b(b), .r(or_result));\n    xor xor_inst(.a(a), .b(b), .r(xor_result));\n    nor nor_inst(.a(a), .b(b), .r(nor_result));\n    slt slt_inst(.a(a), .b(b), .r(slt_result));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result));\n    sll sll_inst(.a(a), .b(b), .r(sll_result));\n    srl srl_inst(.a(a), .b(b), .r(srl_result));\n    sra sra_inst(.a(a), .b(b), .r(sra_result));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result));\n    srav srav_inst(.a(a), .b(b), .r(srav_result));\n    lui lui_inst(.a(a), .r(lui_result));\n\n    // Select result based on aluc\n    assign result = (aluc == 6'b100000) ? add_result :\n                    (aluc == 6'b100001) ? addu_result :\n                    (aluc == 6'b100010) ? sub_result :\n                    (aluc == 6'b100011) ? subu_result :\n                    (aluc == 6'b100100) ? and_result :\n                    (aluc == 6'b100101) ? or_result :\n                    (aluc == 6'b100110) ? xor_result :\n                    (aluc == 6'b100111) ? nor_result :\n                    (aluc == 6'b101010) ? slt_result :\n                    (aluc == 6'b101011) ? sltu_result :\n                    (aluc == 6'b000000) ? sll_result :\n                    (aluc == 6'b000010) ? srl_result :\n                    (aluc == 6'b000011) ? sra_result :\n                    (aluc == 6'b000100) ? sllv_result :\n                    (aluc == 6'b000110) ? srlv_result :\n                    (aluc == 6'b000111) ? srav_result :\n                    lui_result;\n\n    // Compute flags\n    assign carry = (aluc == 6'b100000) ? add_result[31] :\n                    (aluc == 6'b100001) ? addu_result[31] :\n                    (aluc == 6'b100010) ? sub_result[31] :\n                    (aluc == 6'b100011) ? subu_result[31] :\n                    (aluc == 6'b100100) ? and_result[31] :\n                    (aluc == 6'b100101) ? or_result[31] :\n                    (aluc == 6'b100110) ? xor_result[31] :\n                    (aluc == 6'b100111) ? nor_result[31] :\n                    (aluc == 6'b101010) ? slt_result[31] :\n                    (aluc == 6'b101011) ? sltu_result[31] :\n                    (aluc == 6'b000000) ? sll_result[31] :\n                    (aluc == 6'b000010) ? srl_result[31] :\n                    (aluc == 6'b000011) ? sra_result[31] :\n                    (aluc == 6'b000100) ? sllv_result[31] :\n                    (aluc == 6'b000110) ? srlv_result[31] :\n                    (aluc == 6'b000111) ? srav_result[31] : 0;\n\n    assign zero = (result == 0);\n    assign negative = (result[31] == 1);\n    assign overflow = (aluc == 6'b101010) ? (a[31] == b[31] && result[31] != a[31]) :\n                      (aluc == 6'b101011) ? (a[31] != b[31] && result[31] != a[31]) : 0;\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] : 0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule subu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a & b;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a | b;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a ^ b;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = ~(a | b);\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 1 : 0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 1 : 0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule sllv(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srlv(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule srav(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule lui(input [31:0] a, output [31:0] r);\n    assign r = {a[31:12], 12'b0};\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA1 CLA2 (.A(A[8:1]), .B(B[8:1]), .Cin(C16), .S(S[8:1]), .Cout(C8));\n    CLA1 CLA3 (.A(A[4:1]), .B(B[4:1]), .Cin(C8), .S(S[4:1]), .Cout(C4));\n    CLA1 CLA4 (.A(A[2:1]), .B(B[2:1]), .Cin(C4), .S(S[2:1]), .Cout(C2));\n    CLA1 CLA5 (.A(A[1:1]), .B(B[1:1]), .Cin(C2), .S(S[1:1]), .Cout(C32));\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [15:1] A,B;\n    input Cin;\n    output [15:1] S;\n    output Cout;\n\n    wire C7,C3,C1;\n\n    CLA CLA1 (.A(A[7:1]), .B(B[7:1]), .Cin(1'b0), .S(S[7:1]), .Cout(C7));\n    CLA CLA2 (.A(A[3:1]), .B(B[3:1]), .Cin(C7), .S(S[3:1]), .Cout(C3));\n    CLA CLA3 (.A(A[1:1]), .B(B[1:1]), .Cin(C3), .S(S[1:1]), .Cout(C1));\n    CLA CLA4 (.A(A[2:1]), .B(B[2:1]), .Cin(C1), .S(S[2:1]), .Cout(Cout));\nendmodule\n\nmodule CLA(A,B,Cin,S,Cout);\n    input [3:1] A,B;\n    input Cin;\n    output [3:1] S;\n    output Cout;\n\n    wire C2,C1;\n\n    CLA CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(1'b0), .S(S[2:1]), .Cout(C2));\n    CLA CLA2 (.A(A[1:1]), .B(B[1:1]), .Cin(C2), .S(S[1:1]), .Cout(C1));\n    CLA CLA3 (.A(A[0:1]), .B(B[0:1]), .Cin(C1), .S(S[0:1]), .Cout(Cout));\nendmodule\n\nmodule CLA(A,B,Cin,S,Cout);\n    input [1:1] A,B;\n    input Cin;\n    output [1:1] S;\n    output Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n    wire [16:1] S16;\n    wire [8:1] S8;\n    wire [4:1] S4;\n    wire [2:1] S2;\n\n    CLA1 CLA1 (.A(A[32:1]), .B(B[32:1]), .Cin(1'b0), .S(S16), .Cout(C16));\n    CLA2 CLA2 (.A(S16), .B(B[32:1]), .Cin(C16), .S(S8), .Cout(C8));\n    CLA3 CLA3 (.A(S8), .B(B[32:1]), .Cin(C8), .S(S4), .Cout(C4));\n    CLA4 CLA4 (.A(S4), .B(B[32:1]), .Cin(C4), .S(S2), .Cout(C2));\n    CLA5 CLA5 (.A(S2), .B(B[32:1]), .Cin(C2), .S(S), .Cout(C32));\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [32:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [16:1] G,P;\n    wire [16:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = {16{Cin}} & (A | B);\n    assign S = G ^ P;\n    assign Cout = C[16];\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [16:1] G,P;\n    wire [16:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = {16{Cin}} & (A | B);\n    assign S = G ^ P;\n    assign Cout = C[16];\nendmodule\n\nmodule CLA3(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire [8:1] G,P;\n    wire [8:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = {8{Cin}} & (A | B);\n    assign S = G ^ P;\n    assign Cout = C[8];\nendmodule\n\nmodule CLA4(A,B,Cin,S,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire [4:1] G,P;\n    wire [4:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = {4{Cin}} & (A | B);\n    assign S = G ^ P;\n    assign Cout = C[4];\nendmodule\n\nmodule CLA5(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [1:1] S;\n    output Cout;\n\n    wire [2:1] G,P;\n    wire [2:1] C;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign C = {2{Cin}} & (A | B);\n    assign S = G ^ P;\n    assign Cout = C[2];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_sum;\nwire [3:0] csa_carry;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(csa_sum[0]), .cout(csa_carry[0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(csa_carry[0]), .sum(csa_sum[1]), .cout(csa_carry[1]));\n\n// Third 4-bit ripple carry adder\nripple_carry_adder rca3(.a(a[11:8]), .b(b[11:8]), .cin(csa_carry[1]), .sum(csa_sum[2]), .cout(csa_carry[2]));\n\n// Fourth 4-bit ripple carry adder\nripple_carry_adder rca4(.a(a[15:12]), .b(b[15:12]), .cin(csa_carry[2]), .sum(csa_sum[3]), .cout(csa_carry[3]));\n\n// Multiplexer to select sum and carry-out\nassign sum = {csa_sum[3], csa_sum[2], csa_sum[1], csa_sum[0]};\nassign cout = csa_carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [4:0] temp_carry;\n\n// First 4-bit adder\nfull_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(temp_sum[0]), .cout(temp_carry[0]));\n\n// Second 4-bit adder\nfull_adder fa2(.a(a[1]), .b(b[1]), .cin(temp_carry[0]), .sum(temp_sum[1]), .cout(temp_carry[1]));\n\n// Third 4-bit adder\nfull_adder fa3(.a(a[2]), .b(b[2]), .cin(temp_carry[1]), .sum(temp_sum[2]), .cout(temp_carry[2]));\n\n// Fourth 4-bit adder\nfull_adder fa4(.a(a[3]), .b(b[3]), .cin(temp_carry[2]), .sum(temp_sum[3]), .cout(temp_carry[3]));\n\n// Multiplexer to select sum and carry-out\nassign sum = {temp_sum[3], temp_sum[2], temp_sum[1], temp_sum[0]};\nassign cout = temp_carry[3];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] csa_sum;\nwire [3:0] csa_carry;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(csa_sum[0]), .cout(csa_carry[0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(csa_carry[0]), .sum(csa_sum[1]), .cout(csa_carry[1]));\n\n// Multiplexer to select sum and carry-out\nassign sum = {csa_sum[1], csa_sum[0]};\nassign cout = csa_carry[1];\n\nendmodule\n`endif"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// First carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Second carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Third carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Final sum\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n\n// Final carry out\nassign cout = carry[3];\n\nendmodule\n\n// Ripple carry adder for 4 bits\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First bit\nassign {cout, sum[0]} = a[0] + b[0] + cin;\n\n// Second bit\nassign {carry[0], sum[1]} = a[1] + b[1] + carry[0];\n\n// Third bit\nassign {carry[1], sum[2]} = a[2] + b[2] + carry[1];\n\n// Fourth bit\nassign {carry[2], sum[3]} = a[3] + b[3] + carry[2];\n\nendmodule\n\n// Carry select adder for 4 bits\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Second ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Final sum and carry\nassign {cout, sum} = {sum_slice[1], sum_slice[0]};\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8bit;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8bit)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift;\n    wire [31:0] product;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift(shift),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    reg [4:0] shift_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n            done <= 0;\n        end else if (shift_count > 0) begin\n            shift_count <= shift_count - 1;\n            done <= 0;\n        end else begin\n            done <= 1;\n        end\n    end\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [4:0] shift, // Shift count output.\n    output [31:0] product // Product output with a data width of 32 bits.\n);\n    reg [15:0] a_reg;\n    reg [15:0] b_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n            shift <= 0;\n            product <= 0;\n        end else if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n            shift <= 5;\n            product <= 0;\n        end else if (shift > 0) begin\n            shift <= shift - 1;\n            product <= product + (b_reg << shift);\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift,  // Shift count input.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] product // Product output with a data width of 32 bits.\n);\n    reg [31:0] product_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_reg <= 0;\n        end else if (start) begin\n            product_reg <= bin << shift;\n        end else if (shift > 0) begin\n            product_reg <= product_reg + (bin << (shift - 1));\n        end\n    end\n\n    assign product = product_reg;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add_sub add(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    add_sub addu(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    and_or ando(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero), .negative(and_negative), .overflow(and_overflow));\n    and_or oro(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero), .negative(or_negative), .overflow(or_overflow));\n    and_or xoro(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero), .negative(xor_negative), .overflow(xor_overflow));\n    and_or noro(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero), .negative(nor_negative), .overflow(nor_overflow));\n    slt_sltu sltu(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero), .negative(slt_negative), .overflow(slt_overflow));\n    slt_sltu sltu(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero), .negative(sltu_negative), .overflow(sltu_overflow));\n    sll_srl sllsrl(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero), .negative(sll_negative), .overflow(sll_overflow));\n    sll_srl srlsrl(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero), .negative(srl_negative), .overflow(srl_overflow));\n    sra_sll sralsl(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero), .negative(sra_negative), .overflow(sra_overflow));\n    sll_srl sllsrlv(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .zero(sllv_zero), .negative(sllv_negative), .overflow(sllv_overflow));\n    sll_srl srlsrlv(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .zero(srlv_zero), .negative(srlv_negative), .overflow(srlv_overflow));\n    sra_sll sralslv(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero), .negative(srav_negative), .overflow(srav_overflow));\n    lui lui(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .zero(lui_zero), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign carry = (add_carry || sub_carry || or_carry || xor_carry || nor_carry) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = (add_overflow || sub_overflow || sll_overflow || srl_overflow || sra_overflow || sllv_overflow || srlv_overflow || srav_overflow) ? 1'b1 : 1'b0;\n    assign add_flag = (slt_result[31]) ? 1'b1 : 1'b0;\n    assign sub_flag = (sltu_result[31]) ? 1'b1 : 1'b0;\n    assign and_flag = (and_result[31]) ? 1'b1 : 1'b0;\n    assign or_flag = (or_result[31]) ? 1'b1 : 1'b0;\n    assign xor_flag = (xor_result[31]) ? 1'b1 : 1'b0;\n    assign nor_flag = (nor_result[31]) ? 1'b1 : 1'b0;\n    assign slt_flag = add_flag;\n    assign sltu_flag = sub_flag;\n    assign sll_flag = (sll_result[31]) ? 1'b1 : 1'b0;\n    assign srl_flag = (srl_result[31]) ? 1'b1 : 1'b0;\n    assign sra_flag = (sra_result[31]) ? 1'b1 : 1'b0;\n    assign sllv_flag = (sllv_result[31]) ? 1'b1 : 1'b0;\n    assign srlv_flag = (srlv_result[31]) ? 1'b1 : 1'b0;\n    assign srav_flag = (srav_result[31]) ? 1'b1 : 1'b0;\n    assign lui_flag = (lui_result[31]) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = (a[31] == b[31] && r[31] != a[31]) ? 1'b1 : 1'b0;\nendmodule\n\nmodule and_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule\n\nmodule slt_sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule\n\nmodule sll_srl(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b[4:0] == 5'b0) ? a : (b[4:0] == 5'b1) ? {a[31], a[31:1]} : (b[4:0] == 5'b2) ? {a[31:2], 2'b0} : (b[4:0] == 5'b3) ? {a[31:3], 3'b0} : (b[4:0] == 5'b4) ? {a[31:4], 4'b0} : (b[4:0] == 5'b5) ? {a[31:5], 5'b0} : (b[4:0] == 5'b6) ? {a[31:6], 6'b0} : (b[4:0] == 5'b7) ? {a[31:7], 7'b0} : (b[4:0] == 5'b8) ? {a[31:8], 8'b0} : (b[4:0] == 5'b9) ? {a[31:9], 9'b0} : (b[4:0] == 5'b10) ? {a[31:10], 10'b0} : (b[4:0] == 5'b11) ? {a[31:11], 11'b0} : (b[4:0] == 5'b12) ? {a[31:12], 12'b0} : (b[4:0] == 5'b13) ? {a[31:13], 13'b0} : (b[4:0] == 5'b14) ? {a[31:14], 14'b0} : (b[4:0] == 5'b15) ? {a[31:15], 15'b0} : (b[4:0] == 5'b16) ? {a[31:16], 16'b0} : (b[4:0] == 5'b17) ? {a[31:17], 17'b0} : (b[4:0] == 5'b18) ? {a[31:18], 18'b0} : (b[4:0] == 5'b19) ? {a[31:19], 19'b0} : (b[4:0] == 5'b20) ? {a[31:20], 20'b0} : (b[4:0] == 5'b21) ? {a[31:21], 21'b0} : (b[4:0] == 5'b22) ? {a[31:22], 22'b0} : (b[4:0] == 5'b23) ? {a[31:23], 23'b0} : (b[4:0] == 5'b24) ? {a[31:24], 24'b0} : (b[4:0] == 5'b25) ? {a[31:25], 25'b0} : (b[4:0] == 5'b26) ? {a[31:26], 26'b0} : (b[4:0] == 5'b27) ? {a[31:27], 27'b0} : (b[4:0] == 5'b28) ? {a[31:28], 28'b0} : (b[4:0] == 5'b29) ? {a[31:29], 29'b0} : (b[4:0] == 5'b30) ? {a[31:30], 30'b0} : (b[4:0] == 5'b31) ? {a[31:31], 31'b0} : 32'b0;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule\n\nmodule sra_sll(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b[4:0] == 5'b0) ? a : (b[4:0] == 5'b1) ? {a[31], a[31:1]} : (b[4:0] == 5'b2) ? {a[31:2], 2'b0} : (b[4:0] == 5'b3) ? {a[31:3], 3'b0} : (b[4:0] == 5'b4) ? {a[31:4], 4'b0} : (b[4:0] == 5'b5) ? {a[31:5], 5'b0} : (b[4:0] == 5'b6) ? {a[31:6], 6'b0} : (b[4:0] == 5'b7) ? {a[31:7], 7'b0} : (b[4:0] == 5'b8) ? {a[31:8], 8'b0} : (b[4:0] == 5'b9) ? {a[31:9], 9'b0} : (b[4:0] == 5'b10) ? {a[31:10], 10'b0} : (b[4:0] == 5'b11) ? {a[31:11], 11'b0} : (b[4:0] == 5'b12) ? {a[31:12], 12'b0} : (b[4:0] == 5'b13) ? {a[31:13], 13'b0} : (b[4:0] == 5'b14) ? {a[31:14], 14'b0} : (b[4:0] == 5'b15) ? {a[31:15], 15'b0} : (b[4:0] == 5'b16) ? {a[31:16], 16'b0} : (b[4:0] == 5'b17) ? {a[31:17], 17'b0} : (b[4:0] == 5'b18) ? {a[31:18], 18'b0} : (b[4:0] == 5'b19) ? {a[31:19], 19'b0} : (b[4:0] == 5'b20) ? {a[31:20], 20'b0} : (b[4:0] == 5'b21) ? {a[31:21], 21'b0} : (b[4:0] == 5'b22) ? {a[31:22], 22'b0} : (b[4:0] == 5'b23) ? {a[31:23], 23'b0} : (b[4:0] == 5'b24) ? {a[31:24], 24'b0} : (b[4:0] == 5'b25) ? {a[31:25], 25'b0} : (b[4:0] == 5'b26) ? {a[31:26], 26'b0} : (b[4:0] == 5'b27) ? {a[31:27], 27'b0} : (b[4:0] == 5'b28) ? {a[31:28], 28'b0} : (b[4:0] == 5'b29) ? {a[31:29], 29'b0} : (b[4:0] == 5'b30) ? {a[31:30], 30'b0} : (b[4:0] == 5'b31) ? {a[31:31], 31'b0} : 32'b0;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[30:20], 12'b0} | a;\n    assign zero = (r == 32'b0) ? 1'b1 : 1'b0;\n    assign negative = (r[31]) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    output [31:0] yout,\n    output done\n);\n    wire [4:0] shift_count;\n    wire [15:0] m_reg;\n    wire [31:0] p_reg;\n    wire [31:0] p_accum;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ain(ain),\n        .bin(bin),\n        .m_reg(m_reg)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .m_reg(m_reg),\n        .p_reg(p_reg),\n        .p_accum(p_accum)\n    );\n\n    // Output Assignment\n    assign yout = p_accum;\n    assign done = start;\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] shift_count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 5'b00000;\n        end else if (start) begin\n            shift_count <= 5'b00000;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,\n    input rst_n,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] m_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m_reg <= 16'b0;\n        end else begin\n            m_reg <= ain;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,\n    input rst_n,\n    input [4:0] shift_count,\n    input [15:0] m_reg,\n    output reg [31:0] p_reg,\n    output reg [31:0] p_accum\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            p_reg <= 32'b0;\n            p_accum <= 32'b0;\n        end else begin\n            p_reg <= m_reg << shift_count;\n            p_accum <= p_accum + (m_reg << shift_count);\n        end\n    end\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetcher for register\n    instruction_fetch_reg ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetcher for RAM/ROM\n    instruction_fetch_ram ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetcher for register\nmodule instruction_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction fetcher for RAM/ROM\nmodule instruction_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0;\n    wire gt1, lt1, eq1;\n    wire gt2, lt2, eq2;\n    wire gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A;\n    input B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:12]),\n    .y(y[15:12]),\n    .prod(prod[11:4])\n);\n\nmult8 mult8_inst3 (\n    .x(x[15:10]),\n    .y(y[15:10]),\n    .prod(prod[9:2])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:7]),\n    .y(y[15:7]),\n    .prod(prod[6:0])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assign the outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetching module for registers\nmodule instruction_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction fetching module for RAM/ROM\nmodule instruction_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3;\n    wire lt0, lt1, lt2, lt3;\n    wire eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires for adder and subtractor\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00; // Reset state to 00\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01; // Increment state\n                2'b01: state <= 2'b10; // Decrement state\n                2'b10: state <= 2'b00; // Reset state\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000; // Reset waveform to 0\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1; // Increment waveform\n                2'b01: wave <= wave - 1; // Decrement waveform\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = |in;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n    wire highest_temp;\n\n    // Determine if highest order '1'\n    assign highest_temp = (in && !highest);\n\n    // Determine if valid\n    assign valid = highest_temp || highest;\n\n    // Assign highest\n    assign highest = highest_temp;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b00000000; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Submodule instances\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\n// Operation selector logic\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= u_adder.sum;\n        2'b01: result <= u_subtractor.diff;\n        2'b10: result <= u_and.out;\n        2'b11: result <= u_or.out;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodule definitions\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = |in;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign valid = in;\n    assign highest = in & !highest;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the output based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect the outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h30),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder and AND modules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h50),\n        .above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output above_threshold;\n    assign above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the 25% PWM module\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    // Instantiate the 50% PWM module\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    // Instantiate the 75% PWM module\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// 25% PWM module\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 0;\n            PWM_out <= 1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 0;\n        end\n    end\nendmodule\n\n// 50% PWM module\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 0;\n            PWM_out <= 1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 0;\n        end\n    end\nendmodule\n\n// 75% PWM module\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 0;\n            PWM_out <= 1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodule instances\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [15:0] count;\n    parameter CYCLES = 16'd1000; // 1000 cycles for 25% duty cycle\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 16'd0;\n            PWM_out <= 1'b0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1'b1;\n            end else begin\n                count <= 16'd0;\n                PWM_out <= 1'b0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [15:0] count;\n    parameter CYCLES = 16'd800; // 800 cycles for 50% duty cycle\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 16'd0;\n            PWM_out <= 1'b0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1'b1;\n            end else begin\n                count <= 16'd0;\n                PWM_out <= 1'b0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [15:0] count;\n    parameter CYCLES = 16'd600; // 600 cycles for 75% duty cycle\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 16'd0;\n            PWM_out <= 1'b0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1'b1;\n            end else begin\n                count <= 16'd0;\n                PWM_out <= 1'b0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n  // Stage 1\n  mux2X1 mux10 (.sel(ctrl[2]), .in1(in), .in2(stage1), .out(stage1));\n  mux2X1 mux11 (.sel(ctrl[1]), .in1(stage1), .in2(stage2), .out(stage2));\n  mux2X1 mux12 (.sel(ctrl[0]), .in1(stage2), .in2(stage3), .out(stage3));\n\n  // Stage 2\n  mux2X1 mux20 (.sel(ctrl[2]), .in1(stage2), .in2(stage4), .out(stage4));\n  mux2X1 mux21 (.sel(ctrl[1]), .in1(stage4), .in2(stage6), .out(stage6));\n  mux2X1 mux22 (.sel(ctrl[0]), .in1(stage6), .in2(stage8), .out(stage8));\n\n  // Stage 3\n  mux2X1 mux30 (.sel(ctrl[2]), .in1(stage3), .in2(stage6), .out(stage6));\n  mux2X1 mux31 (.sel(ctrl[1]), .in1(stage6), .in2(stage8), .out(stage8));\n  mux2X1 mux32 (.sel(ctrl[0]), .in1(stage8), .in2(stage8), .out(stage8));\n\n  // Stage 4\n  mux2X1 mux40 (.sel(ctrl[2]), .in1(stage4), .in2(stage8), .out(stage8));\n  mux2X1 mux41 (.sel(ctrl[1]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux42 (.sel(ctrl[0]), .in1(stage8), .in2(stage8), .out(stage8));\n\n  // Stage 5\n  mux2X1 mux50 (.sel(ctrl[2]), .in1(stage6), .in2(stage8), .out(stage8));\n  mux2X1 mux51 (.sel(ctrl[1]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux52 (.sel(ctrl[0]), .in1(stage8), .in2(stage8), .out(stage8));\n\n  // Stage 6\n  mux2X1 mux60 (.sel(ctrl[2]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux61 (.sel(ctrl[1]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux62 (.sel(ctrl[0]), .in1(stage8), .in2(stage8), .out(stage8));\n\n  // Stage 7\n  mux2X1 mux70 (.sel(ctrl[2]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux71 (.sel(ctrl[1]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux72 (.sel(ctrl[0]), .in1(stage8), .in2(stage8), .out(stage8));\n\n  // Stage 8\n  mux2X1 mux80 (.sel(ctrl[2]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux81 (.sel(ctrl[1]), .in1(stage8), .in2(stage8), .out(stage8));\n  mux2X1 mux82 (.sel(ctrl[0]), .in1(stage8), .in2(stage8), .out(stage8));\n\n  assign out = stage8;\n\nendmodule\n\nmodule mux2X1 (sel, in1, in2, out);\n  input sel;\n  input [7:0] in1, in2;\n  output [7:0] out;\n\n  assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(carry[1]),\n        .S(S[8:5]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(carry[2]),\n        .S(S[12:9]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(carry[3]),\n        .S(S[16:13]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;         // 4-bit input A\n    input [4:1] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [4:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [5:1] sum;        // 5-bit sum\n    wire c1, c2;            // Carry-out from 2-bit adders\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(sum[2:1]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c1),\n        .S(sum[4:3]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = c2;\n\n    // Concatenate the sum to get the final 4-bit sum\n    assign S = {sum[5], sum[4:3]};\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;         // 2-bit input A\n    input [2:1] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [2:1] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out from the first adder\n\n    // Instantiate the 1-bit full adder for the LSB\n    full_adder fa(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry from the 1-bit adder\n    assign C_out = c1;\n\n    // Concatenate the sum to get the final 2-bit sum\n    assign S = {c1, A[2:1] + B[2:1]};\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in input\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out from the first adder\n\n    // Instantiate the 1-bit full adder for the LSB\n    full_adder fa(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry from the 1-bit adder\n    assign C_out = c1;\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodules\n    wire pwm_25_out;\n    wire pwm_50_out;\n    wire pwm_75_out;\n\n    // Instantiate submodules\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    // Assign outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count = 0;\n    reg pwm_state = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            pwm_state <= 0;\n        end else begin\n            if (count == 100_000_000) begin\n                pwm_state <= ~pwm_state;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_state;\n\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count = 0;\n    reg pwm_state = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            pwm_state <= 0;\n        end else begin\n            if (count == 50_000_000) begin\n                pwm_state <= ~pwm_state;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_state;\n\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count = 0;\n    reg pwm_state = 0;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            pwm_state <= 0;\n        end else begin\n            if (count == 75_000_000) begin\n                pwm_state <= ~pwm_state;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_state;\n\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adder for A[0] * B[0]\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum1), .cout(0));\n\n// 4-bit full adder for A[1] * B[1]\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(0), .sum(sum2), .cout(0));\n\n// 4-bit full adder for A[2] * B[2]\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(0), .sum(sum3), .cout(0));\n\n// 4-bit full adder for A[3] * B[3]\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(0), .sum(sum4), .cout(0));\n\n// 8-bit full adder for A[0] * B[0] + A[1] * B[1]\nfull_adder_8bit A4BS0(.a(sum1), .b(sum2), .cin(0), .sum(sum4), .cout(0));\n\n// 8-bit full adder for A[2] * B[2] + A[3] * B[3]\nfull_adder_8bit A4BS1(.a(sum3), .b(sum4), .cin(0), .sum(product), .cout(0));\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nwire c1, c2;\n\nxor x1(a, b, sum);\nand a1(a, b, c1);\nand a2(a, b, c2);\nor o1(c1, cin, cout);\nor o2(c2, c1, cout);\n\nendmodule\n\nmodule full_adder_8bit(\n    input [3:0] a, b, cin,\n    output [7:0] sum, cout);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adder for A[0] * B[0]\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum1), .cout(0));\n\n// 4-bit full adder for A[1] * B[1]\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(0), .sum(sum2), .cout(0));\n\n// 4-bit full adder for A[2] * B[2]\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(0), .sum(sum3), .cout(0));\n\n// 4-bit full adder for A[3] * B[3]\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(0), .sum(sum4), .cout(0));\n\n// 8-bit full adder for A[0] * B[0] + A[1] * B[1]\nfull_adder_8bit A4BS0(.a(sum1), .b(sum2), .cin(0), .sum(sum4), .cout(0));\n\n// 8-bit full adder for A[2] * B[2] + A[3] * B[3]\nfull_adder_8bit A4BS1(.a(sum3), .b(sum4), .cin(0), .sum(sum4), .cout(0));\n\nendmodule\n\nmodule full_adder_8bit(\n    input [3:0] a, b, cin,\n    output [7:0] sum, cout);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adder for A[0] * B[0]\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum1), .cout(0));\n\n// 4-bit full adder for A[1] * B[1]\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(0), .sum(sum2), .cout(0));\n\n// 4-bit full adder for A[2] * B[2]\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(0), .sum(sum3), .cout(0));\n\n// 4-bit full adder for A[3] * B[3]\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(0), .sum(sum4), .cout(0));\n\n// 8-bit full adder for A[0] * B[0] + A[1] * B[1] + A[2] * B[2] + A[3] * B[3]\nfull_adder_8bit A4BS0(.a(sum1), .b(sum2), .cin(0), .sum(sum4), .cout(0));\n\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count for the counter\n\n    wire [11:0] counter_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    reg [11:0] duty_cycle_threshold;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            duty_cycle_threshold <= 0;\n            pwm_out <= 0;\n        end else begin\n            duty_cycle_threshold <= DUTY_CYCLE * MAX_COUNT / 100;\n            pwm_out <= (counter_out < duty_cycle_threshold) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_1, shifted_2, shifted_3, shifted_4, shifted_5, shifted_6, shifted_7, shifted_8;\n\n  // Stage 1: Shift by 4\n  mux2X1 #(.WIDTH(8)) ins_27(.sel(ctrl[2]), .in0(in), .in1(shifted_1), .out(shifted_2));\n  mux2X1 #(.WIDTH(8)) ins_26(.sel(ctrl[2]), .in0(in), .in1(shifted_2), .out(shifted_3));\n  mux2X1 #(.WIDTH(8)) ins_25(.sel(ctrl[2]), .in0(in), .in1(shifted_3), .out(shifted_4));\n  mux2X1 #(.WIDTH(8)) ins_24(.sel(ctrl[2]), .in0(in), .in1(shifted_4), .out(shifted_5));\n\n  // Stage 2: Shift by 2\n  mux2X1 #(.WIDTH(8)) ins_23(.sel(ctrl[1]), .in0(shifted_2), .in1(shifted_5), .out(shifted_6));\n  mux2X1 #(.WIDTH(8)) ins_22(.sel(ctrl[1]), .in0(shifted_3), .in1(shifted_6), .out(shifted_7));\n  mux2X1 #(.WIDTH(8)) ins_21(.sel(ctrl[1]), .in0(shifted_4), .in1(shifted_7), .out(shifted_8));\n\n  // Stage 3: Shift by 1\n  mux2X1 #(.WIDTH(8)) ins_20(.sel(ctrl[0]), .in0(shifted_5), .in1(shifted_8), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_17(.sel(ctrl[0]), .in0(shifted_6), .in1(out), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_16(.sel(ctrl[0]), .in0(shifted_7), .in1(out), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_15(.sel(ctrl[0]), .in0(shifted_8), .in1(out), .out(out));\n\n  // Stage 4: Final shift\n  mux2X1 #(.WIDTH(8)) ins_14(.sel(ctrl[2]), .in0(in), .in1(shifted_1), .out(shifted_2));\n  mux2X1 #(.WIDTH(8)) ins_13(.sel(ctrl[2]), .in0(in), .in1(shifted_2), .out(shifted_3));\n  mux2X1 #(.WIDTH(8)) ins_12(.sel(ctrl[2]), .in0(in), .in1(shifted_3), .out(shifted_4));\n  mux2X1 #(.WIDTH(8)) ins_11(.sel(ctrl[2]), .in0(in), .in1(shifted_4), .out(shifted_5));\n  mux2X1 #(.WIDTH(8)) ins_10(.sel(ctrl[2]), .in0(in), .in1(shifted_5), .out(shifted_6));\n  mux2X1 #(.WIDTH(8)) ins_07(.sel(ctrl[2]), .in0(in), .in1(shifted_6), .out(shifted_7));\n  mux2X1 #(.WIDTH(8)) ins_06(.sel(ctrl[2]), .in0(in), .in1(shifted_7), .out(shifted_8));\n  mux2X1 #(.WIDTH(8)) ins_05(.sel(ctrl[2]), .in0(in), .in1(shifted_8), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_04(.sel(ctrl[2]), .in0(in), .in1(out), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_03(.sel(ctrl[2]), .in0(in), .in1(out), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_02(.sel(ctrl[2]), .in0(in), .in1(out), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_01(.sel(ctrl[2]), .in0(in), .in1(out), .out(out));\n  mux2X1 #(.WIDTH(8)) ins_00(.sel(ctrl[2]), .in0(in), .in1(out), .out(out));\n\nendmodule\n\nmodule mux2X1#(parameter WIDTH = 8)(input sel, input [WIDTH-1:0] in0, input [WIDTH-1:0] in1, output reg [WIDTH-1:0] out);\n  always @(*) begin\n    if (sel) begin\n      out <= in1;\n    end else begin\n      out <= in0;\n    end\n  end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adders for each bit of A and B\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(sum0[0]), .sum(sum1), .cout(sum0[1]));\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(sum1[0]), .sum(sum2), .cout(sum1[1]));\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(sum2[0]), .sum(sum3), .cout(sum2[1]));\n\n// Shift registers for each bit of the product\nshift_register_4bit A4BS0(.sum(sum0), .shifted_sum(shifted_sum0));\nshift_register_4bit A4BS1(.sum(sum1), .shifted_sum(shifted_sum1));\nshift_register_4bit A4BS2(.sum(sum2), .shifted_sum(shifted_sum2));\nshift_register_4bit A4BS3(.sum(sum3), .shifted_sum(shifted_sum3));\n\n// Combine the shifted sums to get the final product\nassign product = {shifted_sum3, shifted_sum2, shifted_sum1, shifted_sum0};\n\nendmodule\n\nmodule full_adder_4bit(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule shift_register_4bit(input [3:0] sum, output [7:0] shifted_sum);\n    assign shifted_sum = {sum[3:0], sum[3:0]};\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out is the last carry\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry chain\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed version of b0 for pe1\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 16'b0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_temp;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_temp[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_temp[0]), .diff(diff[1]), .bout(b_temp[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_temp[1]), .diff(diff[2]), .bout(b_temp[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_temp[2]), .diff(diff[3]), .bout(b_temp[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_temp[3]), .diff(diff[4]), .bout(b_temp[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_temp[4]), .diff(diff[5]), .bout(b_temp[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_temp[5]), .diff(diff[6]), .bout(b_temp[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_temp[6]), .diff(diff[7]), .bout(b_temp[7]));\n\n    assign bout = b_temp[7]; \nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage (default 50%)\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = MAX_COUNT * DUTY_CYCLE / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 500; // Duty cycle threshold value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (counter_out < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed version of b0\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 16'b0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[4]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Output carry-out\n    assign C_out = C4[16];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;         // 4-bit input A\n    input [4:1] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [4:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G and P vectors\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Generate C vector\n    assign C[1] = G[1] | (P[1] & C_in);\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign C[4] = G[4] | (P[4] & C[3]);\n    assign C[5] = G[5] | (P[5] & C[4]);\n\n    // Generate sum vector\n    assign S[1] = P[1] ^ C_in;\n    assign S[2] = P[2] ^ C[1];\n    assign S[3] = P[3] ^ C[2];\n    assign S[4] = P[4] ^ C[3];\n    assign S[5] = P[5] ^ C[4];\n\n    // Output carry-out\n    assign C_out = C[5];\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the signed and unsigned multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] borrow;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:0] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders for each nibble\n    cla_4bit add1(.A(A[4:1]), .B(B[4:1]), .C_in(1'b0), .S(S[4:1]), .C_out(c1));\n    cla_4bit add2(.A(A[8:5]), .B(B[8:5]), .C_in(c1), .S(S[8:5]), .C_out(c2));\n    cla_4bit add3(.A(A[12:9]), .B(B[12:9]), .C_in(c2), .S(S[12:9]), .C_out(c3));\n    cla_4bit add4(.A(A[16:13]), .B(B[16:13]), .C_in(c3), .S(S[16:13]), .C_out(c4));\n\n    // Carry-out is the carry from the last nibble\n    assign C_out = c4;\n\nendmodule\n\nmodule cla_4bit (A, B, C_in, S, C_out);\n    input [3:1] A;       // 4-bit input A\n    input [3:1] B;       // 4-bit input B\n    input C_in;          // Carry-in\n    output [3:1] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:1] c;        // Carry output for each bit\n\n    // Instantiate full adder for each bit\n    full_adder fa1 (.A(A[1]), .B(B[1]), .C_in(C_in), .S(S[1]), .C_out(c[1]));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .C_in(c[1]), .S(S[2]), .C_out(c[2]));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .C_in(c[2]), .S(S[3]), .C_out(c[3]));\n\n    // Carry-out is the carry from the last bit\n    assign C_out = c[3];\n\nendmodule\n\nmodule full_adder (A, B, C_in, S, C_out);\n    input A, B, C_in;    // Inputs\n    output S, C_out;     // Outputs\n\n    assign S = A ^ B ^ C_in; // Sum\n    assign C_out = (A & B) | (B & C_in) | (A & C_in); // Carry out\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n\n    // Count Control Module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next)\n    );\n\n    // Overflow Detection Module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_temp;\n\n    // Generate borrow for each bit\n    assign b_temp[0] = bin;\n    assign b_temp[1] = b_temp[0] ^ a[0] ^ b[0];\n    assign b_temp[2] = b_temp[1] ^ a[1] ^ b[1];\n    assign b_temp[3] = b_temp[2] ^ a[2] ^ b[2];\n    assign b_temp[4] = b_temp[3] ^ a[3] ^ b[3];\n    assign b_temp[5] = b_temp[4] ^ a[4] ^ b[4];\n    assign b_temp[6] = b_temp[5] ^ a[5] ^ b[5];\n    assign b_temp[7] = b_temp[6] ^ a[6] ^ b[6];\n    assign b_temp[8] = b_temp[7] ^ a[7] ^ b[7];\n\n    // Calculate difference\n    assign diff = a - b - b_temp[7:0];\n\n    // Calculate borrow out\n    assign bout = b_temp[8];\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] even_parity_x;\n    wire [7:0] even_parity_y;\n\n    // Instantiate two 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(even_parity_x)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(even_parity_y)\n    );\n\n    // Compute the final parity\n    assign P = even_parity_x ^ even_parity_y;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [7:0] even_parity;\n\n    // Compute the even parity of X\n    assign even_parity = X[7] ^ X[6] ^ X[5] ^ X[4] ^ X[3] ^ X[2] ^ X[1] ^ X[0];\n\n    // Output the parity\n    assign P = even_parity;\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_int;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_int)\n    );\n\n    // Output the count and overflow signal\n    assign count_out = count;\n    assign overflow = overflow_int;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] x_parity;\n    wire [7:0] y_parity;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(x_parity)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(y_parity)\n    );\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Parity output\n\n    wire [7:0] x_parity;\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(\n        .X(X[3:0]),\n        .P(x_parity[3:0])\n    );\n\n    parity_4bit gen2(\n        .X(X[7:4]),\n        .P(x_parity[7:4])\n    );\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3] ^ x_parity[4] ^ x_parity[5] ^ x_parity[6] ^ x_parity[7];\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;      // 4-bit input X\n    output P;           // Parity output\n\n    wire [3:0] x_parity;\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(\n        .X(X[1:0]),\n        .P(x_parity[1:0])\n    );\n\n    parity_2bit gen2(\n        .X(X[3:2]),\n        .P(x_parity[3:2])\n    );\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3];\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;      // 2-bit input X\n    output P;           // Parity output\n\n    assign P = X[0] ^ X[1];\n\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n`define INSTR_SIZE 32\n`define PC_SIZE 32\n`define REG_FILE_SIZE 32\n`define INSTR_MEM_SIZE 32\n`define PC_INIT 0\n`define INSTR_MEM_INIT 0\n`define REG_FILE_INIT 0\n`define INSTR_MEM_INIT_VAL 0\n`define REG_FILE_INIT_VAL 0\n\nwire [31:0] alu_result;\nwire [31:0] next_pc;\nwire [31:0] next_reg_file [0:31];\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(next_pc), .res_instr(res_instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(res_instr), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd), .next_pc(next_pc), .next_reg_file(next_reg_file));\nexecute_stage execute(.clk(clk), .rst(rst), .op(op), .rs1(rs1), .rs2(rs2), .alu_result(alu_result));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .next_pc(next_pc), .next_reg_file(next_reg_file), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .alu_result(alu_result), .next_pc(next_pc), .next_reg_file(next_reg_file), .res_reg_file(res_reg_file));\n\n// Assign outputs\nassign res_reg_file = next_reg_file;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] res_instr\n);\n  reg [31:0] pc_reg;\n  reg [31:0] res_instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= `PC_INIT;\n      res_instr_reg <= `INSTR_MEM_INIT_VAL;\n    end else begin\n      pc_reg <= pc_reg + 1;\n      res_instr_reg <= instr_mem[pc_reg];\n    end\n  end\n\n  assign pc = pc_reg;\n  assign res_instr = res_instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [5:0] op,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [31:0] next_pc,\n  output [31:0] next_reg_file [0:31]\n);\n  reg [5:0] op_reg;\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [31:0] next_pc_reg;\n  reg [31:0] next_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      op_reg <= 6'b0;\n      rs1_reg <= 5'b0;\n      rs2_reg <= 5'b0;\n      rd_reg <= 5'b0;\n      next_pc_reg <= `PC_INIT;\n      next_reg_file_reg <= `REG_FILE_INIT;\n    end else begin\n      op_reg <= instr[31:26];\n      rs1_reg <= instr[25:21];\n      rs2_reg <= instr[20:16];\n      rd_reg <= instr[15:11];\n      next_pc_reg <= next_pc_reg + 1;\n      next_reg_file_reg[rd_reg] <= instr[31:26];\n    end\n  end\n\n  assign op = op_reg;\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign next_pc = next_pc_reg;\n  assign next_reg_file = next_reg_file_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [5:0] op,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  output [31:0] alu_result\n);\n  reg [31:0] rs1_val;\n  reg [31:0] rs2_val;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_val <= 32'b0;\n      rs2_val <= 32'b0;\n    end else begin\n      rs1_val <= reg_file[rs1];\n      rs2_val <= reg_file[rs2];\n    end\n  end\n\n  assign alu_result = (op == 6'b001000) ? rs1_val + rs2_val : rs1_val - rs2_val;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] next_pc,\n  input [31:0] next_reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] alu_result_reg;\n  reg [31:0] next_pc_reg;\n  reg [31:0] next_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result_reg <= 32'b0;\n      next_pc_reg <= `PC_INIT;\n      next_reg_file_reg <= `REG_FILE_INIT;\n    end else begin\n      alu_result_reg <= alu_result;\n      next_pc_reg <= next_pc;\n      next_reg_file_reg <= next_reg_file;\n    end\n  end\n\n  assign res_reg_file = next_reg_file_reg;\n\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] next_pc,\n  input [31:0] next_reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] alu_result_reg;\n  reg [31:0] next_pc_reg;\n  reg [31:0] next_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result_reg <= 32'b0;\n      next_pc_reg <= `PC_INIT;\n      next_reg_file_reg <= `REG_FILE_INIT;\n    end else begin\n      alu_result_reg <= alu_result;\n      next_pc_reg <= next_pc;\n      next_reg_file_reg <= next_reg_file;\n    end\n  end\n\n  assign res_reg_file = next_reg_file_reg;\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_and_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_and_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_and_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_and_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_and_add(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    assign product = a + (b << 1);\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUBTRACT 2'b01\n`define BITWISE_AND 2'b10\n`define BITWISE_OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUBTRACT: result <= subtract_result;\n            `BITWISE_AND: result <= bitwise_and_result;\n            `BITWISE_OR: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        count_out <= count;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit chunk\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit chunk\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;             // Carry-in input\n    output [1:0] S;         // 2-bit sum output\n    output C_out;           // Carry-out output\n\n    wire c1;                // Carry-out wire\n\n    // Instantiate 1-bit full adder for the last bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c1;\n\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;                // 1-bit input A\n    input B;                // 1-bit input B\n    input C_in;             // Carry-in input\n    output S;               // 1-bit sum output\n    output C_out;           // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\n\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq0, gt0, lt0;\nwire [3:0] eq1, gt1, lt1;\nwire [3:0] eq2, gt2, lt2;\nwire [3:0] eq3, gt3, lt3;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq1), .gt(gt1), .lt(lt1));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq2), .gt(gt2), .lt(lt2));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq3), .gt(gt3), .lt(lt3));\n\nassign eq = eq0 | eq1 | eq2 | eq3;\nassign gt = gt0 & gt1 & gt2 & gt3;\nassign lt = lt0 & lt1 & lt2 & lt3;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire eq0, gt0, lt0;\nwire eq1, gt1, lt1;\n\ncomparator_2bit comp_slice0(.a(a[1:0]), .b(b[1:0]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq1), .gt(gt1), .lt(lt1));\n\nassign eq = eq0 | eq1;\nassign gt = gt0 & gt1;\nassign lt = lt0 & lt1;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq0, gt0, lt0;\n\nassign eq = a == b;\nassign gt = a > b;\nassign lt = a < b;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_result;\n\n// Instantiating pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .op(op), .alu_result(alu_result));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .rd(rd), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      instr_reg <= instr_mem[pc_reg];\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg, rs2_reg, rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[10:6];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_result\n);\n  reg [31:0] alu_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_result_reg <= rs1 + rs2;\n        6'b001010: alu_result_reg <= rs1 - rs2;\n        default: alu_result_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_result = alu_result_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= alu_result;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [4:0] rd,\n  input [31:0] res_reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file[rd] <= 0;\n    end else begin\n      res_reg_file[rd] <= res_reg_file[rd];\n    end\n  end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b1), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b2), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b3), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b1, b2, b3;\n\n  // Update delayed values\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out wire\n\n    // Instantiate 1-bit full adder for the final bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c1;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in input\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  reg [15:0] b1, b2, b3;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\n\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    wire [8:0] carry;\n    assign {carry[0], sum} = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Module instantiation\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] rd;\n    wire [5:0] opcode;\n\n    // Fetch stage\n    fetch_stage fetch (\n        .clk(clk),\n        .rst(rst),\n        .instr_mem(instr_mem),\n        .pc(reg_file[31]),\n        .fetched_instr(fetched_instr)\n    );\n\n    // Execute stage\n    execute_stage execute (\n        .clk(clk),\n        .rst(rst),\n        .fetched_instr(fetched_instr),\n        .op1(op1),\n        .op2(op2),\n        .result(result),\n        .opcode(opcode),\n        .rd(rd)\n    );\n\n    // Writeback stage\n    writeback_stage writeback (\n        .clk(clk),\n        .rst(rst),\n        .result(result),\n        .rd(rd),\n        .reg_file(reg_file),\n        .out_reg_file(out_reg_file)\n    );\n\nendmodule\n\n// Module for fetch stage\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\n// Module for execute stage\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result,\n    output reg [4:0] rd,\n    output reg [5:0] opcode\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            rd <= 0;\n            opcode <= 0;\n        end else begin\n            op1 <= fetched_instr[31:26];\n            op2 <= fetched_instr[5:0];\n            rd <= fetched_instr[11:6];\n            opcode <= fetched_instr[31:26];\n            if (opcode == 6'b000000) begin // Addition\n                result <= op1 + op2;\n            end else if (opcode == 6'b001010) begin // Subtraction\n                result <= op1 - op2;\n            end\n        end\n    end\nendmodule\n\n// Module for writeback stage\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag\n    assign zero = (result == 32'b0) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [8:1] Bout8;\n\n    sub8_32 SUB1(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bin),\n        .D(D[8:1]),\n        .Bout(Bout8[1])\n    );\n\n    sub8_32 SUB2(\n        .A(A[16:9]),\n        .B(B[16:9]),\n        .Bin(Bout8[1]),\n        .D(D[16:9]),\n        .Bout(Bout8[2])\n    );\n\n    sub8_32 SUB3(\n        .A(A[24:17]),\n        .B(B[24:17]),\n        .Bin(Bout8[2]),\n        .D(D[24:17]),\n        .Bout(Bout8[3])\n    );\n\n    sub8_32 SUB4(\n        .A(A[32:25]),\n        .B(B[32:25]),\n        .Bin(Bout8[3]),\n        .D(D[32:25]),\n        .Bout(Bout8[4])\n    );\n\n    assign Bout = Bout8[4];\nendmodule\n\nmodule sub8_32(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [8:1] Bout8;\n\n    sub8_8 SUB1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Bin(Bin),\n        .D(D[4:1]),\n        .Bout(Bout8[1])\n    );\n\n    sub8_8 SUB2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .Bin(Bout8[1]),\n        .D(D[8:5]),\n        .Bout(Bout8[2])\n    );\n\n    sub8_8 SUB3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .Bin(Bout8[2]),\n        .D(D[12:9]),\n        .Bout(Bout8[3])\n    );\n\n    sub8_8 SUB4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .Bin(Bout8[3]),\n        .D(D[16:13]),\n        .Bout(Bout8[4])\n    );\n\n    assign Bout = Bout8[4];\nendmodule\n\nmodule sub8_8(A, B, Bin, D, Bout);\n    input [4:1] A;\n    input [4:1] B;\n    input Bin;\n    output [4:1] D;\n    output Bout;\n\n    wire [1:1] Bout1;\n\n    sub4_4 SUB1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .Bin(Bin),\n        .D(D[2:1]),\n        .Bout(Bout1[1])\n    );\n\n    sub4_4 SUB2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .Bin(Bout1[1]),\n        .D(D[4:3]),\n        .Bout(Bout1[2])\n    );\n\n    sub4_4 SUB3(\n        .A(A[6:5]),\n        .B(B[6:5]),\n        .Bin(Bout1[2]),\n        .D(D[6:5]),\n        .Bout(Bout1[3])\n    );\n\n    sub4_4 SUB4(\n        .A(A[8:7]),\n        .B(B[8:7]),\n        .Bin(Bout1[3]),\n        .D(D[8:7]),\n        .Bout(Bout)\n    );\nendmodule\n\nmodule sub4_4(A, B, Bin, D, Bout);\n    input [2:1] A;\n    input [2:1] B;\n    input Bin;\n    output [2:1] D;\n    output Bout;\n\n    wire [1:1] Bout1;\n\n    sub2_2 SUB1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bin),\n        .D(D[1:1]),\n        .Bout(Bout1[1])\n    );\n\n    sub2_2 SUB2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .Bin(Bout1[1]),\n        .D(D[2:2]),\n        .Bout(Bout1[2])\n    );\n\n    sub2_2 SUB3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .Bin(Bout1[2]),\n        .D(D[3:3]),\n        .Bout(Bout)\n    );\nendmodule\n\nmodule sub2_2(A, B, Bin, D, Bout);\n    input [1:1] A;\n    input [1:1] B;\n    input Bin;\n    output [1:1] D;\n    output Bout;\n\n    wire [1:1] Bout1;\n\n    sub1_1 SUB1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bin),\n        .D(D[1:1]),\n        .Bout(Bout1[1])\n    );\n\n    sub1_1 SUB2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .Bin(Bout1[1]),\n        .D(D[2:2]),\n        .Bout(Bout)\n    );\nendmodule\n\nmodule sub1_1(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n\n    assign D = A ^ B ^ Bin;\n    assign Bout = Bin;\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the operation code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count)\n  );\n\n  // Connect the mode signal to the counter module\n  assign counter_inst.mode = mode;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (mode) begin\n        count <= count - 1;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  \n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the count value based on the mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (mode == 0);\n  end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire [1:0] op_code\n);\n    assign result = (op_code == 2'b00) ? a & b : a | b;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    sub8_32 SUB1(\n        .A(A[32:1]),\n        .B(B[32:1]),\n        .Bin(Bin),\n        .D(D[32:1]),\n        .Bout(Bout0)\n    );\n\n    sub8_32 SUB2(\n        .A(A[31:1]),\n        .B(B[31:1]),\n        .Bin(Bout0),\n        .D(D[31:1]),\n        .Bout(Bout1)\n    );\n\n    sub8_32 SUB3(\n        .A(A[30:1]),\n        .B(B[30:1]),\n        .Bin(Bout1),\n        .D(D[30:1]),\n        .Bout(Bout2)\n    );\n\n    sub8_32 SUB4(\n        .A(A[29:1]),\n        .B(B[29:1]),\n        .Bin(Bout2),\n        .D(D[29:1]),\n        .Bout(Bout3)\n    );\nendmodule\n\nmodule sub8_32(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [8:1] Bout0, Bout1;\n\n    sub8_8 SUB1(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bin),\n        .D(D[8:1]),\n        .Bout(Bout0)\n    );\n\n    sub8_8 SUB2(\n        .A(A[7:1]),\n        .B(B[7:1]),\n        .Bin(Bout0),\n        .D(D[7:1]),\n        .Bout(Bout1)\n    );\nendmodule\n\nmodule sub8_8(A, B, Bin, D, Bout);\n    input [4:1] A;\n    input [4:1] B;\n    input Bin;\n    output [4:1] D;\n    output Bout;\n    wire [4:1] Bout0, Bout1;\n\n    sub4_4 SUB1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Bin(Bin),\n        .D(D[4:1]),\n        .Bout(Bout0)\n    );\n\n    sub4_4 SUB2(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .Bin(Bout0),\n        .D(D[3:1]),\n        .Bout(Bout1)\n    );\nendmodule\n\nmodule sub4_4(A, B, Bin, D, Bout);\n    input [2:1] A;\n    input [2:1] B;\n    input Bin;\n    output [2:1] D;\n    output Bout;\n    wire [2:1] Bout0, Bout1;\n\n    sub2_2 SUB1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .Bin(Bin),\n        .D(D[2:1]),\n        .Bout(Bout0)\n    );\n\n    sub2_2 SUB2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bout0),\n        .D(D[1:1]),\n        .Bout(Bout1)\n    );\nendmodule\n\nmodule sub2_2(A, B, Bin, D, Bout);\n    input [1:1] A;\n    input [1:1] B;\n    input Bin;\n    output [1:1] D;\n    output Bout;\n    assign {Bout, D[1:1]} = A[1:1] - B[1:1] - Bin;\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else if (load) begin\n            q <= d;\n        end\n    end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define I_FORMAT 6'b000000\n\n// Fetch stage\nfetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\n// Execute stage\nexecute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\n// Writeback stage\nwriteback writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(execute.out_reg_file),\n    .out_reg_file(writeback.out_reg_file)\n);\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    reg [31:0] op1, op2, result;\n    reg [5:0] opcode;\n    reg [4:0] rd;\n    reg [4:0] rs1, rs2;\n    reg [5:0] funct;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            opcode <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            funct <= 0;\n        end\n        else begin\n            op1 <= reg_file[rs1];\n            op2 <= reg_file[rs2];\n            case (funct)\n                `ADD: result <= op1 + op2;\n                `SUB: result <= op1 - op2;\n            endcase\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[0] <= 0;\n            out_reg_file[1] <= 0;\n            out_reg_file[2] <= 0;\n            out_reg_file[3] <= 0;\n            out_reg_file[4] <= 0;\n            out_reg_file[5] <= 0;\n            out_reg_file[6] <= 0;\n            out_reg_file[7] <= 0;\n            out_reg_file[8] <= 0;\n            out_reg_file[9] <= 0;\n            out_reg_file[10] <= 0;\n            out_reg_file[11] <= 0;\n            out_reg_file[12] <= 0;\n            out_reg_file[13] <= 0;\n            out_reg_file[14] <= 0;\n            out_reg_file[15] <= 0;\n            out_reg_file[16] <= 0;\n            out_reg_file[17] <= 0;\n            out_reg_file[18] <= 0;\n            out_reg_file[19] <= 0;\n            out_reg_file[20] <= 0;\n            out_reg_file[21] <= 0;\n            out_reg_file[22] <= 0;\n            out_reg_file[23] <= 0;\n            out_reg_file[24] <= 0;\n            out_reg_file[25] <= 0;\n            out_reg_file[26] <= 0;\n            out_reg_file[27] <= 0;\n            out_reg_file[28] <= 0;\n            out_reg_file[29] <= 0;\n            out_reg_file[30] <= 0;\n            out_reg_file[31] <= 0;\n        end\n        else begin\n            out_reg_file[0] <= reg_file[0];\n            out_reg_file[1] <= reg_file[1];\n            out_reg_file[2] <= reg_file[2];\n            out_reg_file[3] <= reg_file[3];\n            out_reg_file[4] <= reg_file[4];\n            out_reg_file[5] <= reg_file[5];\n            out_reg_file[6] <= reg_file[6];\n            out_reg_file[7] <= reg_file[7];\n            out_reg_file[8] <= reg_file[8];\n            out_reg_file[9] <= reg_file[9];\n            out_reg_file[10] <= reg_file[10];\n            out_reg_file[11] <= reg_file[11];\n            out_reg_file[12] <= reg_file[12];\n            out_reg_file[13] <= reg_file[13];\n            out_reg_file[14] <= reg_file[14];\n            out_reg_file[15] <= reg_file[15];\n            out_reg_file[16] <= reg_file[16];\n            out_reg_file[17] <= reg_file[17];\n            out_reg_file[18] <= reg_file[18];\n            out_reg_file[19] <= reg_file[19];\n            out_reg_file[20] <= reg_file[20];\n            out_reg_file[21] <= reg_file[21];\n            out_reg_file[22] <= reg_file[22];\n            out_reg_file[23] <= reg_file[23];\n            out_reg_file[24] <= reg_file[24];\n            out_reg_file[25] <= reg_file[25];\n            out_reg_file[26] <= reg_file[26];\n            out_reg_file[27] <= reg_file[27];\n            out_reg_file[28] <= reg_file[28];\n            out_reg_file[29] <= reg_file[29];\n            out_reg_file[30] <= reg_file[30];\n            out_reg_file[31] <= reg_file[31];\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control logic to determine the result\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire [1:0] op_code\n);\n    assign result = (op_code == 2'b00) ? a & b : a | b;\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_up increment (\n        .clk(clk),\n        .reset(reset),\n        .init_count(init_out),\n        .count_out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_up (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count_out <= init_count;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (valid_in) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n        end else if (valid_in) begin\n            data_out <= data_out + data_in;\n        end\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end else if (count == 4) begin\n            valid_out <= 1;\n        end else begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodules\n    wire [3:0] init_out;\n    wire [3:0] inc_out;\n\n    // Initialization submodule\n    initial_count init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Increment submodule\n    increment inc (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .inc_out(inc_out)\n    );\n\n    // Output\n    assign out = inc_out;\n\nendmodule\n\nmodule initial_count (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end\n    end\nendmodule\n\nmodule increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            out <= init_out + 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0(\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1(\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b00000000;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodules\ncounter_logic u_counter_logic (\n    .current_count(count),\n    .next_count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .current_count(count),\n    .next_count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    output reg [15:0] next_count,\n    input wire up_down\n);\n\nalways @(*) begin\n    if (up_down)\n        next_count = current_count + 1;\n    else\n        next_count = current_count - 1;\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        next_count <= 0;\n    else\n        next_count <= current_count;\nend\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [2:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [2:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product PP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product PP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product PP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product PP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product PP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product PP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product PP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product PP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 2 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 2-bit adder\n    adder_2bit adder (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X[0]),\n        .Y(Y[0]),\n        .Sum(Sum[0]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Carry_in,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output assignment\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y), .A(A0));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y), .A(A1));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y), .A(A2));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y), .A(A3));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y), .A(A4));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y), .A(A5));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y), .A(A6));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y), .A(A7));\n\n    // Assign the final product\n    assign P = A7 + (A6 << 1) + (A5 << 2) + (A4 << 3) + (A3 << 4) + (A2 << 5) + (A1 << 6) + (A0 << 7);\n\nendmodule\n\nmodule add_shift(X, Y, A);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] A;\n    reg [15:0] A_reg;\n\n    always @(*) begin\n        A_reg = 0;\n        if (Y[0]) A_reg = A_reg + (X << 0);\n        if (Y[1]) A_reg = A_reg + (X << 1);\n        if (Y[2]) A_reg = A_reg + (X << 2);\n        if (Y[3]) A_reg = A_reg + (X << 3);\n        if (Y[4]) A_reg = A_reg + (X << 4);\n        if (Y[5]) A_reg = A_reg + (X << 5);\n        if (Y[6]) A_reg = A_reg + (X << 6);\n        if (Y[7]) A_reg = A_reg + (X << 7);\n    end\n\n    assign A = A_reg;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.A(A0), .B(X), .C(Y[0]), .S(0));\n    add_shift AS1(.A(A1), .B(A0), .C(Y[1]), .S(1));\n    add_shift AS2(.A(A2), .B(A1), .C(Y[2]), .S(2));\n    add_shift AS3(.A(A3), .B(A2), .C(Y[3]), .S(3));\n    add_shift AS4(.A(A4), .B(A3), .C(Y[4]), .S(4));\n    add_shift AS5(.A(A5), .B(A4), .C(Y[5]), .S(5));\n    add_shift AS6(.A(A6), .B(A5), .C(Y[6]), .S(6));\n    add_shift AS7(.A(A7), .B(A6), .C(Y[7]), .S(7));\n\n    // Assign the product\n    assign P = A7;\n\nendmodule\n\nmodule add_shift(A, B, C, S);\n    input [15:0] B;\n    input C;\n    input [3:0] S;\n    output [15:0] A;\n\n    wire [15:0] B_shifted;\n\n    assign B_shifted = B << S;\n\n    always @(*) begin\n        if (C)\n            A = B + B_shifted;\n        else\n            A = B_shifted;\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge rst_n or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negating the divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient <= 0;\n        remainder <= 0;\n        res_valid <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            counter <= 4'd0;\n            shift_reg <= {8'd0, dividend};\n            quotient <= 0;\n            remainder <= 0;\n            res_valid <= 1;\n        end else if (res_ready) begin\n            res_valid <= 0;\n        end else begin\n            if (counter < 4'd15) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[14:0], 1'b0};\n                if (shift_reg[15] == divisor[7]) begin\n                    temp_quotient[counter] <= 1;\n                    temp_remainder[counter] <= 0;\n                end else begin\n                    temp_quotient[counter] <= 0;\n                    temp_remainder[counter] <= shift_reg[15];\n                end\n            end else begin\n                quotient <= temp_quotient;\n                remainder <= temp_remainder;\n                res_valid <= 1;\n            end\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= 0;\n        end else begin\n            if (res_valid) begin\n                result <= {remainder, quotient};\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 2 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(Carry_out)\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit full adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Carry_in,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instance of the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instance of the logic module\n    JC_logic logic_inst (\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input           clk,\n    input           rst_n,\n    output [63:0]  Q,\n    output reg [63:0] Q_reg\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_reg <= 64'b0;\n        end else begin\n            Q_reg <= Q;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input   [63:0]  Q,\n    output  [63:0] Q_next\n);\n\n    assign Q_next = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit input operand X\n    input [3:0] Y;       // 4-bit input operand Y\n    output [7:0] P;       // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    full_adder add1(\n        .a(X[0]),\n        .b(Y[0]),\n        .cin(1'b0),\n        .sum(p0),\n        .cout(p1)\n    );\n\n    full_adder add2(\n        .a(X[1]),\n        .b(Y[1]),\n        .cin(p1),\n        .sum(p2),\n        .cout(p3)\n    );\n\n    full_adder add3(\n        .a(X[2]),\n        .b(Y[2]),\n        .cin(p3),\n        .sum(p2),\n        .cout(p3)\n    );\n\n    full_adder add4(\n        .a(X[3]),\n        .b(Y[3]),\n        .cin(p3),\n        .sum(p2),\n        .cout(p3)\n    );\n\n    // Final sum\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit input operand X\n    input [3:0] Y;       // 4-bit input operand Y\n    output [7:0] P;       // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products;\n\n    // Partial products\n    wire [3:0] pp0, pp1, pp2, pp3;\n    assign pp0 = X[0] & Y[0];\n    assign pp1 = X[1] & Y[1];\n    assign pp2 = X[2] & Y[2];\n    assign pp3 = X[3] & Y[3];\n\n    // Shift and add\n    wire [7:0] sum0, sum1, sum2, sum3;\n    assign sum0 = {pp0, 4'b0000};\n    assign sum1 = {pp1, 4'b0000} << 1;\n    assign sum2 = {pp2, 4'b0000} << 2;\n    assign sum3 = {pp3, 4'b0000} << 3;\n\n    // Adders\n    adder_8bit add1(.a(sum0), .b(sum1), .c(0), .sum(sum0));\n    adder_8bit add2(.a(sum2), .b(sum3), .c(0), .sum(sum2));\n    adder_8bit add3(.a(sum0), .b(sum2), .c(0), .sum(P));\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n    assign sum = a + b + c;\nendmodule\n\nmodule full_adder_8bit(a, b, c, sum, c_out);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n    output c_out;\n    assign {c_out, sum} = a + b + c;\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4'd9) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 7'd49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [3:0] counter;\nwire [15:0] shift_reg;\n\n// Instantiate submodules\nabs_value abs_dividend_module (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_module (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .divisor(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_module (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .shift_reg(shift_reg)\n);\n\nresult_management res_mgmt_module (\n    .clk(clk),\n    .rst(rst),\n    .counter(counter),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .result(result)\n);\n\n// Connect submodules\nassign result = {shift_reg[15:8], shift_reg[7:0]};\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= ~dividend + 1;\n        end else begin\n            result <= dividend;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negated divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= ~divisor + 1;\n        end else begin\n            result <= divisor;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [15:0] shift_reg\n);\n\nreg [3:0] counter_reg;\nreg [15:0] shift_reg_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter_reg <= 0;\n        shift_reg_reg <= 0;\n    end else begin\n        if (opn_valid) begin\n            if (sign) begin\n                counter_reg <= 4'd15;\n                shift_reg_reg <= {1'b0, dividend[7:0]};\n            end else begin\n                counter_reg <= 4'd7;\n                shift_reg_reg <= {1'b0, dividend[7:0]};\n            end\n        end else begin\n            if (counter_reg > 0) begin\n                counter_reg <= counter_reg - 1;\n                shift_reg_reg <= shift_reg_reg << 1;\n            end\n        end\n    end\nend\n\nassign counter = counter_reg;\nassign shift_reg = shift_reg_reg;\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] counter,\n    input wire res_ready,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nreg [3:0] counter_reg;\nreg [15:0] shift_reg_reg;\nreg [15:0] result_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter_reg <= 0;\n        shift_reg_reg <= 0;\n        result_reg <= 0;\n        res_valid <= 0;\n    end else begin\n        if (opn_valid) begin\n            counter_reg <= counter;\n            shift_reg_reg <= 0;\n            result_reg <= 0;\n            res_valid <= 1;\n        end else begin\n            if (res_ready) begin\n                res_valid <= 0;\n            end\n            if (counter_reg > 0) begin\n                counter_reg <= counter_reg - 1;\n                shift_reg_reg <= shift_reg_reg << 1;\n                result_reg <= result_reg + shift_reg_reg[0];\n            end\n        end\n    end\nend\n\nassign result = result_reg;\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the 4-bit adder for each bit of Y\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;             // 1-bit input multiplier\n    output [7:0] p;      // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the 2-bit adder for each bit of x\n    adder_2bit adder_0(.x(x[0]), .y(y), .p(p0));\n    adder_2bit adder_1(.x(x[1]), .y(y), .p(p1));\n\n    // Combine the partial products\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input x;             // 1-bit input multiplicand\n    input y;             // 1-bit input multiplier\n    output [7:0] p;      // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the 1-bit adder for each bit of x\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n    adder_1bit adder_1(.x(x), .y(y), .p(p1));\n\n    // Combine the partial products\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input x;             // 1-bit input multiplicand\n    input y;             // 1-bit input multiplier\n    output [7:0] p;      // 8-bit output representing the product of x and y\n\n    assign p = x + (y << 1);\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result, sub_result, and_result;\n    wire add_carry, sub_carry;\n\n    // Instantiate adder and subtractor modules\n    adder add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    and_gate and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry :\n                       1'b0;\n\nendmodule\n\nmodule adder(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A + B;\nendmodule\n\nmodule subtractor(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A - B;\nendmodule\n\nmodule and_gate(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        remainder = dividend;\n        quotient = 0;\n        while (remainder >= divisor) begin\n            remainder = remainder - divisor;\n            quotient = quotient + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4'd9) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 7'd49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer to select carry/borrow\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(p0), .y(Y[1]), .p(p1));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(p1), .y(Y[2]), .p(p2));\n\n    // Assign the final product\n    assign P = {p2, p1, p0};\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input [0:0] y;      // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_2bit adder_1(.x(p0), .y(x[1]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [1:0] x;      // 2-bit input multiplicand\n    input [0:0] y;      // 1-bit input multiplier\n    output [3:0] p;     // 4-bit output representing the product of x and y\n\n    wire [3:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_1bit adder_1(.x(p0), .y(x[1]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [0:0] x;      // 1-bit input multiplicand\n    input [0:0] y;      // 1-bit input multiplier\n    output [1:0] p;     // 2-bit output representing the product of x and y\n\n    assign p = x + y;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the results to the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepend 16 zeroes to the dividend\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        // Shift the dividend and compare with the divisor\n        quotient = 0;\n        remainder = dividend;\n        while (remainder >= divisor) begin\n            remainder = remainder - divisor;\n            quotient = quotient + 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire clk_div_int1, clk_div_int2;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average u_clk_average (\n        .clk(clk),\n        .count(counter_out),\n        .clk_div_int1(clk_div_int1)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MUL2_DIV_CLK(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .clk_div_int1(clk_div_int1),\n        .clk_div_int2(clk_div_int2)\n    );\n\n    // Logical OR gate to generate final divided clock signal\n    assign clk_div = clk_div_int1 | clk_div_int2;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input [3:0] count,\n    output reg clk_div_int1\n);\n    always @(posedge clk) begin\n        if (count == 4) begin\n            clk_div_int1 <= 1;\n        end else if (count == 3) begin\n            clk_div_int1 <= 0;\n        end else begin\n            clk_div_int1 <= clk_div_int1;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_div_int1,\n    output reg clk_div_int2\n);\n    always @(negedge clk) begin\n        clk_div_int2 <= clk_div_int1;\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate adder, subtractor, and_logical, or_logical submodules\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\n// Select result based on op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND_RESULT\n);\n    assign AND_RESULT = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR_RESULT\n);\n    assign OR_RESULT = A | B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selection logic\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'b00000000;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"sum\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"diff\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", operand_b, \"and_result\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", operand_b, \"or_result\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4, clk_3;\n    reg [2:0] counter;\n    wire clk_avg, clk_adj;\n\n    // Counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter)\n    );\n\n    // Clock average generator module\n    clk_average u_clk_average (\n        .clk_in(clk),\n        .counter_value(counter),\n        .clk_avg(clk_avg)\n    );\n\n    // Clock adjustment module\n    clk_adjustment u_clk_adjustment (\n        .clk_in(clk),\n        .clk_avg(clk_avg),\n        .clk_adj(clk_adj)\n    );\n\n    // Logic to generate divided clock\n    assign clk_4 = (counter == 3'b000) ? 1'b0 : 1'b1;\n    assign clk_3 = (counter == 3'b001) ? 1'b0 : 1'b1;\n    assign clk_div = clk_4 | clk_adj;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] counter\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 3'b000;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk_in,\n    input [2:0] counter_value,\n    output reg clk_avg\n);\n    always @(posedge clk_in) begin\n        if (counter_value == 3'b000) begin\n            clk_avg <= 1'b0;\n        end else if (counter_value == 3'b001) begin\n            clk_avg <= 1'b1;\n        end else begin\n            clk_avg <= 1'b0;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk_in,\n    input clk_avg,\n    output reg clk_adj\n);\n    always @(posedge clk_in) begin\n        if (clk_avg) begin\n            clk_adj <= 1'b1;\n        end else begin\n            clk_adj <= 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    // Output selection\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                  hold3_out;\n\nendmodule\n\n// Submodule for data holding\nmodule data_hold (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        out <= in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] sum;\nwire [3:0] diff;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder adder (\"A\", a, \"B\", b, \"SUM\", sum);\nsubtractor subtractor (\"A\", a, \"B\", b, \"DIFF\", diff);\nand_module and_op (\"A\", a, \"B\", b, \"AND_RESULT\", and_result);\nor_module or_op (\"A\", a, \"B\", b, \"OR_RESULT\", or_result);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM,\n    input [3:0] B_\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF,\n    input [3:0] B_\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND_RESULT,\n    input [3:0] B_\n);\n    assign AND_RESULT = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR_RESULT,\n    input [3:0] B_\n);\n    assign OR_RESULT = A | B;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Divisor value\n\n    // Submodule instances\n    wire clk_div1, clk_div2;\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0;\n    wire [7:0] hold1;\n    wire [7:0] hold2;\n    wire [7:0] hold3;\n\n    // Submodule instances\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                 hold3;\n\nendmodule\n\n// Submodule for data holding\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule interfaces\n    wire clk_div1;\n    wire clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Submodule parameter\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Submodule parameter\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .counter_limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out,\n    output counter_limit\n);\n\nparameter NUM_DIV = 4; // Even number that divides the input clock frequency\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter_out <= 0;\n    end else begin\n        if (counter_out == NUM_DIV / 2 - 1) begin\n            counter_out <= 0;\n        end else begin\n            counter_out <= counter_out + 1;\n        end\n    end\nend\n\nassign counter_limit = (counter_out == NUM_DIV / 2 - 1);\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 4; // Even number that divides the input clock frequency\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else begin\n        if (counter_out == NUM_DIV / 2 - 1) begin\n            clk_div <= ~clk_div;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl duty_ctrl_inst (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen_inst (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] adjusted_duty;\n\n    always @(posedge clk) begin\n        if (counter < adjusted_duty) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 10) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 5) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] pulse_width;\n    reg pwm_out_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pulse_width <= duty_cycle;\n            pwm_out_reg <= 1'b1;\n        end else begin\n            pulse_width <= 8'd255 - duty_cycle;\n            pwm_out_reg <= 1'b0;\n        end\n\n        counter <= counter + 1;\n        if (counter == 8'd255) begin\n            counter <= 0;\n        end\n    end\n\n    assign pwm_out = pwm_out_reg;\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output [7:0] adjusted_duty\n);\n\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\n    assign adjusted_duty = duty_cycle_reg;\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module (\n    .a(data_a),\n    .b(data_b),\n    .result(add_result)\n);\n\nsubtractor sub_module (\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result)\n);\n\nmultiplier mul_module (\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result)\n);\n\ndivider div_module (\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_8, b_8, a_8_eq, b_8_eq;\n    wire [3:0] a_4, b_4, a_4_eq, b_4_eq;\n    wire [1:0] a_2, b_2, a_2_eq, b_2_eq;\n    wire a_1, b_1, a_1_eq, b_1_eq;\n\n    // 8-bit comparators\n    comp8 comp8_inst1(.a(a[31:24]), .b(b[31:24]), .equal(a_8_eq));\n    comp8 comp8_inst2(.a(a[23:16]), .b(b[23:16]), .equal(b_8_eq));\n    comp8 comp8_inst3(.a(a[15:8]), .b(b[15:8]), .equal(a_8));\n    comp8 comp8_inst4(.a(a[7:0]), .b(b[7:0]), .equal(b_8));\n\n    // 4-bit comparators\n    comp4 comp4_inst1(.a(a_8), .b(b_8), .equal(a_4_eq));\n    comp4 comp4_inst2(.a(a_8_eq), .b(b_8_eq), .equal(a_4));\n    comp4 comp4_inst3(.a(a_4), .b(b_4), .equal(a_2_eq));\n    comp4 comp4_inst4(.a(a_4_eq), .b(b_4_eq), .equal(a_2));\n\n    // 2-bit comparators\n    comp2 comp2_inst1(.a(a_2), .b(b_2), .equal(a_1_eq));\n    comp2 comp2_inst2(.a(a_2_eq), .b(b_2_eq), .equal(a_1));\n\n    // Final output\n    assign equal = a_1_eq & b_1_eq;\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comp4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comp2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate arithmetic operations\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select operation based on opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end\n        else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n            valid <= (opcode == 2'b11) ? ~div_result[15] : 1;\n        end\n    end\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a / b;\n    assign valid = (b == 0) ? 0 : 1;\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal_0, equal_1, equal_2, equal_3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_3)\n    );\n\n    assign equal = equal_0 & equal_1 & equal_2 & equal_3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add add_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(add_carry),\n        .zero(add_zero),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .carry(add_carry),\n        .zero(add_zero),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .carry(and_carry),\n        .zero(and_zero),\n        .negative(and_negative),\n        .overflow(and_overflow)\n    );\n\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_result),\n        .carry(or_carry),\n        .zero(or_zero),\n        .negative(or_negative),\n        .overflow(or_overflow)\n    );\n\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_result),\n        .carry(xor_carry),\n        .zero(xor_zero),\n        .negative(xor_negative),\n        .overflow(xor_overflow)\n    );\n\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_result),\n        .carry(nor_carry),\n        .zero(nor_zero),\n        .negative(nor_negative),\n        .overflow(nor_overflow)\n    );\n\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .carry(slt_carry),\n        .zero(slt_zero),\n        .negative(slt_negative),\n        .overflow(slt_overflow)\n    );\n\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_result),\n        .carry(sltu_carry),\n        .zero(sltu_zero),\n        .negative(sltu_negative),\n        .overflow(sltu_overflow)\n    );\n\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .carry(sll_carry),\n        .zero(sll_zero),\n        .negative(sll_negative),\n        .overflow(sll_overflow)\n    );\n\n    srl srl_inst(\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .carry(srl_carry),\n        .zero(srl_zero),\n        .negative(srl_negative),\n        .overflow(srl_overflow)\n    );\n\n    sra sra_inst(\n        .a(a),\n        .b(b),\n        .r(sra_result),\n        .carry(sra_carry),\n        .zero(sra_zero),\n        .negative(sra_negative),\n        .overflow(sra_overflow)\n    );\n\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(sllv_result),\n        .carry(sllv_carry),\n        .zero(sllv_zero),\n        .negative(sllv_negative),\n        .overflow(sllv_overflow)\n    );\n\n    srlv srlv_inst(\n        .a(a),\n        .b(b),\n        .r(srlv_result),\n        .carry(srlv_carry),\n        .zero(srlv_zero),\n        .negative(srlv_negative),\n        .overflow(srlv_overflow)\n    );\n\n    srav srav_inst(\n        .a(a),\n        .b(b),\n        .r(srav_result),\n        .carry(srav_carry),\n        .zero(srav_zero),\n        .negative(srav_negative),\n        .overflow(srav_overflow)\n    );\n\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .carry(lui_carry),\n        .zero(lui_zero),\n        .negative(lui_negative),\n        .overflow(lui_overflow)\n    );\n\n    // Select operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               lui_result;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? addu_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? subu_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  lui_zero;\n\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? addu_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? subu_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   lui_carry;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? addu_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? subu_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      lui_negative;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? addu_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? subu_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      lui_overflow;\n\n    assign flag = (aluc == 6'b101010) ? slt_flag :\n                  (aluc == 6'b101011) ? sltu_flag :\n                  (aluc == 6'b000000) ? sll_flag :\n                  (aluc == 6'b000010) ? srl_flag :\n                  (aluc == 6'b000011) ? sra_flag :\n                  (aluc == 6'b000100) ? sllv_flag :\n                  (aluc == 6'b000110) ? srlv_flag :\n                  (aluc == 6'b000111) ? srav_flag :\n                  0;\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == 1 && b[31] == 0 && r[31] == 0);\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == 1 && b[31] == 0 && r[31] == 0);\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the results\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_remainder;\n    reg [15:0] shifted_dividend_temp;\n    reg [15:0] shifted_remainder_temp;\n    reg [15:0] shifted_dividend_temp2;\n    reg [15:0] shifted_remainder_temp2;\n    reg [15:0] shifted_dividend_temp3;\n    reg [15:0] shifted_remainder_temp3;\n    reg [15:0] shifted_dividend_temp4;\n    reg [15:0] shifted_remainder_temp4;\n    reg [15:0] shifted_dividend_temp5;\n    reg [15:0] shifted_remainder_temp5;\n    reg [15:0] shifted_dividend_temp6;\n    reg [15:0] shifted_remainder_temp6;\n    reg [15:0] shifted_dividend_temp7;\n    reg [15:0] shifted_remainder_temp7;\n    reg [15:0] shifted_dividend_temp8;\n    reg [15:0] shifted_remainder_temp8;\n    reg [15:0] shifted_dividend_temp9;\n    reg [15:0] shifted_remainder_temp9;\n    reg [15:0] shifted_dividend_temp10;\n    reg [15:0] shifted_remainder_temp10;\n    reg [15:0] shifted_dividend_temp11;\n    reg [15:0] shifted_remainder_temp11;\n    reg [15:0] shifted_dividend_temp12;\n    reg [15:0] shifted_remainder_temp12;\n    reg [15:0] shifted_dividend_temp13;\n    reg [15:0] shifted_remainder_temp13;\n    reg [15:0] shifted_dividend_temp14;\n    reg [15:0] shifted_remainder_temp14;\n    reg [15:0] shifted_dividend_temp15;\n    reg [15:0] shifted_remainder_temp15;\n    reg [15:0] shifted_dividend_temp16;\n    reg [15:0] shifted_remainder_temp16;\n    reg [15:0] shifted_dividend_temp17;\n    reg [15:0] shifted_remainder_temp17;\n    reg [15:0] shifted_dividend_temp18;\n    reg [15:0] shifted_remainder_temp18;\n    reg [15:0] shifted_dividend_temp19;\n    reg [15:0] shifted_remainder_temp19;\n    reg [15:0] shifted_dividend_temp20;\n    reg [15:0] shifted_remainder_temp20;\n    reg [15:0] shifted_dividend_temp21;\n    reg [15:0] shifted_remainder_temp21;\n    reg [15:0] shifted_dividend_temp22;\n    reg [15:0] shifted_remainder_temp22;\n    reg [15:0] shifted_dividend_temp23;\n    reg [15:0] shifted_remainder_temp23;\n    reg [15:0] shifted_dividend_temp24;\n    reg [15:0] shifted_remainder_temp24;\n    reg [15:0] shifted_dividend_temp25;\n    reg [15:0] shifted_remainder_temp25;\n    reg [15:0] shifted_dividend_temp26;\n    reg [15:0] shifted_remainder_temp26;\n    reg [15:0] shifted_dividend_temp27;\n    reg [15:0] shifted_remainder_temp27;\n    reg [15:0] shifted_dividend_temp28;\n    reg [15:0] shifted_remainder_temp28;\n    reg [15:0] shifted_dividend_temp29;\n    reg [15:0] shifted_remainder_temp29;\n    reg [15:0] shifted_dividend_temp30;\n    reg [15:0] shifted_remainder_temp30;\n    reg [15:0] shifted_dividend_temp31;\n    reg [15:0] shifted_remainder_temp31;\n    reg [15:0] shifted_dividend_temp32;\n    reg [15:0] shifted_remainder_temp32;\n    reg [15:0] shifted_dividend_temp33;\n    reg [15:0] shifted_remainder_temp33;\n    reg [15:0] shifted_dividend_temp34;\n    reg [15:0] shifted_remainder_temp34;\n    reg [15:0] shifted_dividend_temp35;\n    reg [15:0] shifted_remainder_temp35;\n    reg [15:0] shifted_dividend_temp36;\n    reg [15:0] shifted_remainder_temp36;\n    reg [15:0] shifted_dividend_temp37;\n    reg [15:0] shifted_remainder_temp37;\n    reg [15:0] shifted_dividend_temp38;\n    reg [15:0] shifted_remainder_temp38;\n    reg [15:0] shifted_dividend_temp39;\n    reg [15:0] shifted_remainder_temp39;\n    reg [15:0] shifted_dividend_temp40;\n    reg [15:0] shifted_remainder_temp40;\n    reg [15:0] shifted_dividend_temp41;\n    reg [15:0] shifted_remainder_temp41;\n    reg [15:0] shifted_dividend_temp42;\n    reg [15:0] shifted_remainder_temp42;\n    reg [15:0] shifted_dividend_temp43;\n    reg [15:0] shifted_remainder_temp43;\n    reg [15:0] shifted_dividend_temp44;\n    reg [15:0] shifted_remainder_temp44;\n    reg [15:0] shifted_dividend_temp45;\n    reg [15:0] shifted_remainder_temp45;\n    reg [15:0] shifted_dividend_temp46;\n    reg [15:0] shifted_remainder_temp46;\n    reg [15:0] shifted_dividend_temp47;\n    reg [15:0] shifted_remainder_temp47;\n    reg [15:0] shifted_dividend_temp48;\n    reg [15:0] shifted_remainder_temp48;\n    reg [15:0] shifted_dividend_temp49;\n    reg [15:0] shifted_remainder_temp49;\n    reg [15:0] shifted_dividend_temp50;\n    reg [15:0] shifted_remainder_temp50;\n    reg [15:0] shifted_dividend_temp51;\n    reg [15:0] shifted_remainder_temp51;\n    reg [15:0] shifted_dividend_temp52;\n    reg [15:0] shifted_remainder_temp52;\n    reg [15:0] shifted_dividend_temp53;\n    reg [15:0] shifted_remainder_temp53;\n    reg [15:0] shifted_dividend_temp54;\n    reg [15:0] shifted_remainder_temp54;\n    reg [15:0] shifted_dividend_temp55;\n    reg [15:0] shifted_remainder_temp55;\n    reg [15:0] shifted_dividend_temp56;\n    reg [15:0] shifted_remainder_temp56;\n    reg [15:0] shifted_dividend_temp57;\n    reg [15:0] shifted_remainder_temp57;\n    reg [15:0] shifted_dividend_temp58;\n    reg [15:0] shifted_remainder_temp58;\n    reg [15:0] shifted_dividend_temp59;\n    reg [15:0] shifted_remainder_temp59;\n    reg [15:0] shifted_dividend_temp60;\n    reg [15:0] shifted_remainder_temp60;\n    reg [15:0] shifted_dividend_temp61;\n    reg [15:0] shifted_remainder_temp61;\n    reg [15:0] shifted_dividend_temp62;\n    reg [15:0] shifted_remainder_temp62;\n    reg [15:0] shifted_dividend_temp63;\n    reg [15:0] shifted_remainder_temp63;\n    reg [15:0] shifted_dividend_temp64;\n    reg [15:0] shifted_remainder_temp64;\n    reg [15:0] shifted_dividend_temp65;\n    reg [15:0] shifted_remainder_temp65;\n    reg [15:0] shifted_dividend_temp66;\n    reg [15:0] shifted_remainder_temp66;\n    reg [15:0] shifted_dividend_temp67;\n    reg [15:0] shifted_remainder_temp67;\n    reg [15:0] shifted_dividend_temp68;\n    reg [15:0] shifted_remainder_temp68;\n    reg [15:0] shifted_dividend_temp69;\n    reg [15:0] shifted_remainder_temp69;\n    reg [15:0] shifted_dividend_temp70;\n    reg [15:0] shifted_remainder_temp70;\n    reg [15:0] shifted_dividend_temp71;\n    reg [15:0] shifted_remainder_temp71;\n    reg [15:0] shifted_dividend_temp72;\n    reg [15:0] shifted_remainder_temp72;\n    reg [15:0] shifted_dividend_temp73;\n    reg [15:0] shifted_remainder_temp73;\n    reg [15:0] shifted_dividend_temp74;\n    reg [15:0] shifted_remainder_temp74;\n    reg [15:0] shifted_dividend_temp75;\n    reg [15:0] shifted_remainder_temp75;\n    reg [15:0] shifted_dividend_temp76;\n    reg [15:0] shifted_remainder_temp76;\n    reg [15:0] shifted_dividend_temp77;\n    reg [15:0] shifted_remainder_temp77;\n    reg [15:0] shifted_dividend_temp78;\n    reg [15:0] shifted_remainder_temp78;\n    reg [15:0] shifted_dividend_temp79;\n    reg [15:0] shifted_remainder_temp79;\n    reg [15:0] shifted_dividend_temp80;\n    reg [15:0] shifted_remainder_temp80;\n    reg [15:0] shifted_dividend_temp81;\n    reg [15:0] shifted_remainder_temp81;\n    reg [15:0] shifted_dividend_temp82;\n    reg [15:0] shifted_remainder_temp82;\n    reg [15:0] shifted_dividend_temp83;\n    reg [15:0] shifted_remainder_temp83;\n    reg [15:0] shifted_dividend_temp84;\n    reg [15:0] shifted_remainder_temp84;\n    reg [15:0] shifted_dividend_temp85;\n    reg [15:0] shifted_remainder_temp85;\n    reg [15:0] shifted_dividend_temp86;\n    reg [15:0] shifted_remainder_temp86;\n    reg [15:0] shifted_dividend_temp87;\n    reg [15:0] shifted_remainder_temp87;\n    reg [15:0] shifted_dividend_temp88;\n    reg [15:0] shifted_remainder_temp88;\n    reg [15:0] shifted_dividend_temp89;\n    reg [15:0] shifted_remainder_temp89;\n    reg [15:0] shifted_dividend_temp90;\n    reg [15:0] shifted_remainder_temp90;\n    reg [15:0] shifted_dividend_temp91;\n    reg [15:0] shifted_remainder_temp91;\n    reg [15:0] shifted_dividend_temp92;\n    reg [15:0] shifted_remainder_temp92;\n    reg [15:0] shifted_dividend_temp93;\n    reg [15:0] shifted_remainder_temp93;\n    reg [15:0] shifted_dividend_temp94;\n    reg [15:0] shifted_remainder_temp94;\n    reg [15:0] shifted_dividend_temp95;\n    reg [15:0] shifted_remainder_temp95;\n    reg [15:0] shifted_dividend_temp96;\n    reg [15:0] shifted_remainder_temp96;\n    reg [15:0] shifted_dividend_temp97;\n    reg [15:0] shifted_remainder_temp97;\n    reg [15:0] shifted_dividend_temp98;\n    reg [15:0] shifted_remainder_temp98;\n    reg [15:0] shifted_dividend_temp99;\n    reg [15:0] shifted_remainder_temp99;\n    reg [15:0] shifted_dividend_temp100;\n    reg [15:0] shifted_remainder_temp100;\n    reg [15:0] shifted_dividend_temp101;\n    reg [15:0] shifted_remainder_temp101;\n    reg [15:0] shifted_dividend_temp102;\n    reg [15:0] shifted_remainder_temp102;\n    reg [15:0] shifted_dividend_temp103;\n    reg [15:0] shifted_remainder_temp103;\n    reg [15:0] shifted_dividend_temp104;\n    reg [15:0] shifted_remainder_temp104;\n    reg [15:0] shifted_dividend_temp105;\n    reg [15:0] shifted_remainder_temp105;\n    reg [15:0] shifted_dividend_temp106;\n    reg [15:0] shifted_remainder_temp106;\n    reg [15:0] shifted_dividend_temp107;\n    reg [15:0] shifted_remainder_temp107;\n    reg [15:0] shifted_dividend_temp108;\n    reg [15:0] shifted_remainder_temp108;\n    reg [15:0] shifted_dividend_temp109;\n    reg [15:0] shifted_remainder_temp109;\n    reg [15:0] shifted_dividend_temp110;\n    reg [15:0] shifted_remainder_temp110;\n    reg [15:0] shifted_dividend_temp111;\n    reg [15:0] shifted_remainder_temp111;\n    reg [15:0] shifted_dividend_temp112;\n    reg [15:0] shifted_remainder_temp112;\n    reg [15:0] shifted_dividend_temp113;\n    reg [15:0] shifted_remainder_temp113;\n    reg [15:0] shifted_dividend_temp114;\n    reg [15:0] shifted_remainder_temp114;\n    reg [15:0] shifted_dividend_temp115;\n    reg [15:0] shifted_remainder_temp115;\n    reg [15:0] shifted_dividend_temp116;\n    reg [15:0] shifted_remainder_temp116;\n    reg [15:0] shifted_dividend_temp117;\n    reg [15:0] shifted_remainder_temp117;\n    reg [15:0] shifted_dividend_temp118;\n    reg [15:0] shifted_remainder_temp118;\n    reg [15:0] shifted_dividend_temp119;\n    reg [15:0] shifted_remainder_temp119;\n    reg [15:0] shifted_dividend_temp120;\n    reg [15:0] shifted_remainder_temp120;\n    reg [15:0] shifted_dividend_temp121;\n    reg [15:0] shifted_remainder_temp121;\n    reg [15:0] shifted_dividend_temp122;\n    reg [15:0] shifted_remainder_temp122;\n    reg [15:0] shifted_dividend_temp123;\n    reg [15:0] shifted_remainder_temp123;\n    reg [15:0] shifted_dividend_temp124;\n    reg [15:0] shifted_remainder_temp124;\n    reg [15:0] shifted_dividend_temp125;\n    reg [15:0] shifted_remainder_temp125;\n    reg [15:0] shifted_dividend_temp126;\n    reg [15:0] shifted_remainder_temp126;\n    reg [15:0] shifted_dividend_temp127;\n    reg [15:0] shifted_remainder_temp127;\n    reg [15:0] shifted_dividend_temp128;\n    reg [15:0] shifted_remainder_temp128;\n    reg [15:0] shifted_dividend_temp129;\n    reg [15:0] shifted_remainder_temp129;\n    reg [15:0] shifted_dividend_temp130;\n    reg [15:0] shifted_remainder_temp130;\n    reg [15:0] shifted_dividend_temp131;\n    reg [15:0] shifted_remainder_temp131;\n    reg [15:0] shifted_dividend_temp132;\n    reg [15:0] shifted_remainder_temp132;\n    reg [15:0] shifted_dividend_temp133;\n    reg [15:0] shifted_remainder_temp133;\n    reg [15:0] shifted_dividend_temp134;\n    reg [15:0] shifted_remainder_temp134;\n    reg [15:0] shifted_dividend_temp135;\n    reg [15:0] shifted_remainder_temp135;\n    reg [15:0] shifted_dividend_temp136;\n    reg [15:0] shifted_remainder_temp136;\n    reg [15:0] shifted_dividend_temp137;\n    reg [15:0] shifted_remainder_temp137;\n    reg [15:0] shifted_dividend_temp138;\n    reg [15:0] shifted_remainder_temp138;\n    reg [15:0] shifted_dividend_temp139;\n    reg [15:0] shifted_remainder_temp139;\n    reg [15:0] shifted_dividend_temp140;\n    reg [15:0] shifted_remainder_temp140;\n    reg [15:0] shifted_dividend_temp141;\n    reg [15:0] shifted_remainder_temp141;\n    reg [15:0] shifted_dividend_temp142;\n    reg [15:0] shifted_remainder_temp142;\n    reg [15:0] shifted_dividend_temp143;\n    reg [15:0] shifted_remainder_temp143;\n    reg [15:0] shifted_dividend_temp144;\n    reg [15:0] shifted_remainder_temp144;\n    reg [15:0] shifted_dividend_temp145;\n    reg [15:0] shifted_remainder_temp145;\n    reg [15:0] shifted_dividend_temp146;\n    reg [15:0] shifted_remainder_temp146;\n    reg [15:0] shifted_dividend_temp147;\n    reg [15:0] shifted_remainder_temp147;\n    reg [15:0] shifted_dividend_temp148;\n    reg [15:0] shifted_remainder_temp148;\n    reg [15:0] shifted_dividend_temp149;\n    reg [15:0] shifted_remainder_temp149;\n    reg [15:0] shifted_dividend_temp150;\n    reg [15:0] shifted_remainder_temp150;\n    reg [15:0] shifted_dividend_temp151;\n    reg [15:0] shifted_remainder_temp151;\n    reg [15:0] shifted_dividend_temp152;\n    reg [15:0] shifted_remainder_temp152;\n    reg [15:0] shifted_dividend_temp153;\n    reg [15:0] shifted_remainder_temp153;\n    reg [15:0] shifted_dividend_temp154;\n    reg [15:0] shifted_remainder_temp154;\n    reg [15:0] shifted_dividend_temp155;\n    reg [15:0] shifted_remainder_temp155;\n    reg [15:0] shifted_dividend_temp156;\n    reg [15:0] shifted_remainder_temp156;\n    reg [15:0] shifted_dividend_temp157;\n    reg [15:0] shifted_remainder_temp157;\n    reg [15:0] shifted_dividend_temp158;\n    reg [15:0] shifted_remainder_temp158;\n    reg [15:0] shifted_dividend_temp159;\n    reg [15:0] shifted_remainder_temp159;\n    reg [15:0] shifted_dividend_temp160;\n    reg [15:0] shifted_remainder_temp160;\n    reg [15:0] shifted_dividend_temp161;\n    reg [15:0] shifted_remainder_temp161;\n    reg [15:0] shifted_dividend_temp162;\n    reg [15:0] shifted_remainder_temp162;\n    reg [15:0] shifted_dividend_temp163;\n    reg [15:0] shifted_remainder_temp163;\n    reg [15:0] shifted_dividend_temp164;\n    reg [15:0] shifted_remainder_temp164;\n    reg [15:0] shifted_dividend_temp165;\n    reg [15:0] shifted_remainder_temp165;\n    reg [15:0] shifted_dividend_temp166;\n    reg [15:0] shifted_remainder_temp166;\n    reg [15:0] shifted_dividend_temp167;\n    reg [15:0] shifted_remainder_temp167;\n    reg [15:0] shifted_dividend_temp168;\n    reg [15:0] shifted_remainder_temp168;\n    reg [15:0] shifted_dividend_temp169;\n    reg [15:0] shifted_remainder_temp169;\n    reg [15:0] shifted_dividend_temp170;\n    reg [15:0] shifted_remainder_temp170;\n    reg [15:0] shifted_dividend_temp171;\n    reg [15:0] shifted_remainder_temp171;\n    reg [15:0] shifted_dividend_temp172;\n    reg [15:0] shifted_remainder_temp172;\n    reg [15:0] shifted_dividend_temp173;\n    reg [15:0] shifted_remainder_temp173;\n    reg [15:0] shifted_dividend_temp174;\n    reg [15:0] shifted_remainder_temp174;\n    reg [15:0] shifted_dividend_temp175;\n    reg [15:0] shifted_remainder_temp175;\n    reg [15:0] shifted_dividend_temp176;\n    reg [15:0] shifted_remainder_temp176;\n    reg [15:0] shifted_dividend_temp177;\n    reg [15:0] shifted_remainder_temp177;\n    reg [15:0] shifted_dividend_temp178;\n    reg [15:0] shifted_remainder_temp178;\n    reg [15:0] shifted_dividend_temp179;\n    reg [15:0] shifted_remainder_temp179;\n    reg [15:0] shifted_dividend_temp180;\n    reg [15:0] shifted_remainder_temp180;\n    reg [15:0] shifted_dividend_temp181;\n    reg [15:0] shifted_remainder_temp181;\n    reg [15:0] shifted_dividend_temp182;\n    reg [15:0] shifted_remainder_temp182;\n    reg [15:0] shifted_dividend_temp183;\n    reg [15:0] shifted_remainder_temp183;\n    reg [15:0] shifted_dividend_temp184;\n    reg [15:0] shifted_remainder_temp184;\n    reg [15:0] shifted_dividend_temp185;\n    reg [15:0] shifted_remainder_temp185;\n    reg [15:0] shifted_dividend_temp186;\n    reg [15:0] shifted_remainder_temp186;\n    reg [15:0] shifted_dividend_temp187;\n    reg [15:0] shifted_remainder_temp187;\n    reg [15:0] shifted_dividend_temp188;\n    reg [15:0] shifted_remainder_temp188;\n    reg [15:0] shifted_dividend_temp189;\n    reg [15:0] shifted_remainder_temp189;\n    reg [15:0] shifted_dividend_temp190;\n    reg [15:0] shifted_remainder_temp190;\n    reg [15:0] shifted_dividend_temp191;\n    reg [15:0] shifted_remainder_temp191;\n    reg [15:0] shifted_dividend_temp192;\n    reg [15:0] shifted_remainder_temp192;\n    reg [15:0] shifted_dividend_temp193;\n    reg [15:0] shifted_remainder_temp193;\n    reg [15:0] shifted_dividend_temp194;\n    reg [15:0] shifted_remainder_temp194;\n    reg [15:0] shifted_dividend_temp195;\n    reg [15:0] shifted_remainder_temp195;\n    reg [15:0] shifted_dividend_temp196;\n    reg [15:0] shifted_remainder_temp196;\n    reg [15:0] shifted_dividend_temp197;\n    reg [15:0] shifted_remainder_temp197;\n    reg [15:0] shifted_dividend_temp198;\n    reg [15:0] shifted_remainder_temp198;\n    reg [15:0] shifted_dividend_temp199;\n    reg [15:0] shifted_remainder_temp199;\n    reg [15:0] shifted_dividend_temp200;\n    reg [15:0] shifted_remainder_temp200;\n    reg [15:0] shifted_dividend_temp201;\n    reg [15:0] shifted_remainder_temp201;\n    reg [15:0] shifted_dividend_temp202;\n    reg [15:0] shifted_remainder_temp202;\n    reg [15:0] shifted_dividend_temp203;\n    reg [15:0] shifted_remainder_temp203;\n    reg [15:0] shifted_dividend_temp204;\n    reg [15:0] shifted_remainder_temp204;\n    reg [15:0] shifted_dividend_temp205;\n    reg [15:0] shifted_remainder_temp205;\n    reg [15:0] shifted_dividend_temp206;\n    reg [15:0] shifted_remainder_temp206;\n    reg [15:0] shifted_dividend_temp207;\n    reg [15:0] shifted_remainder_temp207;\n    reg [15:0] shifted_dividend_temp208;\n    reg [15:0] shifted_remainder_temp208;\n    reg [15:0] shifted_dividend_temp209;\n    reg [15:0] shifted_remainder_temp209;\n    reg [15:0] shifted_dividend_temp210;\n    reg [15:0] shifted_remainder_temp210;\n    reg [15:0] shifted_dividend_temp211;\n    reg [15:0] shifted_remainder_temp211;\n    reg [15:0] shifted_dividend_temp212;\n    reg [15:0] shifted_remainder_temp212;\n    reg [15:0] shifted_dividend_temp213;\n    reg [15:0] shifted_remainder_temp213;\n    reg [15:0] shifted_dividend_temp214;\n    reg [15:0] shifted_remainder_temp214;\n    reg [15:0] shifted_dividend_temp215;\n    reg [15:0] shifted_remainder_temp215;\n    reg [15:0] shifted_dividend_temp216;\n    reg [15:0] shifted_remainder_temp216;\n    reg [15:"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the results\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire carry;          // Carry output from the adder\n\n    // Calculate 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Perform subtraction using full adder\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .C_in(1'b0),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Assign output\n    assign D = sum;\n    assign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input C_in;           // Carry input\n    output [7:0] sum;    // 8-bit sum output\n    output carry;        // Carry output\n\n    wire [8:0] temp_sum; // Temporary sum\n\n    // Perform addition using full adder\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .sum(temp_sum[0]),\n        .carry(temp_sum[1])\n    );\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(temp_sum[1]),\n        .sum(temp_sum[2]),\n        .carry(temp_sum[3])\n    );\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(temp_sum[3]),\n        .sum(temp_sum[4]),\n        .carry(temp_sum[5])\n    );\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(temp_sum[5]),\n        .sum(temp_sum[6]),\n        .carry(temp_sum[7])\n    );\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(temp_sum[7]),\n        .sum(temp_sum[8]),\n        .carry(temp_sum[9])\n    );\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .C_in(temp_sum[9]),\n        .sum(temp_sum[10]),\n        .carry(temp_sum[11])\n    );\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .C_in(temp_sum[11]),\n        .sum(temp_sum[12]),\n        .carry(temp_sum[13])\n    );\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .C_in(temp_sum[13]),\n        .sum(temp_sum[14]),\n        .carry(temp_sum[15])\n    );\n\n    // Assign output\n    assign sum = temp_sum[7:0];\n    assign carry = temp_sum[8];\n\nendmodule\n\nmodule full_adder(A, B, C_in, sum, carry);\n    input A;           // Input A\n    input B;           // Input B\n    input C_in;        // Carry input\n    output sum;        // Sum output\n    output carry;      // Carry output\n\n    assign sum = A ^ B ^ C_in;\n    assign carry = (A & B) | (C_in & (A ^ B));\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the difference of A and B\n    output B_out;       // Borrow output indicating if a borrow was generated\n\n    wire [7:0] B_comp;  // 2's complement of B\n    wire [7:0] sum;     // Sum of A and B_comp\n    wire carry;         // Carry output from the full adder\n\n    // Generate the 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Perform the subtraction operation\n    assign {carry, sum} = A + B_comp;\n\n    // Assign the output\n    assign D = sum;\n    assign B_out = carry;\nendmodule\n\nmodule adder_8bit(A, B, carry, sum);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    input carry;        // Carry input from the previous adder\n    output [7:0] sum;   // 8-bit sum of A and B\n    output carry_out;   // Carry output indicating if a carry was generated\n\n    wire [7:0] sum_temp; // Temporary sum\n    wire carry_temp;     // Temporary carry\n\n    // Perform the addition operation\n    assign {carry_temp, sum_temp} = A + B + carry;\n\n    // Assign the output\n    assign sum = sum_temp;\n    assign carry_out = carry_temp;\nendmodule\n\nmodule full_adder(A, B, carry, sum, carry_out);\n    input A;            // First input operand\n    input B;            // Second input operand\n    input carry;        // Carry input\n    output sum;         // Sum output\n    output carry_out;   // Carry output indicating if a carry was generated\n\n    assign {carry_out, sum} = A + B + carry;\nendmodule"}
{"task_id": "alu", "response": "`define ADD 6'b100000\n`define ADDU 6'b100001\n`define SUB 6'b100010\n`define SUBU 6'b100011\n`define AND 6'b100100\n`define OR 6'b100101\n`define XOR 6'b100110\n`define NOR 6'b100111\n`define SLT 6'b101010\n`define SLTU 6'b101011\n`define SLL 6'b000000\n`define SRL 6'b000010\n`define SRA 6'b000011\n`define SLLV 6'b000100\n`define SRLV 6'b000110\n`define SRAV 6'b000111\n`define LUI 6'b001111\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\nwire [31:0] xor_result;\nwire [31:0] nor_result;\nwire [31:0] slt_result;\nwire [31:0] sltu_result;\nwire [31:0] sll_result;\nwire [31:0] srl_result;\nwire [31:0] sra_result;\nwire [31:0] sllv_result;\nwire [31:0] srlv_result;\nwire [31:0] srav_result;\nwire [31:0] lui_result;\n\nwire [31:0] add_carry;\nwire [31:0] sub_carry;\nwire [31:0] and_carry;\nwire [31:0] or_carry;\nwire [31:0] xor_carry;\nwire [31:0] nor_carry;\nwire [31:0] slt_carry;\nwire [31:0] sltu_carry;\nwire [31:0] sll_carry;\nwire [31:0] srl_carry;\nwire [31:0] sra_carry;\nwire [31:0] sllv_carry;\nwire [31:0] srlv_carry;\nwire [31:0] srav_carry;\nwire [31:0] lui_carry;\n\nwire [31:0] add_overflow;\nwire [31:0] sub_overflow;\nwire [31:0] and_overflow;\nwire [31:0] or_overflow;\nwire [31:0] xor_overflow;\nwire [31:0] nor_overflow;\nwire [31:0] slt_overflow;\nwire [31:0] sltu_overflow;\nwire [31:0] sll_overflow;\nwire [31:0] srl_overflow;\nwire [31:0] sra_overflow;\nwire [31:0] sllv_overflow;\nwire [31:0] srlv_overflow;\nwire [31:0] srav_overflow;\nwire [31:0] lui_overflow;\n\nwire [31:0] add_zero;\nwire [31:0] sub_zero;\nwire [31:0] and_zero;\nwire [31:0] or_zero;\nwire [31:0] xor_zero;\nwire [31:0] nor_zero;\nwire [31:0] slt_zero;\nwire [31:0] sltu_zero;\nwire [31:0] sll_zero;\nwire [31:0] srl_zero;\nwire [31:0] sra_zero;\nwire [31:0] sllv_zero;\nwire [31:0] srlv_zero;\nwire [31:0] srav_zero;\nwire [31:0] lui_zero;\n\nwire add_flag;\nwire sub_flag;\nwire and_flag;\nwire or_flag;\nwire xor_flag;\nwire nor_flag;\nwire slt_flag;\nwire sltu_flag;\nwire sll_flag;\nwire srl_flag;\nwire sra_flag;\nwire sllv_flag;\nwire srlv_flag;\nwire srav_flag;\nwire lui_flag;\n\n// Instantiate submodules\nadd_submodule add(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow));\naddu_submodule addu(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow));\nsub_submodule sub(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow));\nsubu_submodule subu(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow));\nand_submodule and1(.a(a), .b(b), .r(and_result), .carry(and_carry), .overflow(and_overflow));\nor_submodule or1(.a(a), .b(b), .r(or_result), .carry(or_carry), .overflow(or_overflow));\nxor_submodule xor1(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .overflow(xor_overflow));\nnor_submodule nor1(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .overflow(nor_overflow));\nslt_submodule slt(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .overflow(slt_overflow));\nsltu_submodule sltu(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .overflow(sltu_overflow));\nsll_submodule sll(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .overflow(sll_overflow));\nsrl_submodule srl(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .overflow(srl_overflow));\nsra_submodule sra(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .overflow(sra_overflow));\nsllv_submodule sllv(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .overflow(sllv_overflow));\nsrlv_submodule srlv(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .overflow(srlv_overflow));\nsrav_submodule srav(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .overflow(srav_overflow));\nlui_submodule lui(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .overflow(lui_overflow));\n\n// Select result based on control signal\nassign r = (aluc == `ADD) ? add_result :\n           (aluc == `ADDU) ? add_result :\n           (aluc == `SUB) ? sub_result :\n           (aluc == `SUBU) ? sub_result :\n           (aluc == `AND) ? and_result :\n           (aluc == `OR) ? or_result :\n           (aluc == `XOR) ? xor_result :\n           (aluc == `NOR) ? nor_result :\n           (aluc == `SLT) ? slt_result :\n           (aluc == `SLTU) ? sltu_result :\n           (aluc == `SLL) ? sll_result :\n           (aluc == `SRL) ? srl_result :\n           (aluc == `SRA) ? sra_result :\n           (aluc == `SLLV) ? sllv_result :\n           (aluc == `SRLV) ? srlv_result :\n           (aluc == `SRAV) ? srav_result :\n           (aluc == `LUI) ? lui_result : 32'b0;\n\n// Compute flags\nassign zero = (r == 32'b0) ? 1'b1 : 1'b0;\nassign carry = (add_carry | sub_carry | or_carry | xor_carry | nor_carry | slt_carry | sltu_carry | sll_carry | srl_carry | sra_carry | sllv_carry | srlv_carry | srav_carry | lui_carry) ? 1'b1 : 1'b0;\nassign negative = (r[31] == 1'b1) ? 1'b1 : 1'b0;\nassign overflow = (add_overflow | sub_overflow | sll_overflow | srl_overflow | sra_overflow | sllv_overflow | srlv_overflow | srav_overflow | lui_overflow) ? 1'b1 : 1'b0;\nassign flag = (aluc == `SLT) ? slt_flag :\n              (aluc == `SLTU) ? sltu_flag :\n              1'b0;\n\n// Compute flag for specific operations\nassign add_flag = (a[31] == b[31]) ? 1'b0 : 1'b1;\nassign sub_flag = (a[31] == b[31]) ? 1'b0 : 1'b1;\nassign and_flag = (a[31] == b[31]) ? 1'b0 : 1'b1;\nassign or_flag = (a[31] == b[31]) ? 1'b0 : 1'b1;\nassign xor_flag = (a[31] == b[31]) ? 1'b0 : 1'b1;\nassign nor_flag = (a[31] == b[31]) ? 1'b0 : 1'b1;\nassign slt_flag = (a < b) ? 1'b1 : 1'b0;\nassign sltu_flag = (a < b) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule add_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign overflow = (a[31] == b[31]) ? 1'b0 : (r[31] == 1'b1) ? 1'b1 : 1'b0;\nendmodule\n\nmodule addu_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign overflow = (a[31] == b[31]) ? 1'b0 : (r[31] == 1'b1) ? 1'b1 : 1'b0;\nendmodule\n\nmodule sub_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a - b;\n    assign overflow = (a[31] == b[31]) ? 1'b0 : (r[31] == 1'b1) ? 1'b1 : 1'b0;\nendmodule\n\nmodule subu_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a - b;\n    assign overflow = (a[31] == b[31]) ? 1'b0 : (r[31] == 1'b1) ? 1'b1 : 1'b0;\nendmodule\n\nmodule and_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule or_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a | b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule xor_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a ^ b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule nor_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = ~(a | b);\n    assign overflow = 1'b0;\nendmodule\n\nmodule slt_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule\n\nmodule sltu_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign overflow = 1'b0;\nendmodule\n\nmodule sll_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule srl_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a >> b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule sra_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule sllv_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule srlv_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = a >> b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule srav_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign overflow = 1'b0;\nendmodule\n\nmodule lui_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow\n);\n    assign {carry, r} = {b[3:0], 27'b0} | a;\n    assign overflow = 1'b0;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;   // 16-bit difference from first subtractor\n\n    // Instantiate 16-bit subtractor for first 16 bits\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .B_out(B_out_16),\n        .Diff(Diff_16)\n    );\n\n    // Instantiate 16-bit subtractor for last 16 bits\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out of 32-bit subtractor\n    assign B_out = B_out_16;\n\nendmodule\n\nmodule sub_16bit(A, B, B_out, Diff);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output B_out;         // Borrow-out output\n    output [15:0] Diff;   // 16-bit output Diff\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;   // 16-bit difference from first subtractor\n\n    // Instantiate 8-bit subtractor for first 8 bits\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .B_out(B_out_16[15:14]),\n        .Diff(Diff_16[15:14])\n    );\n\n    // Instantiate 8-bit subtractor for last 8 bits\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out_16[14:13]),\n        .Diff(Diff_16[14:13])\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out of 16-bit subtractor\n    assign B_out = B_out_16[13];\n\n    // Assign difference from first subtractor to 16-bit difference\n    assign Diff = {Diff_16[13:0], B_out_16[13]};\n\nendmodule\n\nmodule sub_8bit(A, B, B_out, Diff);\n    input [7:0] A;       // 8-bit input A\n    input [7:0] B;       // 8-bit input B\n    output B_out;        // Borrow-out output\n    output [7:0] Diff;   // 8-bit output Diff\n\n    wire [7:0] B_out_8;  // 8-bit borrow-out from first subtractor\n    wire [7:0] Diff_8;   // 8-bit difference from first subtractor\n\n    // Instantiate 4-bit subtractor for first 4 bits\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .B_out(B_out_8[7:6]),\n        .Diff(Diff_8[7:6])\n    );\n\n    // Instantiate 4-bit subtractor for last 4 bits\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out_8[6:5]),\n        .Diff(Diff_8[6:5])\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out of 8-bit subtractor\n    assign B_out = B_out_8[5];\n\n    // Assign difference from first subtractor to 8-bit difference\n    assign Diff = {Diff_8[5:0], B_out_8[5]};\n\nendmodule\n\nmodule sub_4bit(A, B, B_out, Diff);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    output B_out;        // Borrow-out output\n    output [3:0] Diff;   // 4-bit output Diff\n\n    wire [3:0] B_out_4;  // 4-bit borrow-out from first subtractor\n    wire [3:0] Diff_4;   // 4-bit difference from first subtractor\n\n    // Instantiate 2-bit subtractor for first 2 bits\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .B_out(B_out_4[3:2]),\n        .Diff(Diff_4[3:2])\n    );\n\n    // Instantiate 2-bit subtractor for last 2 bits\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .B_out(B_out_4[2:1]),\n        .Diff(Diff_4[2:1])\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out of 4-bit subtractor\n    assign B_out = B_out_4[1];\n\n    // Assign difference from first subtractor to 4-bit difference\n    assign Diff = {Diff_4[1:0], B_out_4[1]};\n\nendmodule\n\nmodule sub_2bit(A, B, B_out, Diff);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    output B_out;        // Borrow-out output\n    output [1:0] Diff;   // 2-bit output Diff\n\n    wire [1:0] B_out_2;  // 2-bit borrow-out from first subtractor\n    wire [1:0] Diff_2;   // 2-bit difference from first subtractor\n\n    // Instantiate 1-bit subtractor for first bit\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .B_out(B_out_2[1]),\n        .Diff(Diff_2[1])\n    );\n\n    // Instantiate 1-bit subtractor for last bit\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .B_out(B_out_2[0]),\n        .Diff(Diff_2[0])\n    );\n\n    // Assign borrow-out from first subtractor to borrow-out of 2-bit subtractor\n    assign B_out = B_out_2[0];\n\n    // Assign difference from first subtractor to 2-bit difference\n    assign Diff = {Diff_2[0], B_out_2[0]};\n\nendmodule\n\nmodule sub_1bit(A, B, B_out, Diff);\n    input A;       // 1-bit input A\n    input B;       // 1-bit input B\n    output B_out;  // Borrow-out output\n    output Diff;   // 1-bit output Diff\n\n    assign B_out = ~(A ^ B);\n    assign Diff = B_out ^ A;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out for first 16 bits\n    wire [15:0] Diff_16;   // 16-bit difference for first 16 bits\n\n    // Instantiate 16-bit subtractor for first 16 bits\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    // Instantiate 16-bit subtractor for last 16 bits\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs for 16-bit subtractors\n    assign B_out = B_out_16 | B_out;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out for first 8 bits\n    wire [7:0] Diff_8;    // 8-bit difference for first 8 bits\n\n    // Instantiate 8-bit subtractor for first 8 bits\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n\n    // Instantiate 8-bit subtractor for last 8 bits\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs for 8-bit subtractors\n    assign B_out = B_out_8 | B_out;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;         // 8-bit input A\n    input [7:0] B;         // 8-bit input B\n    output [7:0] Diff;     // 8-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [3:0] B_out_4;    // 4-bit borrow-out for first 4 bits\n    wire [3:0] Diff_4;     // 4-bit difference for first 4 bits\n\n    // Instantiate 4-bit subtractor for first 4 bits\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff_4),\n        .B_out(B_out_4)\n    );\n\n    // Instantiate 4-bit subtractor for last 4 bits\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs for 4-bit subtractors\n    assign B_out = B_out_4 | B_out;\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [1:0] B_out_2;    // 2-bit borrow-out for first 2 bits\n    wire [1:0] Diff_2;     // 2-bit difference for first 2 bits\n\n    // Instantiate 2-bit subtractor for first 2 bits\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff_2),\n        .B_out(B_out_2)\n    );\n\n    // Instantiate 2-bit subtractor for last 2 bits\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine borrow-outs for 2-bit subtractors\n    assign B_out = B_out_2 | B_out;\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit output Diff\n    output B_out;          // Borrow-out output\n\n    assign {B_out, Diff} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub_32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub_16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub_8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\nendmodule\n\nmodule sub_32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub_16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub_8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub_16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub_8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub_8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .C_in(b_out[3:3]),\n        .D(D[12:8]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .C_in(b_out[2:2]),\n        .D(D[8:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[1:1]),\n        .D(D[4:1]),\n        .B_out(b_out[0:0])\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out[3:1];\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b1, b2, b3, b4; // 4-bit borrow outputs\n\n    // Instantiate 4-bit full subtractors\n    sub4_16bit sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .B_out(b1),\n        .D(D[16:4])\n    );\n\n    sub4_16bit sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .B_out(b2),\n        .D(D[12:1])\n    );\n\n    sub4_16bit sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .B_out(b3),\n        .D(D[8:1])\n    );\n\n    sub4_16bit sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .B_out(b4),\n        .D(D[4:1])\n    );\n\n    // Combine borrow outputs\n    assign B_out = b1[1] | b2[1] | b3[1] | b4[1];\nendmodule\n\nmodule sub4_16bit(A, B, B_out, D);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    output [4:1] D;       // 4-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b1, b2;    // 2-bit borrow outputs\n\n    // Instantiate 2-bit full subtractors\n    sub2_16bit sub1(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .B_out(b1),\n        .D(D[4:2])\n    );\n\n    sub2_16bit sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .B_out(b2),\n        .D(D[2:1])\n    );\n\n    // Combine borrow outputs\n    assign B_out = b1[1] | b2[1];\nendmodule\n\nmodule sub2_16bit(A, B, B_out, D);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    output [2:1] D;       // 2-bit output D\n    output B_out;         // Borrow-out output\n\n    wire b1, b2;          // 1-bit borrow outputs\n\n    // Instantiate 1-bit full subtractors\n    sub1_16bit sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .B_out(b1),\n        .D(D[2:1])\n    );\n\n    sub1_16bit sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .B_out(b2),\n        .D(D[1:1])\n    );\n\n    // Combine borrow outputs\n    assign B_out = b1 | b2;\nendmodule\n\nmodule sub1_16bit(A, B, B_out, D);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output B_out;         // Borrow-out output\n    output D;             // 1-bit output D\n\n    assign D = A ^ B;     // XOR operation\n    assign B_out = A & B; // AND operation\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the relationship between A and B\n    assign A_greater = (diff == 0) && (borrow == 0);\n    assign A_equal = (diff == 0) && (borrow == 1);\n    assign A_less = (diff != 0) && (borrow == 0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow flag indicating if borrow occurred\n);\n\n    // Perform subtraction\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Assign outputs based on borrow and diff\n    assign A_greater = (diff != 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0);\n    assign A_less = (diff == 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_2;\n\n    CLA1 CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(C16[1])\n    );\n\n    CLA2 CLA2(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(C16[1]),\n        .S(S[32:17]),\n        .Cout(C16_2)\n    );\n\n    assign C32 = C16_2;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire [16:1] C16;\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16[1]));\n    CLA2 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16[1]), .S(S[32:17]), .Cout(C32));\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n    wire [15:1] G,P;\n    genvar i;\n    generate\n        for(i=1;i<=15;i=i+1) begin:gen\n            assign G[i] = A[i] & B[i];\n            assign P[i] = A[i] ^ B[i];\n        end\n    endgenerate\n    assign S[1] = Cin ^ P[1];\n    assign Cout = Cin & G[1];\n    genvar j;\n    generate\n        for(j=2;j<=16;j=j+1) begin:gen2\n            assign S[j] = P[j-1] ^ P[j] ^ G[j-1] ^ G[j];\n            assign Cout = (P[j-1] & P[j]) | (P[j-1] & G[j]) | (P[j] & G[j-1]) | (G[j-1] & G[j]);\n        end\n    endgenerate\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [32:1] A,B;\n    input Cin;\n    output [32:1] S;\n    output Cout;\n    wire [15:1] G,P;\n    genvar i;\n    generate\n        for(i=1;i<=15;i=i+1) begin:gen\n            assign G[i] = A[i] & B[i];\n            assign P[i] = A[i] ^ B[i];\n        end\n    endgenerate\n    assign S[1] = Cin ^ P[1];\n    assign Cout = Cin & G[1];\n    genvar j;\n    generate\n        for(j=2;j<=32;j=j+1) begin:gen2\n            assign S[j] = P[j-1] ^ P[j] ^ G[j-1] ^ G[j];\n            assign Cout = (P[j-1] & P[j]) | (P[j-1] & G[j]) | (P[j] & G[j-1]) | (G[j-1] & G[j]);\n        end\n    endgenerate\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Instantiate 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n// Instantiate 4-bit carry select adder slices\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n// Output carry-out\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] carry;\n\n// Instantiate 4-bit full adder\nfull_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\nfull_adder fa2(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\nfull_adder fa3(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\nfull_adder fa4(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n\n// Output carry-out\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] carry;\n\n// Instantiate 2-bit ripple carry adder for first 4 bits\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum[3:2]), .cout(carry[1]));\n\n// Instantiate 2-bit carry select for first 4 bits\ncarry_select_adder_slice cs_slice1(.a(a[1:0]), .b(b[1:0]), .cin(carry[0]), .sum(sum[1:0]), .cout(carry[1]));\n\n// Output carry-out\nassign cout = carry[1];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate 4-bit ripple carry adder for initial 4 bits\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n    // Instantiate carry select adder slices for 4-bit sections\n    carry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n    carry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n    carry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    // Assign carry-out\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // 4-bit ripple carry adder logic\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate ripple carry adder for first 4 bits\n    ripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(sum), .cout(carry[0]));\n\n    // Instantiate ripple carry adder for second 4 bits\n    ripple_carry_adder rca2(.a(a), .b(b), .cin(carry[0]), .sum(sum), .cout(carry[1]));\n\n    // Instantiate ripple carry adder for third 4 bits\n    ripple_carry_adder rca3(.a(a), .b(b), .cin(carry[1]), .sum(sum), .cout(carry[2]));\n\n    // Instantiate ripple carry adder for fourth 4 bits\n    ripple_carry_adder rca4(.a(a), .b(b), .cin(carry[2]), .sum(sum), .cout(carry[3]));\n\n    // Assign carry-out\n    assign cout = carry[3];\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8bit;\n\n    // Instantiate 8-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8bit)\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 8-bit adder logic\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output assignment\n    assign yout = product;\n    assign done = start & !rst_n;\n\nendmodule\n\n// Submodule for control unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Submodule for register unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, ain};\n        end else if (shift_count == 5) begin\n            product <= {16'b0, bin};\n        end\n    end\n\nendmodule\n\n// Submodule for multiplier unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [31:0] product // Product register\n);\n\n    reg [31:0] shifted_bin; // Shifted multiplier register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shifted_bin <= 0;\n        end else if (shift_count == 5) begin\n            shifted_bin <= {16'b0, bin};\n        end else begin\n            shifted_bin <= {shifted_bin[30:0], shifted_bin[31]};\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (shift_count == 5) begin\n            product <= {16'b0, bin};\n        end else begin\n            product <= product + shifted_bin;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, ain}; // Initialize multiplicand\n        end else if (shift_count == 5) begin\n            product <= {16'b0, bin}; // Initialize multiplier\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [31:0] product // Product register\n);\n\n    reg [31:0] product_reg; // Register to store the product\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_reg <= 0;\n        end else if (start) begin\n            product_reg <= {16'b0, product[15:0]}; // Initialize product register\n        end else if (shift_count == 5) begin\n            product_reg <= product_reg + (product_reg[31] ? product : 0); // Shift and accumulate\n        end\n    end\n\n    assign product = product_reg; // Assign product to output\n\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3, lt0, lt1, lt2, lt3, eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wires to hold the multiplication result\nwire [63:0] mult_result;\nwire [31:0] accumulator_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .accumulator_result(accumulator_result)\n);\n\n// Assigning the accumulator output to the output\nassign c = accumulator_result;\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] accumulator_result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            accumulator_result <= 0;\n        end else begin\n            accumulator_result <= accumulator_result + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Selecting the operation based on mode\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n    assign prod = x * y;\n\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0, gt1, lt1, eq1, gt2, lt2, eq2, gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires for adder and subtractor\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning outputs\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, borrow_sub;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(borrow_sub));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : borrow_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetcher for register\n    instruction_fetch ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetcher for RAM/ROM\n    instruction_fetch ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignments\n    assign ins = fetch[1] ? ins_p2 : ins_p1;\n    assign ad1 = fetch[1] ? ad1_p2 : ad1_p1;\n    assign ad2 = fetch[1] ? ad2_p2 : ad2_p1;\n\nendmodule\n\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Assign output code and valid\n    assign code = code_temp;\n    assign valid = |code_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    wire prev_highest;\n\n    assign valid = in | prev_highest;\n    assign highest = in & ~prev_highest;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selector logic\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n    wire valid_temp;\n\n    // Instantiate submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb4(.in(in[4]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb1(.in(in[1]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(valid_temp));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = valid_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n    wire highest_temp;\n\n    // Check if input is '1'\n    assign highest_temp = in;\n\n    // Check if highest is the highest priority\n    assign highest = highest_temp & ~highest_temp;\n\n    // Set valid if highest is set\n    assign valid = highest_temp;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd64),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd64),\n        .above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output above_threshold;\n    assign above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b00000000; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between adder and subtractor outputs\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodules\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 100_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 50_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 75_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Instantiate final 2-bit full adder for the carry-out\n    two_bit_adder add3(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[2]),\n        .S(S[3:2]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:0] A;        // 2-bit input A\n    input [2:0] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry chain\n\n    // Instantiate 1-bit full adder for each bit\n    full_adder fa1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    full_adder fa2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    full_adder fa3(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(C2),\n        .S(S[2]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry calculation\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodules\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    localparam CYCLES_25 = 250; // 25% duty cycle\n    reg [10:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES_25) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    localparam CYCLES_50 = 500; // 50% duty cycle\n    reg [10:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES_50) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    localparam CYCLES_75 = 750; // 75% duty cycle\n    reg [10:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES_75) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adders\nfull_adder_4 GPP0 (.a(a[0]), .b(b[0]), .cin(0), .sum(sum1[0]), .cout(sum1[1]));\nfull_adder_4 GPP1 (.a(a[1]), .b(b[1]), .cin(sum1[1]), .sum(sum1[2]), .cout(sum1[3]));\nfull_adder_4 GPP2 (.a(a[2]), .b(b[2]), .cin(sum1[3]), .sum(sum1[4]), .cout(sum1[5]));\nfull_adder_4 GPP3 (.a(a[3]), .b(b[3]), .cin(sum1[5]), .sum(sum1[6]), .cout(sum1[7]));\n\n// 8-bit full adders\nfull_adder_8 A4BS0 (.a(sum1), .b(0), .cin(0), .sum(sum2), .cout(sum3[0]));\nfull_adder_8 A4BS1 (.a(sum1), .b(sum2), .cin(sum3[0]), .sum(sum2), .cout(sum3[1]));\nfull_adder_8 A4BS2 (.a(sum1), .b(sum2), .cin(sum3[1]), .sum(sum2), .cout(sum3[2]));\n\nassign product = sum4;\n\nendmodule\n\nmodule full_adder_4(\n    input a, b, cin,\n    output sum, cout);\n\nassign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule full_adder_8(\n    input [3:0] a, b, cin,\n    output [3:0] sum, cout);\n\nwire [4:0] temp;\n\nassign {cout, temp} = a + b + cin;\nassign sum = temp[3:0];\n\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage (0-100)\n    parameter MAX_COUNT = 100; // Maximum count value for the counter\n\n    wire [7:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [7:0] count_out\n);\n    parameter MAX_COUNT = 100; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [7:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage (0-100)\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adders for each bit\nfull_adder_4bit GPP0 (.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\nfull_adder_4bit GPP1 (.a(a[1]), .b(b[1]), .cin(sum0), .sum(sum1), .cout(0));\nfull_adder_4bit GPP2 (.a(a[2]), .b(b[2]), .cin(sum1), .sum(sum2), .cout(0));\nfull_adder_4bit GPP3 (.a(a[3]), .b(b[3]), .cin(sum2), .sum(sum3), .cout(0));\n\n// Shift registers for each bit\nshift_register_4bit A4BS0 (.sum(sum0), .shifted_sum(shifted_sum0));\nshift_register_4bit A4BS1 (.sum(sum1), .shifted_sum(shifted_sum1));\nshift_register_4bit A4BS2 (.sum(sum2), .shifted_sum(shifted_sum2));\nshift_register_4bit A4BS3 (.sum(sum3), .shifted_sum(shifted_sum3));\n\n// Output\nassign product = {shifted_sum3, shifted_sum2, shifted_sum1, shifted_sum0};\n\nendmodule\n\nmodule full_adder_4bit(input a, b, cin, output sum, cout);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule shift_register_4bit(input sum, output [7:0] shifted_sum);\n    reg [7:0] shifted_sum;\n    always @(*) begin\n        shifted_sum[0] = sum;\n        shifted_sum[7:1] = shifted_sum[6:0];\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [3:0] sum;        // 4-bit sum\n    wire c1, c2;           // Carry-out from the 2-bit adder\n\n    // Instantiate 2-bit full adder for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(sum[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(sum[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the last carry\n    assign C_out = c2;\n    assign S = sum;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out from the 1-bit adder\n\n    // Instantiate 1-bit full adder for the LSB\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the last carry\n    assign C_out = c1;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Percentage of the PWM period that is active (duty cycle)\n    parameter MAX_COUNT = 10000; // Maximum count value for the counter\n\n    wire counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output to the comparator output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [15:0] count_out\n);\n    parameter MAX_COUNT = 10000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out >= MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [15:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Percentage of the PWM period that is active (duty cycle)\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:0] carry;    // Intermediate carry\n\n    // Instantiate 4-bit carry lookahead adders for each 4-bit group\n    cla_4bit add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[0])\n    );\n\n    cla_4bit add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    cla_4bit add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[1]),\n        .S(S[7:4]),\n        .C_out(carry[2])\n    );\n\n    cla_4bit add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[2]),\n        .S(S[11:8]),\n        .C_out(carry[3])\n    );\n\n    // Combine the 4-bit carry bits to get the final carry out\n    assign C_out = carry[3];\nendmodule\n\nmodule cla_4bit(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [4:0] temp;     // Temporary sum\n    wire [3:0] carry;    // Intermediate carry\n\n    // Perform addition and carry propagation\n    assign temp = A + B + C_in;\n    assign S = temp[3:0];\n    assign C_out = temp[4];\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_5;\n  wire [7:0] shifted_in_6;\n  wire [7:0] shifted_in_7;\n  wire [7:0] shifted_in_8;\n\n  wire [7:0] shifted_in_9;\n  wire [7:0] shifted_in_10;\n  wire [7:0] shifted_in_11;\n  wire [7:0] shifted_in_12;\n  wire [7:0] shifted_in_13;\n  wire [7:0] shifted_in_14;\n  wire [7:0] shifted_in_15;\n  wire [7:0] shifted_in_16;\n\n  wire [7:0] shifted_in_17;\n  wire [7:0] shifted_in_18;\n  wire [7:0] shifted_in_19;\n  wire [7:0] shifted_in_20;\n  wire [7:0] shifted_in_21;\n  wire [7:0] shifted_in_22;\n  wire [7:0] shifted_in_23;\n  wire [7:0] shifted_in_24;\n  wire [7:0] shifted_in_25;\n  wire [7:0] shifted_in_26;\n\n  wire [7:0] shifted_in_27;\n\n  // Shift by 4\n  mux2X1 #(.WIDTH(8)) ins_17(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_2));\n  mux2X1 #(.WIDTH(8)) ins_16(.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in_2), .out(shifted_in_3));\n  mux2X1 #(.WIDTH(8)) ins_15(.sel(ctrl[2]), .in0(shifted_in_3), .in1(shifted_in_3), .out(shifted_in_4));\n  mux2X1 #(.WIDTH(8)) ins_14(.sel(ctrl[2]), .in0(shifted_in_4), .in1(shifted_in_4), .out(shifted_in_5));\n  mux2X1 #(.WIDTH(8)) ins_13(.sel(ctrl[2]), .in0(shifted_in_5), .in1(shifted_in_5), .out(shifted_in_6));\n  mux2X1 #(.WIDTH(8)) ins_12(.sel(ctrl[2]), .in0(shifted_in_6), .in1(shifted_in_6), .out(shifted_in_7));\n  mux2X1 #(.WIDTH(8)) ins_11(.sel(ctrl[2]), .in0(shifted_in_7), .in1(shifted_in_7), .out(shifted_in_8));\n\n  // Shift by 2\n  mux2X1 #(.WIDTH(8)) ins_10(.sel(ctrl[1]), .in0(in), .in1(shifted_in_8), .out(shifted_in_9));\n  mux2X1 #(.WIDTH(8)) ins_09(.sel(ctrl[1]), .in0(shifted_in_9), .in1(shifted_in_9), .out(shifted_in_10));\n  mux2X1 #(.WIDTH(8)) ins_08(.sel(ctrl[1]), .in0(shifted_in_10), .in1(shifted_in_10), .out(shifted_in_11));\n  mux2X1 #(.WIDTH(8)) ins_07(.sel(ctrl[1]), .in0(shifted_in_11), .in1(shifted_in_11), .out(shifted_in_12));\n  mux2X1 #(.WIDTH(8)) ins_06(.sel(ctrl[1]), .in0(shifted_in_12), .in1(shifted_in_12), .out(shifted_in_13));\n  mux2X1 #(.WIDTH(8)) ins_05(.sel(ctrl[1]), .in0(shifted_in_13), .in1(shifted_in_13), .out(shifted_in_14));\n  mux2X1 #(.WIDTH(8)) ins_04(.sel(ctrl[1]), .in0(shifted_in_14), .in1(shifted_in_14), .out(shifted_in_15));\n  mux2X1 #(.WIDTH(8)) ins_03(.sel(ctrl[1]), .in0(shifted_in_15), .in1(shifted_in_15), .out(shifted_in_16));\n  mux2X1 #(.WIDTH(8)) ins_02(.sel(ctrl[1]), .in0(shifted_in_16), .in1(shifted_in_16), .out(shifted_in_17));\n  mux2X1 #(.WIDTH(8)) ins_01(.sel(ctrl[1]), .in0(shifted_in_17), .in1(shifted_in_17), .out(shifted_in_18));\n  mux2X1 #(.WIDTH(8)) ins_00(.sel(ctrl[1]), .in0(shifted_in_18), .in1(shifted_in_18), .out(shifted_in_19));\n\n  // Shift by 1\n  mux2X1 #(.WIDTH(8)) ins_27(.sel(ctrl[0]), .in0(in), .in1(shifted_in_19), .out(shifted_in_20));\n  mux2X1 #(.WIDTH(8)) ins_26(.sel(ctrl[0]), .in0(shifted_in_20), .in1(shifted_in_20), .out(shifted_in_21));\n  mux2X1 #(.WIDTH(8)) ins_25(.sel(ctrl[0]), .in0(shifted_in_21), .in1(shifted_in_21), .out(shifted_in_22));\n  mux2X1 #(.WIDTH(8)) ins_24(.sel(ctrl[0]), .in0(shifted_in_22), .in1(shifted_in_22), .out(shifted_in_23));\n  mux2X1 #(.WIDTH(8)) ins_23(.sel(ctrl[0]), .in0(shifted_in_23), .in1(shifted_in_23), .out(shifted_in_24));\n  mux2X1 #(.WIDTH(8)) ins_22(.sel(ctrl[0]), .in0(shifted_in_24), .in1(shifted_in_24), .out(shifted_in_25));\n  mux2X1 #(.WIDTH(8)) ins_21(.sel(ctrl[0]), .in0(shifted_in_25), .in1(shifted_in_25), .out(shifted_in_26));\n  mux2X1 #(.WIDTH(8)) ins_20(.sel(ctrl[0]), .in0(shifted_in_26), .in1(shifted_in_26), .out(shifted_in_27));\n\n  assign out = shifted_in_27;\n\nendmodule\n\nmodule mux2X1#(parameter WIDTH = 8)(input sel, input [WIDTH-1:0] in0, input [WIDTH-1:0] in1, output [WIDTH-1:0] out);\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiating the submodules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Selecting the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extracting the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Checking for zero result\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Submodule for signed multiplication\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Submodule for unsigned multiplication\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n  // Stage 1: Shift by 4 positions\n  mux2X1 mux10 (.sel(ctrl[2]), .in0(in), .in1(stage1), .out(stage1));\n  mux2X1 mux11 (.sel(ctrl[2]), .in0(stage1), .in1(in), .out(stage2));\n  mux2X1 mux12 (.sel(ctrl[2]), .in0(stage2), .in1(stage1), .out(stage3));\n  mux2X1 mux13 (.sel(ctrl[2]), .in0(stage3), .in1(stage2), .out(stage4));\n\n  // Stage 2: Shift by 2 positions\n  mux2X1 mux20 (.sel(ctrl[1]), .in0(stage4), .in1(stage3), .out(stage5));\n  mux2X1 mux21 (.sel(ctrl[1]), .in0(stage5), .in1(stage4), .out(stage6));\n  mux2X1 mux22 (.sel(ctrl[1]), .in0(stage6), .in1(stage5), .out(stage7));\n  mux2X1 mux23 (.sel(ctrl[1]), .in0(stage7), .in1(stage6), .out(stage8));\n\n  // Stage 3: Shift by 1 position\n  mux2X1 mux30 (.sel(ctrl[0]), .in0(stage8), .in1(stage7), .out(out));\n  mux2X1 mux31 (.sel(ctrl[0]), .in0(stage8), .in1(stage7), .out(out));\n  mux2X1 mux32 (.sel(ctrl[0]), .in0(stage8), .in1(stage7), .out(out));\n  mux2X1 mux33 (.sel(ctrl[0]), .in0(stage8), .in1(stage7), .out(out));\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_int;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_int)\n    );\n\n    // Assign the output\n    assign count_out = count;\n    assign overflow = overflow_int;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg [3:0]    count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Output carry\n    assign C_out = C4;\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G and P\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Generate C\n    assign C[1] = G[1] | (P[1] & C_in);\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign C[4] = G[4] | (P[4] & C[3]);\n    assign C_out = C[5];\n\n    // Generate sum\n    assign S = A ^ B;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;       // 8-bit input x\n    output p;            // Parity output\n\n    wire [7:0] x_parity; // Parity of x\n\n    // Compute the parity of x\n    assign p = ^x;\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed version of b0\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 16'b0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_int;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_int)\n    );\n\n    // Assign the output signals\n    assign count_out = count;\n    assign overflow = overflow_int;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]   count,\n    output          overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    wire c_out;\n    sub3 S0 (.a(a), .b(b), .bin(bin), .diff(diff), .cout(c_out));\n    sub3 S1 (.a(diff), .b(1'b1), .bin(c_out), .diff(diff), .cout(bout));\nendmodule\n\nmodule sub3 (input a, b, bin, output diff, cout);\n    assign {cout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delayed version of b0\n  assign b1 = (rst) ? 0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] p1;      // Parity output from first generator\n    wire [7:0] p2;      // Parity output from second generator\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(p1)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(p2)\n    );\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Parity output\n\n    wire [7:0] p1;      // Parity output from first generator\n    wire [7:0] p2;      // Parity output from second generator\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(\n        .X(X[3:0]),\n        .P(p1)\n    );\n\n    parity_4bit gen2(\n        .X(X[7:4]),\n        .P(p2)\n    );\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;      // 4-bit input X\n    output P;           // Parity output\n\n    wire [3:0] p1;      // Parity output from first generator\n    wire [3:0] p2;      // Parity output from second generator\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(\n        .X(X[1:0]),\n        .P(p1)\n    );\n\n    parity_2bit gen2(\n        .X(X[3:2]),\n        .P(p2)\n    );\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;      // 2-bit input X\n    output P;           // Parity output\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUB: result <= subtract_result;\n            `AND: result <= bitwise_and_result;\n            `OR: result <= bitwise_or_result;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c1),\n        .S(S[4:3]),\n        .C_out(c2)\n    );\n\n    // Last 2 bits are added directly\n    assign {C_out, S[4:3]} = A[4:3] + B[4:3] + {1'b0, C_in};\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    assign {C_out, S} = A + B + {1'b0, C_in};\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq1, gt1, lt1;\nwire [3:0] eq2, gt2, lt2;\nwire [3:0] eq3, gt3, lt3;\nwire [3:0] eq4, gt4, lt4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq1), .gt(gt1), .lt(lt1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq2), .gt(gt2), .lt(lt2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq3), .gt(gt3), .lt(lt3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq4), .gt(gt4), .lt(lt4));\n\nassign eq = (eq1 & eq2 & eq3 & eq4);\nassign gt = (gt1 & gt2 & gt3 & gt4);\nassign lt = (lt1 & lt2 & lt3 & lt4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire eq0, gt0, lt0;\nwire eq1, gt1, lt1;\n\ncomparator_2bit comp_slice0(.a(a[1:0]), .b(b[1:0]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq1), .gt(gt1), .lt(lt1));\n\nassign eq = (eq0 & eq1);\nassign gt = (gt0 & gt1);\nassign lt = (lt0 & lt1);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\n\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_result;\nwire [31:0] mem_result;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op), .alu_result(alu_result));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .mem_result(mem_result));\nwriteback_stage writeback(.clk(clk), .rst(rst), .mem_result(mem_result), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      instr_reg <= instr_mem[pc_reg];\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[10:6];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output [31:0] alu_result\n);\n  reg [31:0] rs1_reg;\n  reg [31:0] rs2_reg;\n  reg [31:0] alu_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      alu_result_reg <= 0;\n    end else begin\n      rs1_reg <= reg_file[rs1];\n      rs2_reg <= reg_file[rs2];\n      case (op)\n        6'b000000: alu_result_reg <= rs1_reg + rs2_reg;\n        6'b001010: alu_result_reg <= rs1_reg - rs2_reg;\n        default: alu_result_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_result = alu_result_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output [31:0] mem_result\n);\n  reg [31:0] mem_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      mem_result_reg <= 0;\n    end else begin\n      mem_result_reg <= alu_result;\n    end\n  end\n\n  assign mem_result = mem_result_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] mem_result,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[0] <= 0;\n      res_reg_file_reg[1] <= 0;\n      res_reg_file_reg[2] <= 0;\n      res_reg_file_reg[3] <= 0;\n      res_reg_file_reg[4] <= 0;\n      res_reg_file_reg[5] <= 0;\n      res_reg_file_reg[6] <= 0;\n      res_reg_file_reg[7] <= 0;\n      res_reg_file_reg[8] <= 0;\n      res_reg_file_reg[9] <= 0;\n      res_reg_file_reg[10] <= 0;\n      res_reg_file_reg[11] <= 0;\n      res_reg_file_reg[12] <= 0;\n      res_reg_file_reg[13] <= 0;\n      res_reg_file_reg[14] <= 0;\n      res_reg_file_reg[15] <= 0;\n      res_reg_file_reg[16] <= 0;\n      res_reg_file_reg[17] <= 0;\n      res_reg_file_reg[18] <= 0;\n      res_reg_file_reg[19] <= 0;\n      res_reg_file_reg[20] <= 0;\n      res_reg_file_reg[21] <= 0;\n      res_reg_file_reg[22] <= 0;\n      res_reg_file_reg[23] <= 0;\n      res_reg_file_reg[24] <= 0;\n      res_reg_file_reg[25] <= 0;\n      res_reg_file_reg[26] <= 0;\n      res_reg_file_reg[27] <= 0;\n      res_reg_file_reg[28] <= 0;\n      res_reg_file_reg[29] <= 0;\n      res_reg_file_reg[30] <= 0;\n      res_reg_file_reg[31] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= mem_result;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_and_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_and_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_and_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_and_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_and_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a & {4'b1111, 4'b1110, 4'b1100, 4'b1000} << b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2, c3, c4; // Carry outputs\n\n    // Instantiate 4-bit full adders\n    four_bit_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:1] A;      // 4-bit input A\n    input [3:1] B;      // 4-bit input B\n    input C_in;         // Carry-in\n    output [3:1] S;     // 4-bit sum output\n    output C_out;       // Carry-out output\n\n    wire c1, c2;        // Carry outputs\n\n    // Instantiate 2-bit full adders\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;      // 2-bit input A\n    input [2:1] B;      // 2-bit input B\n    input C_in;         // Carry-in\n    output [2:1] S;     // 2-bit sum output\n    output C_out;       // Carry-out output\n\n    // Instantiate 1-bit full adder\n    full_adder fa(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(C_out)\n    );\n\n    // Carry-out\n    assign C_out = (A[1] & B[1]) | (C_in & (A[1] ^ B[1]));\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;   // Inputs\n    output S, C_out;    // Sum and carry-out\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(control_signal),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[32:17], B[32:17], Bout0, D[32:17], Bout1);\n    subtractor_8bit SUB3(A[32:11], B[32:11], Bout1, D[32:11], Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D[32:6], Bout3);\n    subtractor_8bit SUB5(A[32:1], B[32:1], Bout3, D[32:1], Bout4);\n    subtractor_8bit SUB6(A[32:25], B[32:25], Bout4, D[32:25], Bout5);\n    subtractor_8bit SUB7(A[32:17], B[32:17], Bout5, D[32:17], Bout6);\n    subtractor_8bit SUB8(A[32:11], B[32:11], Bout6, D[32:11], Bout7);\n    subtractor_8bit SUB9(A[32:6], B[32:6], Bout7, D[32:6], Bout);\n    subtractor_8bit SUB10(A[32:1], B[32:1], Bout, Bin, D[32:1]);\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [8:1] Bout0, Bout1;\n\n    subtractor_4bit SUB1(A[8:5], B[8:5], Bin, D[8:5], Bout0);\n    subtractor_4bit SUB2(A[8:4], B[8:4], Bout0, D[8:4], Bout1);\n    subtractor_4bit SUB3(A[8:3], B[8:3], Bout1, D[8:3], Bout);\n    subtractor_4bit SUB4(A[8:2], B[8:2], Bout, Bin, D[8:2]);\n    subtractor_4bit SUB5(A[8:1], B[8:1], Bin, D[8:1], Bout);\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [4:1] A;\n    input [4:1] B;\n    input Bin;\n    output [4:1] D;\n    output Bout;\n    wire [4:1] Bout0, Bout1;\n\n    subtractor_2bit SUB1(A[4:3], B[4:3], Bin, D[4:3], Bout0);\n    subtractor_2bit SUB2(A[4:2], B[4:2], Bout0, D[4:2], Bout1);\n    subtractor_2bit SUB3(A[4:1], B[4:1], Bout1, D[4:1], Bout);\n    subtractor_2bit SUB4(A[4:3], B[4:3], Bout, Bin, D[4:3]);\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [2:1] A;\n    input [2:1] B;\n    input Bin;\n    output [2:1] D;\n    output Bout;\n\n    assign {Bout, D[2:1]} = A[2:1] - B[2:1] - Bin;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] pc;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc));\n  decode_stage decode (.clk(clk), .rst(rst), .pc(pc), .reg_file(reg_file), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute (.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .alu_result(alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(alu_result), .rd(rd), .res_reg_file(res_reg_file));\n  writeback_stage writeback (.clk(clk), .rst(rst), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] reg_file [0:31],\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr_mem[pc][25:20];\n      rs2 <= instr_mem[pc][15:10];\n      rd <= instr_mem[pc][4:0];\n      op <= instr_mem[pc][31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [31:0] alu_result\n);\n  // Example operation: rs1 + rs2\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else\n      alu_result <= reg_file[rs1] + reg_file[rs2];\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file[0] <= 0;\n      res_reg_file[1] <= 0;\n      res_reg_file[2] <= 0;\n      res_reg_file[3] <= 0;\n      res_reg_file[4] <= 0;\n      res_reg_file[5] <= 0;\n      res_reg_file[6] <= 0;\n      res_reg_file[7] <= 0;\n      res_reg_file[8] <= 0;\n      res_reg_file[9] <= 0;\n      res_reg_file[10] <= 0;\n      res_reg_file[11] <= 0;\n      res_reg_file[12] <= 0;\n      res_reg_file[13] <= 0;\n      res_reg_file[14] <= 0;\n      res_reg_file[15] <= 0;\n      res_reg_file[16] <= 0;\n      res_reg_file[17] <= 0;\n      res_reg_file[18] <= 0;\n      res_reg_file[19] <= 0;\n      res_reg_file[20] <= 0;\n      res_reg_file[21] <= 0;\n      res_reg_file[22] <= 0;\n      res_reg_file[23] <= 0;\n      res_reg_file[24] <= 0;\n      res_reg_file[25] <= 0;\n      res_reg_file[26] <= 0;\n      res_reg_file[27] <= 0;\n      res_reg_file[28] <= 0;\n      res_reg_file[29] <= 0;\n      res_reg_file[30] <= 0;\n      res_reg_file[31] <= 0;\n    end else begin\n      res_reg_file[rd] <= alu_result;\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31]\n);\n  // Writeback stage\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.en(en), .in_data(in_data), .out_data(left_rot));\nright_rotate rr(.en(en), .in_data(in_data), .out_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  // Registers to hold previous values\n  reg [15:0] b1, b2, b3;\n\n  // Update registers on rising edge of clk\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      c <= 0;\n    end\n    else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.en(en), .in_data(in_data), .out_data(left_rot));\nright_rotate rr(.en(en), .in_data(in_data), .out_data(right_rot));\n\nassign out_data = rot_dir ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the output based on the op_code\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n\n  // Registers to hold delayed values of b0, b1, b2, and b3\n  reg [15:0] b1, b2, b3;\n\n  // Assign b1, b2, b3 on the rising edge of clk\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      product <= 0;\n    end else begin\n      product <= a * b;\n    end\n  end\n\n  assign c = product;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the correct count value based on the mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else begin\n        count <= count + 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  \n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select count value based on mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else if (mode == 0) begin\n        count <= count + 1;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    sub8_32 SUB1(\n        .A(A[32:1]),\n        .B(B[32:1]),\n        .Bin(Bin),\n        .D(D[32:1]),\n        .Bout(Bout0)\n    );\n\n    sub8_32 SUB2(\n        .A(A[32:1]),\n        .B(B[24:1]),\n        .Bin(Bout0),\n        .D(D[24:1]),\n        .Bout(Bout1)\n    );\n\n    sub8_32 SUB3(\n        .A(A[24:1]),\n        .B(B[16:1]),\n        .Bin(Bout1),\n        .D(D[16:1]),\n        .Bout(Bout2)\n    );\n\n    sub8_32 SUB4(\n        .A(A[16:1]),\n        .B(B[8:1]),\n        .Bin(Bout2),\n        .D(D[8:1]),\n        .Bout(Bout3)\n    );\n\n    sub8_32 SUB5(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bout3),\n        .D(D[8:1]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub8_32(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2;\n\n    sub8_8 SUB1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Bin(Bin),\n        .D(D[7:0]),\n        .Bout(Bout0)\n    );\n\n    sub8_8 SUB2(\n        .A(A[15:8]),\n        .B(B[7:0]),\n        .Bin(Bout0),\n        .D(D[15:8]),\n        .Bout(Bout1)\n    );\n\n    sub8_8 SUB3(\n        .A(A[23:16]),\n        .B(B[7:0]),\n        .Bin(Bout1),\n        .D(D[23:16]),\n        .Bout(Bout2)\n    );\n\n    sub8_8 SUB4(\n        .A(A[31:24]),\n        .B(B[7:0]),\n        .Bin(Bout2),\n        .D(D[31:24]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub8_8(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1;\n\n    sub8_1 SUB1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Bin(Bin),\n        .D(D[7:0]),\n        .Bout(Bout0)\n    );\n\n    sub8_1 SUB2(\n        .A(A[15:8]),\n        .B(B[7:0]),\n        .Bin(Bout0),\n        .D(D[15:8]),\n        .Bout(Bout1)\n    );\n\n    sub8_1 SUB3(\n        .A(A[23:16]),\n        .B(B[7:0]),\n        .Bin(Bout1),\n        .D(D[23:16]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub8_1(A, B, Bin, D, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Bout;\n    wire [0:0] Bout0;\n\n    sub1_1 SUB1(\n        .A(A[0:0]),\n        .B(B[0:0]),\n        .Bin(Bin),\n        .D(D[0:0]),\n        .Bout(Bout0)\n    );\n\nendmodule\n\nmodule sub1_1(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n    wire Bout0;\n\n    assign D = A ^ B ^ Bin;\n    assign Bout = A & B;\n\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff;\n    wire [31:0] and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Combine the results based on the operation selected\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate the T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction structure\nstruct instruction {\n    reg_t rd; // Destination register\n    reg_t ra; // First operand\n    reg_t rb; // Second operand\n    op_t op; // Operation code\n};\n\n// Register type\ntypedef reg_t [4:0] reg_t;\n\n// Operation type\ntypedef reg_t [5:0] op_t;\n\n// Fetch stage\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[0]; // Fetch first instruction\nendmodule\n\n// Execute stage\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] result\n);\n    instruction instr;\n    reg_t ra_val, rb_val;\n    reg_t rd_val;\n    op_t op;\n\n    assign instr = fetched_instr;\n    assign ra_val = reg_file[instr.ra];\n    assign rb_val = reg_file[instr.rb];\n    assign rd_val = instr.rd;\n    assign op = instr.op;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            case (op)\n                `ADD: result <= ra_val + rb_val;\n                `SUB: result <= ra_val - rb_val;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    reg_t rd_val;\n    reg_t result_val;\n\n    assign rd_val = result;\n    assign result_val = result;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[0] <= 0;\n            out_reg_file[1] <= 0;\n            out_reg_file[2] <= 0;\n            out_reg_file[3] <= 0;\n            out_reg_file[4] <= 0;\n            out_reg_file[5] <= 0;\n            out_reg_file[6] <= 0;\n            out_reg_file[7] <= 0;\n            out_reg_file[8] <= 0;\n            out_reg_file[9] <= 0;\n            out_reg_file[10] <= 0;\n            out_reg_file[11] <= 0;\n            out_reg_file[12] <= 0;\n            out_reg_file[13] <= 0;\n            out_reg_file[14] <= 0;\n            out_reg_file[15] <= 0;\n            out_reg_file[16] <= 0;\n            out_reg_file[17] <= 0;\n            out_reg_file[18] <= 0;\n            out_reg_file[19] <= 0;\n            out_reg_file[20] <= 0;\n            out_reg_file[21] <= 0;\n            out_reg_file[22] <= 0;\n            out_reg_file[23] <= 0;\n            out_reg_file[24] <= 0;\n            out_reg_file[25] <= 0;\n            out_reg_file[26] <= 0;\n            out_reg_file[27] <= 0;\n            out_reg_file[28] <= 0;\n            out_reg_file[29] <= 0;\n            out_reg_file[30] <= 0;\n            out_reg_file[31] <= 0;\n        end else begin\n            out_reg_file[rd_val] <= result_val;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_count(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_count;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodules\ncounter_logic u_counter_logic (\n    .count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count),\n    .next_count(u_counter_logic.next_count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? count + 1 : count - 1;\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    input wire [15:0] next_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation to be performed\n`define ADD 4'b0000\n`define SUB 4'b1000\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2;\nwire [5:0] rd;\nwire [31:0] result;\nwire [4:0] opcode;\n\n// Instantiating the stages\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(0),\n    .fetched_instr(fetched_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .fetched_instr(fetched_instr),\n    .reg_file(reg_file),\n    .op1(op1),\n    .op2(op2),\n    .rd(rd),\n    .result(result),\n    .opcode(opcode)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .result(result),\n    .rd(rd),\n    .reg_file(out_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [5:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [5:0] rd,\n    output [31:0] result,\n    output [4:0] opcode\n);\n    assign {opcode, op1, op2, rd} = fetched_instr;\n    assign result = (opcode == `ADD) ? op1 + op2 : op1 - op2;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [5:0] rd,\n    output reg [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file[rd] <= 0;\n        end else begin\n            reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count_out;\n    wire [9:0] accumulator_out;\n    wire valid_out_internal;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count_out(count_out)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .accumulator_out(accumulator_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(count_out),\n        .valid_out_internal(valid_out_internal)\n    );\n\n    // Output the valid_out signal\n    assign valid_out = valid_out_internal;\n\n    // Output the accumulated data\n    assign data_out = accumulator_out;\n\nendmodule\n\n// Counter module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_out <= 0;\n        else if (valid_in)\n            count_out <= count_out + 1;\n    end\nendmodule\n\n// Data accumulator module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    output reg  [9:0]   accumulator_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulator_out <= 0;\n        else\n            accumulator_out <= accumulator_out + data_in;\n    end\nendmodule\n\n// Valid output module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count_out,\n    output reg          valid_out_internal\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out_internal <= 0;\n        else if (count_out == 4)\n            valid_out_internal <= 1;\n        else\n            valid_out_internal <= 0;\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n\n    assign result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n\n    assign result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n\n    assign result = a ^ b;\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Cin,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Cin;\n    assign Carry_out = (X & Y) | (Y & Cin) | (X & Cin);\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, bitwise_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(bitwise_result)\n    );\n\n    // Control signal for the bitwise operation\n    wire [31:0] bitwise_control;\n    assign bitwise_control = (op_code == 2'b10) ? operand_b : operand_a;\n\n    // Output result based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b11) ? bitwise_result : 32'b0;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(*) begin\n        result = a & b;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output reg [63:0]    next_state\n);\n\n    always @(*) begin\n        next_state = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(Carry_out)\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Cin,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Cin;\n    assign Carry_out = (X & Y) | (Cin & (X ^ Y));\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output reg [63:0]    next_state\n);\n\n    always @(*) begin\n        next_state = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control logic to determine the operation based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire [1:0] op_code\n);\n    assign result = (op_code == 2'b00) ? a & b : a | b;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate wires\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        res_valid <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else begin\n        if (opn_valid) begin\n            if (res_ready) begin\n                counter <= 0;\n                shift_reg <= {dividend[7], dividend[7:1]};\n                res_valid <= 1;\n            end else begin\n                if (counter < 8) begin\n                    counter <= counter + 1;\n                    shift_reg <= {shift_reg[14:0], 1'b0};\n                end else begin\n                    res_valid <= 0;\n                end\n            end\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        quotient <= 0;\n        remainder <= 0;\n    end else begin\n        if (counter == 8) begin\n            quotient <= shift_reg;\n            remainder <= dividend - (quotient * divisor);\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= {remainder, quotient};\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignment\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for generating 50MHz clock\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for generating 10MHz clock\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for generating 1MHz clock\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] temp;\n\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignment\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_carry;\n\n    // Instantiate the adder\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting the result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting the carry out\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A - B;\n\nendmodule\n\n// AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .result(result)\n);\n\n// Assigning the result\nassign result = {remainder, quotient};\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else begin\n            if (sign) begin\n                result <= -dividend;\n            end else begin\n                result <= dividend;\n            end\n        end\n    end\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else begin\n            if (sign) begin\n                result <= dividend;\n            end else begin\n                result <= -dividend;\n            end\n        end\n    end\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [3:0] counter;\n    reg [15:0] shift_reg;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'd0;\n            shift_reg <= 16'd0;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n            res_valid <= 1'b0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                counter <= 4'd0;\n                shift_reg <= {8'd0, dividend};\n                quotient <= 16'd0;\n                remainder <= 16'd0;\n                res_valid <= 1'b1;\n            end else if (res_ready && res_valid) begin\n                res_valid <= 1'b0;\n            end else if (counter < 4'd15) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[14:0], 1'b0};\n                if (shift_reg[15]) begin\n                    temp_quotient <= temp_quotient + 16'd1;\n                    temp_remainder <= temp_remainder - divisor;\n                end\n            end else begin\n                quotient <= temp_quotient;\n                remainder <= temp_remainder;\n                res_valid <= 1'b1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_valid,\n    input wire res_ready,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 16'd0;\n        end else begin\n            if (res_ready && res_valid) begin\n                result <= 16'd0;\n            end else begin\n                result <= result;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] counter_out_shifted;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n    wire [3:0] clk_div_intermediate;\n\n    // Counter module\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (counter == MUL2_DIV_CLK - 1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign counter_out = counter;\n\n    // Clock average generator\n    assign clk_average[0] = counter_out[0];\n    assign clk_average[1] = counter_out[1];\n    assign clk_average[2] = counter_out[2];\n    assign clk_average[3] = counter_out[3];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = counter_out[0] ? 1'b0 : clk_average[0];\n    assign clk_adjusted[1] = counter_out[1] ? 1'b0 : clk_average[1];\n    assign clk_adjusted[2] = counter_out[2] ? 1'b0 : clk_average[2];\n    assign clk_adjusted[3] = counter_out[3] ? 1'b0 : clk_average[3];\n\n    // Intermediate clock signal generation\n    assign clk_div_intermediate[0] = clk_adjusted[0] | clk_adjusted[1];\n    assign clk_div_intermediate[1] = clk_adjusted[2] | clk_adjusted[3];\n\n    // Final clock signal generation\n    assign clk_div = clk_div_intermediate[0] | clk_div_intermediate[1];\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select result based on operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is selected based on operation\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend, divisor;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .result(dividend),\n        .odd(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    // Adjust the bit widths\n    assign result = {32'b0, A[31:16]};\n    assign odd = {32'b0, A[15:0]};\n\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,  // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    // Implement the division algorithm\n    assign result = {32'b0, dividend[31:16] / divisor};\n    assign odd = {32'b0, dividend[15:0] % divisor};\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj_neg;\n    wire clk_adj_pos;\n\n    // Counter module\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (counter < MUL2_DIV_CLK) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    // Clock average generator\n    assign clk_avg = (counter == 4);\n\n    // Clock adjustment module\n    assign clk_adj_neg = (counter == 3);\n    assign clk_adj_pos = (counter == 2);\n\n    // Final clock output\n    assign clk_div = clk_avg | clk_adj_neg | clk_adj_pos;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (counter < 15) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input clk_avg,\n    output reg clk_avg_out\n);\n    always @(posedge clk) begin\n        clk_avg_out <= clk_avg;\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_adj_neg,\n    input clk_adj_pos,\n    output reg clk_adj_out\n);\n    always @(posedge clk) begin\n        clk_adj_out <= clk_adj_neg | clk_adj_pos;\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    // Instantiate the submodules\n    data_mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(mux0_out)\n    );\n\n    data_mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(mux1_out)\n    );\n\n    data_mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(mux2_out)\n    );\n\n    // Output selection based on the selection signal\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for each data path\nmodule data_mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_d (\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0}; // Adjust dividend to 32 bits\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    always @(*) begin\n        remainder = dividend; // Initialize remainder\n        quotient = 0; // Initialize quotient\n        for (i = 0; i < 16; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = {quotient[30:0], 1'b0};\n            end\n            remainder = {remainder[30:0], 1'b0}; // Shift remainder\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Assign the product to the output\n    assign P = accumulator;\n\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] accumulator;\n    reg [15:0] accumulator;\n\n    always @(*) begin\n        if (Y[0])\n            accumulator = accumulator + (X << 0);\n        if (Y[1])\n            accumulator = accumulator + (X << 1);\n        if (Y[2])\n            accumulator = accumulator + (X << 2);\n        if (Y[3])\n            accumulator = accumulator + (X << 3);\n        if (Y[4])\n            accumulator = accumulator + (X << 4);\n        if (Y[5])\n            accumulator = accumulator + (X << 5);\n        if (Y[6])\n            accumulator = accumulator + (X << 6);\n        if (Y[7])\n            accumulator = accumulator + (X << 7);\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for data path multiplexing\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'b00000000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Parameter for odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR of both clock outputs\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIVISOR = NUM_DIV - 1; // Parameter for divisor value\n\n    reg [DIVISOR - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIVISOR) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIVISOR = NUM_DIV - 1; // Parameter for divisor value\n\n    reg [DIVISOR - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIVISOR) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3_out)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                  hold3_out;\n\nendmodule\n\n// Submodule for data holding\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] shifted_dividend;\n    reg [15:0] shifted_remainder;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_result;\n    reg [15:0] temp_remainder_shifted;\n\n    // Initialize variables\n    initial begin\n        dividend = A;\n        divisor = B;\n        shifted_dividend = {16{1'b0}};\n        shifted_remainder = {16{1'b0}};\n        temp_quotient = {16{1'b0}};\n        temp_remainder = {16{1'b0}};\n        temp_result = {16{1'b0}};\n        temp_remainder_shifted = {16{1'b0}};\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        shifted_dividend = dividend >> 1;\n        shifted_remainder = remainder << 1;\n\n        if (shifted_dividend >= divisor) begin\n            temp_quotient = 1;\n            temp_remainder = shifted_dividend - divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = shifted_remainder;\n        end\n\n        temp_result = temp_quotient << 15;\n        temp_remainder_shifted = temp_remainder << 1;\n\n        quotient = temp_result | quotient;\n        remainder = temp_remainder_shifted | remainder;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR to generate the divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV = NUM_DIV - 1; // Divisor value\n\n    reg [DIV:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV = NUM_DIV - 1; // Divisor value\n\n    reg [DIV:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.x(X), .y(Y), .shift(0), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.x(X), .y(Y), .shift(1), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.x(X), .y(Y), .shift(2), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.x(X), .y(Y), .shift(3), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.x(X), .y(Y), .shift(4), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.x(X), .y(Y), .shift(5), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.x(X), .y(Y), .shift(6), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.x(X), .y(Y), .shift(7), .accumulator(accumulator));\n\n    // Assign the product to the output\n    assign P = accumulator;\n\nendmodule\n\nmodule add_shift(x, y, shift, accumulator);\n    input [7:0] x;\n    input [7:0] y;\n    input [3:0] shift;\n    output [15:0] accumulator;\n\n    wire [7:0] shifted_x;\n    wire [7:0] shifted_y;\n\n    assign shifted_x = x << shift;\n    assign shifted_y = y << shift;\n\n    // Instantiate the add module\n    add_module add(.x(shifted_x), .y(shifted_y), .sum(accumulator));\n\nendmodule\n\nmodule add_module(x, y, sum);\n    input [7:0] x;\n    input [7:0] y;\n    output [15:0] sum;\n\n    assign sum = x + y;\n\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0;\n    wire [7:0] hold1;\n    wire [7:0] hold2;\n    wire [7:0] hold3;\n\n    // Instantiate submodules\n    data_hold hold0_inst (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_hold hold1_inst (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_hold hold2_inst (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_hold hold3_inst (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                 hold3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] dividend;\nwire [7:0] divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Instantiate the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Assign the output ports\nassign result = quotient;\nassign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n// Define temporary variables\nreg [15:0] dividend_temp;\nreg [7:0] divisor_temp;\nreg [15:0] quotient_temp;\nreg [15:0] remainder_temp;\n\n// Initialize the temporary variables\ninitial begin\n    dividend_temp = A;\n    divisor_temp = B;\n    quotient_temp = 0;\n    remainder_temp = 0;\nend\n\n// Perform the division algorithm\nalways @(*) begin\n    if (dividend_temp >= divisor_temp) begin\n        quotient_temp = dividend_temp / divisor_temp;\n        remainder_temp = dividend_temp % divisor_temp;\n        dividend_temp = remainder_temp << 8;\n    end else begin\n        quotient_temp = 0;\n        remainder_temp = dividend_temp;\n    end\nend\n\n// Assign the output ports\nassign quotient = quotient_temp;\nassign remainder = remainder_temp;\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div),\n    .counter_limit(counter_limit)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\nparameter NUM_DIV = 4; // Even number that divides the frequency\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count_out <= 0;\n    end else if (count_out == NUM_DIV / 2 - 1) begin\n        count_out <= 0;\n    end else begin\n        count_out <= count_out + 1;\n    end\nend\n\nassign limit = (count_out == NUM_DIV / 2 - 1);\n\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div,\n    input limit\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (limit) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products[3:0];\n    wire [7:0] sum;\n\n    // Generate partial products\n    assign partial_products[0] = X & Y;\n    assign partial_products[1] = X << 1 & Y;\n    assign partial_products[2] = X << 2 & Y;\n    assign partial_products[3] = X << 3 & Y;\n\n    // Add partial products\n    adder_8bit add1(.a(partial_products[0]), .b(partial_products[1]), .sum(sum));\n    adder_8bit add2(.a(sum), .b(partial_products[2]), .sum(sum));\n    adder_8bit add3(.a(sum), .b(partial_products[3]), .sum(P));\n\nendmodule\n\nmodule adder_8bit(a, b, sum);\n    input [7:0] a;\n    input [7:0] b;\n    output [7:0] sum;\n\n    wire [8:0] temp_sum;\n\n    // Full adder logic\n    assign temp_sum = a + b;\n    assign sum = temp_sum[7:0];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out),\n    .limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    parameter NUM_DIV = 4; // Even number that divides the input clock frequency\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == NUM_DIV / 2 - 1) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\n    assign limit = (count_out == NUM_DIV / 2 - 1);\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (counter_out == 0) begin\n            clk_div <= 1;\n        end else begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products[3:0];\n    wire [7:0] sum;\n\n    // Generate partial products\n    genvar i;\n    for (i = 0; i < 4; i = i + 1) begin\n        assign partial_products[i] = X[i] & Y;\n    end\n\n    // Generate sum\n    assign sum = partial_products[0] + partial_products[1] + partial_products[2] + partial_products[3];\n\n    // Assign product\n    assign P = sum;\n\nendmodule\n\nmodule adder_8bit(a, b, sum);\n    input [7:0] a;\n    input [7:0] b;\n    output [7:0] sum;\n\n    wire [7:0] carry;\n\n    // Full adder for each bit\n    genvar j;\n    for (j = 0; j < 8; j = j + 1) begin\n        full_adder fa(.a(a[j]), .b(b[j]), .cin(carry[j]), .sum(sum[j]), .cout(carry[j+1]));\n    end\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire carry_out;      // Carry output from the full adder\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry_out(carry_out)\n    );\n\n    // Output assignment\n    assign D = sum[7:0];\n    assign B_out = carry_out;\nendmodule\n\nmodule adder_8bit(A, B, sum, carry_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 9-bit sum\n    output carry_out;    // Carry output indicating if a carry was generated during addition\n\n    wire [8:0] temp_sum; // Temporary sum\n\n    // Full adder instantiation\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(0),\n        .Sum(temp_sum[0]),\n        .Cout(temp_sum[1])\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(temp_sum[0]),\n        .Sum(temp_sum[2]),\n        .Cout(temp_sum[3])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(temp_sum[2]),\n        .Sum(temp_sum[4]),\n        .Cout(temp_sum[5])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(temp_sum[4]),\n        .Sum(temp_sum[6]),\n        .Cout(temp_sum[7])\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(temp_sum[6]),\n        .Sum(temp_sum[8]),\n        .Cout(temp_sum[9])\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(temp_sum[8]),\n        .Sum(temp_sum[10]),\n        .Cout(temp_sum[11])\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(temp_sum[10]),\n        .Sum(temp_sum[12]),\n        .Cout(temp_sum[13])\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(temp_sum[12]),\n        .Sum(temp_sum[14]),\n        .Cout(temp_sum[15])\n    );\n\n    assign sum = temp_sum;\n    assign carry_out = temp_sum[8];\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the 4-bit adder for each bit position\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [3:0] p;     // 4-bit output representing the sum of x and y\n\n    wire [4:0] sum;     // Intermediate sum\n\n    // Calculate the sum\n    assign sum = x + y;\n\n    // Assign the output\n    assign p = sum[3:0];\n\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            counter <= counter + 1;\n        end else begin\n            pwm_out <= 1'b0;\n            counter <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire carry;          // Carry output from the adder\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .Cin(1'b0),\n        .Sum(sum),\n        .Cout(carry)\n    );\n\n    // Outputs\n    assign D = sum[7:0];\n    assign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input Cin;           // Carry input\n    output [7:0] Sum;   // 8-bit output representing the sum of A and B\n    output Cout;        // Carry output indicating if a carry was generated during the addition\n\n    wire [8:0] temp;    // Intermediate sum\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .Sum(temp[0]),\n        .Cout(temp[1])\n    );\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(temp[1]),\n        .Sum(temp[2]),\n        .Cout(temp[3])\n    );\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(temp[3]),\n        .Sum(temp[4]),\n        .Cout(temp[5])\n    );\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(temp[5]),\n        .Sum(temp[6]),\n        .Cout(temp[7])\n    );\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(temp[7]),\n        .Sum(temp[8]),\n        .Cout(temp[9])\n    );\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(temp[9]),\n        .Sum(temp[10]),\n        .Cout(temp[11])\n    );\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(temp[11]),\n        .Sum(temp[12]),\n        .Cout(temp[13])\n    );\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(temp[13]),\n        .Sum(temp[14]),\n        .Cout(temp[15])\n    );\n\n    // Outputs\n    assign Sum = temp[7:0];\n    assign Cout = temp[8];\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;           // Input A\n    input B;           // Input B\n    input Cin;         // Carry input\n    output Sum;        // Sum output\n    output Cout;       // Carry output\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_low, b_low, a_high, b_high;\n    wire [7:0] a_low_equal, b_low_equal, a_high_equal, b_high_equal;\n\n    // Instantiate 8-bit comparators for each 8-bit section\n    comp8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(a_low_equal)\n    );\n    comp8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(b_low_equal)\n    );\n    comp8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(a_high_equal)\n    );\n    comp8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(b_high_equal)\n    );\n\n    // Combine results from each 8-bit comparator\n    assign a_low = a_low_equal;\n    assign b_low = b_low_equal;\n    assign a_high = a_high_equal;\n    assign b_high = b_high_equal;\n\n    // Combine results from each 8-bit comparator\n    assign equal = a_low & b_low & a_high & b_high;\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    wire [31:0] nor_result;\n    wire [31:0] slt_result;\n    wire [31:0] sltu_result;\n    wire [31:0] sll_result;\n    wire [31:0] srl_result;\n    wire [31:0] sra_result;\n    wire [31:0] lui_result;\n\n    // Instantiate submodules\n    add add_inst (.a(a), .b(b), .r(add_result));\n    addu addu_inst (.a(a), .b(b), .r(sub_result));\n    sub sub_inst (.a(a), .b(b), .r(sub_result));\n    and and_inst (.a(a), .b(b), .r(and_result));\n    or or_inst (.a(a), .b(b), .r(or_result));\n    xor xor_inst (.a(a), .b(b), .r(xor_result));\n    nor nor_inst (.a(a), .b(b), .r(nor_result));\n    slt slt_inst (.a(a), .b(b), .r(slt_result));\n    sltu sltu_inst (.a(a), .b(b), .r(sltu_result));\n    sll sll_inst (.a(a), .b(b), .r(sll_result));\n    srl srl_inst (.a(a), .b(b), .r(srl_result));\n    sra sra_inst (.a(a), .b(b), .r(sra_result));\n    lui lui_inst (.a(a), .r(lui_result));\n\n    // Select result based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? sub_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] == 1 && aluc == 6'b101010) || (r[31] == 0 && aluc == 6'b101011);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] : (aluc == 6'b101011) ? sltu_result[31] : 0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a & b;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a | b;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a ^ b;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = ~(a | b);\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 1 : 0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 1 : 0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule lui(input [31:0] a, output [31:0] r);\n    assign r = {12'b0, a[31:12]};\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Combine the results\n    assign P = p0 + (p1 << 1) + (p2 << 2);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the shift and add modules\n    shift_add_4bit shift_0(.x(x), .y(y), .p(p0));\n    shift_add_4bit shift_1(.x(x), .y(y), .p(p1));\n\n    // Combine the results\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule shift_add_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the add module\n    add_4bit add_0(.x(x), .y(y), .p(p0));\n    add_4bit add_1(.x(x), .y(y), .p(p1));\n\n    // Combine the results\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule add_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of X and Y\n\n    assign p = x + (y << 3);\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each section\n    comp8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_hi)\n    );\n\n    // Combine the results of each comparator\n    assign equal = equal_lo & equal_hi;\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    // Implement the 8-bit comparator logic here\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate adder, subtractor, and_logical, or_logical submodules\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\n// Select result based on op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND_RESULT\n);\n    assign AND_RESULT = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR_RESULT\n);\n    assign OR_RESULT = A | B;\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", operand_a, operand_b, sum);\nsubtractor subtractor (\"-\", operand_a, operand_b, diff);\nand_logical and_logical (\"&\", operand_a, operand_b, and_result);\nor_logical or_logical (\"|\", operand_a, operand_b, or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] sum\n);\n    assign sum = operand_a + operand_b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] diff\n);\n    assign diff = operand_a - operand_b;\nendmodule\n\nmodule and_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] and_result\n);\n    assign and_result = operand_a & operand_b;\nendmodule\n\nmodule or_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] or_result\n);\n    assign or_result = operand_a | operand_b;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output [31:0] B_out;  // 32-bit output representing the borrow-out\n\n    wire [15:0] S1_diff, S1_borrow;\n    wire [15:0] S2_diff, S2_borrow;\n\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S1_diff),\n        .Borrow(S1_borrow)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S2_diff),\n        .Borrow(S2_borrow)\n    );\n\n    assign Diff = {S2_diff, S1_diff};\n    assign B_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output [15:0] Borrow; // 16-bit output representing the borrow-out\n\n    wire [7:0] S1_diff, S1_borrow;\n    wire [7:0] S2_diff, S2_borrow;\n\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S1_diff),\n        .Borrow(S1_borrow)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S2_diff),\n        .Borrow(S2_borrow)\n    );\n\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_8bit(A, B, Diff, Borrow);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] Diff;   // 8-bit output representing the difference of A and B\n    output [7:0] Borrow; // 8-bit output representing the borrow-out\n\n    wire [3:0] S1_diff, S1_borrow;\n    wire [3:0] S2_diff, S2_borrow;\n\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S1_diff),\n        .Borrow(S1_borrow)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S2_diff),\n        .Borrow(S2_borrow)\n    );\n\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_4bit(A, B, Diff, Borrow);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n    output [3:0] Borrow; // 4-bit output representing the borrow-out\n\n    wire [1:0] S1_diff, S1_borrow;\n    wire [1:0] S2_diff, S2_borrow;\n\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S1_diff),\n        .Borrow(S1_borrow)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S2_diff),\n        .Borrow(S2_borrow)\n    );\n\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_2bit(A, B, Diff, Borrow);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n    output [1:0] Borrow; // 2-bit output representing the borrow-out\n\n    wire [0] S1_diff, S1_borrow;\n    wire [0] S2_diff, S2_borrow;\n\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(S1_diff),\n        .Borrow(S1_borrow)\n    );\n\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S2_diff),\n        .Borrow(S2_borrow)\n    );\n\n    assign Diff = {S2_diff, S1_diff};\n    assign Borrow = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_1bit(A, B, Diff, Borrow);\n    input A;       // 1-bit input operand A\n    input B;       // 1-bit input operand B\n    output Diff;   // 1-bit output representing the difference of A and B\n    output Borrow; // 1-bit output representing the borrow-out\n\n    assign Diff = A ^ B;\n    assign Borrow = A & B;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate submodules\nadder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor subtractor_inst (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_module and_inst (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_module or_inst (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Multiplexer\nalways @(*) begin\n    case(op)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_temp;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_temp)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_temp),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result\n);\n    assign result = (op_code == 2'b00) ? data_a + data_b :\n                    (op_code == 2'b01) ? data_a - data_b :\n                    (op_code == 2'b10) ? data_a & data_b :\n                    (op_code == 2'b11) ? data_a | data_b : 4'b0000;\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output zero\n);\n    assign zero = (result == 4'b0000);\nendmodule"}
{"task_id": "alu", "response": "`define ADD 6'b100000\n`define ADDU 6'b100001\n`define SUB 6'b100010\n`define SUBU 6'b100011\n`define AND 6'b100100\n`define OR 6'b100101\n`define XOR 6'b100110\n`define NOR 6'b100111\n`define SLT 6'b101010\n`define SLTU 6'b101011\n`define SLL 6'b000000\n`define SRL 6'b000010\n`define SRA 6'b000011\n`define SLLV 6'b000100\n`define SRLV 6'b000110\n`define SRAV 6'b000111\n`define LUI 6'b001111\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, lui_result;\nwire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, lui_carry;\nwire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, lui_overflow;\nwire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, lui_zero;\nwire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, lui_negative;\n\nsubmodule add add_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .zero(add_zero), .negative(add_negative));\nsubmodule addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .zero(add_zero), .negative(add_negative));\nsubmodule sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .zero(sub_zero), .negative(sub_negative));\nsubmodule subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .zero(sub_zero), .negative(sub_negative));\nsubmodule and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .overflow(and_overflow), .zero(and_zero), .negative(and_negative));\nsubmodule or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .overflow(or_overflow), .zero(or_zero), .negative(or_negative));\nsubmodule xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .overflow(xor_overflow), .zero(xor_zero), .negative(xor_negative));\nsubmodule nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .overflow(nor_overflow), .zero(nor_zero), .negative(nor_negative));\nsubmodule slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .overflow(slt_overflow), .zero(slt_zero), .negative(slt_negative));\nsubmodule sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .overflow(sltu_overflow), .zero(sltu_zero), .negative(sltu_negative));\nsubmodule sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .overflow(sll_overflow), .zero(sll_zero), .negative(sll_negative));\nsubmodule srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .overflow(srl_overflow), .zero(srl_zero), .negative(srl_negative));\nsubmodule sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .overflow(sra_overflow), .zero(sra_zero), .negative(sra_negative));\nsubmodule sllv sllv_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .overflow(sll_overflow), .zero(sll_zero), .negative(sll_negative));\nsubmodule srlv srlv_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .overflow(srl_overflow), .zero(srl_zero), .negative(srl_negative));\nsubmodule srav srav_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .overflow(sra_overflow), .zero(sra_zero), .negative(sra_negative));\nsubmodule lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .overflow(lui_overflow), .zero(lui_zero), .negative(lui_negative));\n\nassign {carry, r} = (aluc == `ADD) ? {add_carry, add_result} :\n                   (aluc == `ADDU) ? {add_carry, add_result} :\n                   (aluc == `SUB) ? {sub_carry, sub_result} :\n                   (aluc == `SUBU) ? {sub_carry, sub_result} :\n                   (aluc == `AND) ? {and_carry, and_result} :\n                   (aluc == `OR) ? {or_carry, or_result} :\n                   (aluc == `XOR) ? {xor_carry, xor_result} :\n                   (aluc == `NOR) ? {nor_carry, nor_result} :\n                   (aluc == `SLT) ? {slt_carry, slt_result} :\n                   (aluc == `SLTU) ? {sltu_carry, sltu_result} :\n                   (aluc == `SLL) ? {sll_carry, sll_result} :\n                   (aluc == `SRL) ? {srl_carry, srl_result} :\n                   (aluc == `SRA) ? {sra_carry, sra_result} :\n                   (aluc == `SLLV) ? {sll_carry, sll_result} :\n                   (aluc == `SRLV) ? {srl_carry, srl_result} :\n                   (aluc == `SRAV) ? {sra_carry, sra_result} :\n                   (aluc == `LUI) ? {lui_carry, lui_result} : 32'b0;\n\nassign zero = (aluc == `ADD) ? add_zero :\n              (aluc == `ADDU) ? add_zero :\n              (aluc == `SUB) ? sub_zero :\n              (aluc == `SUBU) ? sub_zero :\n              (aluc == `AND) ? and_zero :\n              (aluc == `OR) ? or_zero :\n              (aluc == `XOR) ? xor_zero :\n              (aluc == `NOR) ? nor_zero :\n              (aluc == `SLT) ? slt_zero :\n              (aluc == `SLTU) ? sltu_zero :\n              (aluc == `SLL) ? sll_zero :\n              (aluc == `SRL) ? srl_zero :\n              (aluc == `SRA) ? sra_zero :\n              (aluc == `SLLV) ? sll_zero :\n              (aluc == `SRLV) ? srl_zero :\n              (aluc == `SRAV) ? sra_zero :\n              (aluc == `LUI) ? lui_zero : 1'b0;\n\nassign negative = (aluc == `ADD) ? add_negative :\n                  (aluc == `ADDU) ? add_negative :\n                  (aluc == `SUB) ? sub_negative :\n                  (aluc == `SUBU) ? sub_negative :\n                  (aluc == `AND) ? and_negative :\n                  (aluc == `OR) ? or_negative :\n                  (aluc == `XOR) ? xor_negative :\n                  (aluc == `NOR) ? nor_negative :\n                  (aluc == `SLT) ? slt_negative :\n                  (aluc == `SLTU) ? sltu_negative :\n                  (aluc == `SLL) ? sll_negative :\n                  (aluc == `SRL) ? srl_negative :\n                  (aluc == `SRA) ? sra_negative :\n                  (aluc == `SLLV) ? sll_negative :\n                  (aluc == `SRLV) ? srl_negative :\n                  (aluc == `SRAV) ? sra_negative :\n                  (aluc == `LUI) ? lui_negative : 1'b0;\n\nassign overflow = (aluc == `ADD) ? add_overflow :\n                  (aluc == `ADDU) ? add_overflow :\n                  (aluc == `SUB) ? sub_overflow :\n                  (aluc == `SUBU) ? sub_overflow :\n                  (aluc == `AND) ? and_overflow :\n                  (aluc == `OR) ? or_overflow :\n                  (aluc == `XOR) ? xor_overflow :\n                  (aluc == `NOR) ? nor_overflow :\n                  (aluc == `SLT) ? slt_overflow :\n                  (aluc == `SLTU) ? sltu_overflow :\n                  (aluc == `SLL) ? sll_overflow :\n                  (aluc == `SRL) ? srl_overflow :\n                  (aluc == `SRA) ? sra_overflow :\n                  (aluc == `SLLV) ? sll_overflow :\n                  (aluc == `SRLV) ? srl_overflow :\n                  (aluc == `SRAV) ? sra_overflow :\n                  (aluc == `LUI) ? lui_overflow : 1'b0;\n\nassign flag = (aluc == `SLT) ? slt_result[31] :\n              (aluc == `SLTU) ? sltu_result[31] : 1'b0;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output [31:0] B_out;  // Borrow-out output\n\n    wire [15:0] S1_out;\n    wire [15:0] S2_out;\n    wire [15:0] B_out_16;\n\n    // Instantiate 16-bit subtractors\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S1_out),\n        .B_out(B_out_16)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output [15:0] B_out;  // Borrow-out output\n\n    wire [7:0] S1_out;\n    wire [7:0] S2_out;\n    wire [7:0] B_out_8;\n\n    // Instantiate 8-bit subtractors\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S1_out),\n        .B_out(B_out_8)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] Diff;   // 8-bit output representing the difference of A and B\n    output [7:0] B_out;  // Borrow-out output\n\n    wire [3:0] S1_out;\n    wire [3:0] S2_out;\n    wire [3:0] B_out_4;\n\n    // Instantiate 4-bit subtractors\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S1_out),\n        .B_out(B_out_4)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n    output [3:0] B_out;  // Borrow-out output\n\n    wire [1:0] S1_out;\n    wire [1:0] S2_out;\n    wire [1:0] B_out_2;\n\n    // Instantiate 2-bit subtractors\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S1_out),\n        .B_out(B_out_2)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n    output [1:0] B_out;  // Borrow-out output\n\n    wire [0:0] S1_out;\n    wire [0:0] S2_out;\n    wire [0:0] B_out_1;\n\n    // Instantiate 1-bit subtractors\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(S1_out),\n        .B_out(B_out_1)\n    );\n\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;       // 1-bit input operand A\n    input B;       // 1-bit input operand B\n    output Diff;   // 1-bit output representing the difference of A and B\n    output B_out;  // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = ~(A & B);\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b; // Addition\n            2'b01: result = data_a - data_b; // Subtraction\n            2'b10: result = data_a & data_b; // AND\n            2'b11: result = data_a | data_b; // OR\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = B_out_16[15] | B_out_8[7];\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = B_out_8[7];\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n    wire add_valid, sub_valid, mul_valid, div_valid;\n\n    // Instantiate arithmetic operations\n    adder add_module(.a(data_a), .b(data_b), .result(add_result), .valid(add_valid));\n    subtractor sub_module(.a(data_a), .b(data_b), .result(sub_result), .valid(sub_valid));\n    multiplier mul_module(.a(data_a), .b(data_b), .result(mul_result), .valid(mul_valid));\n    divider div_module(.a(data_a), .b(data_b), .result(div_result), .valid(div_valid));\n\n    // Select operation based on opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                `ADD_OP: begin\n                    result <= add_result;\n                    valid <= add_valid;\n                end\n                `SUB_OP: begin\n                    result <= sub_result;\n                    valid <= sub_valid;\n                end\n                `MUL_OP: begin\n                    result <= mul_result;\n                    valid <= mul_valid;\n                end\n                `DIV_OP: begin\n                    result <= div_result;\n                    valid <= div_valid;\n                end\n                default: begin\n                    result <= 0;\n                    valid <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a + b;\n    assign valid = 1;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a - b;\n    assign valid = 1;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a * b;\n    assign valid = 1;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a / b;\n    assign valid = (b != 0);\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate arithmetic operation modules\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result = 0;\n            valid = 0;\n        end else begin\n            result = a / b;\n            valid = 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input operand A\n    input [16:1] B;       // 16-bit input operand B\n    output [16:1] D;      // 16-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire b0, b1, b2, b3;  // Borrow outputs for each subtraction\n\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C(1'b0),\n        .D(D[16:1]),\n        .B_out(b0)\n    );\n\n    sub4 sub2(\n        .A(A[15:1]),\n        .B(B[15:1]),\n        .C(b0),\n        .D(D[15:1]),\n        .B_out(b1)\n    );\n\n    sub4 sub3(\n        .A(A[14:1]),\n        .B(B[14:1]),\n        .C(b1),\n        .D(D[14:1]),\n        .B_out(b2)\n    );\n\n    sub4 sub4(\n        .A(A[13:1]),\n        .B(B[13:1]),\n        .C(b2),\n        .D(D[13:1]),\n        .B_out(b3)\n    );\n\n    assign B_out = b3;\nendmodule\n\nmodule sub4(A, B, C, D, B_out);\n    input [4:1] A;        // 4-bit input operand A\n    input [4:1] B;        // 4-bit input operand B\n    input C;              // Carry-in\n    output [4:1] D;       // 4-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire b0, b1;          // Borrow outputs for each subtraction\n\n    sub3 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C(1'b0),\n        .D(D[4:1]),\n        .B_out(b0)\n    );\n\n    sub3 sub2(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .C(b0),\n        .D(D[3:1]),\n        .B_out(b1)\n    );\n\n    sub3 sub3(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C(b1),\n        .D(D[2:1]),\n        .B_out(b0)\n    );\n\n    sub3 sub4(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C(b0),\n        .D(D[1:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub3(A, B, C, D, B_out);\n    input [3:1] A;        // 3-bit input operand A\n    input [3:1] B;        // 3-bit input operand B\n    input C;              // Carry-in\n    output [3:1] D;       // 3-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire b0, b1;          // Borrow outputs for each subtraction\n\n    sub2 sub1(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .C(1'b0),\n        .D(D[3:1]),\n        .B_out(b0)\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C(b0),\n        .D(D[2:1]),\n        .B_out(b1)\n    );\n\n    sub2 sub3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C(b1),\n        .D(D[1:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub2(A, B, C, D, B_out);\n    input [2:1] A;        // 2-bit input operand A\n    input [2:1] B;        // 2-bit input operand B\n    input C;              // Carry-in\n    output [2:1] D;       // 2-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire b0;              // Borrow output for each subtraction\n\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C(1'b0),\n        .D(D[2:1]),\n        .B_out(b0)\n    );\n\n    sub1 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C(b0),\n        .D(D[1:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub1(A, B, C, D, B_out);\n    input [1:1] A;        // 1-bit input operand A\n    input [1:1] B;        // 1-bit input operand B\n    input C;              // Carry-in\n    output [1:1] D;       // 1-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    assign {B_out, D} = A - B - C;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .C_in(b_out[1:1]),\n        .D(D[12:8]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .C_in(b_out[2:2]),\n        .D(D[8:4]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[3:3]),\n        .D(D[4:1]),\n        .B_out(b_out[4:4])\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out[4:1];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out[2:2])\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out[2:1];\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Assign borrow-out\n    assign B_out = b_out[1:1];\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in\n    output D;             // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out\n\n    assign D = A ^ B ^ C_in;\n    assign B_out = (A & B) | (A & C_in) | (B & C_in);\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the comparison results\n    assign A_greater = (sub_result != 32'b0) && (borrow == 1'b0);\n    assign A_equal = (sub_result == 32'b0);\n    assign A_less = (sub_result == 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sub_result,\n    output borrow\n);\n\n    // Perform subtraction\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the result\n    assign A_greater = (diff != 0) && (borrow == 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Subtraction operation\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire C16,C8,C4,C2,C1;\n    \n    // Instantiate 16-bit CLA\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA2 CLA2 (.A(A[8:17]), .B(B[8:17]), .Cin(C16), .S(S[8:17]), .Cout(C8));\n    CLA2 CLA3 (.A(A[4:18]), .B(B[4:18]), .Cin(C8), .S(S[4:18]), .Cout(C4));\n    CLA2 CLA4 (.A(A[2:19]), .B(B[2:19]), .Cin(C4), .S(S[2:19]), .Cout(C2));\n    CLA2 CLA5 (.A(A[1:20]), .B(B[1:20]), .Cin(C2), .S(S[1:20]), .Cout(C1));\n    assign C32 = C1;\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n    wire C15,C14,C13,C12,C11,C10,C9,C8,C7,C6,C5,C4,C3,C2,C1;\n    \n    // Instantiate 16-bit CLA\n    CLA CLA1 (.A(A[15:1]), .B(B[15:1]), .Cin(1'b0), .S(S[15:1]), .Cout(C15));\n    CLA CLA2 (.A(A[14:2]), .B(B[14:2]), .Cin(C15), .S(S[14:2]), .Cout(C14));\n    CLA CLA3 (.A(A[13:3]), .B(B[13:3]), .Cin(C14), .S(S[13:3]), .Cout(C13));\n    CLA CLA4 (.A(A[12:4]), .B(B[12:4]), .Cin(C13), .S(S[12:4]), .Cout(C12));\n    CLA CLA5 (.A(A[11:5]), .B(B[11:5]), .Cin(C12), .S(S[11:5]), .Cout(C11));\n    CLA CLA6 (.A(A[10:6]), .B(B[10:6]), .Cin(C11), .S(S[10:6]), .Cout(C10));\n    CLA CLA7 (.A(A[9:7]), .B(B[9:7]), .Cin(C10), .S(S[9:7]), .Cout(C9));\n    CLA CLA8 (.A(A[8:8]), .B(B[8:8]), .Cin(C9), .S(S[8:8]), .Cout(C8));\n    CLA CLA9 (.A(A[7:9]), .B(B[7:9]), .Cin(C8), .S(S[7:9]), .Cout(C7));\n    CLA CLA10(.A(A[6:10]), .B(B[6:10]), .Cin(C7), .S(S[6:10]), .Cout(C6));\n    CLA CLA11(.A(A[5:11]), .B(B[5:11]), .Cin(C6), .S(S[5:11]), .Cout(C5));\n    CLA CLA12(.A(A[4:12]), .B(B[4:12]), .Cin(C5), .S(S[4:12]), .Cout(C4));\n    CLA CLA13(.A(A[3:13]), .B(B[3:13]), .Cin(C4), .S(S[3:13]), .Cout(C3));\n    CLA CLA14(.A(A[2:14]), .B(B[2:14]), .Cin(C3), .S(S[2:14]), .Cout(C2));\n    CLA CLA15(.A(A[1:15]), .B(B[1:15]), .Cin(C2), .S(S[1:15]), .Cout(C1));\n    assign Cout = C1;\nendmodule\n\nmodule CLA(A,B,Cin,S,Cout);\n    input [15:1] A,B;\n    input Cin;\n    output [15:1] S;\n    output Cout;\n    wire C14,C13,C12,C11,C10,C9,C8,C7,C6,C5,C4,C3,C2,C1;\n    \n    // Instantiate 16-bit CLA\n    CLA CLA1 (.A(A[14:2]), .B(B[14:2]), .Cin(1'b0), .S(S[14:2]), .Cout(C14));\n    CLA CLA2 (.A(A[13:3]), .B(B[13:3]), .Cin(C14), .S(S[13:3]), .Cout(C13));\n    CLA CLA3 (.A(A[12:4]), .B(B[12:4]), .Cin(C13), .S(S[12:4]), .Cout(C12));\n    CLA CLA4 (.A(A[11:5]), .B(B[11:5]), .Cin(C12), .S(S[11:5]), .Cout(C11));\n    CLA CLA5 (.A(A[10:6]), .B(B[10:6]), .Cin(C11), .S(S[10:6]), .Cout(C10));\n    CLA CLA6 (.A(A[9:7]), .B(B[9:7]), .Cin(C10), .S(S[9:7]), .Cout(C9));\n    CLA CLA7 (.A(A[8:8]), .B(B[8:8]), .Cin(C9), .S(S[8:8]), .Cout(C8));\n    CLA CLA8 (.A(A[7:9]), .B(B[7:9]), .Cin(C8), .S(S[7:9]), .Cout(C7));\n    CLA CLA9 (.A(A[6:10]), .B(B[6:10]), .Cin(C7), .S(S[6:10]), .Cout(C6));\n    CLA CLA10(.A(A[5:11]), .B(B[5:11]), .Cin(C6), .S(S[5:11]), .Cout(C5));\n    CLA CLA11(.A(A[4:12]), .B(B[4:12]), .Cin(C5), .S(S[4:12]), .Cout(C4));\n    CLA CLA12(.A(A[3:13]), .B(B[3:13]), .Cin(C4), .S(S[3:13]), .Cout(C3));\n    CLA CLA13(.A(A[2:14]), .B(B[2:14]), .Cin(C3), .S(S[2:14]), .Cout(C2));\n    CLA CLA14(.A(A[1:15]), .B(B[1:15]), .Cin(C2), .S(S[1:15]), .Cout(C1));\n    assign Cout = C1;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_2;\n\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16[1]));\n    CLA1 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16[1]), .S(S[32:17]), .Cout(C16[2]));\n\n    assign C32 = C16[2];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate 4-bit ripple carry adder for initial 4 bits\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Instantiate 4-bit carry select adder slices for next 4 bits\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Assemble the sum and carry-out\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Ripple carry adder logic\nassign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate 2 ripple carry adders for each 4-bit section\nripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\nripple_carry_adder rca2(.a(a), .b(b), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Instantiate multiplexer to select sum and carry based on cin\nassign {cout, sum} = (cin) ? {carry[1], sum_slice[1]} : {carry[0], sum_slice[0]};\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4 bits\nwire [3:0] ripple_carry_out;\nwire [3:0] sum_slice_1;\nwire [3:0] sum_slice_2;\n\n// Second 4 bits\nwire [3:0] ripple_carry_out_2;\nwire [3:0] sum_slice_3;\nwire [3:0] sum_slice_4;\n\n// Third 4 bits\nwire [3:0] ripple_carry_out_3;\nwire [3:0] sum_slice_5;\nwire [3:0] sum_slice_6;\n\n// Fourth 4 bits\nwire [3:0] ripple_carry_out_4;\nwire [3:0] sum_slice_7;\nwire [3:0] sum_slice_8;\n\n// Instantiate the ripple carry adder for first 4 bits\nripple_carry rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice_1), .carry(ripple_carry_out));\n\n// Instantiate the carry select adder for first 4 bits\ncarry_select_adder_slice cs_slice1(.a(a[3:0]), .b(b[3:0]), .cin(ripple_carry_out), .sum(sum_slice_2), .carry(carry[0]));\n\n// Instantiate the ripple carry adder for second 4 bits\nripple_carry rca2(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice_3), .carry(ripple_carry_out_2));\n\n// Instantiate the carry select adder for second 4 bits\ncarry_select_adder_slice cs_slice2(.a(a[7:4]), .b(b[7:4]), .cin(ripple_carry_out_2), .sum(sum_slice_4), .carry(carry[1]));\n\n// Instantiate the ripple carry adder for third 4 bits\nripple_carry rca3(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice_5), .carry(ripple_carry_out_3));\n\n// Instantiate the carry select adder for third 4 bits\ncarry_select_adder_slice cs_slice3(.a(a[11:8]), .b(b[11:8]), .cin(ripple_carry_out_3), .sum(sum_slice_6), .carry(carry[2]));\n\n// Instantiate the ripple carry adder for fourth 4 bits\nripple_carry rca4(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice_7), .carry(ripple_carry_out_4));\n\n// Instantiate the carry select adder for fourth 4 bits\ncarry_select_adder_slice cs_slice4(.a(a[15:12]), .b(b[15:12]), .cin(ripple_carry_out_4), .sum(sum_slice_8), .carry(carry[3]));\n\n// Assemble the final sum and carry-out\nassign sum = {sum_slice_1, sum_slice_2, sum_slice_3, sum_slice_4, sum_slice_5, sum_slice_6, sum_slice_7, sum_slice_8};\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry(a, b, cin, sum, carry);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput carry;\n\nassign {carry, sum} = a + b + cin;\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, carry);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput carry;\n\nwire [3:0] ripple_carry_out;\nwire [3:0] sum_slice;\n\n// Instantiate the ripple carry adder\nripple_carry rca(.a(a), .b(b), .cin(cin), .sum(sum_slice), .carry(ripple_carry_out));\n\n// Select the sum based on carry-in\nassign sum = (ripple_carry_out) ? a : b;\n\n// Select the carry based on carry-in\nassign carry = (ripple_carry_out) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for first 4 bits\n    add4 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for last 4 bits\n    add4 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for first 2 bits\n    add2 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for last 2 bits\n    add2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for first bit\n    add1 add1_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co)\n    );\n\n    // 1-bit adder for last bit\n    add1 add1_inst2 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co),\n        .y(y[1]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // 8-bit adder for first 8 bits\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for first 4 bits\n    add4 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for last 4 bits\n    add4 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for first 2 bits\n    add2 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for last 2 bits\n    add2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for first bit\n    add1 add1_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co)\n    );\n\n    // 1-bit adder for last bit\n    add1 add1_inst2 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co),\n        .y(y[1]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (a & Cin) | (b & Cin);\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [8:0] sum_temp;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum_temp[0]), .cout(sum_temp[1]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(sum_temp[1]), .sum(sum_temp[2]), .cout(sum_temp[3]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(sum_temp[3]), .sum(sum_temp[4]), .cout(sum_temp[5]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(sum_temp[5]), .sum(sum_temp[6]), .cout(sum_temp[7]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(sum_temp[7]), .sum(sum_temp[8]), .cout(sum_temp[9]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(sum_temp[9]), .sum(sum_temp[10]), .cout(sum_temp[11]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(sum_temp[11]), .sum(sum_temp[12]), .cout(sum_temp[13]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(sum_temp[13]), .sum(sum_temp[14]), .cout(sum_temp[15]));\n\n    assign sum = sum_temp[7:0];\n    assign cout = sum_temp[8];\nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift_count;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift_count(shift_count)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(yout)\n    );\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            done <= 0;\n        end else if (start) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n    end\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift_count // Shift count register.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count input.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product output with a data width of 32 bits.\n);\n    reg [15:0] multiplicand; // Multiplicand register.\n    reg [15:0] multiplier;   // Multiplier register.\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            multiplicand <= 0;\n            multiplier <= 0;\n            product <= 0;\n        end else if (start) begin\n            multiplicand <= ain;\n            multiplier <= bin;\n            product <= 0;\n        end else begin\n            if (shift_count < 16) begin\n                product <= product + (multiplicand[shift_count] ? multiplier : 0);\n            end\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift_count(shift_count)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n\nendmodule\n\n// Submodule for Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            done <= 0;\n        end else if (start) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n    end\nendmodule\n\n// Submodule for Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift_count // Shift count register\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\nendmodule\n\n// Submodule for Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n    reg [31:0] temp_product;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            temp_product <= 0;\n            product <= 0;\n        end else if (start) begin\n            temp_product <= 0;\n            product <= 0;\n        end else begin\n            temp_product <= temp_product + (bin << shift_count);\n            product <= temp_product;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire [3:0] gt_b, lt_b, eq_b;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_b[3]), .lt(lt_b[3]), .eq(eq_b[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_b[2]), .lt(lt_b[2]), .eq(eq_b[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_b[1]), .lt(lt_b[1]), .eq(eq_b[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_b[0]), .lt(lt_b[0]), .eq(eq_b[0]));\n\n    assign gt = (gt_b[3] & gt_b[2] & gt_b[1] & gt_b[0]) | (lt_b[3] & lt_b[2] & lt_b[1] & lt_b[0]);\n    assign lt = (lt_b[3] & lt_b[2] & lt_b[1] & lt_b[0]) | (gt_b[3] & gt_b[2] & gt_b[1] & gt_b[0]);\n    assign eq = (eq_b[3] & eq_b[2] & eq_b[1] & eq_b[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n\n    always @(*) begin\n        sum = a + b;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(code_temp[0]));\n\n    // Combine the output of each check_bit submodule\n    assign code = code_temp;\n    assign valid = |code_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !highest;\n    assign valid = in;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire pwm_25_out, pwm_50_out, pwm_75_out;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    // Assign outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    reg [31:0] threshold;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter >= threshold) begin\n                PWM_out <= 1;\n                counter <= 0;\n            end else begin\n                PWM_out <= 0;\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        threshold = 32'd10000000; // 100MHz\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    reg [31:0] threshold;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter >= threshold) begin\n                PWM_out <= 1;\n                counter <= 0;\n            end else begin\n                PWM_out <= 0;\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        threshold = 32'd50000000; // 50MHz\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    reg [31:0] threshold;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter >= threshold) begin\n                PWM_out <= 1;\n                counter <= 0;\n            end else begin\n                PWM_out <= 0;\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    always @(*) begin\n        threshold = 32'd75000000; // 75MHz\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .temp_threshold(8'd64),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, temp_threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] temp_threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > temp_threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case(state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case(state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Submodule instances\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\n// Operation selector logic\nalways @(*) begin\n    case(op_sel)\n        2'b00: result = u_adder.sum;\n        2'b01: result = u_subtractor.diff;\n        2'b10: result = u_and.out;\n        2'b11: result = u_or.out;\n        default: result = 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodule implementations\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d_0, d_1, d_2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d_0));\n    my_dff8 u1 (.clk(clk), .d(d_0), .q(d_1));\n    my_dff8 u2 (.clk(clk), .d(d_1), .q(d_2));\n\n    // Select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d_0;\n            2'b10: q <= d_1;\n            2'b11: q <= d_2;\n            default: q <= 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles for 25% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 50; // Number of clock cycles for 50% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 25; // Number of clock cycles for 75% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation result based on the op_sel signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n  // Stage 1: Shift by 4\n  mux2X1 mux1(stage1, in, in, ctrl[2]);\n\n  // Stage 2: Shift by 2\n  mux2X1 mux2(stage2, stage1, stage1, ctrl[1]);\n\n  // Stage 3: Shift by 1\n  mux2X1 mux3(stage3, stage2, stage2, ctrl[0]);\n\n  // Stage 4: Shift by 4\n  mux2X1 mux4(stage4, stage3, stage3, ctrl[2]);\n\n  // Stage 5: Shift by 2\n  mux2X1 mux5(stage5, stage4, stage4, ctrl[1]);\n\n  // Stage 6: Shift by 1\n  mux2X1 mux6(stage6, stage5, stage5, ctrl[0]);\n\n  // Stage 7: Shift by 4\n  mux2X1 mux7(stage7, stage6, stage6, ctrl[2]);\n\n  // Stage 8: Shift by 2\n  mux2X1 mux8(stage8, stage7, stage7, ctrl[1]);\n\n  // Final output\n  assign out = stage8;\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out; // Output from the counter\n    wire comparator_out; // Output from the comparator\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < (DUTY_CYCLE * MAX_COUNT / 100));\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(carry[1]),\n        .S(S[16:13]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add2(\n        .A(A[13:10]),\n        .B(B[13:10]),\n        .C_in(carry[2]),\n        .S(S[13:10]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add3(\n        .A(A[10:7]),\n        .B(B[10:7]),\n        .C_in(carry[3]),\n        .S(S[10:7]),\n        .C_out(carry[4])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[4]),\n        .S(S[7:4]),\n        .C_out(carry[5])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[5];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    two_bit_adder add2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(carry[2]),\n        .S(S[2:1]),\n        .C_out(carry[3])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry outputs\n\n    // Instantiate 1-bit full adder for the last bit\n    one_bit_adder add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(C1)\n    );\n\n    // Instantiate 1-bit full adder for the last bit\n    one_bit_adder add2(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C1),\n        .S(S[0]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A, B;            // Inputs\n    input C_in;            // Carry-in input\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (A & C_in) | (B & C_in); // Carry calculation\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delayed b0 for pe1\n  reg [15:0] b1_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] GPP0, GPP1, GPP2, GPP3;\nwire [3:0] A4BS0, A4BS1, A4BS2;\n\n// Generate partial products\nfull_adder FA0 (.a(a[0]), .b(b[0]), .cin(0), .sum(GPP0), .cout(A4BS0));\nfull_adder FA1 (.a(a[1]), .b(b[1]), .cin(GPP0), .sum(GPP1), .cout(A4BS1));\nfull_adder FA2 (.a(a[2]), .b(b[2]), .cin(GPP1), .sum(GPP2), .cout(A4BS2));\nfull_adder FA3 (.a(a[3]), .b(b[3]), .cin(GPP2), .sum(product[7]), .cout(product[6]));\n\n// Shift registers\nreg [3:0] GPP0_reg, GPP1_reg, GPP2_reg, GPP3_reg;\nalways @(*) begin\n    GPP0_reg = GPP0;\n    GPP1_reg = GPP1;\n    GPP2_reg = GPP2;\n    GPP3_reg = GPP3;\nend\n\n// Generate final product\nfull_adder FA4 (.a(A4BS0), .b(A4BS1), .cin(A4BS2), .sum(product[3]), .cout(product[2]));\nfull_adder FA5 (.a(GPP0_reg), .b(GPP1_reg), .cin(product[2]), .sum(product[1]), .cout(product[0]));\nfull_adder FA6 (.a(GPP2_reg), .b(GPP3_reg), .cin(product[0]), .sum(product[7]), .cout(product[4]));\nfull_adder FA7 (.a(product[1]), .b(product[2]), .cin(product[4]), .sum(product[5]), .cout(product[3]));\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n\n    // Count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next)\n    );\n\n    // Overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count_out <= 4'b0000;\n        else if (en)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry output from each adder\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .S(S[16:1]),\n        .C_out(carry[1])\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(carry[1]),\n        .S(S[12:1]),\n        .C_out(carry[2])\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(carry[2]),\n        .S(S[8:1]),\n        .C_out(carry[3])\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(carry[3]),\n        .S(S[4:1]),\n        .C_out(carry[4])\n    );\n\n    // Output carry-out\n    assign C_out = carry[4];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] temp;      // Temporary sum\n    wire [4:1] carry;     // Carry output from each adder\n\n    // Adder logic\n    assign temp[1] = A[1] ^ B[1];\n    assign temp[2] = A[2] ^ B[2];\n    assign temp[3] = A[3] ^ B[3];\n    assign temp[4] = A[4] ^ B[4];\n    assign temp[5] = A[1] & B[1] | A[2] & B[2] | A[3] & B[3] | A[4] & B[4];\n\n    // Carry logic\n    assign carry[1] = A[1] & B[1] | A[2] & B[2] | A[3] & B[3] | A[4] & B[4];\n    assign carry[2] = A[2] & B[2] | A[3] & B[3] | A[4] & B[4];\n    assign carry[3] = A[3] & B[3] | A[4] & B[4];\n    assign carry[4] = A[4] & B[4];\n\n    // Output logic\n    assign S = temp ^ {5{C_in}};\n    assign C_out = carry[4];\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the parity of the combined 16 bits\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;       // 8-bit input X\n    output p;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of X\n    assign p = ^x;\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and_module(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or_module(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUB: result <= subtract_result;\n            `AND: result <= bitwise_and_result;\n            `OR: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] temp;\n\n    // Subtractor 0\n    wire [8:0] temp0;\n    wire bout0;\n    sub7_bit S0(\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(temp0[0]),\n        .bout(bout0)\n    );\n\n    // Subtractor 1\n    wire [8:0] temp1;\n    wire bout1;\n    sub7_bit S1(\n        .a(a[1]),\n        .b(b[1]),\n        .bin(temp0[0]),\n        .diff(temp1[1]),\n        .bout(bout1)\n    );\n\n    // Subtractor 2\n    wire [8:0] temp2;\n    wire bout2;\n    sub7_bit S2(\n        .a(a[2]),\n        .b(b[2]),\n        .bin(temp1[1]),\n        .diff(temp2[2]),\n        .bout(bout2)\n    );\n\n    // Subtractor 3\n    wire [8:0] temp3;\n    wire bout3;\n    sub7_bit S3(\n        .a(a[3]),\n        .b(b[3]),\n        .bin(temp2[2]),\n        .diff(temp3[3]),\n        .bout(bout3)\n    );\n\n    // Subtractor 4\n    wire [8:0] temp4;\n    wire bout4;\n    sub7_bit S4(\n        .a(a[4]),\n        .b(b[4]),\n        .bin(temp3[3]),\n        .diff(temp4[4]),\n        .bout(bout4)\n    );\n\n    // Subtractor 5\n    wire [8:0] temp5;\n    wire bout5;\n    sub7_bit S5(\n        .a(a[5]),\n        .b(b[5]),\n        .bin(temp4[4]),\n        .diff(temp5[5]),\n        .bout(bout5)\n    );\n\n    // Subtractor 6\n    wire [8:0] temp6;\n    wire bout6;\n    sub7_bit S6(\n        .a(a[6]),\n        .b(b[6]),\n        .bin(temp5[5]),\n        .diff(temp6[6]),\n        .bout(bout6)\n    );\n\n    // Subtractor 7\n    wire [8:0] temp7;\n    wire bout7;\n    sub7_bit S7(\n        .a(a[7]),\n        .b(b[7]),\n        .bin(temp6[6]),\n        .diff(temp7[7]),\n        .bout(bout7)\n    );\n\n    assign temp = {temp7[7], temp6[6], temp5[5], temp4[4], temp3[3], temp2[2], temp1[1], temp0[0]};\n    assign diff = temp[7:0];\n    assign bout = temp[8];\n\nendmodule\n\nmodule sub7_bit(\n    input a, b, bin,\n    output diff, bout);\n\n    assign {diff, bout} = a - b - bin;\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] next_pc;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(next_pc));\n  decode_stage decode(.clk(clk), .rst(rst), .pc(next_pc), .instr(instr_mem[next_pc]), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .rd(rd), .op(op), .alu_result(alu_result));\n  memory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .mem_result(res_reg_file[rd]));\n  writeback_stage writeback(.clk(clk), .rst(rst), .rd(rd), .mem_result(res_reg_file[rd]));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] next_pc\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      next_pc <= 0;\n    else\n      next_pc <= next_pc + 1;\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[25:21];\n      rs2 <= instr[20:16];\n      rd <= instr[12:8];\n      op <= instr[31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result <= 0;\n    else begin\n      case (op)\n        6'b000000: alu_result <= rs1 + rs2;\n        6'b000010: alu_result <= rs1 - rs2;\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] mem_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      mem_result <= 0;\n    else\n      mem_result <= alu_result;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [4:0] rd,\n  input [31:0] mem_result,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file[0] <= 0;\n      res_reg_file[1] <= 0;\n      res_reg_file[2] <= 0;\n      res_reg_file[3] <= 0;\n      res_reg_file[4] <= 0;\n      res_reg_file[5] <= 0;\n      res_reg_file[6] <= 0;\n      res_reg_file[7] <= 0;\n      res_reg_file[8] <= 0;\n      res_reg_file[9] <= 0;\n      res_reg_file[10] <= 0;\n      res_reg_file[11] <= 0;\n      res_reg_file[12] <= 0;\n      res_reg_file[13] <= 0;\n      res_reg_file[14] <= 0;\n      res_reg_file[15] <= 0;\n      res_reg_file[16] <= 0;\n      res_reg_file[17] <= 0;\n      res_reg_file[18] <= 0;\n      res_reg_file[19] <= 0;\n      res_reg_file[20] <= 0;\n      res_reg_file[21] <= 0;\n      res_reg_file[22] <= 0;\n      res_reg_file[23] <= 0;\n      res_reg_file[24] <= 0;\n      res_reg_file[25] <= 0;\n      res_reg_file[26] <= 0;\n      res_reg_file[27] <= 0;\n      res_reg_file[28] <= 0;\n      res_reg_file[29] <= 0;\n      res_reg_file[30] <= 0;\n      res_reg_file[31] <= 0;\n    end else begin\n      res_reg_file[rd] <= mem_result;\n    end\n  end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slices, gt_slices, lt_slices;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slices[0]), .gt(gt_slices[0]), .lt(lt_slices[0]));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slices[1]), .gt(gt_slices[1]), .lt(lt_slices[1]));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slices[2]), .gt(gt_slices[2]), .lt(lt_slices[2]));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slices[3]), .gt(gt_slices[3]), .lt(lt_slices[3]));\n\n// Combine slices to determine final output\nassign eq = &eq_slices;\nassign gt = |gt_slices;\nassign lt = |lt_slices;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire eq0, gt0, lt0;\nwire eq1, gt1, lt1;\nwire eq2, gt2, lt2;\nwire eq3, gt3, lt3;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice0(.a(a[1:0]), .b(b[1:0]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq1), .gt(gt1), .lt(lt1));\ncomparator_2bit comp_slice2(.a(a[5:4]), .b(b[5:4]), .eq(eq2), .gt(gt2), .lt(lt2));\ncomparator_2bit comp_slice3(.a(a[7:6]), .b(b[7:6]), .eq(eq3), .gt(gt3), .lt(lt3));\n\n// Combine slices to determine final output\nassign eq = eq0 & eq1 & eq2 & eq3;\nassign gt = gt0 | gt1 | gt2 | gt3;\nassign lt = lt0 | lt1 | lt2 | lt3;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq0, gt0, lt0;\nwire eq1, gt1, lt1;\n\n// Instantiate 1-bit comparator slices\ncomparator_1bit comp_slice0(.a(a[0]), .b(b[0]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_1bit comp_slice1(.a(a[1]), .b(b[1]), .eq(eq1), .gt(gt1), .lt(lt1));\n\n// Combine slices to determine final output\nassign eq = eq0 & eq1;\nassign gt = gt0 | gt1;\nassign lt = lt0 | lt1;\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_next), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_next), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_next), .c(c3));\n\n  // Registers to hold previous values for PEs\n  reg [15:0] b_reg0, b_reg1, b_reg2;\n\n  // Assigning previous values to next inputs\n  assign pe1.b_next = b_reg0;\n  assign pe2.b_next = b_reg1;\n  assign pe3.b_next = b_reg2;\n\n  // Updating registers\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_reg0 <= 0;\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n    end else begin\n      b_reg0 <= b0;\n      b_reg1 <= b_reg0;\n      b_reg2 <= b_reg1;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 0;\n    end else begin\n      c_reg <= a * b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_and_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_and_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_and_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_and_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_and_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[24:17], B[24:17], Bout0, D[24:17], Bout1);\n    subtractor_8bit SUB3(A[16:9], B[16:9], Bout1, D[16:9], Bout2);\n    subtractor_8bit SUB4(A[8:1], B[8:1], Bout2, D[8:1], Bout3);\n\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit chunk\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(carry[1]),\n        .S(S[4:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(carry[2]),\n        .S(S[8:5]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(carry[3]),\n        .S(S[12:9]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit chunk\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry chain\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum\n    assign C_out = (A & B) | (A & C_in) | (B & C_in); // Carry-out\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_count(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_count;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0), .carry(sum0[8]));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1), .carry(sum1[8]));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2), .carry(sum2[8]));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3), .carry(sum3[8]));\n\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum,\n    output carry\n);\nassign {carry, sum} = a + b;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Module instance\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n    wire [31:0] fetched_instr;\n    wire [31:0] op1, op2, result;\n    wire [4:0] rd;\n    wire [5:0] opcode;\n    wire [5:0] funct;\n    wire [31:0] reg_file_out;\n\n    // Instantiate fetch stage\n    fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(0), .fetched_instr(fetched_instr));\n\n    // Instantiate execute stage\n    execute_stage execute (.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .op1(op1), .op2(op2), .result(result), .rd(rd), .opcode(opcode), .funct(funct));\n\n    // Instantiate writeback stage\n    writeback_stage writeback (.clk(clk), .rst(rst), .result(result), .rd(rd), .reg_file(reg_file), .reg_file_out(reg_file_out));\n\n    // Connect output to register file output\n    assign out_reg_file = reg_file_out;\n\nendmodule\n\n// Stage modules\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    output reg [31:0] op1,\n    output reg [31:0] op2,\n    output reg [31:0] result,\n    output reg [4:0] rd,\n    output reg [5:0] opcode,\n    output reg [5:0] funct\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            rd <= 0;\n            opcode <= 0;\n            funct <= 0;\n        end else begin\n            op1 <= fetched_instr[31:26];\n            op2 <= fetched_instr[25:21];\n            result <= 0;\n            rd <= fetched_instr[15:11];\n            opcode <= fetched_instr[31:26];\n            funct <= fetched_instr[5:0];\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] reg_file_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            reg_file_out <= 0;\n        end else begin\n            reg_file_out <= result;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output [15:0] p\n);\n    assign p = x * y;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                                         or_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init_out,\n    output reg [7:0] transition_out\n);\n    always @(posedge clk) begin\n        transition_out <= init_out << 1;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (count > 0)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_out;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_out(count_out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_out == 4'd11) begin\n                count_out <= 4'b0000;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = (mode == 0) ? count_value : (~count_value + 1);\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= (count == 255) ? 0 : (mode == 0) ? count + 1 : count - 1;\n  end\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output [63:0]       next_Q\n);\n\n    assign next_Q = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    // Instantiate the frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control signal for the bitwise operator\n    wire and_or_control;\n    assign and_or_control = op_code[1];\n\n    // Output selection based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire [1:0] op_code\n);\n    assign result = (op_code == 2'b00) ? a & b : a | b;\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= {1'b0, out[7:1]};\n    end\nend\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire div_complete;\n\n    // Submodule instances\n    abs_value abs_dividend_inst (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_inst (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    div_control ctrl_inst (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .div_complete(div_complete)\n    );\n\n    result_mgmt res_mgmt_inst (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .res_ready(res_ready),\n        .div_complete(div_complete),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .result(result),\n        .res_valid(res_valid)\n    );\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for calculating negative value\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for managing division control\nmodule div_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg div_complete\n);\n\n    reg [7:0] quotient;\n    reg [7:0] remainder;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            div_complete <= 0;\n        end else begin\n            if (counter == 0) begin\n                shift_reg <= dividend;\n                quotient <= 0;\n                remainder <= 0;\n            end else begin\n                shift_reg <= {shift_reg[6:0], 1'b0};\n                quotient <= quotient + 1;\n                remainder <= remainder + divisor;\n            end\n\n            if (remainder >= dividend) begin\n                quotient <= quotient - 1;\n                remainder <= remainder - divisor;\n            end\n\n            if (counter == 7) begin\n                div_complete <= 1;\n            end else begin\n                div_complete <= 0;\n            end\n\n            counter <= counter + 1;\n        end\n    end\n\nendmodule\n\n// Submodule for managing result validity\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    input wire div_complete,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end else begin\n            if (opn_valid && !res_valid && res_ready) begin\n                result <= {shift_reg, quotient};\n                res_valid <= 1;\n            end else if (res_ready) begin\n                res_valid <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n    parameter CYCLES_PER_DIV = 4;\n    parameter CYCLES_PER_AVERAGE = 3;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK * CYCLES_PER_DIV)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_gen #(.CYCLES_PER_AVERAGE(CYCLES_PER_AVERAGE)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MUL2_DIV_CLK(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the two clock signals\n    assign clk_div = clk_adjusted[0] | clk_adjusted[1];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_gen(\n    input               clk,\n    input               rst_n,\n    input [3:0]         count_out,\n    output reg [3:0]    clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average <= {clk_average[2:0], count_out[3]};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [3:0]         count_out,\n    output reg [3:0]    clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted <= {count_out[2:0], ~count_out[3]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n    always @(*) begin\n        dividend = {A[15:0], 16'b0}; // Prepare dividend\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    always @(*) begin\n        remainder = dividend; // Initialize remainder\n        quotient = 0; // Initialize quotient\n        for (i = 0; i < 16; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = {quotient[30:0], 1'b0};\n            end\n            remainder = {remainder[30:0], 1'b0}; // Shift remainder\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Generate the divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1;\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1;\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Perform addition\n    assign {Carry_out, Sum} = X + Y;\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.A(A0), .B(X), .C(Y[0]), .S(0));\n    add_shift AS1(.A(A1), .B(A0), .C(Y[1]), .S(1));\n    add_shift AS2(.A(A2), .B(A1), .C(Y[2]), .S(2));\n    add_shift AS3(.A(A3), .B(A2), .C(Y[3]), .S(3));\n    add_shift AS4(.A(A4), .B(A3), .C(Y[4]), .S(4));\n    add_shift AS5(.A(A5), .B(A4), .C(Y[5]), .S(5));\n    add_shift AS6(.A(A6), .B(A5), .C(Y[6]), .S(6));\n    add_shift AS7(.A(A7), .B(A6), .C(Y[7]), .S(7));\n\n    // Assign the product to the output\n    assign P = A7;\n\nendmodule\n\nmodule add_shift(A, B, C, S);\n    input [15:0] B;\n    input [15:0] C;\n    input [3:0] S;\n    output [15:0] A;\n\n    wire [15:0] shifted_B;\n\n    assign shifted_B = B << S;\n\n    always @(*) begin\n        if (C)\n            A = shifted_B + B;\n        else\n            A = shifted_B;\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiating the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\nreg [15:0] temp_dividend;\nreg [7:0] temp_divisor;\nreg [3:0] shift_count;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\n\n// Initialization\ninitial begin\n    temp_dividend = A;\n    temp_divisor = B;\n    shift_count = 0;\n    quotient = 0;\n    remainder = 0;\nend\n\n// Division algorithm\nalways @(*) begin\n    if (temp_dividend >= temp_divisor) begin\n        temp_quotient = 1;\n        temp_remainder = temp_dividend - temp_divisor;\n    end else begin\n        temp_quotient = 0;\n        temp_remainder = temp_dividend;\n    end\nend\n\n// Shift and compare\nalways @(*) begin\n    if (shift_count < 16) begin\n        temp_dividend = temp_remainder << 1;\n        temp_divisor = temp_divisor << 1;\n        shift_count = shift_count + 1;\n    end\nend\n\n// Final results\nalways @(*) begin\n    quotient = temp_quotient;\n    remainder = temp_remainder;\nend\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .counter_limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out,\n    output counter_limit\n);\n    parameter NUM_DIV = 4; // Even number that divides the input clock frequency\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_out <= 0;\n        end else begin\n            if (counter_out == (NUM_DIV / 2) - 1) begin\n                counter_out <= 0;\n            end else begin\n                counter_out <= counter_out + 1;\n            end\n        end\n    end\n\n    assign counter_limit = (counter_out == (NUM_DIV / 2) - 1);\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 0) begin\n                clk_div <= 1;\n            end else begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry wire for each submodule\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0(.A(A[7:0]), .B(B[7:0]), .Cin(Cin), .Sum(Sum[7:0]), .Cout(carry[0]));\n    adder_8bit add1(.A(A[15:8]), .B(B[15:8]), .Cin(carry[0]), .Sum(Sum[15:8]), .Cout(carry[1]));\n    adder_8bit add2(.A(A[23:16]), .B(B[23:16]), .Cin(carry[1]), .Sum(Sum[23:16]), .Cout(carry[2]));\n    adder_8bit add3(.A(A[31:24]), .B(B[31:24]), .Cin(carry[2]), .Sum(Sum[31:24]), .Cout(carry[3]));\n\n    // Output carry out\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] temp_sum; // Temporary sum to hold intermediate sum\n\n    // 8-bit addition\n    assign temp_sum = A + B + Cin;\n\n    // Output sum and carry out\n    assign Sum = temp_sum[7:0];\n    assign Cout = temp_sum[8];\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input A\n    input [7:0] B;       // 8-bit input B\n    output [7:0] D;      // 8-bit output D\n    output B_out;        // Borrow output\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;     // Sum of A and B_comp\n    wire carry;         // Carry output from the full adder\n\n    // 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit position\n    full_adder adder_inst[7:0](\n        .a(A[7:0]),\n        .b(B_comp[7:0]),\n        .carry_in(1'b0),\n        .sum(sum[7:0]),\n        .carry_out(carry)\n    );\n\n    // Assign the output\n    assign D = sum;\n    assign B_out = carry;\n\nendmodule\n\nmodule full_adder(a, b, carry_in, sum, carry_out);\n    input a, b, carry_in;\n    output sum, carry_out;\n\n    assign sum = a ^ b ^ carry_in;\n    assign carry_out = (a & b) | (carry_in & (a ^ b));\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift operations\n    assign p0_0 = X & Y;\n    assign p0_1 = X << 1 & Y;\n    assign p0_2 = X << 2 & Y;\n    assign p0_3 = X << 3 & Y;\n\n    assign p1_0 = X >> 1 & Y;\n    assign p1_1 = X >> 2 & Y;\n    assign p1_2 = X >> 3 & Y;\n    assign p1_3 = X >> 4 & Y;\n\n    assign p2_0 = X >> 2 & Y;\n    assign p2_1 = X >> 3 & Y;\n    assign p2_2 = X >> 4 & Y;\n    assign p2_3 = X >> 5 & Y;\n\n    assign p3_0 = X >> 3 & Y;\n    assign p3_1 = X >> 4 & Y;\n    assign p3_2 = X >> 5 & Y;\n    assign p3_3 = X >> 6 & Y;\n\n    // Adders\n    adder_8bit add1(.a(p0_0), .b(p0_1), .c(p0), .c_in(1'b0));\n    adder_8bit add2(.a(p0), .b(p0_2), .c(p1), .c_in(1'b0));\n    adder_8bit add3(.a(p1), .b(p1_1), .c(p2), .c_in(1'b0));\n\n    // Final addition\n    assign P = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, c_in);\n    input [7:0] a, b;\n    input c_in;\n    output [7:0] c;\n    wire c_out;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .c_in(c_in), .sum(c[0]), .c_out(c_out));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c_in(c_out), .sum(c[1]), .c_out(c_out));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c_in(c_out), .sum(c[2]), .c_out(c_out));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c_in(c_out), .sum(c[3]), .c_out(c_out));\n    full_adder fa4(.a(a[4]), .b(b[4]), .c_in(c_out), .sum(c[4]), .c_out(c_out));\n    full_adder fa5(.a(a[5]), .b(b[5]), .c_in(c_out), .sum(c[5]), .c_out(c_out));\n    full_adder fa6(.a(a[6]), .b(b[6]), .c_in(c_out), .sum(c[6]), .c_out(c_out));\n    full_adder fa7(.a(a[7]), .b(b[7]), .c_in(c_out), .sum(c[7]), .c_out(c_out));\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n    assign sum = a ^ b ^ c_in;\n    assign c_out = (a & b) | (a & c_in) | (b & c_in);\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate the adder\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op[0]),\n        .result(add_result),\n        .carry(add_carry)\n    );\n\n    // Instantiate the subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op[1]),\n        .result(sub_result),\n        .borrow(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for the result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for the carry out\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output carry\n);\n\n    assign {carry, result} = (op) ? B + A : A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output borrow\n);\n\n    assign {borrow, result} = (op) ? B - A : A - B;\n\nendmodule\n\n// AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(p0), .y(Y[1]), .p(p1));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(p1), .y(Y[2]), .p(p2));\n\n    // Assign the final product\n    assign P = {p2, p1, p0};\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_2bit adder_1(.x(p0), .y(x[1]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_1bit adder_1(.x(p0), .y(x[2]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    // Add the inputs\n    assign p = x + (y << 4);\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for data path multiplexing\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from subtraction\n    wire [15:0] Diff_16;  // 16-bit difference from subtraction\n\n    // Instantiate 16-bit subtractors\n    sub_16bit S1 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .B_out(B_out_16),\n        .Diff(Diff_16)\n    );\n\n    sub_16bit S2 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine results\n    assign Diff = {Diff_16, B_out_16};\nendmodule\n\nmodule sub_16bit(A, B, B_out, Diff);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output B_out;         // Borrow-out output\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out from subtraction\n    wire [7:0] Diff_8;    // 8-bit difference from subtraction\n\n    // Instantiate 8-bit subtractors\n    sub_8bit S1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .B_out(B_out_8),\n        .Diff(Diff_8)\n    );\n\n    sub_8bit S2 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine results\n    assign Diff = {Diff_8, B_out_8};\nendmodule\n\nmodule sub_8bit(A, B, B_out, Diff);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output B_out;        // Borrow-out output\n    output [7:0] Diff;   // 8-bit output representing the difference of A and B\n\n    wire [3:0] B_out_4; // 4-bit borrow-out from subtraction\n    wire [3:0] Diff_4;  // 4-bit difference from subtraction\n\n    // Instantiate 4-bit subtractors\n    sub_4bit S1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .B_out(B_out_4),\n        .Diff(Diff_4)\n    );\n\n    sub_4bit S2 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine results\n    assign Diff = {Diff_4, B_out_4};\nendmodule\n\nmodule sub_4bit(A, B, B_out, Diff);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output B_out;        // Borrow-out output\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n\n    wire [1:0] B_out_2; // 2-bit borrow-out from subtraction\n    wire [1:0] Diff_2;  // 2-bit difference from subtraction\n\n    // Instantiate 2-bit subtractors\n    sub_2bit S1 (\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .B_out(B_out_2),\n        .Diff(Diff_2)\n    );\n\n    sub_2bit S2 (\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    // Combine results\n    assign Diff = {Diff_2, B_out_2};\nendmodule\n\nmodule sub_2bit(A, B, B_out, Diff);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output B_out;        // Borrow-out output\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n\n    assign {B_out, Diff} = A - B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Instantiate the submodules\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                 hold3;\n\nendmodule\n\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical module\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical module\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    addu addu(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    addu addu(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    and andu(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow), .flag(and_flag));\n    or oru(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow), .flag(or_flag));\n    xor xoru(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow), .flag(xor_flag));\n    nor noru(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow), .flag(nor_flag));\n    slt sltu(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow), .flag(slt_flag));\n    sll srl(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow), .flag(sll_flag));\n    srl sra(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow), .flag(srl_flag));\n    sllv srlv(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow), .flag(sllv_flag));\n    srlv srav(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow), .flag(srlv_flag));\n    sra srau(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow), .flag(sra_flag));\n    lui luiu(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow), .flag(lui_flag));\n\n    // Select result based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow || sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_flag : (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) || ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\n    assign flag = 1'b0;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output zero\n);\n    assign zero = (result == 4'b0000);\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each 8-bit section\n    comp8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_hi)\n    );\n\n    // Combine results for final output\n    assign equal = equal_lo & equal_hi;\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C(1'b0),\n        .D(D[16:1]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C(b_out[1:1]),\n        .D(D[12:1]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C(b_out[2:2]),\n        .D(D[8:1]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C(b_out[3:3]),\n        .D(D[4:1]),\n        .B_out(b_out[4:4])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[4:1];\nendmodule\n\nmodule sub4(A, B, C, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C;              // Carry-in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 3-bit borrow-out\n\n    // Instantiate 3-bit full subtractors\n    sub3 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C(C),\n        .D(D[4:1]),\n        .B_out(b_out[1:1])\n    );\n\n    sub3 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C(b_out[1:1]),\n        .D(D[2:1]),\n        .B_out(b_out[2:2])\n    );\n\n    sub3 sub3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C(b_out[2:2]),\n        .D(D[1:1]),\n        .B_out(b_out[3:3])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[3:1];\nendmodule\n\nmodule sub3(A, B, C, D, B_out);\n    input [3:1] A;        // 3-bit input A\n    input [3:1] B;        // 3-bit input B\n    input C;              // Carry-in\n    output [3:1] D;       // 3-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .C(C),\n        .D(D[3:1]),\n        .B_out(b_out[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C(b_out[1:1]),\n        .D(D[2:1]),\n        .B_out(b_out[2:2])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[2:1];\nendmodule\n\nmodule sub2(A, B, C, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C;              // Carry-in\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;            // 1-bit borrow-out\n\n    // Instantiate 1-bit full subtractor\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C(C),\n        .D(D[2:1]),\n        .B_out(b_out)\n    );\n\n    // Output borrow-out\n    assign B_out = b_out;\nendmodule\n\nmodule sub1(A, B, C, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    input C;              // Carry-in\n    output [1:1] D;       // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    // Instantiate 1-bit full subtractor\n    assign {B_out, D} = A - B - C;\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate the arithmetic operation modules\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select the operation based on the opcode input\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n            valid <= (opcode == 2'b11) ? 1 : 0;\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction module instantiation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0);\n    assign A_less = (diff != 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff, // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire C16,C8,C4,C2;\n\n    CLA16 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA16 CLA2 (.A(A[16:1]), .B(B[16:1]), .Cin(C16), .S(S[16:1]), .Cout(C8));\n    CLA16 CLA3 (.A(A[8:1]), .B(B[8:1]), .Cin(C8), .S(S[8:1]), .Cout(C4));\n    CLA16 CLA4 (.A(A[8:1]), .B(B[8:1]), .Cin(C4), .S(S[8:1]), .Cout(C2));\n    CLA16 CLA5 (.A(A[4:1]), .B(B[4:1]), .Cin(C2), .S(S[4:1]), .Cout(C16));\n    CLA16 CLA6 (.A(A[4:1]), .B(B[4:1]), .Cin(C16), .S(S[4:1]), .Cout(C8));\n    CLA16 CLA7 (.A(A[4:1]), .B(B[4:1]), .Cin(C8), .S(S[4:1]), .Cout(C4));\n    CLA16 CLA8 (.A(A[4:1]), .B(B[4:1]), .Cin(C4), .S(S[4:1]), .Cout(C2));\n    CLA16 CLA9 (.A(A[2:1]), .B(B[2:1]), .Cin(C2), .S(S[2:1]), .Cout(C16));\n    CLA16 CLA10(.A(A[2:1]), .B(B[2:1]), .Cin(C16), .S(S[2:1]), .Cout(C8));\n    CLA16 CLA11(.A(A[2:1]), .B(B[2:1]), .Cin(C8), .S(S[2:1]), .Cout(C4));\n    CLA16 CLA12(.A(A[2:1]), .B(B[2:1]), .Cin(C4), .S(S[2:1]), .Cout(C2));\n    CLA16 CLA13(.A(A[1:1]), .B(B[1:1]), .Cin(C2), .S(S[1:1]), .Cout(C16));\n    CLA16 CLA14(.A(A[1:1]), .B(B[1:1]), .Cin(C16), .S(S[1:1]), .Cout(C8));\n    CLA16 CLA15(.A(A[1:1]), .B(B[1:1]), .Cin(C8), .S(S[1:1]), .Cout(C4));\n    CLA16 CLA16(.A(A[1:1]), .B(B[1:1]), .Cin(C4), .S(S[1:1]), .Cout(C2));\n    assign C32 = C2;\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns/1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Instantiate 4-bit ripple carry adder for first 4 bits\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n// Instantiate 4-bit carry select adder slices for next 4 bits\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n// Final carry out is the last carry of the last carry select adder slice\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Ripple carry adder logic\nassign sum = a ^ b ^ cin;\nassign carry = (a & b) | (a & cin) | (b & cin);\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Instantiate 2 ripple carry adders for each 4-bit section\nripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(sum), .cout(carry[0]));\nripple_carry_adder rca2(.a(a), .b(b), .cin(carry[0]), .sum(sum), .cout(carry[1]));\n\n// Multiplexer to select sum and carry based on cin\nassign sum = (cin) ? (a ^ b) : (a ^ b ^ cin);\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\n    // Assign the carry out of the last 8-bit adder\n    assign Co = Co_8;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for the first 4 bits\n    add4_inst1 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for the last 4 bits\n    add4_inst2 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4_inst1 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for the first 2 bits\n    add2_inst1 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for the last 2 bits\n    add2_inst2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2_inst1 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for the first bit\n    add1_inst1 add1_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co)\n    );\n\n    // 1-bit adder for the last bit\n    add1_inst2 add1_inst2 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co),\n        .y(y[1]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add1_inst1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\n\nendmodule\n\nmodule add1_inst2 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for the first 4 bits\n    add4_inst1 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for the last 4 bits\n    add4_inst2 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4_inst2 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for the first 2 bits\n    add2_inst1 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for the last 2 bits\n    add2_inst2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift;    // Shift count register\n    wire [31:0] product; // Product register\n    wire [15:0] m;       // Multiplier register\n    wire [15:0] a;       // Multiplicand register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(a),\n        .m(m)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(a),\n        .m(m),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start;\n\nendmodule\n\n// Submodule for Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift // Shift count register\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n        end else if (start) begin\n            shift <= 5;\n        end else begin\n            shift <= shift + 1;\n        end\n    end\nendmodule\n\n// Submodule for Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Multiplicand input.\n    input [15:0] m      // Multiplier input.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m <= 0;\n            a <= 0;\n        end else if (start) begin\n            m <= bin;\n            a <= ain;\n        end\n    end\nendmodule\n\n// Submodule for Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Multiplicand input.\n    input [15:0] m,     // Multiplier input.\n    output reg [31:0] product // Product register.\n);\n    reg [15:0] shifted_m;\n    reg [31:0] acc;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n            acc <= 0;\n            shifted_m <= 0;\n        end else if (start) begin\n            shifted_m <= m;\n            acc <= 0;\n        end else begin\n            if (a[shift]) begin\n                acc <= acc + shifted_m;\n            end\n            shifted_m <= shifted_m << 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            product <= acc;\n        end\n    end\nendmodule"}
