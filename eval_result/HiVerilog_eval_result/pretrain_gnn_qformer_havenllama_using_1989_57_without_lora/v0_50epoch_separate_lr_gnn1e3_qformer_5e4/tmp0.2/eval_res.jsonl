{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output selection based on mode\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0;\n    wire gt1, lt1, eq1;\n    wire gt2, lt2, eq2;\n    wire gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? add_result : sub_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0, gt1, lt1, eq1, gt2, lt2, eq2, gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire [3:0] gt_temp, lt_temp, eq_temp;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_temp[3]), .lt(lt_temp[3]), .eq(eq_temp[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_temp[2]), .lt(lt_temp[2]), .eq(eq_temp[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_temp[1]), .lt(lt_temp[1]), .eq(eq_temp[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_temp[0]), .lt(lt_temp[0]), .eq(eq_temp[0]));\n\n    assign gt = (gt_temp[3] & gt_temp[2] & gt_temp[1] & gt_temp[0]) | (gt_temp[3] & gt_temp[2] & gt_temp[1] & ~gt_temp[0]) | (gt_temp[3] & gt_temp[2] & ~gt_temp[1] & ~gt_temp[0]) | (gt_temp[3] & ~gt_temp[2] & ~gt_temp[1] & ~gt_temp[0]) | (~gt_temp[3] & ~gt_temp[2] & ~gt_temp[1] & gt_temp[0]);\n    assign lt = (lt_temp[3] & lt_temp[2] & lt_temp[1] & lt_temp[0]) | (lt_temp[3] & lt_temp[2] & lt_temp[1] & ~lt_temp[0]) | (lt_temp[3] & lt_temp[2] & ~lt_temp[1] & ~lt_temp[0]) | (lt_temp[3] & ~lt_temp[2] & ~lt_temp[1] & ~lt_temp[0]) | (~lt_temp[3] & ~lt_temp[2] & ~lt_temp[1] & lt_temp[0]);\n    assign eq = (eq_temp[3] & eq_temp[2] & eq_temp[1] & eq_temp[0]) | (eq_temp[3] & eq_temp[2] & eq_temp[1] & ~eq_temp[0]) | (eq_temp[3] & eq_temp[2] & ~eq_temp[1] & ~eq_temp[0]) | (eq_temp[3] & ~eq_temp[2] & ~eq_temp[1] & ~eq_temp[0]) | (~eq_temp[3] & ~eq_temp[2] & ~eq_temp[1] & eq_temp[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3;\n    wire lt0, lt1, lt2, lt3;\n    wire eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder and subtractor modules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0;\n    wire gt1, lt1, eq1;\n    wire gt2, lt2, eq2;\n    wire gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output selection based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3, lt0, lt1, lt2, lt3, eq0, eq1, eq2, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires for adder and subtractor\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output based on mode\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0, gt1, lt1, eq1, gt2, lt2, eq2, gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 || gt1 || gt2 || gt3;\n    assign lt = lt0 || lt1 || lt2 || lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires for addition and subtraction\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output logic based on mode\nassign result = (mode == 0) ? add_result : sub_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [7:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output the result based on the mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\n// 8-bit multiplier module\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Selecting the result based on mode\nassign result = (mode) ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & ~gt_bits[0]) | (gt_bits[3] & gt_bits[2] & ~gt_bits[1] & ~gt_bits[0]) | (gt_bits[3] & ~gt_bits[2] & ~gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (~gt_bits[3] & gt_bits[2] & gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & gt_bits[2] & ~gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & ~gt_bits[2] & gt_bits[1] & gt_bits[0]) | (~gt_bits[3] & ~gt_bits[2] & gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & ~gt_bits[2] & ~gt_bits[1] & ~gt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & ~lt_bits[0]) | (lt_bits[3] & lt_bits[2] & ~lt_bits[1] & ~lt_bits[0]) | (lt_bits[3] & ~lt_bits[2] & ~lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (~lt_bits[3] & lt_bits[2] & lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & lt_bits[2] & ~lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & ~lt_bits[2] & lt_bits[1] & lt_bits[0]) | (~lt_bits[3] & ~lt_bits[2] & lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & ~lt_bits[2] & ~lt_bits[1] & ~lt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]) | (eq_bits[3] & eq_bits[2] & eq_bits[1] & ~eq_bits[0]) | (eq_bits[3] & eq_bits[2] & ~eq_bits[1] & ~eq_bits[0]) | (eq_bits[3] & ~eq_bits[2] & ~eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]) | (~eq_bits[3] & eq_bits[2] & eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & eq_bits[2] & ~eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & ~eq_bits[2] & eq_bits[1] & eq_bits[0]) | (~eq_bits[3] & ~eq_bits[2] & eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & ~eq_bits[2] & ~eq_bits[1] & ~eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [7:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\n// Output the result based on the mode\nassign result = (mode == 0) ? add_result : sub_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0;\n    wire gt1, lt1, eq1;\n    wire gt2, lt2, eq2;\n    wire gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\n// 8-bit multiplier module\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .op1(op1),\n    .op2(op2),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .op1(op1),\n    .op2(op2),\n    .result(subtractor_result)\n);\n\n// Output logic\nassign result = (mode == 0) ? adder_result : subtractor_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nwire [7:0] prod0, prod1, prod2, prod3;\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod0)\n);\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod1)\n);\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod2)\n);\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod3)\n);\n\n// Combine the 4 products\nassign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod_8;\n\n    // Instantiate 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod_8)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod_8)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod_8)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod_8)\n    );\n\n    // Concatenate the 8-bit products\n    assign prod = {prod_8, prod_8};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = gt_bits[0] & gt_bits[1] & gt_bits[2] & gt_bits[3];\n    assign lt = lt_bits[0] & lt_bits[1] & lt_bits[2] & lt_bits[3];\n    assign eq = eq_bits[0] & eq_bits[1] & eq_bits[2] & eq_bits[3];\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .result(multiplication_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, lt0, eq0, gt1, lt1, eq1, gt2, lt2, eq2, gt3, lt3, eq3;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt0), .lt(lt0), .eq(eq0));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt3), .lt(lt3), .eq(eq3));\n\n    assign gt = gt0 && gt1 && gt2 && gt3;\n    assign lt = lt0 && lt1 && lt2 && lt3;\n    assign eq = eq0 && eq1 && eq2 && eq3;\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider submodule\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning the results to the output ports\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider submodule\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning the results to the output ports\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [7:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning the results to outputs\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider submodule\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider submodule\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & ~gt_bits[0]) | (gt_bits[3] & gt_bits[2] & ~gt_bits[1] & ~gt_bits[0]) | (gt_bits[3] & ~gt_bits[2] & ~gt_bits[1] & ~gt_bits[0]) | (~gt_bits[3] & ~gt_bits[2] & ~gt_bits[1] & gt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & ~lt_bits[0]) | (lt_bits[3] & lt_bits[2] & ~lt_bits[1] & ~lt_bits[0]) | (lt_bits[3] & ~lt_bits[2] & ~lt_bits[1] & ~lt_bits[0]) | (~lt_bits[3] & ~lt_bits[2] & ~lt_bits[1] & lt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]) | (eq_bits[3] & eq_bits[2] & eq_bits[1] & ~eq_bits[0]) | (eq_bits[3] & eq_bits[2] & ~eq_bits[1] & ~eq_bits[0]) | (eq_bits[3] & ~eq_bits[2] & ~eq_bits[1] & ~eq_bits[0]) | (~eq_bits[3] & ~eq_bits[2] & ~eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = A > B;\n    assign lt = A < B;\n    assign eq = A == B;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the 4 products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .product(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(multiplication_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 4 8-bit multipliers\nwire [7:0] prod0, prod1, prod2, prod3;\nmult8 mult8_inst1 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod0)\n);\nmult8 mult8_inst2 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod1)\n);\nmult8 mult8_inst3 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod2)\n);\nmult8 mult8_inst4 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod3)\n);\n\n// Combine the products\nassign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply the two inputs\nassign prod = x * y;\n\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    wire [3:0] gt_bits, lt_bits, eq_bits;\n\n    bit_compare bc0 (.A(A[3]), .B(B[3]), .gt(gt_bits[3]), .lt(lt_bits[3]), .eq(eq_bits[3]));\n    bit_compare bc1 (.A(A[2]), .B(B[2]), .gt(gt_bits[2]), .lt(lt_bits[2]), .eq(eq_bits[2]));\n    bit_compare bc2 (.A(A[1]), .B(B[1]), .gt(gt_bits[1]), .lt(lt_bits[1]), .eq(eq_bits[1]));\n    bit_compare bc3 (.A(A[0]), .B(B[0]), .gt(gt_bits[0]), .lt(lt_bits[0]), .eq(eq_bits[0]));\n\n    assign gt = (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]) | (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]);\n    assign lt = (lt_bits[3] & lt_bits[2] & lt_bits[1] & lt_bits[0]) | (gt_bits[3] & gt_bits[2] & gt_bits[1] & gt_bits[0]);\n    assign eq = (eq_bits[3] & eq_bits[2] & eq_bits[1] & eq_bits[0]);\nendmodule\n\nmodule bit_compare (A, B, gt, lt, eq);\n    input A, B;\n    output gt, lt, eq;\n\n    assign gt = (A > B);\n    assign lt = (A < B);\n    assign eq = (A == B);\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for division and subtraction\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider submodule\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning the results to the output ports\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider submodule\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n// Instantiate 8-bit multipliers\nmult8 mult8_inst1 (\n    .x(x[15:8]),\n    .y(y[15:8]),\n    .prod(prod[15:8])\n);\n\nmult8 mult8_inst2 (\n    .x(x[7:0]),\n    .y(y[15:8]),\n    .prod(prod[7:0])\n);\n\nmult8 mult8_inst3 (\n    .x(x[15:8]),\n    .y(y[7:0]),\n    .prod(prod[23:16])\n);\n\nmult8 mult8_inst4 (\n    .x(x[7:0]),\n    .y(y[7:0]),\n    .prod(prod[31:24])\n);\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n\n// Multiply 8-bit numbers\nassign prod = x * y;\n\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] multiplication_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .product(multiplication_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(multiplication_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_carry;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .carry(sub_carry));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_carry;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a - b;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [7:0] prod0, prod1, prod2, prod3;\n\n    // Instantiate 4 8-bit multipliers\n    mult8 mult8_inst1 (\n        .x(x[7:0]),\n        .y(y[7:0]),\n        .prod(prod0)\n    );\n\n    mult8 mult8_inst2 (\n        .x(x[15:8]),\n        .y(y[7:0]),\n        .prod(prod1)\n    );\n\n    mult8 mult8_inst3 (\n        .x(x[7:0]),\n        .y(y[15:8]),\n        .prod(prod2)\n    );\n\n    mult8 mult8_inst4 (\n        .x(x[15:8]),\n        .y(y[15:8]),\n        .prod(prod3)\n    );\n\n    // Combine the products\n    assign prod = {prod3, prod2, prod1, prod0};\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] div_result;\nwire [31:0] sub_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(div_result),\n    .y(z),\n    .difference(sub_result)\n);\n\n// Assigning outputs\nassign quotient = div_result;\nassign difference = sub_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .mult_result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .mult_result(mult_result),\n    .current_value(c)\n);\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] mult_result\n);\n    assign mult_result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [63:0] mult_result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + mult_result[31:0];\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[7], din[6], din[5], din[4], din[3], din[2], din[1], din[0]};\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_carry;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .carry(sub_carry));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    // Select carry based on op signal\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_carry;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetching module for registers\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Instantiating the divider submodule\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Assigning outputs\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider submodule\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires\nwire [31:0] quotient_w;\nwire [31:0] difference_w;\n\n// Submodule instances\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(quotient_w)\n);\n\nsubtractor u_subtractor (\n    .x(quotient_w),\n    .y(z),\n    .difference(difference_w)\n);\n\n// Output assignment\nassign quotient = quotient_w;\nassign difference = difference_w;\n\nendmodule\n\n// Divider submodule\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] difference\n);\n    assign difference = x - y;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_carry;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .carry(sub_carry));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_carry;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_din;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_din)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_din),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch_reg ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch_ram ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // Assign outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad12;\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\n\nendmodule\n\n// Instruction fetching module for registers\nmodule instruction_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction fetching module for RAM/ROM\nmodule instruction_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Select the operation based on the control signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] stage1_out;\n    wire [7:0] stage2_out;\n\n    // Instantiate the bit reversal module for the first stage\n    bit_reverse br1 (\n        .din(din),\n        .dout(stage1_out)\n    );\n\n    // Instantiate the bit reversal module for the second stage\n    bit_reverse br2 (\n        .din(stage1_out),\n        .dout(stage2_out)\n    );\n\n    // Assign the output to the final output\n    assign dout = stage2_out;\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum_result;\nwire [31:0] diff_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff_result)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Selecting the operation based on the selector input\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum_result;\n        2'b01: result <= diff_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    // Select carry or borrow based on op signal\n    assign carry_borrow = (op == 2'b11) ? carry_sub : carry_add;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] reversed_data;\n\n    // Instantiate two bit reversal modules\n    bit_reverse br1 (\n        .din(din),\n        .dout(reversed_data)\n    );\n\n    bit_reverse br2 (\n        .din(reversed_data),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register input\n    reg [2:0] ins_reg1;\n    reg [4:0] ad1_reg1;\n    reg [7:0] ad2_reg1;\n\n    // Instruction register for RAM/ROM input\n    reg [2:0] ins_reg2;\n    reg [4:0] ad1_reg2;\n    reg [7:0] ad2_reg2;\n\n    // Instance of the instruction register for register input\n    instruction_register ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction register for RAM/ROM input\n    instruction_register ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assigning the outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_reg1;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_reg1;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_reg1;\n\n    // Assigning the outputs based on the fetch signal\n    assign ins = (fetch == 2'b10) ? ins_p2 : ins_reg2;\n    assign ad1 = (fetch == 2'b10) ? ad1_p2 : ad1_reg2;\n    assign ad2 = (fetch == 2'b10) ? ad2_p2 : ad2_reg2;\n\n    // Updating the registers on the rising edge of the clock\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 0;\n            ad1_reg1 <= 0;\n            ad2_reg1 <= 0;\n            ins_reg2 <= 0;\n            ad1_reg2 <= 0;\n            ad2_reg2 <= 0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= ins_p1;\n                ad1_reg1 <= ad1_p1;\n                ad2_reg1 <= ad2_p1;\n            end else if (fetch == 2'b10) begin\n                ins_reg2 <= ins_p2;\n                ad1_reg2 <= ad1_p2;\n                ad2_reg2 <= ad2_p2;\n            end\n        end\n    end\n\nendmodule\n\nmodule instruction_register (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 0;\n            ad1_reg <= 0;\n            ad2_reg <= 0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data[7:0];\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule outputs\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Operation selection and output assignment\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    // Select carry or borrow based on operation\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] sum_temp;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(sum_temp)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = sum_temp;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the first instruction submodule\n    instruction_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the second instruction submodule\n    instruction_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Combining the outputs of the submodules\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction submodule for register source\nmodule instruction_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction submodule for RAM/ROM source\nmodule instruction_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] sum_temp;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(sum_temp)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = sum_temp;\n        end else begin\n            sum = 8'b0;\n        end\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic to select output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selector logic\nalways @(*) begin\n    case(op_sel)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate submodule\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate submodule\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic to decide output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register input\n    reg [2:0] ins_reg1;\n    reg [4:0] ad1_reg1;\n    reg [7:0] ad2_reg1;\n\n    // Instruction register for RAM/ROM input\n    reg [2:0] ins_reg2;\n    reg [4:0] ad1_reg2;\n    reg [7:0] ad2_reg2;\n\n    // Instance of the submodule for register input\n    instruction_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the submodule for RAM/ROM input\n    instruction_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assigning the outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\n    // Registers for storing the instructions\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 0;\n            ad1_reg1 <= 0;\n            ad2_reg1 <= 0;\n            ins_reg2 <= 0;\n            ad1_reg2 <= 0;\n            ad2_reg2 <= 0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= ins_p1;\n                ad1_reg1 <= ad1_p1;\n                ad2_reg1 <= ad2_p1;\n            end else if (fetch == 2'b10) begin\n                ins_reg2 <= ins_p2;\n                ad1_reg2 <= ad1_p2;\n                ad2_reg2 <= ad2_p2;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for register input\nmodule instruction_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Submodule for RAM/ROM input\nmodule instruction_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\nwire [7:0] result;\n\n// Instantiate the 8-bit adder\nmy_adder8 adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\n// Control logic to select output\nalways @(*) begin\n    if (ctrl) begin\n        sum = result;\n    end else begin\n        sum = 0;\n    end\nend\n\nendmodule\n\n// 8-bit adder module\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire and_carry, or_carry, add_carry, sub_carry;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result), .carry(and_carry));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result), .carry(or_carry));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .carry(sub_carry));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b00) ? and_carry :\n                          (op == 2'b01) ? or_carry :\n                          (op == 2'b10) ? add_carry :\n                          sub_carry;\nendmodule\n\nmodule bitwise_and(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic to determine output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_out, borrow_out;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_out));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(borrow_out));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_out : borrow_out;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .result(result)\n    );\n\n    // Control logic to determine output\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] result\n);\n    assign result = a + b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching submodule for register\n    inst_fetch_reg ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching submodule for RAM/ROM\n    inst_fetch_ram ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assign the outputs based on the fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetching submodule for register\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction fetching submodule for RAM/ROM\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule connections\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection\nalways @(*) begin\n    case(op_sel)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 32'b0; // Default case\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate submodule\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate submodule\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] result;\n\n    // Instantiate the 8-bit adder\n    my_adder8 adder (\n        .a(a),\n        .b(b),\n        .sum(result)\n    );\n\n    // Control logic\n    always @(*) begin\n        if (ctrl) begin\n            sum = result;\n        end else begin\n            sum = 8'b0;\n        end\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result, add_result, sub_result;\n    wire carry_add, carry_sub;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(carry_add));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(carry_sub));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? carry_add : carry_sub;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetching module for registers\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule\n\n// Instruction fetching module for RAM/ROM\nmodule instruction_fetch (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_borrow;\n\n    // Instantiate submodules\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n\n    // Select operation based on op signal\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result : sub_result;\n\n    // Carry/Borrow output\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow;\n    assign {borrow, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Submodule instances\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\n// Operation selection logic\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= u_adder.sum;\n        2'b01: result <= u_subtractor.diff;\n        2'b10: result <= u_and.out;\n        2'b11: result <= u_or.out;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodule definitions\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the 25% PWM module\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    // Instantiate the 50% PWM module\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    // Instantiate the 75% PWM module\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// 25% PWM module\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// 50% PWM module\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// 75% PWM module\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 3750000; // 37.5MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    instruction_fetch_reg ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    instruction_fetch_ram ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule instruction_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule instruction_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire add_carry, sub_borrow;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry_out(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .borrow_out(sub_borrow));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_borrow;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry_out;\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow_out);\n    input [3:0] a, b;\n    output [3:0] result;\n    output borrow_out;\n    assign {borrow_out, result} = a - b;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires to hold results\nwire [31:0] sum_result;\nwire [31:0] diff_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum_result;\n        2'b01: result <= diff_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n\n    wire [3:0] and_result, or_result;\n    wire [3:0] add_result, sub_result;\n    wire add_carry, sub_carry;\n\n    bitwise_and and_unit(.a(a), .b(b), .result(and_result));\n    bitwise_or or_unit(.a(a), .b(b), .result(or_result));\n    adder_4bit add_unit(.a(a), .b(b), .result(add_result), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .result(sub_result), .carry(sub_carry));\n\n    assign result = (op == 2'b00) ? and_result :\n                    (op == 2'b01) ? or_result :\n                    (op == 2'b10) ? add_result :\n                    sub_result;\n\n    assign carry_borrow = (op == 2'b10) ? add_carry : sub_carry;\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input [3:0] a, b;\n    output [3:0] result;\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, result, carry);\n    input [3:0] a, b;\n    output [3:0] result;\n    output carry;\n    assign {carry, result} = a - b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% duty cycle PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% duty cycle PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% duty cycle PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Submodule instances\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(result)\n);\n\n// Operation selector logic\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= u_adder.sum;\n        2'b01: result <= u_subtractor.diff;\n        2'b10: result <= u_and.out;\n        2'b11: result <= u_or.out;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Submodule implementations\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching submodule for register\n    inst_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching submodule for RAM/ROM\n    inst_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Instruction fetching module for register\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Instruction fetching module for RAM/ROM\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n\n    wire [2:0] code_0, code_1, code_2, code_3, code_4, code_5, code_6, code_7;\n\n    check_bit cb0(.in(in[7]), .code(code_0), .valid(valid));\n    check_bit cb1(.in(in[6]), .code(code_1), .valid(valid));\n    check_bit cb2(.in(in[5]), .code(code_2), .valid(valid));\n    check_bit cb3(.in(in[4]), .code(code_3), .valid(valid));\n    check_bit cb4(.in(in[3]), .code(code_4), .valid(valid));\n    check_bit cb5(.in(in[2]), .code(code_5), .valid(valid));\n    check_bit cb6(.in(in[1]), .code(code_6), .valid(valid));\n    check_bit cb7(.in(in[0]), .code(code_7), .valid(valid));\n\n    assign code = (code_7 > code_6) ? (code_7 > code_5) ? (code_7 > code_4) ? (code_7 > code_3) ? (code_7 > code_2) ? (code_7 > code_1) ? 7 : 6 : 5 : 4 : 3 : 2 : 1 : 0;\nendmodule\n\nmodule check_bit(in, code, valid);\n    input in;\n    output [1:0] code;\n    output valid;\n\n    assign code = in ? 1 : 0;\n    assign valid = in;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Operation selection and output\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25 pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50 pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75 pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 0;\n            PWM_out <= 1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 0;\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 0;\n            PWM_out <= 1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 0;\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else if (counter >= THRESHOLD) begin\n            counter <= 0;\n            PWM_out <= 1;\n        end else begin\n            counter <= counter + 1;\n            PWM_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .code(code_temp[2]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb6(.in(in[6]), .code(code_temp[1]), .highest(code_temp[0]), .valid(code_temp[2]));\n    check_bit cb5(.in(in[5]), .code(code_temp[0]), .highest(1'b0), .valid(code_temp[2]));\n    check_bit cb4(.in(in[4]), .code(code_temp[2]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .code(code_temp[1]), .highest(code_temp[0]), .valid(code_temp[2]));\n    check_bit cb2(.in(in[2]), .code(code_temp[0]), .highest(1'b0), .valid(code_temp[2]));\n    check_bit cb1(.in(in[1]), .code(code_temp[2]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .code(code_temp[1]), .highest(code_temp[0]), .valid(code_temp[2]));\n\n    // Assign output code and valid signal\n    assign code = code_temp;\n    assign valid = |code_temp;\nendmodule\n\nmodule check_bit(in, code, highest, valid);\n    input in;\n    output reg code;\n    output reg highest;\n    output reg valid;\n\n    always @(*) begin\n        if (in) begin\n            code = 1'b1;\n            highest = 1'b1;\n            valid = 1'b1;\n        end else if (highest) begin\n            code = 1'b0;\n            highest = 1'b0;\n            valid = 1'b1;\n        end else begin\n            code = 1'b0;\n            highest = 1'b0;\n            valid = 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register fetch\n    instruction_p1 ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM fetch\n    instruction_p2 ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Instruction register logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            case (fetch)\n                2'b01: begin\n                    ins <= ins_p1;\n                    ad1 <= ad1_p1;\n                    ad2 <= ad2_p1;\n                end\n                2'b10: begin\n                    ins <= ins_p2;\n                    ad1 <= ad1_p2;\n                    ad2 <= ad2_p2;\n                end\n                default: begin\n                    ins <= ins;\n                    ad1 <= ad1;\n                    ad2 <= ad2;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for register fetch\nmodule instruction_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\n// Submodule for RAM/ROM fetch\nmodule instruction_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodules\nwire [31:0] sum_result;\nwire [31:0] diff_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff_result)\n);\n\n// Instantiating the AND submodule\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR submodule\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Selecting the operation based on the selector input\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= sum_result;\n        2'b01: result <= diff_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit modules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Combine the output of each check_bit module\n    assign code = code_temp;\n    assign valid = |code_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !valid;\n    assign valid = valid | in;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1_m (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2_m (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = fetch[0] ? ins_p1 : ins_p2;\n    assign ad1 = fetch[0] ? ad1_p1 : ad1_p2;\n    assign ad2 = fetch[0] ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule outputs\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating the submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Operation selection\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= adder_result;\n        2'b01: result <= subtractor_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit modules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = |in;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    reg highest_temp;\n    reg valid_temp;\n\n    always @(*) begin\n        if (in) begin\n            highest_temp = 1;\n            valid_temp = 1;\n        end else begin\n            highest_temp = 0;\n            valid_temp = 0;\n        end\n    end\n\n    assign highest = highest_temp;\n    assign valid = valid_temp;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest_bit;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest_bit(highest_bit[1]), .valid(valid));\n\n    // Assign the highest bit to the output code\n    assign code = highest_bit;\n\nendmodule\n\nmodule check_bit(in, highest_bit, valid);\n    input in;\n    output highest_bit;\n    output valid;\n\n    wire highest_bit_temp;\n\n    assign highest_bit_temp = (in && !highest_bit);\n    assign highest_bit = highest_bit_temp;\n    assign valid = highest_bit_temp || valid;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n// Intermediate wires for submodule outputs\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiating submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Operation selector logic\nalways @(*) begin\n    case(op_sel)\n        2'b00: result = adder_result;\n        2'b01: result = subtractor_result;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\n// AND gate module\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\n// OR gate module\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    reg [2:0] ins_reg1;\n    reg [4:0] ad1_reg1;\n    reg [7:0] ad2_reg1;\n\n    // Instruction register for RAM/ROM source\n    reg [2:0] ins_reg2;\n    reg [4:0] ad1_reg2;\n    reg [7:0] ad2_reg2;\n\n    // Instance of the instruction register for register source\n    instruction_register ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction register for RAM/ROM source\n    instruction_register ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Assigning the values from the submodules\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_reg1;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_reg1;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_reg1;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 0;\n            ad1_reg1 <= 0;\n            ad2_reg1 <= 0;\n            ins_reg2 <= 0;\n            ad1_reg2 <= 0;\n            ad2_reg2 <= 0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= ins_p1;\n                ad1_reg1 <= ad1_p1;\n                ad2_reg1 <= ad2_p1;\n            end else if (fetch == 2'b10) begin\n                ins_reg2 <= ins_p2;\n                ad1_reg2 <= ad1_p2;\n                ad2_reg2 <= ad2_p2;\n            end\n        end\n    end\nendmodule\n\nmodule instruction_register (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation result based on the op_sel signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the 25% PWM module\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    // Instantiate the 50% PWM module\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    // Instantiate the 75% PWM module\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// 25% PWM module\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// 50% PWM module\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// 75% PWM module\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n    parameter THRESHOLD = 37500000; // 37.5MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n\n    wire [2:0] code_0, code_1, code_2, code_3, code_4, code_5, code_6, code_7;\n\n    check_bit cb0(.in(in[7]), .code(code_0), .valid(valid));\n    check_bit cb1(.in(in[6]), .code(code_1), .valid(valid));\n    check_bit cb2(.in(in[5]), .code(code_2), .valid(valid));\n    check_bit cb3(.in(in[4]), .code(code_3), .valid(valid));\n    check_bit cb4(.in(in[3]), .code(code_4), .valid(valid));\n    check_bit cb5(.in(in[2]), .code(code_5), .valid(valid));\n    check_bit cb6(.in(in[1]), .code(code_6), .valid(valid));\n    check_bit cb7(.in(in[0]), .code(code_7), .valid(valid));\n\n    assign code = (code_7 > code_6) ? code_7 : code_6;\n    assign code = (code_6 > code_5) ? code_6 : code_5;\n    assign code = (code_5 > code_4) ? code_5 : code_4;\n    assign code = (code_4 > code_3) ? code_4 : code_3;\n    assign code = (code_3 > code_2) ? code_3 : code_2;\n    assign code = (code_2 > code_1) ? code_2 : code_1;\n    assign code = (code_1 > code_0) ? code_1 : code_0;\n\nendmodule\n\nmodule check_bit(in, code, valid);\n    input in;\n    output [2:0] code;\n    output valid;\n\n    wire [2:0] code_0, code_1;\n\n    assign code_0 = (in) ? 3'b100 : 3'b000;\n    assign code_1 = (in) ? 3'b010 : 3'b000;\n\n    assign code = (code_1 > code_0) ? code_1 : code_0;\n    assign valid = (in) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel == 0) ? add_result : and_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest_bit;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest_bit(highest_bit[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest_bit(highest_bit[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest_bit(highest_bit[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest_bit(highest_bit[1]), .valid(valid));\n\n    // Assign the highest bit to the output code\n    assign code = highest_bit;\n\nendmodule\n\nmodule check_bit(in, highest_bit, valid);\n    input in;\n    output highest_bit;\n    output valid;\n\n    wire highest_bit_temp;\n\n    assign highest_bit_temp = (in & ~highest_bit);\n    assign highest_bit = (highest_bit_temp) ? 1'b1 : highest_bit;\n    assign valid = (highest_bit_temp) ? 1'b1 : valid;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 32'd10000000; // 25% duty cycle\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 32'd50000000; // 50% duty cycle\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 32'd75000000; // 75% duty cycle\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n    wire valid_temp;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb4(.in(in[4]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb1(.in(in[1]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(valid_temp));\n\n    // Assign output\n    assign code = code_temp;\n    assign valid = valid_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in;\n    assign valid = highest;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] adder_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest_pos;\n\n    // Instantiate check_bit submodules for each bit\n    check_bit cb7(.in(in[7]), .highest_pos(highest_pos[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest_pos(highest_pos[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest_pos(highest_pos[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest_pos(highest_pos[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest_pos(highest_pos[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest_pos(highest_pos[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest_pos(highest_pos[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest_pos(highest_pos[1]), .valid(valid));\n\n    // Assign the highest priority bit to the output code\n    assign code = highest_pos;\n\nendmodule\n\nmodule check_bit(in, highest_pos, valid);\n    input in;\n    output highest_pos;\n    output valid;\n    reg highest_pos;\n    reg valid;\n\n    always @(in) begin\n        if (in) begin\n            highest_pos = 1;\n            valid = 1;\n        end else begin\n            highest_pos = 0;\n            valid = 0;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching submodule for registers\n    reg_fetch_reg ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .fetch(2'b01),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching submodule for RAM/ROM\n    reg_fetch_ram ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .fetch(2'b10),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignments\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule reg_fetch_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch == 2'b01) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule reg_fetch_ram (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch == 2'b10) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit modules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = |code_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !highest;\n    assign valid = in;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation result based on the op_sel signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instance of the instruction fetching module for registers\n    inst_fetch_reg ins_p1_m (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[0]),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instance of the instruction fetching module for RAM/ROM\n    inst_fetch_ram ins_p2_m (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch[1]),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output assignment\n    assign ins = fetch[1] ? ins_p2 : ins_p1;\n    assign ad1 = fetch[1] ? ad1_p2 : ad1_p1;\n    assign ad2 = fetch[1] ? ad2_p2 : ad2_p1;\n\nendmodule\n\nmodule inst_fetch_reg (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule\n\nmodule inst_fetch_ram (\n    input clk,\n    input rst,\n    input fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data[7:0];\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(highest[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest(highest[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest(highest[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest(highest[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest(highest[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest(highest[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest(highest[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest(highest[1]), .valid(valid));\n\n    // Output code\n    assign code = highest;\n\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    // Initialize highest priority to 0\n    reg highest = 0;\n    reg valid = 0;\n\n    always @(*) begin\n        if (in) begin\n            highest = 1;\n            valid = 1;\n        end else if (highest == 1) begin\n            highest = 2;\n            valid = 1;\n        end else if (highest == 2) begin\n            highest = 0;\n            valid = 1;\n        end else begin\n            valid = 0;\n        end\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] adder_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n    wire valid_temp;\n\n    // Instantiate check_bit modules for each bit\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb4(.in(in[4]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(valid_temp));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(valid_temp));\n    check_bit cb1(.in(in[1]), .highest(code_temp[2]), .valid(valid_temp));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(valid_temp));\n\n    // Assign output\n    assign code = code_temp;\n    assign valid = valid_temp;\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    assign highest = in & !highest;\n    assign valid = highest | valid;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire pwm_25_out, pwm_50_out, pwm_75_out;\n\n    // Instantiate the 25% PWM module\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    // Instantiate the 50% PWM module\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    // Instantiate the 75% PWM module\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    // Assign the outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n// 25% PWM module\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] counter;\n    reg pwm_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter < 10000000) begin\n                counter <= counter + 1;\n                pwm_out <= 0;\n            end else begin\n                counter <= 0;\n                pwm_out <= 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_out;\nendmodule\n\n// 50% PWM module\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] counter;\n    reg pwm_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter < 5000000) begin\n                counter <= counter + 1;\n                pwm_out <= 0;\n            end else begin\n                counter <= 0;\n                pwm_out <= 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_out;\nendmodule\n\n// 75% PWM module\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] counter;\n    reg pwm_out;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter < 7500000) begin\n                counter <= counter + 1;\n                pwm_out <= 0;\n            end else begin\n                counter <= 0;\n                pwm_out <= 1;\n            end\n        end\n    end\n\n    assign PWM_out = pwm_out;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] highest;\n\n    // Instantiate check_bit submodules for each bit of the input\n    check_bit cb7(.in(in[7]), .highest(highest[2]), .valid(valid));\n    check_bit cb6(.in(in[6]), .highest(highest[1]), .valid(valid));\n    check_bit cb5(.in(in[5]), .highest(highest[0]), .valid(valid));\n    check_bit cb4(.in(in[4]), .highest(highest[2]), .valid(valid));\n    check_bit cb3(.in(in[3]), .highest(highest[1]), .valid(valid));\n    check_bit cb2(.in(in[2]), .highest(highest[0]), .valid(valid));\n    check_bit cb1(.in(in[1]), .highest(highest[2]), .valid(valid));\n    check_bit cb0(.in(in[0]), .highest(highest[1]), .valid(valid));\n\n    // Assign the highest priority bit to the output code\n    assign code = highest;\n\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    reg highest_found;\n    reg highest_priority;\n\n    always @(*) begin\n        highest_found = in;\n        highest_priority = highest_found;\n        valid = highest_found;\n    end\n\n    assign highest = highest_priority;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[0]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[0]), .valid(code_temp[0]));\n\n    // Determine output code and valid signal\n    assign code = code_temp;\n    assign valid = (code_temp[2] || code_temp[1] || code_temp[0]);\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    wire highest_temp;\n\n    // Check if highest bit is set\n    assign highest_temp = (in && !highest);\n\n    // Determine if valid bit is set\n    assign valid = highest_temp;\n\n    // Set highest bit if valid\n    assign highest = highest_temp;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation result based on the op_sel signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [2:0] code_temp;\n\n    // Instantiate check_bit submodules\n    check_bit cb7(.in(in[7]), .highest(code_temp[2]), .valid(code_temp[1]));\n    check_bit cb6(.in(in[6]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb5(.in(in[5]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb4(.in(in[4]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb3(.in(in[3]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb2(.in(in[2]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb1(.in(in[1]), .highest(code_temp[1]), .valid(code_temp[0]));\n    check_bit cb0(.in(in[0]), .highest(code_temp[1]), .valid(code_temp[0]));\n\n    // Output code and valid signal\n    assign code = code_temp;\n    assign valid = (code_temp[2] | code_temp[1] | code_temp[0]);\nendmodule\n\nmodule check_bit(in, highest, valid);\n    input in;\n    output highest;\n    output valid;\n\n    // Initialize highest and valid\n    assign highest = 0;\n    assign valid = 0;\n\n    // Check if input is '1'\n    assign valid = in;\n    assign highest = (in & ~highest);\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] adder_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the operation result based on the op_sel signal\nassign result = (op_sel) ? and_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h30), // Threshold temperature value\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_detected),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires to hold the results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the bitwise AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the output based on the operation select signal\nassign result = (op_sel) ? and_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output [0] alarm_out;\n    wire [0] temp_above_threshold;\n    wire [0] smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h30),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between adder and subtractor outputs\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between adder and subtractor outputs\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h30),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60), // Threshold temperature in Celsius\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor >= threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on the mode input\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h50),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h50),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output above_threshold;\n    assign above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between adder and subtractor outputs\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR gate\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor >= threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b1 : 1'b0;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results of the adders and subtractors\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on the mode input\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_detected),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output above_threshold;\n    assign above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire [7:0] count;\n\n    // Instantiate the counter module\n    counter cnt (\n        .clk(clk),\n        .enable(1'b1),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instantiate the wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    always @(posedge clk) begin\n        wave_out <= (count % freq) ? 1'b0 : 1'b1;\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM modules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 10000000; // 10MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 5000000; // 5MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 7500000; // 7.5MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode input\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 25000000; // 25% duty cycle threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 50000000; // 50% duty cycle threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    localparam THRESHOLD = 75000000; // 75% duty cycle threshold\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'h40),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold, smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .temp_above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR gate\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, temp_above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output temp_above_threshold;\n    assign temp_above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold, smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder and subtractor submodules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select between addition and subtraction\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input [7:0] temp_sensor;\n    input [0] smoke_sensor;\n    output alarm_out;\n    wire temp_above_threshold;\n    wire smoke_detected;\n\n    // Instantiate temperature comparison module\n    compare_temp comp_temp (\n        .temp_sensor(temp_sensor),\n        .threshold(8'd60),\n        .above_threshold(temp_above_threshold)\n    );\n\n    // Instantiate OR logic module\n    or_logic or_gate (\n        .temp_above_threshold(temp_above_threshold),\n        .smoke_detected(smoke_sensor),\n        .alarm_out(alarm_out)\n    );\n\nendmodule\n\nmodule compare_temp (temp_sensor, threshold, above_threshold);\n    input [7:0] temp_sensor;\n    input [7:0] threshold;\n    output above_threshold;\n    assign above_threshold = (temp_sensor > threshold);\nendmodule\n\nmodule or_logic (temp_above_threshold, smoke_detected, alarm_out);\n    input temp_above_threshold;\n    input smoke_detected;\n    output alarm_out;\n    assign alarm_out = temp_above_threshold | smoke_detected;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire [31:0] counter_25;\n    wire [31:0] counter_50;\n    wire [31:0] counter_75;\n\n    // Instantiate the PWM submodules\n    pwm_25_module pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25),\n        .counter(counter_25)\n    );\n\n    pwm_50_module pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50),\n        .counter(counter_50)\n    );\n\n    pwm_75_module pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75),\n        .counter(counter_75)\n    );\n\nendmodule\n\n// Submodule for 25% PWM\nmodule pwm_25_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 50% PWM\nmodule pwm_50_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 50000000; // 50MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for 75% PWM\nmodule pwm_75_module (\n    input CLK_in,\n    input RST,\n    output PWM_out,\n    output reg [31:0] counter\n);\n\n    parameter THRESHOLD = 75000000; // 75MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= THRESHOLD) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the results\nwire [15:0] adder_result;\nwire [15:0] subtractor_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(adder_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtractor_result)\n);\n\n// Multiplexer to select the result based on mode\nassign result = (mode) ? subtractor_result : adder_result;\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] a_shifted[3:0];\nwire [3:0] b_shifted[3:0];\nwire [7:0] sum[3:0];\n\n// Shift registers\nassign a_shifted[0] = a;\nassign b_shifted[0] = b;\nassign a_shifted[1] = {a[0], a[3:1]};\nassign b_shifted[1] = {b[0], b[3:1]};\nassign a_shifted[2] = {a[1], a[3:2]};\nassign b_shifted[2] = {b[1], b[3:2]};\nassign a_shifted[3] = {a[2], a[3]};\nassign b_shifted[3] = {b[2], b[3]};\n\n// Full adders\nfull_adder GPP0 (.a(a_shifted[0]), .b(b_shifted[0]), .cin(0), .sum(sum[0]), .cout(0));\nfull_adder GPP1 (.a(a_shifted[1]), .b(b_shifted[1]), .cin(0), .sum(sum[1]), .cout(0));\nfull_adder GPP2 (.a(a_shifted[2]), .b(b_shifted[2]), .cin(0), .sum(sum[2]), .cout(0));\nfull_adder GPP3 (.a(a_shifted[3]), .b(b_shifted[3]), .cin(0), .sum(sum[3]), .cout(0));\n\n// Shift sum\nassign product = {sum[3], sum[2], sum[1], sum[0]};\n\nendmodule\n\nmodule full_adder(\n    input [3:0] a, b,\n    input cin,\n    output [3:0] sum,\n    output cout);\n\nwire c_out;\n\nassign {c_out, sum} = a + b + cin;\nassign cout = c_out;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodules\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 100_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 50_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 75_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry of the 4-bit adders\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out is the last carry of the 2-bit adders\n    assign C_out = carry[2];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry-out from 1-bit adders\n\n    // Instantiate 1-bit full adders for each bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry of the 1-bit adders\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adders\nfull_adder_4 GPP0 (.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(1'b0));\nfull_adder_4 GPP1 (.a(a[1]), .b(b[1]), .cin(sum0[0]), .sum(sum1), .cout(sum0[1]));\nfull_adder_4 GPP2 (.a(a[2]), .b(b[2]), .cin(sum1[0]), .sum(sum2), .cout(sum1[1]));\nfull_adder_4 GPP3 (.a(a[3]), .b(b[3]), .cin(sum2[0]), .sum(sum3), .cout(sum2[1]));\n\n// 8-bit full adders\nfull_adder_8 A4BS0 (.a(sum0), .b(sum1), .cin(0), .sum(sum4[0]), .cout(1'b0));\nfull_adder_8 A4BS1 (.a(sum2), .b(sum3), .cin(sum4[0]), .sum(sum4[1]), .cout(sum4[2]));\nfull_adder_8 A4BS2 (.a(sum0), .b(sum3), .cin(sum4[1]), .sum(sum4[3]), .cout(sum4[4]));\nfull_adder_8 A4BS3 (.a(sum1), .b(sum2), .cin(sum4[3]), .sum(sum4[5]), .cout(sum4[6]));\nfull_adder_8 A4BS4 (.a(sum0), .b(sum2), .cin(sum4[5]), .sum(sum4[7]), .cout(sum4[8]));\n\nassign product = sum4;\n\nendmodule\n\nmodule full_adder_4(\n    input a, b, cin,\n    output sum, cout);\n\nwire c1, c2;\n\nxor x1(a, b, sum);\nand a1(a, b, c1);\nand a2(a, b, c2);\nor o1(c1, cin, cout);\nor o2(c2, sum, cout);\n\nendmodule\n\nmodule full_adder_8(\n    input [3:0] a, b, cin,\n    output [3:0] sum, cout);\n\nwire [3:0] c1, c2;\n\nfull_adder_4 fa0 (.a(a[0]), .b(b[0]), .cin(cin[0]), .sum(sum[0]), .cout(c1[0]));\nfull_adder_4 fa1 (.a(a[1]), .b(b[1]), .cin(c1[0]), .sum(sum[1]), .cout(c1[1]));\nfull_adder_4 fa2 (.a(a[2]), .b(b[2]), .cin(c1[1]), .sum(sum[2]), .cout(c1[2]));\nfull_adder_4 fa3 (.a(a[3]), .b(b[3]), .cin(c1[2]), .sum(sum[3]), .cout(c1[3]));\n\nor o1(c1[0], c1[1], c1[2], c1[3], cout[0]);\nor o2(c1[1], c1[2], c1[3], cout[1]);\nor o3(c1[2], c1[3], cout[2]);\n\nendmodule\n\nmodule or(\n    input [3:0] a, b, c,\n    output cout);\n\nassign cout = a[0] | b[0] | c[0] | a[1] | b[1] | c[1] | a[2] | b[2] | c[2] | a[3] | b[3] | c[3];\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles for 25% duty cycle\n\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 50; // Number of clock cycles for 50% duty cycle\n\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 25; // Number of clock cycles for 75% duty cycle\n\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adders for each bit position\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(shifted_sum0[0]));\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(shifted_sum0[0]), .sum(sum1), .cout(shifted_sum1[1]));\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(shifted_sum1[1]), .sum(sum2), .cout(shifted_sum2[2]));\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(shifted_sum2[2]), .sum(sum3), .cout(shifted_sum3[3]));\n\n// Shift registers for each bit position\nshift_register_4bit A4BS0(.a(sum0), .b(b[0]), .cin(0), .sum(shifted_sum0[0]));\nshift_register_4bit A4BS1(.a(sum1), .b(b[1]), .cin(shifted_sum0[0]), .sum(shifted_sum1[1]));\nshift_register_4bit A4BS2(.a(sum2), .b(b[2]), .cin(shifted_sum1[1]), .sum(shifted_sum2[2]));\nshift_register_4bit A4BS3(.a(sum3), .b(b[3]), .cin(shifted_sum2[2]), .sum(shifted_sum3[3]));\n\nassign product = {shifted_sum3, shifted_sum2, shifted_sum1, shifted_sum0};\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule shift_register_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders for each nibble\n    full_adder_4bit add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    full_adder_4bit add2(\n        .A(A[5:2]),\n        .B(B[5:2]),\n        .C_in(c1),\n        .S(S[5:2]),\n        .C_out(c2)\n    );\n\n    full_adder_4bit add3(\n        .A(A[9:6]),\n        .B(B[9:6]),\n        .C_in(c2),\n        .S(S[9:6]),\n        .C_out(c3)\n    );\n\n    full_adder_4bit add4(\n        .A(A[13:10]),\n        .B(B[13:10]),\n        .C_in(c3),\n        .S(S[13:10]),\n        .C_out(c4)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c4;\nendmodule\n\nmodule full_adder_4bit(A, B, C_in, S, C_out);\n    input A, B, C_in;     // Inputs\n    output S, C_out;      // Outputs\n\n    wire c1, c2;\n\n    // 2-bit full adder for the first nibble\n    full_adder fa1(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    // 2-bit full adder for the second nibble\n    full_adder fa2(\n        .A(S),\n        .B(c1),\n        .C_in(1'b0),\n        .S(S),\n        .C_out(c2)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c2;\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;     // Inputs\n    output S, C_out;      // Outputs\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    parameter CYCLES = 32'd100_000_000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= CYCLES) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    parameter CYCLES = 32'd50_000_000; // 50MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= CYCLES) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    parameter CYCLES = 32'd75_000_000; // 75MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter >= CYCLES) begin\n                counter <= 0;\n                PWM_out <= 1;\n            end else begin\n                counter <= counter + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] GPP0, GPP1, GPP2, GPP3;\nwire [3:0] A4BS0, A4BS1, A4BS2;\n\n// Generate partial products\nfull_adder_4 GPP0 (.a(a[0]), .b(b[0]), .cin(1'b0), .sum(GPP0), .cout(A4BS0));\nfull_adder_4 GPP1 (.a(a[1]), .b(b[1]), .cin(GPP0), .sum(GPP1), .cout(A4BS1));\nfull_adder_4 GPP2 (.a(a[2]), .b(b[2]), .cin(GPP1), .sum(GPP2), .cout(A4BS2));\nfull_adder_4 GPP3 (.a(a[3]), .b(b[3]), .cin(GPP2), .sum(product[3:0]), .cout(product[7]));\n\n// Generate the product\nfull_adder_4 A4BS0 (.a(a[0]), .b(b[0]), .cin(1'b0), .sum(product[0]), .cout(product[1]));\nfull_adder_4 A4BS1 (.a(a[1]), .b(b[1]), .cin(product[0]), .sum(product[1]), .cout(product[2]));\nfull_adder_4 A4BS2 (.a(a[2]), .b(b[2]), .cin(product[1]), .sum(product[2]), .cout(product[3]));\n\nendmodule\n\nmodule full_adder_4(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 50000000; // 50MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 25000000; // 25MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adders\ngp_0 gpp0(\n    .a(a),\n    .b(b),\n    .sum(sum0)\n);\n\ngp_1 gpp1(\n    .a(a),\n    .b(b),\n    .sum(sum1)\n);\n\ngp_2 gpp2(\n    .a(a),\n    .b(b),\n    .sum(sum2)\n);\n\ngp_3 gpp3(\n    .a(a),\n    .b(b),\n    .sum(sum3)\n);\n\n// 8-bit full adder\na4bs a4bs0(\n    .a(sum0),\n    .b(sum1),\n    .sum(sum4[0]),\n    .carry(sum4[1])\n);\n\na4bs a4bs1(\n    .a(sum2),\n    .b(sum3),\n    .sum(sum4[2]),\n    .carry(sum4[3])\n);\n\na4bs a4bs2(\n    .a(sum0),\n    .b(sum2),\n    .sum(sum4[4]),\n    .carry(sum4[5])\n);\n\na4bs a4bs3(\n    .a(sum1),\n    .b(sum3),\n    .sum(sum4[6]),\n    .carry(sum4[7])\n);\n\n// Assign product\nassign product = sum4;\n\nendmodule\n\n// 4-bit full adder\nmodule gp_0(a, b, sum);\ninput [3:0] a, b;\noutput [3:0] sum;\nassign sum = a + b;\nendmodule\n\nmodule gp_1(a, b, sum);\ninput [3:0] a, b;\noutput [3:0] sum;\nassign sum = a + b;\nendmodule\n\nmodule gp_2(a, b, sum);\ninput [3:0] a, b;\noutput [3:0] sum;\nassign sum = a + b;\nendmodule\n\nmodule gp_3(a, b, sum);\ninput [3:0] a, b;\noutput [3:0] sum;\nassign sum = a + b;\nendmodule\n\n// 8-bit full adder\nmodule a4bs(a, b, sum, carry);\ninput [7:0] a, b;\noutput [7:0] sum;\noutput carry;\nassign {carry, sum} = a + b;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [15:0] carry;    // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .C_in(carry[15]),\n        .S(S[15:12]),\n        .C_out(carry[14])\n    );\n\n    four_bit_adder add2(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[12]),\n        .S(S[11:8]),\n        .C_out(carry[11])\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[8]),\n        .S(S[7:4]),\n        .C_out(carry[7])\n    );\n\n    four_bit_adder add4(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .C_in(carry[4]),\n        .S(S[3:0]),\n        .C_out(carry[0])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[15];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] sum;       // 4-bit sum\n    wire carry_out;       // Carry-out from the adder\n\n    // Instantiate a 2-bit full adder for each 2-bit group\n    two_bit_adder adder1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .S(sum[3:2]),\n        .C_out(carry_out)\n    );\n\n    two_bit_adder adder2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(carry_out),\n        .S(sum[1:0]),\n        .C_out(C_out)\n    );\n\n    // Sum is the sum of the two 2-bit adders\n    assign S = sum;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire carry_out;        // Carry-out from the adder\n\n    // Instantiate a 1-bit full adder for the LSB\n    one_bit_adder adder1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(carry_out)\n    );\n\n    // Carry-out is the carry-out from the 1-bit adder\n    assign C_out = carry_out;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in input\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    wire carry_out;        // Carry-out from the adder\n\n    // Carry-out is the XOR of A and B\n    assign S = A ^ B;\n    assign C_out = A & B | C_in;\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// Full adder for product bits 0 and 1\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(sum1));\n\n// Full adder for product bits 2 and 3\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(sum1), .sum(sum2), .cout(sum3));\n\n// Full adder for product bits 4 and 5\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(sum3), .sum(sum4[0]), .cout(sum4[1]));\n\n// Full adder for product bits 6 and 7\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(sum4[1]), .sum(sum4[2]), .cout(sum4[3]));\n\n// Shift register for product bits 4 to 7\nshift_register_4bit A4BS0(.sum(sum4[0]), .cin(0), .shifted(sum4[1]), .shifted_out(sum4[2]));\n\n// Shift register for product bits 5 to 8\nshift_register_4bit A4BS1(.sum(sum4[1]), .cin(sum4[2]), .shifted(sum4[3]), .shifted_out(sum4[4]));\n\n// Shift register for product bits 6 to 9\nshift_register_4bit A4BS2(.sum(sum4[2]), .cin(sum4[3]), .shifted(sum4[4]), .shifted_out(sum4[5]));\n\nassign product = {sum0, sum1, sum2, sum3, sum4[0], sum4[1], sum4[2], sum4[3], sum4[4], sum4[5]};\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nwire c1, c2;\n\nxor x1(a, b, sum);\nand a1(a, b, c1);\nand a2(a, ~b, c2);\nor o1(c1, cin, cout);\nor o2(c2, cin, c1);\n\nendmodule\n\nmodule shift_register_4bit(\n    input sum, cin,\n    output shifted, shifted_out);\n\nwire c1, c2;\n\nxor x1(sum, cin, shifted);\nand a1(sum, cin, c1);\nand a2(sum, ~cin, c2);\nor o1(c1, c2, shifted_out);\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles for 25% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 50; // Number of clock cycles for 50% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 25; // Number of clock cycles for 75% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n\n    // Submodule instances\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state)\n    );\n\n    waveform_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule waveform_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave <= 5'b00000;\n        end else begin\n            case (state)\n                2'b00: wave <= wave + 1;\n                2'b01: wave <= wave - 1;\n                default: wave <= 5'b00000;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// Full adders for each bit\nfull_adder_4bit GPP0 (.a(a[0]), .b(b[0]), .cin(0), .sum(sum1), .cout(0));\nfull_adder_4bit GPP1 (.a(a[1]), .b(b[1]), .cin(sum1[0]), .sum(sum2), .cout(sum1[1]));\nfull_adder_4bit GPP2 (.a(a[2]), .b(b[2]), .cin(sum2[0]), .sum(sum3), .cout(sum2[1]));\nfull_adder_4bit GPP3 (.a(a[3]), .b(b[3]), .cin(sum3[0]), .sum(sum4), .cout(sum3[1]));\n\n// Shift registers for each bit\nshift_register_4bit A4BS0 (.sum(sum1), .cout(sum2[0]), .shift_out(product[0]));\nshift_register_4bit A4BS1 (.sum(sum2), .cout(sum3[0]), .shift_out(product[1]));\nshift_register_4bit A4BS2 (.sum(sum3), .cout(sum4[0]), .shift_out(product[2]));\nshift_register_4bit A4BS3 (.sum(sum4), .cout(0), .shift_out(product[3]));\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule shift_register_4bit(\n    input [3:0] sum, cin,\n    output shift_out);\n\nreg [3:0] shift_reg;\n\nalways @(*) begin\n    shift_reg[0] = sum[0];\n    shift_reg[1] = sum[1];\n    shift_reg[2] = sum[2];\n    shift_reg[3] = sum[3];\nend\n\nassign shift_out = cin ? 4'b0000 : shift_reg;\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(d0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(d0),\n        .q(d1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(d1),\n        .q(d2)\n    );\n\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b00000000;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else if (count == CYCLES / 4) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else if (count == CYCLES / 2) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else if (count == CYCLES * 3 / 4) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// Full adders for each bit position\nfull_adder GPP0 (.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\nfull_adder GPP1 (.a(a[1]), .b(b[1]), .cin(sum0), .sum(sum1), .cout(sum0));\nfull_adder GPP2 (.a(a[2]), .b(b[2]), .cin(sum1), .sum(sum2), .cout(sum1));\nfull_adder GPP3 (.a(a[3]), .b(b[3]), .cin(sum2), .sum(sum3), .cout(sum2));\n\n// Shift registers for each bit position\nshift_register A4BS0 (.sum(sum0), .cout(sum1), .shift_out(sum4[0]));\nshift_register A4BS1 (.sum(sum1), .cout(sum2), .shift_out(sum4[1]));\nshift_register A4BS2 (.sum(sum2), .cout(sum3), .shift_out(sum4[2]));\nshift_register A4BS3 (.sum(sum3), .cout(0), .shift_out(sum4[3]));\n\nassign product = sum4;\n\nendmodule\n\nmodule full_adder(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule shift_register(input sum, cin, output shift_out);\n    assign shift_out = sum;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out from the last adder\n    assign C_out = carry[4];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:0] A;        // 2-bit input A\n    input [2:0] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry chain\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A, B;           // Inputs\n    input C_in;           // Carry-in\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b00000000; // Default case to avoid latches\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adders for each bit position\nfull_adder_4 GPP0 (.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\nfull_adder_4 GPP1 (.a(a[1]), .b(b[1]), .cin(sum0), .sum(sum1), .cout(0));\nfull_adder_4 GPP2 (.a(a[2]), .b(b[2]), .cin(sum1), .sum(sum2), .cout(0));\nfull_adder_4 GPP3 (.a(a[3]), .b(b[3]), .cin(sum2), .sum(sum3), .cout(0));\n\n// Shift registers for each bit position\nshift_register_4 A4BS0 (.sum(sum0), .shifted_sum(shifted_sum0));\nshift_register_4 A4BS1 (.sum(sum1), .shifted_sum(shifted_sum1));\nshift_register_4 A4BS2 (.sum(sum2), .shifted_sum(shifted_sum2));\nshift_register_4 A4BS3 (.sum(sum3), .shifted_sum(shifted_sum3));\n\n// Output product\nassign product = {shifted_sum3, shifted_sum2, shifted_sum1, shifted_sum0};\n\nendmodule\n\nmodule full_adder_4(input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule shift_register_4(input [3:0] sum, output [7:0] shifted_sum);\n    assign shifted_sum = {sum, 4'b0000};\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodule instances\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 50000000; // 50MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 25000000; // 25MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count >= CYCLES) begin\n                count <= 0;\n                PWM_out <= 1;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// 4-bit full adders\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(sum0[0]), .sum(sum1), .cout(sum0[1]));\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(sum1[0]), .sum(sum2), .cout(sum1[1]));\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(sum2[0]), .sum(sum3), .cout(sum2[1]));\n\n// Shift registers\nassign shifted_sum0 = {sum0, 2'b00};\nassign shifted_sum1 = {sum1, shifted_sum0[7:2]};\nassign shifted_sum2 = {sum2, shifted_sum1[7:2]};\nassign shifted_sum3 = {sum3, shifted_sum2[7:2]};\n\n// Output\nassign product = shifted_sum3;\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b00000000;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] temp1, temp2, temp3, temp4;\nwire [7:0] temp5, temp6, temp7, temp8;\n\n// First stage\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(temp1), .cout(temp2));\n\n// Second stage\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(temp2), .sum(temp3), .cout(temp4));\n\n// Third stage\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(temp4), .sum(temp5), .cout(temp6));\n\n// Fourth stage\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(temp6), .sum(temp7), .cout(temp8));\n\n// Final stage\nassign product = {temp8, temp7, temp6, temp5, temp4, temp3, temp2, temp1};\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles for 25% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 50; // Number of clock cycles for 50% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 25; // Number of clock cycles for 75% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                PWM_out <= 1;\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Select the output based on the sel input\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n            default: q <= 8'b00000000;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry outputs from each full adder\n\n    // Instantiate 4-bit full adders for each nibble\n    four_bit_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry from the last full adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry outputs from each bit\n\n    // Instantiate 2-bit full adders for each bit\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry from the last bit\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [1:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;              // Carry output from the first bit\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry from the last bit\n    assign C_out = c1;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= q0;\n            2'b10: q <= q1;\n            2'b11: q <= q2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] a_reg, b_reg;\nwire [7:0] product_reg;\n\n// Registers for inputs\nreg [3:0] a_reg, b_reg;\nreg [7:0] product_reg;\n\n// Full adders for multiplication\nwire [7:0] sum0, sum1, sum2, sum3;\nwire [7:0] sum0_reg, sum1_reg, sum2_reg, sum3_reg;\n\n// Shift registers for multiplication\nwire [7:0] shifted_a0, shifted_a1, shifted_a2, shifted_a3;\nwire [7:0] shifted_b0, shifted_b1, shifted_b2, shifted_b3;\n\n// Instantiate full adders\nfull_adder_4bit GPP0 (.a(a), .b(b_reg), .cin(0), .sum(sum0), .cout(sum0_reg));\nfull_adder_4bit GPP1 (.a(a_reg), .b(b), .cin(0), .sum(sum1), .cout(sum1_reg));\nfull_adder_4bit GPP2 (.a(a), .b(b_reg), .cin(sum0_reg), .sum(sum2), .cout(sum2_reg));\nfull_adder_4bit GPP3 (.a(a_reg), .b(b), .cin(sum1_reg), .sum(sum3), .cout(sum3_reg));\n\n// Instantiate shift registers\nshift_register_4bit A4BS0 (.data_in(a), .shift_in(0), .shift_out(shifted_a0));\nshift_register_4bit A4BS1 (.data_in(b), .shift_in(0), .shift_out(shifted_b0));\nshift_register_4bit A4BS2 (.data_in(a), .shift_in(1), .shift_out(shifted_a1));\nshift_register_4bit A4BS3 (.data_in(b), .shift_in(1), .shift_out(shifted_b1));\nshift_register_4bit A4BS4 (.data_in(a), .shift_in(2), .shift_out(shifted_a2));\nshift_register_4bit A4BS5 (.data_in(b), .shift_in(2), .shift_out(shifted_b2));\nshift_register_4bit A4BS6 (.data_in(a), .shift_in(3), .shift_out(shifted_a3));\nshift_register_4bit A4BS7 (.data_in(b), .shift_in(3), .shift_out(shifted_b3));\n\n// Assign output\nassign product = sum3 + (shifted_a3 << 3) + (shifted_b3 << 3);\n\nendmodule\n\nmodule full_adder_4bit(\n    input [3:0] a, b,\n    input cin,\n    output [7:0] sum,\n    output cout);\n\nassign {cout, sum} = a + b + cin;\n\nendmodule\n\nmodule shift_register_4bit(\n    input [3:0] data_in,\n    input shift_in,\n    output [7:0] shift_out);\n\nreg [7:0] shift_reg;\n\nalways @(*) begin\n    shift_reg = {shift_reg[2:0], shift_in};\nend\n\nassign shift_out = {shift_reg[6:4], data_in};\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(d0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(d0),\n        .q(d1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(d1),\n        .q(d2)\n    );\n\n    // Select the output based on the sel input\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b00000000;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 100; // Number of clock cycles for 25% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 0;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 50; // Number of clock cycles for 50% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 0;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter CYCLES = 25; // Number of clock cycles for 75% duty cycle\n    reg [7:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                count <= 0;\n                PWM_out <= 0;\n            end else begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum1, sum2, sum3;\nwire [7:0] sum4;\n\n// 4-bit full adders\ngp_4b GPP0 (.a(a[0]), .b(b[0]), .sum(sum1));\ngp_4b GPP1 (.a(a[1]), .b(b[1]), .sum(sum2));\ngp_4b GPP2 (.a(a[2]), .b(b[2]), .sum(sum3));\ngp_4b GPP3 (.a(a[3]), .b(b[3]), .sum(sum4));\n\n// 8-bit full adder\na4b_8b A4BS0 (.a(sum1), .b(sum2), .sum(sum4[0]));\na4b_8b A4BS1 (.a(sum3), .b(sum4[1]), .sum(sum4[2]));\na4b_8b A4BS2 (.a(sum4[3]), .b(sum4[4]), .sum(sum4[5]));\n\nassign product = sum4;\n\nendmodule\n\nmodule gp_4b(input a, b, output sum);\nassign sum = a ^ b;\nendmodule\n\nmodule a4b_8b(input a, b, output sum);\nassign sum = a ^ b;\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b00000000; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum1, sum2, sum3, sum4;\nwire [7:0] sum5, sum6, sum7;\n\n// 4-bit full adders\ngp_4bit GPP0 (.a(a[0]), .b(b[0]), .sum(sum1));\ngp_4bit GPP1 (.a(a[1]), .b(b[1]), .sum(sum2));\ngp_4bit GPP2 (.a(a[2]), .b(b[2]), .sum(sum3));\ngp_4bit GPP3 (.a(a[3]), .b(b[3]), .sum(sum4));\n\n// 8-bit full adders\na4bs A4BS0 (.a(sum1), .b(sum2), .sum(sum5));\na4bs A4BS1 (.a(sum3), .b(sum4), .sum(sum6));\na4bs A4BS2 (.a(sum5), .b(sum6), .sum(sum7));\n\nassign product = sum7;\n\nendmodule\n\nmodule gp_4bit(input a, b, output sum);\nassign sum = a ^ b;\nendmodule\n\nmodule a4bs(input [3:0] a, b, output sum);\nassign sum = {a[3], a[2], a[1], a[0], b[3], b[2], b[1], b[0]};\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders\n    four_bit_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1[1]),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2[2]),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3[3]),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out\n    assign C_out = c4[4];\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] c;\n\n    // Instantiate 2-bit full adders\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(S[2:1]),\n        .C_out(c[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c[2]),\n        .S(S[4:3]),\n        .C_out(c[3])\n    );\n\n    // Carry-out\n    assign C_out = c[4];\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;         // 2-bit input A\n    input [2:1] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [2:1] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 1-bit full adder\n    full_adder fa(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    // Instantiate 1-bit full adder\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    // Carry-out\n    assign C_out = c2;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select the output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = d0;\n            2'b10: q = d1;\n            2'b11: q = d2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodule instances\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100_000_000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 50_000_000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 75_000_000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\nwire [3:0] sum0, sum1, sum2, sum3;\nwire [7:0] shifted_sum0, shifted_sum1, shifted_sum2, shifted_sum3;\n\n// Full adder for sum0\nfull_adder_4bit GPP0(.a(a[0]), .b(b[0]), .cin(0), .sum(sum0), .cout(0));\n\n// Full adder for sum1\nfull_adder_4bit GPP1(.a(a[1]), .b(b[1]), .cin(sum0), .sum(sum1), .cout(0));\n\n// Full adder for sum2\nfull_adder_4bit GPP2(.a(a[2]), .b(b[2]), .cin(sum1), .sum(sum2), .cout(0));\n\n// Full adder for sum3\nfull_adder_4bit GPP3(.a(a[3]), .b(b[3]), .cin(sum2), .sum(sum3), .cout(0));\n\n// Shift registers for sum0, sum1, sum2, and sum3\nshift_register_4bit A4BS0(.sum(sum0), .shifted_sum(shifted_sum0));\nshift_register_4bit A4BS1(.sum(sum1), .shifted_sum(shifted_sum1));\nshift_register_4bit A4BS2(.sum(sum2), .shifted_sum(shifted_sum2));\nshift_register_4bit A4BS3(.sum(sum3), .shifted_sum(shifted_sum3));\n\nassign product = {shifted_sum3, shifted_sum2, shifted_sum1, shifted_sum0};\n\nendmodule\n\nmodule full_adder_4bit(\n    input a, b, cin,\n    output sum, cout);\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule\n\nmodule shift_register_4bit(\n    input [3:0] sum,\n    output [7:0] shifted_sum);\n\nreg [7:0] shifted_sum;\n\nalways @(*) begin\n    shifted_sum = {sum, shifted_sum[7:4]};\nend\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] d0, d1, d2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(d0));\n    my_dff8 u1 (.clk(clk), .d(d0), .q(d1));\n    my_dff8 u2 (.clk(clk), .d(d1), .q(d2));\n\n    // Multiplexer to select output based on sel\n    always @(posedge clk) begin\n        case(sel)\n            2'b00: q <= d;\n            2'b01: q <= d0;\n            2'b10: q <= d1;\n            2'b11: q <= d2;\n            default: q <= 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter >= CYCLES) begin\n                PWM_out <= 0;\n                counter <= 0;\n            end else begin\n                PWM_out <= 1;\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    parameter CYCLES = 50000000; // 50MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter >= CYCLES) begin\n                PWM_out <= 0;\n                counter <= 0;\n            end else begin\n                PWM_out <= 1;\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] counter;\n    parameter CYCLES = 25000000; // 25MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter >= CYCLES) begin\n                PWM_out <= 0;\n                counter <= 0;\n            end else begin\n                PWM_out <= 1;\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff8 u0 (.clk(clk), .d(d), .q(q0));\n    my_dff8 u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff8 u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Multiplexer to select output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'b00000000;\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output the last flip-flop's output\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[3]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = C4[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C;         // Carry output for each bit\n\n    // Instantiate 2-bit full adders for each bit\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(C[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(C[1]),\n        .S(S[4:3]),\n        .C_out(C[2])\n    );\n\n    two_bit_adder add3(\n        .A(A[6:5]),\n        .B(B[6:5]),\n        .C_in(C[2]),\n        .S(S[6:5]),\n        .C_out(C[3])\n    );\n\n    two_bit_adder add4(\n        .A(A[8:7]),\n        .B(B[8:7]),\n        .C_in(C[3]),\n        .S(S[8:7]),\n        .C_out(C[4])\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = C[4];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry output for each bit\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(C1),\n        .S(S[2]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A, B;           // Inputs\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (A & C_in) | (B & C_in);\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output the last flip-flop's output\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodules\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 100_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 50_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output PWM_out\n);\n    reg [31:0] count;\n    reg PWM_state;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_state <= 0;\n        end else begin\n            if (count == 75_000_000) begin\n                count <= 0;\n                PWM_state <= ~PWM_state;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign PWM_out = PWM_state;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output the last flip-flop's output\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [4:1] carry;    // Intermediate carry signals\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .S(S[16:1]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[12:5]),\n        .B(B[12:5]),\n        .C_in(carry[1]),\n        .S(S[12:5]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[8:3]),\n        .B(B[8:3]),\n        .C_in(carry[2]),\n        .S(S[8:3]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[4:0]),\n        .B(B[4:0]),\n        .C_in(carry[3]),\n        .S(S[4:0]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;       // 4-bit input A\n    input [4:1] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [4:1] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [5:1] sum;      // 5-bit sum\n    wire c_out;           // Carry-out from the last adder\n\n    // Perform the addition\n    assign {c_out, sum} = A + B + C_in;\n\n    // Assign the sum to the output\n    assign S = sum[4:1];\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Output from the last flip-flop\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    pwm_duty_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES / 4) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES / 2) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES * 3 / 4) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect the outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodule instances\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle PWM\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES / 4) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle PWM\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES / 2) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle PWM\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [31:0] count;\n    parameter CYCLES = 100000000; // 100MHz clock\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (count < CYCLES * 3 / 4) begin\n                count <= count + 1;\n                PWM_out <= 0;\n            end else if (count < CYCLES) begin\n                count <= count + 1;\n                PWM_out <= 1;\n            end else begin\n                count <= 0;\n                PWM_out <= 0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out wire\n\n    // Instantiate 1-bit full adder for the final bit\n    full_adder fa(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the final adder\n    assign C_out = c1;\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in input\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] borrow;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7]; \nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1, q2;\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));\n    my_dff u2 (.clk(clk), .d(q1), .q(q2));\n\n    // Connect outputs\n    assign q = q2;\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  // Stage 1: Shift by 4\n  mux2X1 #(.WIDTH(8)) stage1(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_2));\n  assign shifted_in = in << 2;\n\n  // Stage 2: Shift by 2\n  mux2X1 #(.WIDTH(8)) stage2(.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(shifted_in_3));\n  mux2X1 #(.WIDTH(8)) stage3(.sel(ctrl[0]), .in0(shifted_in_3), .in1(shifted_in_4), .out(shifted_in_4));\n  assign shifted_in_3 = shifted_in_2 >> 2;\n  assign shifted_in_4 = shifted_in_2 >> 1;\n\n  // Final stage: Shift by 1\n  mux2X1 #(.WIDTH(8)) final_stage(.sel(ctrl[0]), .in0(shifted_in_4), .in1(in), .out(out));\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(carry[1]),\n        .S(S[8:5]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(carry[2]),\n        .S(S[12:9]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(carry[3]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] sum;        // 4-bit sum\n    wire [3:1] carry;      // Carry chain\n\n    // Perform addition\n    assign {C_out, sum} = A + B + C_in;\n\n    // Assign sum to output\n    assign S = sum[3:1];\n\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n// Submodules\npwm_duty_25 pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_25)\n);\n\npwm_duty_50 pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_50)\n);\n\npwm_duty_75 pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(PWM_75)\n);\n\nendmodule\n\n// Submodule for 25% duty cycle\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [15:0] count;\n    parameter CYCLES = 16'd10000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                if (count == CYCLES / 4) begin\n                    PWM_out <= 1;\n                end\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [15:0] count;\n    parameter CYCLES = 16'd8000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                if (count == CYCLES / 2) begin\n                    PWM_out <= 1;\n                end\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [15:0] count;\n    parameter CYCLES = 16'd6000;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == CYCLES) begin\n                PWM_out <= 0;\n                count <= 0;\n            end else begin\n                if (count == CYCLES * 3 / 4) begin\n                    PWM_out <= 1;\n                end\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [10:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output to the comparator output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [10:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [10:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else if (counter_out < DUTY_CYCLE) begin\n            comparator_out <= 1;\n        end else begin\n            comparator_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry outputs from each full adder\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry outputs from each full adder\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c1),\n        .S(S[4:3]),\n        .C_out(c2)\n    );\n\n    // Last 2 bits are added directly\n    assign {C_out, S[2:1]} = A[2:1] + B[2:1] + C_in;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum counter value\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Connect the comparator output to the PWM output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum counter value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == MAX_COUNT) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    reg [7:0] duty_cycle_threshold;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            duty_cycle_threshold <= DUTY_CYCLE * 10;\n        end else begin\n            duty_cycle_threshold <= DUTY_CYCLE * 10;\n        end\n    end\n\n    assign comparator_out = (counter_out < duty_cycle_threshold);\n\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (counter_out < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(carry[1]),\n        .S(S[8:5]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(carry[2]),\n        .S(S[12:9]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(carry[3]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] sum;       // 4-bit sum\n    wire carry_out;       // Carry-out from the last adder\n\n    // Perform the addition\n    assign {carry_out, S} = A + B + C_in;\n\n    // Assign the carry out\n    assign C_out = carry_out;\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_5;\n  wire [7:0] shifted_in_6;\n  wire [7:0] shifted_in_7;\n  wire [7:0] shifted_in_8;\n  wire [7:0] shifted_in_9;\n  wire [7:0] shifted_in_10;\n  wire [7:0] shifted_in_11;\n  wire [7:0] shifted_in_12;\n  wire [7:0] shifted_in_13;\n  wire [7:0] shifted_in_14;\n  wire [7:0] shifted_in_15;\n  wire [7:0] shifted_in_16;\n  wire [7:0] shifted_in_17;\n  wire [7:0] shifted_in_18;\n  wire [7:0] shifted_in_19;\n  wire [7:0] shifted_in_20;\n  wire [7:0] shifted_in_21;\n  wire [7:0] shifted_in_22;\n  wire [7:0] shifted_in_23;\n  wire [7:0] shifted_in_24;\n  wire [7:0] shifted_in_25;\n  wire [7:0] shifted_in_26;\n  wire [7:0] shifted_in_27;\n\n  // Stage 1: Shift by 4\n  mux2X1 ins_00(.sel(ctrl[2]), .in0(in), .in1(8'b00000000), .out(shifted_in));\n\n  // Stage 2: Shift by 2\n  mux2X1 ins_01(.sel(ctrl[1]), .in0(shifted_in), .in1(in), .out(shifted_in_2));\n\n  // Stage 3: Shift by 1\n  mux2X1 ins_02(.sel(ctrl[0]), .in0(shifted_in_2), .in1(in), .out(shifted_in_3));\n\n  // Stage 4: Shift by 4\n  mux2X1 ins_03(.sel(ctrl[2]), .in0(shifted_in_3), .in1(8'b00000000), .out(shifted_in_4));\n\n  // Stage 5: Shift by 2\n  mux2X1 ins_04(.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_5));\n\n  // Stage 6: Shift by 1\n  mux2X1 ins_05(.sel(ctrl[0]), .in0(shifted_in_5), .in1(shifted_in_4), .out(shifted_in_6));\n\n  // Stage 7: Shift by 4\n  mux2X1 ins_06(.sel(ctrl[2]), .in0(shifted_in_6), .in1(8'b00000000), .out(shifted_in_7));\n\n  // Stage 8: Shift by 2\n  mux2X1 ins_07(.sel(ctrl[1]), .in0(shifted_in_7), .in1(shifted_in_6), .out(shifted_in_8));\n\n  // Stage 9: Shift by 1\n  mux2X1 ins_08(.sel(ctrl[0]), .in0(shifted_in_8), .in1(shifted_in_7), .out(shifted_in_9));\n\n  // Stage 10: Shift by 4\n  mux2X1 ins_09(.sel(ctrl[2]), .in0(shifted_in_9), .in1(8'b00000000), .out(shifted_in_10));\n\n  // Stage 11: Shift by 2\n  mux2X1 ins_10(.sel(ctrl[1]), .in0(shifted_in_10), .in1(shifted_in_9), .out(shifted_in_11));\n\n  // Stage 12: Shift by 1\n  mux2X1 ins_11(.sel(ctrl[0]), .in0(shifted_in_11), .in1(shifted_in_10), .out(shifted_in_12));\n\n  // Stage 13: Shift by 4\n  mux2X1 ins_12(.sel(ctrl[2]), .in0(shifted_in_12), .in1(8'b00000000), .out(shifted_in_13));\n\n  // Stage 14: Shift by 2\n  mux2X1 ins_13(.sel(ctrl[1]), .in0(shifted_in_13), .in1(shifted_in_12), .out(shifted_in_14));\n\n  // Stage 15: Shift by 1\n  mux2X1 ins_14(.sel(ctrl[0]), .in0(shifted_in_14), .in1(shifted_in_13), .out(shifted_in_15));\n\n  // Stage 16: Shift by 4\n  mux2X1 ins_15(.sel(ctrl[2]), .in0(shifted_in_15), .in1(8'b00000000), .out(shifted_in_16));\n\n  // Stage 17: Shift by 2\n  mux2X1 ins_16(.sel(ctrl[1]), .in0(shifted_in_16), .in1(shifted_in_15), .out(shifted_in_17));\n\n  // Stage 18: Shift by 1\n  mux2X1 ins_17(.sel(ctrl[0]), .in0(shifted_in_17), .in1(shifted_in_16), .out(shifted_in_18));\n\n  // Stage 19: Shift by 4\n  mux2X1 ins_18(.sel(ctrl[2]), .in0(shifted_in_18), .in1(8'b00000000), .out(shifted_in_19));\n\n  // Stage 20: Shift by 2\n  mux2X1 ins_19(.sel(ctrl[1]), .in0(shifted_in_19), .in1(shifted_in_18), .out(shifted_in_20));\n\n  // Stage 21: Shift by 1\n  mux2X1 ins_20(.sel(ctrl[0]), .in0(shifted_in_20), .in1(shifted_in_19), .out(shifted_in_21));\n\n  // Stage 22: Shift by 4\n  mux2X1 ins_21(.sel(ctrl[2]), .in0(shifted_in_21), .in1(8'b00000000), .out(shifted_in_22));\n\n  // Stage 23: Shift by 2\n  mux2X1 ins_22(.sel(ctrl[1]), .in0(shifted_in_22), .in1(shifted_in_21), .out(shifted_in_23));\n\n  // Stage 24: Shift by 1\n  mux2X1 ins_23(.sel(ctrl[0]), .in0(shifted_in_23), .in1(shifted_in_22), .out(shifted_in_24));\n\n  // Stage 25: Shift by 4\n  mux2X1 ins_24(.sel(ctrl[2]), .in0(shifted_in_24), .in1(8'b00000000), .out(shifted_in_25));\n\n  // Stage 26: Shift by 2\n  mux2X1 ins_25(.sel(ctrl[1]), .in0(shifted_in_25), .in1(shifted_in_24), .out(shifted_in_26));\n\n  // Stage 27: Shift by 1\n  mux2X1 ins_26(.sel(ctrl[0]), .in0(shifted_in_26), .in1(shifted_in_25), .out(shifted_in_27));\n\n  assign out = shifted_in_27;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] count_out; // Output from the counter\n    wire pwm_out_int; // Internal PWM output\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(count_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .count_out(count_out),\n        .pwm_out(pwm_out_int)\n    );\n\n    // Assign the internal PWM output to the output\n    assign pwm_out = pwm_out_int;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == MAX_COUNT) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule comparator(\n    input [11:0] count_out,\n    input [11:0] duty_cycle,\n    output pwm_out\n);\n    assign pwm_out = (count_out < duty_cycle);\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output comparator_out\n);\n    parameter DUTY_CYCLE = 50;\n\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            duty_cycle_reg <= DUTY_CYCLE;\n        end else begin\n            duty_cycle_reg <= DUTY_CYCLE;\n        end\n    end\n\n    assign comparator_out = (counter_out < duty_cycle_reg);\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;         // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    input C_in;           // Carry-in input\n    output [1:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;              // Carry-out wire\n\n    // Instantiate 1-bit full adder for the last bit\n    full_adder fa(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c1;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (B & C_in) | (A & C_in); // Carry-out calculation\n\nendmodule"}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 100; // Maximum count value for the counter\n\n    wire [7:0] counter_out;\n    wire [7:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [7:0] count_out\n);\n    parameter MAX_COUNT = 100; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [7:0] counter_out,\n    output reg pwm_out\n);\n    parameter THRESHOLD = 50; // Threshold value for the comparator\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (counter_out < THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  mux2X1 ins_00 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_01 (.sel(ctrl[1]), .in0(shifted_in), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_02 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in_4), .out(shifted_in_3));\n\n  mux2X1 ins_03 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_04 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_05 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_06 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_07 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_08 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_09 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_10 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_11 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_12 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_13 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_14 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_15 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_16 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_17 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_18 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_19 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_20 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_21 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_22 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_23 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_24 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_25 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_26 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  mux2X1 ins_27 (.sel(ctrl[0]), .in0(in), .in1(shifted_in_2), .out(shifted_in_4));\n  mux2X1 ins_28 (.sel(ctrl[1]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 ins_29 (.sel(ctrl[2]), .in0(shifted_in_2), .in1(shifted_in), .out(shifted_in_3));\n\n  assign out = shifted_in;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_temp;\n    wire [8:0] diff_temp;\n\n    // Generate the borrow-in for each bit\n    assign b_temp[0] = bin;\n    assign b_temp[1] = bin;\n    assign b_temp[2] = bin;\n    assign b_temp[3] = bin;\n    assign b_temp[4] = bin;\n    assign b_temp[5] = bin;\n    assign b_temp[6] = bin;\n    assign b_temp[7] = bin;\n    assign b_temp[8] = bin;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(b_temp[0]), .diff(diff_temp[0]), .bout(b_temp[1]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_temp[1]), .diff(diff_temp[1]), .bout(b_temp[2]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_temp[2]), .diff(diff_temp[2]), .bout(b_temp[3]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_temp[3]), .diff(diff_temp[3]), .bout(b_temp[4]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_temp[4]), .diff(diff_temp[4]), .bout(b_temp[5]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_temp[5]), .diff(diff_temp[5]), .bout(b_temp[6]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_temp[6]), .diff(diff_temp[6]), .bout(b_temp[7]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_temp[7]), .diff(diff_temp[7]), .bout(b_temp[8]));\n\n    assign diff = diff_temp[7:0];\n    assign bout = b_temp[8];\nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out; // Output of the counter\n    wire [11:0] duty_cycle_threshold; // Threshold value for the comparator\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = MAX_COUNT * DUTY_CYCLE / 100;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (counter_out < DUTY_CYCLE) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n    wire [7:0] shifted_in_2;\n    wire [7:0] shifted_in_3;\n    wire [7:0] shifted_in_4;\n\n    // Stage 1: Shift by 4\n    mux2X1 mux1 (.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_2));\n    mux2X1 mux2 (.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(shifted_in_4));\n    mux2X1 mux3 (.sel(ctrl[0]), .in0(shifted_in_4), .in1(shifted_in_2), .out(out));\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n    input sel;\n    input [7:0] in0, in1;\n    output [7:0] out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Internal carry\n\n    // Instantiate 4-bit full adders for each 4-bit chunk\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Internal carry\n\n    // Instantiate 2-bit full adders for each 2-bit chunk\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Instantiate final 2-bit adder for the carry-out\n    two_bit_adder add3(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[2]),\n        .S(S[3:2]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:0] A;         // 2-bit input A\n    input [2:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [2:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [3:1] carry;      // Internal carry\n\n    // Instantiate 1-bit full adder for each bit\n    full_adder fa1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(0),\n        .S(S[0]),\n        .C_out(carry[1])\n    );\n\n    full_adder fa2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(carry[1]),\n        .S(S[1]),\n        .C_out(carry[2])\n    );\n\n    full_adder fa3(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(carry[2]),\n        .S(S[2]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_temp;\n\n    // Generate borrow for each bit\n    assign b_temp[0] = bin;\n    assign b_temp[1] = b_temp[0] ^ a[0] ^ b[0];\n    assign b_temp[2] = b_temp[1] ^ a[1] ^ b[1];\n    assign b_temp[3] = b_temp[2] ^ a[2] ^ b[2];\n    assign b_temp[4] = b_temp[3] ^ a[3] ^ b[3];\n    assign b_temp[5] = b_temp[4] ^ a[4] ^ b[4];\n    assign b_temp[6] = b_temp[5] ^ a[5] ^ b[5];\n    assign b_temp[7] = b_temp[6] ^ a[6] ^ b[6];\n    assign b_temp[8] = b_temp[7] ^ a[7] ^ b[7];\n\n    // Generate difference\n    assign diff[0] = a[0] ^ b[0];\n    assign diff[1] = a[1] ^ b[1] ^ b_temp[1];\n    assign diff[2] = a[2] ^ b[2] ^ b_temp[2];\n    assign diff[3] = a[3] ^ b[3] ^ b_temp[3];\n    assign diff[4] = a[4] ^ b[4] ^ b_temp[4];\n    assign diff[5] = a[5] ^ b[5] ^ b_temp[5];\n    assign diff[6] = a[6] ^ b[6] ^ b_temp[6];\n    assign diff[7] = a[7] ^ b[7] ^ b_temp[7];\n\n    // Generate borrow-out\n    assign bout = b_temp[8];\nendmodule\n\nmodule subtractor_1bit(\n    input a, b, bin,\n    output diff, bout);\n\n    assign diff = a ^ b ^ bin;\n    assign bout = bin ^ a ^ b;\n\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out >= MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 500; // Duty cycle threshold value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (counter_out < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  // Stage 1: Shift by 4\n  mux2X1 mux1 (.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_2));\n  mux2X1 mux2 (.sel(ctrl[1]), .in0(shifted_in_2), .in1(in), .out(shifted_in_3));\n  mux2X1 mux3 (.sel(ctrl[0]), .in0(shifted_in_3), .in1(in), .out(shifted_in_4));\n\n  // Stage 2: Shift by 2\n  mux2X1 mux4 (.sel(ctrl[2]), .in0(shifted_in_4), .in1(shifted_in_2), .out(shifted_in));\n  mux2X1 mux5 (.sel(ctrl[1]), .in0(shifted_in), .in1(shifted_in_3), .out(shifted_in_2));\n  mux2X1 mux6 (.sel(ctrl[0]), .in0(shifted_in_2), .in1(shifted_in_4), .out(shifted_in_3));\n\n  // Stage 3: Shift by 1\n  mux2X1 mux7 (.sel(ctrl[2]), .in0(shifted_in_3), .in1(shifted_in), .out(shifted_in_2));\n  mux2X1 mux8 (.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(shifted_in_4));\n  mux2X1 mux9 (.sel(ctrl[0]), .in0(shifted_in_4), .in1(shifted_in), .out(shifted_in_3));\n\n  assign out = shifted_in_3;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n  // Stage 1: Shift by 4 positions\n  mux2X1 mux1(stage1, in, stage1, 1'b1);\n  mux2X1 mux2(stage2, stage1, stage2, ctrl[2]);\n\n  // Stage 2: Shift by 2 positions\n  mux2X1 mux3(stage3, stage2, stage3, ctrl[1]);\n  mux2X1 mux4(stage4, stage3, stage4, ctrl[1]);\n\n  // Stage 3: Shift by 1 position\n  mux2X1 mux5(stage5, stage4, stage5, ctrl[0]);\n  mux2X1 mux6(stage6, stage5, stage6, ctrl[0]);\n\n  // Stage 4: Shift by 1 position\n  mux2X1 mux7(stage7, stage6, stage7, ctrl[0]);\n  mux2X1 mux8(stage8, stage7, stage8, ctrl[0]);\n\n  assign out = stage8;\n\nendmodule\n\nmodule mux2X1 (out, sel, in1, in2);\n  input sel;\n  input [7:0] in1, in2;\n  output [7:0] out;\n\n  assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage (default = 50%)\n    parameter MAX_COUNT = 10000; // Maximum count value for the counter\n\n    wire [15:0] counter_out; // Output from the counter module\n    wire [15:0] duty_cycle_threshold; // Threshold value for the comparator\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = MAX_COUNT * DUTY_CYCLE / 100;\n\n    // Instantiate the comparator module\n    comparator #(.MAX_COUNT(MAX_COUNT)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .threshold(duty_cycle_threshold),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [15:0] count_out\n);\n    parameter MAX_COUNT = 10000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [15:0] count_out,\n    input [15:0] threshold,\n    output reg pwm_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (count_out < threshold) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry in the chain\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out is the last carry in the chain\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry chain\n\n    // Instantiate 1-bit full adder for the last bit\n    full_adder fa(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    // Instantiate 1-bit full adder for the carry bit\n    full_adder fa_carry(\n        .A(C1),\n        .B(C_in),\n        .C_in(0),\n        .S(C2),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry calculation\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n    parameter MAX_COUNT = 10000; // Maximum count value for the counter\n\n    wire [15:0] counter_out;\n    wire [15:0] duty_cycle_threshold;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = MAX_COUNT * DUTY_CYCLE / 100;\n\n    // Instantiate the comparator module\n    comparator #(.THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_value(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [15:0] count_out\n);\n    parameter MAX_COUNT = 10000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [15:0] count_value,\n    input [15:0] threshold,\n    output reg pwm_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (count_value < threshold) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_5;\n  wire [7:0] shifted_in_6;\n  wire [7:0] shifted_in_7;\n  wire [7:0] shifted_in_8;\n  wire [7:0] shifted_in_9;\n  wire [7:0] shifted_in_10;\n  wire [7:0] shifted_in_11;\n  wire [7:0] shifted_in_12;\n  wire [7:0] shifted_in_13;\n  wire [7:0] shifted_in_14;\n  wire [7:0] shifted_in_15;\n  wire [7:0] shifted_in_16;\n  wire [7:0] shifted_in_17;\n  wire [7:0] shifted_in_18;\n  wire [7:0] shifted_in_19;\n  wire [7:0] shifted_in_20;\n  wire [7:0] shifted_in_21;\n  wire [7:0] shifted_in_22;\n  wire [7:0] shifted_in_23;\n  wire [7:0] shifted_in_24;\n  wire [7:0] shifted_in_25;\n  wire [7:0] shifted_in_26;\n  wire [7:0] shifted_in_27;\n\n  mux2X1 ins_17 (ctrl[2], in, shifted_in_17, shifted_in);\n  mux2X1 ins_16 (ctrl[2], shifted_in_17, shifted_in_16, shifted_in);\n  mux2X1 ins_15 (ctrl[2], shifted_in_16, shifted_in_15, shifted_in);\n  mux2X1 ins_14 (ctrl[2], shifted_in_15, shifted_in_14, shifted_in);\n  mux2X1 ins_13 (ctrl[2], shifted_in_14, shifted_in_13, shifted_in);\n  mux2X1 ins_12 (ctrl[2], shifted_in_13, shifted_in_12, shifted_in);\n  mux2X1 ins_11 (ctrl[2], shifted_in_12, shifted_in_11, shifted_in);\n  mux2X1 ins_10 (ctrl[2], shifted_in_11, shifted_in_10, shifted_in);\n  mux2X1 ins_07 (ctrl[1], shifted_in_10, shifted_in_07, shifted_in);\n  mux2X1 ins_06 (ctrl[1], shifted_in_07, shifted_in_06, shifted_in);\n  mux2X1 ins_05 (ctrl[1], shifted_in_06, shifted_in_05, shifted_in);\n  mux2X1 ins_04 (ctrl[1], shifted_in_05, shifted_in_04, shifted_in);\n  mux2X1 ins_03 (ctrl[1], shifted_in_04, shifted_in_03, shifted_in);\n  mux2X1 ins_02 (ctrl[1], shifted_in_03, shifted_in_02, shifted_in);\n  mux2X1 ins_01 (ctrl[1], shifted_in_02, shifted_in_01, shifted_in);\n  mux2X1 ins_00 (ctrl[0], shifted_in_01, shifted_in_00, shifted_in);\n\n  assign out = shifted_in_00;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[3]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Output carry-out\n    assign C_out = C4[4];\n\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G and P\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Generate C\n    assign C[1] = G[1] | (P[1] & C_in);\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign C[4] = G[4] | (P[4] & C[3]);\n    assign C[5] = G[5] | (P[5] & C[4]);\n\n    // Generate sum\n    assign S = P ^ C_in;\n\n    // Output carry-out\n    assign C_out = C[5];\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    wire c;\n    assign {c, diff} = a - b - bin;\n    assign bout = c;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_value(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output to the comparator output\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] count_value,\n    output reg comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            comparator_out <= 0;\n        end else begin\n            comparator_out <= (count_value < DUTY_CYCLE);\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 100; // Maximum count value for the counter\n\n    wire [7:0] counter_out;\n    wire [7:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_value(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [7:0] count_out\n);\n    parameter MAX_COUNT = 100; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [7:0] count_value,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 50; // Duty cycle threshold for the PWM signal\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (count_value < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire [11:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (MAX_COUNT * DUTY_CYCLE) / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE_THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output reg pwm_out\n);\n    parameter DUTY_CYCLE_THRESHOLD = 500;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 0;\n        end else if (counter_out < DUTY_CYCLE_THRESHOLD) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] borrow;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2, c3, c4; // Carry-out wires\n\n    // Instantiate 4-bit carry-lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2),\n        .S(S[3:3]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(c3),\n        .S(S[4:4]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [3:1] A;      // 4-bit input A\n    input [3:1] B;      // 4-bit input B\n    input C_in;         // Carry-in input\n    output [3:1] S;     // 4-bit sum output\n    output C_out;       // Carry-out output\n\n    wire c1, c2, c3;    // Carry-out wires\n\n    // Instantiate 2-bit carry-lookahead adders\n    carry_lookahead_2 add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_2 add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    // Instantiate 1-bit carry-lookahead adder\n    carry_lookahead_1 add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2),\n        .S(S[3:3]),\n        .C_out(c3)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c3;\nendmodule\n\nmodule carry_lookahead_2(A, B, C_in, S, C_out);\n    input [2:1] A;      // 2-bit input A\n    input [2:1] B;      // 2-bit input B\n    input C_in;         // Carry-in input\n    output [2:1] S;     // 2-bit sum output\n    output C_out;       // Carry-out output\n\n    wire c1, c2;        // Carry-out wires\n\n    // Instantiate 1-bit carry-lookahead adders\n    carry_lookahead_1 add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_1 add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\nendmodule\n\nmodule carry_lookahead_1(A, B, C_in, S, C_out);\n    input [1:1] A;      // 1-bit input A\n    input [1:1] B;      // 1-bit input B\n    input C_in;         // Carry-in input\n    output [1:1] S;     // 1-bit sum output\n    output C_out;       // Carry-out output\n\n    // Instantiate 1-bit full adder\n    full_adder fa(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;            // Input A\n    input B;            // Input B\n    input C_in;         // Carry-in input\n    output S;           // Sum output\n    output C_out;       // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (B & C_in) | (A & C_in);\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Duty cycle in percentage\n\n    wire [31:0] counter_out;\n    wire [31:0] duty_cycle_threshold;\n\n    // Calculate the duty cycle threshold\n    assign duty_cycle_threshold = (1 << 31) * DUTY_CYCLE / 100;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(1 << 31)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.THRESHOLD(duty_cycle_threshold)) u_comparator (\n        .count_value(counter_out),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [31:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out < MAX_COUNT) begin\n            count_out <= count_out + 1;\n        end else begin\n            count_out <= 0;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input [31:0] count_value,\n    input [31:0] threshold,\n    output reg pwm_out\n);\n    always @(*) begin\n        if (count_value < threshold) begin\n            pwm_out = 1;\n        end else begin\n            pwm_out = 0;\n        end\n    end\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n  wire [7:0] shifted_in_5;\n  wire [7:0] shifted_in_6;\n  wire [7:0] shifted_in_7;\n  wire [7:0] shifted_in_8;\n  wire [7:0] shifted_in_9;\n  wire [7:0] shifted_in_10;\n  wire [7:0] shifted_in_11;\n  wire [7:0] shifted_in_12;\n  wire [7:0] shifted_in_13;\n  wire [7:0] shifted_in_14;\n  wire [7:0] shifted_in_15;\n  wire [7:0] shifted_in_16;\n  wire [7:0] shifted_in_17;\n  wire [7:0] shifted_in_18;\n  wire [7:0] shifted_in_19;\n  wire [7:0] shifted_in_20;\n  wire [7:0] shifted_in_21;\n  wire [7:0] shifted_in_22;\n  wire [7:0] shifted_in_23;\n  wire [7:0] shifted_in_24;\n  wire [7:0] shifted_in_25;\n  wire [7:0] shifted_in_26;\n  wire [7:0] shifted_in_27;\n\n  // Stage 1: Shift by 4\n  mux2X1 ins_00(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(shifted_in_2));\n  mux2X1 ins_01(.sel(ctrl[2]), .in0(shifted_in), .in1(in), .out(shifted_in_3));\n\n  // Stage 2: Shift by 2\n  mux2X1 ins_02(.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(shifted_in_4));\n  mux2X1 ins_03(.sel(ctrl[1]), .in0(shifted_in_3), .in1(shifted_in_2), .out(shifted_in_5));\n\n  // Stage 3: Shift by 1\n  mux2X1 ins_04(.sel(ctrl[0]), .in0(shifted_in_4), .in1(shifted_in_5), .out(shifted_in_6));\n  mux2X1 ins_05(.sel(ctrl[0]), .in0(shifted_in_5), .in1(shifted_in_4), .out(shifted_in_7));\n\n  // Stage 4: Shift by 4\n  mux2X1 ins_06(.sel(ctrl[2]), .in0(shifted_in_6), .in1(shifted_in_7), .out(shifted_in_8));\n  mux2X1 ins_07(.sel(ctrl[2]), .in0(shifted_in_7), .in1(shifted_in_6), .out(shifted_in_9));\n\n  // Stage 5: Shift by 2\n  mux2X1 ins_08(.sel(ctrl[1]), .in0(shifted_in_8), .in1(shifted_in_9), .out(shifted_in_10));\n  mux2X1 ins_09(.sel(ctrl[1]), .in0(shifted_in_9), .in1(shifted_in_8), .out(shifted_in_11));\n\n  // Stage 6: Shift by 1\n  mux2X1 ins_10(.sel(ctrl[0]), .in0(shifted_in_10), .in1(shifted_in_11), .out(shifted_in_12));\n  mux2X1 ins_11(.sel(ctrl[0]), .in0(shifted_in_11), .in1(shifted_in_10), .out(shifted_in_13));\n\n  // Stage 7: Shift by 4\n  mux2X1 ins_12(.sel(ctrl[2]), .in0(shifted_in_12), .in1(shifted_in_13), .out(shifted_in_14));\n  mux2X1 ins_13(.sel(ctrl[2]), .in0(shifted_in_13), .in1(shifted_in_12), .out(shifted_in_15));\n\n  // Stage 8: Shift by 2\n  mux2X1 ins_14(.sel(ctrl[1]), .in0(shifted_in_14), .in1(shifted_in_15), .out(shifted_in_16));\n  mux2X1 ins_15(.sel(ctrl[1]), .in0(shifted_in_15), .in1(shifted_in_14), .out(shifted_in_17));\n\n  // Stage 9: Shift by 1\n  mux2X1 ins_16(.sel(ctrl[0]), .in0(shifted_in_16), .in1(shifted_in_17), .out(shifted_in_18));\n  mux2X1 ins_17(.sel(ctrl[0]), .in0(shifted_in_17), .in1(shifted_in_16), .out(shifted_in_19));\n\n  // Stage 10: Shift by 4\n  mux2X1 ins_18(.sel(ctrl[2]), .in0(shifted_in_18), .in1(shifted_in_19), .out(shifted_in_20));\n  mux2X1 ins_19(.sel(ctrl[2]), .in0(shifted_in_19), .in1(shifted_in_18), .out(shifted_in_21));\n\n  // Stage 11: Shift by 2\n  mux2X1 ins_20(.sel(ctrl[1]), .in0(shifted_in_20), .in1(shifted_in_21), .out(shifted_in_22));\n  mux2X1 ins_21(.sel(ctrl[1]), .in0(shifted_in_21), .in1(shifted_in_20), .out(shifted_in_23));\n\n  // Stage 12: Shift by 1\n  mux2X1 ins_22(.sel(ctrl[0]), .in0(shifted_in_22), .in1(shifted_in_23), .out(shifted_in_24));\n  mux2X1 ins_23(.sel(ctrl[0]), .in0(shifted_in_23), .in1(shifted_in_22), .out(shifted_in_25));\n\n  // Stage 13: Shift by 4\n  mux2X1 ins_24(.sel(ctrl[2]), .in0(shifted_in_24), .in1(shifted_in_25), .out(shifted_in_26));\n  mux2X1 ins_25(.sel(ctrl[2]), .in0(shifted_in_25), .in1(shifted_in_24), .out(shifted_in_27));\n\n  assign out = shifted_in_27;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0;\n  input [7:0] in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit carry lookahead adders\n    cla_4bit add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .S(S[16:1]),\n        .C_out(carry[1])\n    );\n\n    cla_4bit add2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(carry[1]),\n        .S(S[12:1]),\n        .C_out(carry[2])\n    );\n\n    cla_4bit add3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(carry[2]),\n        .S(S[8:1]),\n        .C_out(carry[3])\n    );\n\n    cla_4bit add4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(carry[3]),\n        .S(S[4:1]),\n        .C_out(carry[4])\n    );\n\n    // Combine carry outputs to get final carry-out\n    assign C_out = carry[4];\nendmodule\n\nmodule cla_4bit(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] temp;      // Temporary sum\n    wire [3:1] carry;     // Carry output from each bit\n\n    // 4-bit addition\n    assign {C_out, temp} = A + B + C_in;\n\n    // Carry propagation\n    assign carry[1] = (temp[1] == 1'b1) ? 1'b1 : C_in;\n    assign carry[2] = (temp[2] == 1'b1) ? 1'b1 : carry[1];\n    assign carry[3] = (temp[3] == 1'b1) ? 1'b1 : carry[2];\n    assign carry[4] = (temp[4] == 1'b1) ? 1'b1 : carry[3];\n\n    // Sum output\n    assign S = temp[4:1];\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    wire c;\n    assign {c, diff} = a - b - bin;\n    assign bout = c;\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    wire [11:0] counter_out;\n    wire comparator_out;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE)) u_comparator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .counter_out(counter_out),\n        .comparator_out(comparator_out)\n    );\n\n    // Assign the output signal\n    assign pwm_out = comparator_out;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [11:0] count_out\n);\n    parameter MAX_COUNT = 1000; // Maximum count value for the counter\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule comparator(\n    input clk,\n    input rst_n,\n    input [11:0] counter_out,\n    output comparator_out\n);\n    parameter DUTY_CYCLE = 50; // Default duty cycle of 50%\n\n    reg [7:0] duty_cycle_threshold;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            duty_cycle_threshold <= DUTY_CYCLE;\n        end else begin\n            duty_cycle_threshold <= DUTY_CYCLE;\n        end\n    end\n\n    assign comparator_out = (counter_out < duty_cycle_threshold);\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub_beh b0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub_beh b1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub_beh b2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub_beh b3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub_beh b4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub_beh b5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub_beh b6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub_beh b7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule sub_beh(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  wire [7:0] mux_out_1;\n  wire [7:0] mux_out_2;\n  wire [7:0] mux_out_3;\n  wire [7:0] mux_out_4;\n\n  mux2X1 ins_17(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(mux_out_1));\n  mux2X1 ins_16(.sel(ctrl[2]), .in0(shifted_in), .in1(in), .out(shifted_in_2));\n  mux2X1 ins_15(.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(mux_out_2));\n  mux2X1 ins_14(.sel(ctrl[1]), .in0(shifted_in_3), .in1(shifted_in_4), .out(shifted_in_3));\n  mux2X1 ins_13(.sel(ctrl[0]), .in0(shifted_in_3), .in1(shifted_in_4), .out(mux_out_3));\n  mux2X1 ins_12(.sel(ctrl[0]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_4));\n  mux2X1 ins_11(.sel(ctrl[2]), .in0(mux_out_2), .in1(mux_out_3), .out(mux_out_4));\n  mux2X1 ins_10(.sel(ctrl[2]), .in0(mux_out_3), .in1(mux_out_4), .out(out));\n\n  mux2X1 ins_27(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(mux_out_1));\n  mux2X1 ins_26(.sel(ctrl[2]), .in0(shifted_in), .in1(in), .out(shifted_in_2));\n  mux2X1 ins_25(.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(mux_out_2));\n  mux2X1 ins_24(.sel(ctrl[1]), .in0(shifted_in_3), .in1(shifted_in_4), .out(shifted_in_3));\n  mux2X1 ins_23(.sel(ctrl[0]), .in0(shifted_in_3), .in1(shifted_in_4), .out(mux_out_3));\n  mux2X1 ins_22(.sel(ctrl[0]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_4));\n  mux2X1 ins_21(.sel(ctrl[2]), .in0(mux_out_2), .in1(mux_out_3), .out(mux_out_4));\n  mux2X1 ins_20(.sel(ctrl[2]), .in0(mux_out_3), .in1(mux_out_4), .out(out));\n\n  mux2X1 ins_07(.sel(ctrl[2]), .in0(in), .in1(shifted_in), .out(mux_out_1));\n  mux2X1 ins_06(.sel(ctrl[2]), .in0(shifted_in), .in1(in), .out(shifted_in_2));\n  mux2X1 ins_05(.sel(ctrl[1]), .in0(shifted_in_2), .in1(shifted_in_3), .out(mux_out_2));\n  mux2X1 ins_04(.sel(ctrl[1]), .in0(shifted_in_3), .in1(shifted_in_4), .out(shifted_in_3));\n  mux2X1 ins_03(.sel(ctrl[0]), .in0(shifted_in_3), .in1(shifted_in_4), .out(mux_out_3));\n  mux2X1 ins_02(.sel(ctrl[0]), .in0(shifted_in_4), .in1(shifted_in_3), .out(shifted_in_4));\n  mux2X1 ins_01(.sel(ctrl[2]), .in0(mux_out_2), .in1(mux_out_3), .out(mux_out_4));\n  mux2X1 ins_00(.sel(ctrl[2]), .in0(mux_out_3), .in1(mux_out_4), .out(out));\n\n  assign shifted_in = in << 2;\n  assign shifted_in_3 = shifted_in_2 << 1;\n  assign shifted_in_4 = shifted_in_3 << 1;\n\nendmodule\n\nmodule mux2X1 (sel, in0, in1, out);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the multc signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n\n  // Stage 1: Shift by 4\n  mux2X1 mux1 (stage1, in, in, ctrl[2]);\n\n  // Stage 2: Shift by 2\n  mux2X1 mux2 (stage2, stage1, in, ctrl[1]);\n\n  // Stage 3: Shift by 1\n  mux2X1 mux3 (stage3, stage2, in, ctrl[0]);\n\n  // Stage 4: Shift by 4\n  mux2X1 mux4 (stage4, stage3, stage1, ctrl[2]);\n\n  // Stage 5: Shift by 2\n  mux2X1 mux5 (stage5, stage4, stage2, ctrl[1]);\n\n  // Stage 6: Shift by 1\n  mux2X1 mux6 (stage6, stage5, stage3, ctrl[0]);\n\n  // Stage 7: Shift by 4\n  mux2X1 mux7 (stage7, stage6, stage1, ctrl[2]);\n\n  // Stage 8: Shift by 2\n  mux2X1 mux8 (stage8, stage7, stage2, ctrl[1]);\n\n  // Final output\n  assign out = stage8;\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiating the submodules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Output selection based on multc\nassign y = multc ? unsigned_result : signed_result;\nassign msb = y[63:32];\nassign lsb = y[31:0];\nassign zero = (y == 0);\n\nendmodule\n\n// Submodule for signed multiplication\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Submodule for unsigned multiplication\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:1] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1[1]),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2[2]),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3[3]),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;       // 4-bit input A\n    input [4:1] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [4:1] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [5:1] c;\n\n    // Instantiate 2-bit carry lookahead adders\n    carry_lookahead_2 add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(S[2:1]),\n        .C_out(c[1])\n    );\n\n    carry_lookahead_2 add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c[2]),\n        .S(S[4:3]),\n        .C_out(c[3])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add3(\n        .A(A[5]),\n        .B(B[5]),\n        .C_in(c[3]),\n        .S(S[5]),\n        .C_out(c[4])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add4(\n        .A(A[6]),\n        .B(B[6]),\n        .C_in(c[4]),\n        .S(S[6]),\n        .C_out(c[5])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add5(\n        .A(A[7]),\n        .B(B[7]),\n        .C_in(c[5]),\n        .S(S[7]),\n        .C_out(c[6])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add6(\n        .A(A[8]),\n        .B(B[8]),\n        .C_in(c[6]),\n        .S(S[8]),\n        .C_out(c[7])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add7(\n        .A(A[9]),\n        .B(B[9]),\n        .C_in(c[7]),\n        .S(S[9]),\n        .C_out(c[8])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add8(\n        .A(A[10]),\n        .B(B[10]),\n        .C_in(c[8]),\n        .S(S[10]),\n        .C_out(c[9])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add9(\n        .A(A[11]),\n        .B(B[11]),\n        .C_in(c[9]),\n        .S(S[11]),\n        .C_out(c[10])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add10(\n        .A(A[12]),\n        .B(B[12]),\n        .C_in(c[10]),\n        .S(S[12]),\n        .C_out(c[11])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add11(\n        .A(A[13]),\n        .B(B[13]),\n        .C_in(c[11]),\n        .S(S[13]),\n        .C_out(c[12])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add12(\n        .A(A[14]),\n        .B(B[14]),\n        .C_in(c[12]),\n        .S(S[14]),\n        .C_out(c[13])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add13(\n        .A(A[15]),\n        .B(B[15]),\n        .C_in(c[13]),\n        .S(S[15]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_2(A, B, C_in, S, C_out);\n    input [2:1] A;       // 2-bit input A\n    input [2:1] B;       // 2-bit input B\n    input C_in;          // Carry-in input\n    output [2:1] S;      // 2-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:1] c;\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(1'b0),\n        .S(S[1]),\n        .C_out(c[1])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c[1]),\n        .S(S[2]),\n        .C_out(c[2])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c[2]),\n        .S(S[3]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_1(A, B, C_in, S, C_out);\n    input A;             // 1-bit input A\n    input B;             // 1-bit input B\n    input C_in;          // Carry-in input\n    output S;            // 1-bit sum output\n    output C_out;        // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b_out;\n\n    sub7 S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    sub7 S1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    sub7 S2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    sub7 S3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    sub7 S4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    sub7 S5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    sub7 S6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    sub7 S7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7]; \nendmodule\n\nmodule sub7 (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted;\n\n  // Stage 1: Shift by 4\n  wire [3:0] sel1 = ctrl[2] ? 4'b1111 : 4'b0000;\n  mux2X1 mux16(shifted, in, in, sel1);\n\n  // Stage 2: Shift by 2\n  wire [3:0] sel2 = ctrl[1] ? 4'b1100 : 4'b0000;\n  mux2X1 mux15(shifted, shifted, in, sel2);\n\n  // Stage 3: Shift by 1\n  wire [3:0] sel3 = ctrl[0] ? 4'b1000 : 4'b0000;\n  mux2X1 mux14(shifted, shifted, in, sel3);\n\n  assign out = shifted;\n\nendmodule\n\nmodule mux2X1 (out, in1, in2, sel);\n  input [3:0] sel;\n  input [7:0] in1, in2;\n  output [7:0] out;\n\n  assign out = (sel[3]) ? in1 : in2;\n  assign out = (sel[2]) ? {in1[6:0], in2[7]} : out;\n  assign out = (sel[1]) ? {in1[5:0], in2[7:1]} : out;\n  assign out = (sel[0]) ? {in1[4:0], in2[7:2]} : out;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] mult_signed_result;\nwire [63:0] mult_unsigned_result;\n\n// Instantiate the signed and unsigned multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(mult_signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(mult_unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? mult_unsigned_result : mult_signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[1]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[1]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Carry-out is the carry out of the last adder\n    assign C_out = C4[1];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;      // 4-bit input A\n    input [4:1] B;      // 4-bit input B\n    input C_in;         // Carry-in input\n    output [4:1] S;     // 4-bit sum output\n    output C_out;       // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G, P, and C\n    genvar i;\n    generate\n        for (i = 1; i < 5; i = i + 1) begin: gen_loop\n            assign G[i] = A[i] & B[i];\n            assign P[i] = A[i] ^ B[i];\n            assign C[i] = G[i] | (P[i] & C_in);\n        end\n    endgenerate\n\n    // Sum is the XOR of A and B with carry-in\n    assign S[1] = A[1] ^ B[1] ^ C_in;\n    assign S[2] = A[2] ^ B[2] ^ C[1];\n    assign S[3] = A[3] ^ B[3] ^ C[2];\n    assign S[4] = A[4] ^ B[4] ^ C[3];\n\n    // Carry-out is the carry out of the last bit\n    assign C_out = C[4];\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  mux2X1 ins_17 (.sel(ctrl[2]), .in1(in), .in2(shifted_in), .out(shifted_in_2));\n  mux2X1 ins_16 (.sel(ctrl[1]), .in1(shifted_in_2), .in2(in), .out(shifted_in_3));\n  mux2X1 ins_15 (.sel(ctrl[0]), .in1(shifted_in_3), .in2(shifted_in_2), .out(shifted_in_4));\n\n  mux2X1 ins_14 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_13 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_12 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n\n  mux2X1 ins_11 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_10 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n  mux2X1 ins_07 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_2), .out(shifted_in));\n\n  mux2X1 ins_06 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_05 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_04 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n\n  mux2X1 ins_03 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_02 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_01 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n\n  mux2X1 ins_00 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_27 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_26 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n\n  mux2X1 ins_25 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_24 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_23 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n\n  mux2X1 ins_22 (.sel(ctrl[2]), .in1(in), .in2(shifted_in_2), .out(shifted_in));\n  mux2X1 ins_21 (.sel(ctrl[1]), .in1(shifted_in), .in2(shifted_in_3), .out(shifted_in));\n  mux2X1 ins_20 (.sel(ctrl[0]), .in1(shifted_in), .in2(shifted_in_4), .out(shifted_in));\n\n  assign out = shifted_in;\n\nendmodule\n\nmodule mux2X1 (sel, in1, in2, out);\n  input sel;\n  input [7:0] in1, in2;\n  output [7:0] out;\n\n  assign out = sel ? in2 : in1;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .S(S[16:1]),\n        .C_out(carry[1])\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(carry[1]),\n        .S(S[12:1]),\n        .C_out(carry[2])\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(carry[2]),\n        .S(S[8:1]),\n        .C_out(carry[3])\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(carry[3]),\n        .S(S[4:1]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry\n    assign C_out = carry[4];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] temp;      // Temporary sum\n    wire [5:1] temp_c;    // Temporary carry\n\n    // Sum calculation\n    assign temp = A + B;\n\n    // Carry calculation\n    assign temp_c[1] = (A[1] & B[1]) | (A[1] & C_in) | (B[1] & C_in);\n    assign temp_c[2] = (A[2] & B[2]) | (A[2] & temp_c[1]) | (B[2] & temp_c[1]) | (A[2] & temp_c[2]) | (B[2] & temp_c[2]);\n    assign temp_c[3] = (A[3] & B[3]) | (A[3] & temp_c[2]) | (B[3] & temp_c[2]) | (A[3] & temp_c[3]) | (B[3] & temp_c[3]);\n    assign temp_c[4] = (A[4] & B[4]) | (A[4] & temp_c[3]) | (B[4] & temp_c[3]) | (A[4] & temp_c[4]) | (B[4] & temp_c[4]);\n    assign C_out = temp_c[4];\n\n    // Sum output\n    assign S = temp[4:1];\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = (multc) ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] mult_signed_result;\nwire [63:0] mult_unsigned_result;\n\n// Instantiate the submodules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(mult_signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(mult_unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? mult_unsigned_result : mult_signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Submodule for signed multiplication\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Submodule for unsigned multiplication\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $unsigned(a) * $unsigned(b);\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[3]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Combine carry-out signals\n    assign C_out = C4[4];\n\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] C;          // Carry signals\n\n    // Instantiate 4-bit full adder\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(C[1])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(C[1]),\n        .S(S[2]),\n        .C_out(C[2])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(C[2]),\n        .S(S[3]),\n        .C_out(C[3])\n    );\n\n    // Combine carry-out signals\n    assign C_out = C[3];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in input\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n    input [7:0] in;\n    input [2:0] ctrl;\n    output [7:0] out;\n\n    wire [7:0] shifted_in;\n    wire [7:0] shifted_in_2;\n    wire [7:0] shifted_in_3;\n    wire [7:0] shifted_in_4;\n\n    wire [7:0] shifted_in_2_2;\n    wire [7:0] shifted_in_2_1;\n    wire [7:0] shifted_in_2_0;\n\n    wire [7:0] shifted_in_3_2;\n    wire [7:0] shifted_in_3_1;\n    wire [7:0] shifted_in_3_0;\n\n    wire [7:0] shifted_in_4_2;\n    wire [7:0] shifted_in_4_1;\n    wire [7:0] shifted_in_4_0;\n\n    mux2X1 ins_17 (shifted_in_4_2, shifted_in_4_1, shifted_in_4_0, ctrl[2], shifted_in_4);\n    mux2X1 ins_16 (shifted_in_3_2, shifted_in_3_1, shifted_in_3_0, ctrl[2], shifted_in_3);\n    mux2X1 ins_15 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[1], shifted_in_2);\n    mux2X1 ins_14 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[0], shifted_in);\n\n    mux2X1 ins_13 (shifted_in_3_2, shifted_in_3_1, shifted_in_3_0, ctrl[2], shifted_in_3);\n    mux2X1 ins_12 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[1], shifted_in_2);\n    mux2X1 ins_11 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[0], shifted_in);\n\n    mux2X1 ins_10 (shifted_in_3_2, shifted_in_3_1, shifted_in_3_0, ctrl[2], shifted_in_3);\n    mux2X1 ins_09 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[1], shifted_in_2);\n    mux2X1 ins_08 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[0], shifted_in);\n\n    mux2X1 ins_07 (shifted_in_3_2, shifted_in_3_1, shifted_in_3_0, ctrl[2], shifted_in_3);\n    mux2X1 ins_06 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[1], shifted_in_2);\n    mux2X1 ins_05 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[0], shifted_in);\n\n    mux2X1 ins_04 (shifted_in_3_2, shifted_in_3_1, shifted_in_3_0, ctrl[2], shifted_in_3);\n    mux2X1 ins_03 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[1], shifted_in_2);\n    mux2X1 ins_02 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[0], shifted_in);\n\n    mux2X1 ins_01 (shifted_in_3_2, shifted_in_3_1, shifted_in_3_0, ctrl[2], shifted_in_3);\n    mux2X1 ins_00 (shifted_in_2_2, shifted_in_2_1, shifted_in_2_0, ctrl[1], shifted_in_2);\n\n    assign shifted_in = in << ctrl[2];\n    assign shifted_in_2 = shifted_in << ctrl[1];\n    assign shifted_in_3 = shifted_in_2 << ctrl[0];\n    assign shifted_in_4 = shifted_in_3 << ctrl[0];\n\n    assign shifted_in_2_2 = shifted_in_2 << 2;\n    assign shifted_in_2_1 = shifted_in_2 << 1;\n    assign shifted_in_2_0 = shifted_in_2;\n\n    assign shifted_in_3_2 = shifted_in_3 << 2;\n    assign shifted_in_3_1 = shifted_in_3 << 1;\n    assign shifted_in_3_0 = shifted_in_3;\n\n    assign shifted_in_4_2 = shifted_in_4 << 2;\n    assign shifted_in_4_1 = shifted_in_4 << 1;\n    assign shifted_in_4_0 = shifted_in_4;\n\n    assign out = shifted_in_4_2;\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n    input [7:0] in0, in1;\n    input sel;\n    output [7:0] out;\n\n    assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  // Stage 1: Shift by 4\n  mux2X1 mux_4 (shifted_in, in, ctrl[2]);\n\n  // Stage 2: Shift by 2\n  mux2X1 mux_2 (shifted_in_2, shifted_in, ctrl[1]);\n\n  // Stage 3: Shift by 1\n  mux2X1 mux_1 (shifted_in_3, shifted_in_2, ctrl[0]);\n\n  // Stage 4: Shift by 1\n  mux2X1 mux_1_4 (shifted_in_4, shifted_in_3, ctrl[0]);\n\n  // Final output\n  assign out = shifted_in_4;\n\nendmodule\n\nmodule mux2X1 (out, sel, in0, in1);\n  input sel;\n  input [7:0] in0, in1;\n  output [7:0] out;\n\n  assign out = sel ? in1 : in0;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[4]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Combine carry-outs\n    assign C_out = C1[1] | C2[2] | C3[4] | C4[16];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G, P and C\n    genvar i;\n    generate\n        for (i = 1; i < 5; i = i + 1) begin: gen_loop\n            assign G[i] = A[i] & B[i];\n            assign P[i] = A[i] ^ B[i];\n            assign C[i] = G[i] | (P[i] & C_in);\n        end\n    endgenerate\n\n    // Sum\n    assign S = A ^ B;\n\n    // Carry-out\n    assign C_out = C[5];\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires to hold intermediate results\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Multiplication module for signed numbers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned numbers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the submodules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Submodule for signed multiplication\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Submodule for unsigned multiplication\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "barrel_shifter", "response": "module barrel_shifter (in, ctrl, out);\n  input [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n\n  wire [7:0] shifted_in;\n  wire [7:0] shifted_in_2;\n  wire [7:0] shifted_in_3;\n  wire [7:0] shifted_in_4;\n\n  // Stage 1: Shift by 4 positions\n  mux2X1 mux1(shifted_in, in, ctrl[2], shifted_in_2);\n  mux2X1 mux2(shifted_in_2, shifted_in_2, ctrl[1], shifted_in_3);\n  mux2X1 mux3(shifted_in_3, shifted_in_3, ctrl[0], shifted_in_4);\n\n  // Stage 2: Shift by 2 positions\n  mux2X1 mux4(shifted_in, shifted_in_2, ctrl[2], shifted_in_2);\n  mux2X1 mux5(shifted_in_2, shifted_in_3, ctrl[1], shifted_in_3);\n  mux2X1 mux6(shifted_in_3, shifted_in_4, ctrl[0], shifted_in_4);\n\n  // Stage 3: Shift by 1 position\n  mux2X1 mux7(shifted_in, shifted_in_3, ctrl[2], shifted_in_3);\n  mux2X1 mux8(shifted_in_3, shifted_in_4, ctrl[1], shifted_in_4);\n  mux2X1 mux9(shifted_in_4, shifted_in_4, ctrl[0], shifted_in_4);\n\n  assign out = shifted_in_4;\n\nendmodule\n\nmodule mux2X1 (a, b, sel, out);\n  input a, b, sel;\n  output out;\n\n  assign out = sel ? b : a;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[2]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[4]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Carry-out is the last carry-in from the last adder\n    assign C_out = C4[16];\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;      // Gates for sum and carry\n    wire [4:1] C;          // Carry-in for each bit\n\n    // Generate G and P\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Generate carry-out and sum\n    assign S = P ^ C_in;\n    assign C_out = (P & C_in) | (G & C_in);\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delayed b0 for pe1\n  assign b1 = (rst) ? 16'b0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n// Wires for the submodules\nwire [63:0] signed_result;\nwire [63:0] unsigned_result;\n\n// Instantiate the multiplication modules\nmult_signed mult_signed (\n    .a(a),\n    .b(b),\n    .y(signed_result)\n);\n\nmult_unsigned mult_unsigned (\n    .a(a),\n    .b(b),\n    .y(unsigned_result)\n);\n\n// Select the result based on the control signal\nassign y = multc ? unsigned_result : signed_result;\n\n// Extract the msb and lsb\nassign msb = y[63:32];\nassign lsb = y[31:0];\n\n// Check if the result is zero\nassign zero = (y == 0);\n\nendmodule\n\n// Multiplication module for signed integers\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\n// Multiplication module for unsigned integers\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  assign b1 = rst ? 16'd0 : b0;\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_int;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_int)\n    );\n\n    // Assign the output\n    assign count_out = count;\n    assign overflow = overflow_int;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count_out <= 4'b0000;\n        else if (en)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]   count,\n    output          overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed b0 for pe1\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 16'b0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] borrow;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7]; \nendmodule\n\nmodule full_subtractor(input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out signals from each adder\n\n    // Instantiate 4-bit carry lookahead adders\n    cla_4bit add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    cla_4bit add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    cla_4bit add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2),\n        .S(S[3:3]),\n        .C_out(c3)\n    );\n\n    cla_4bit add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(c3),\n        .S(S[4:4]),\n        .C_out(c4)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c4;\nendmodule\n\nmodule cla_4bit(A, B, C_in, S, C_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out signals from each adder\n\n    // Instantiate 2-bit carry lookahead adders\n    cla_2bit add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    cla_2bit add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c2;\nendmodule\n\nmodule cla_2bit(A, B, C_in, S, C_out);\n    input [2:1] A;         // 2-bit input A\n    input [2:1] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [2:1] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out signal from the adder\n\n    // Instantiate 1-bit carry lookahead adder\n    cla_1bit add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    // Carry-out from the last adder\n    assign C_out = c1;\nendmodule\n\nmodule cla_1bit(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in input\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    // Carry-out from the adder\n    assign C_out = (A & B) | (C_in & (A ^ B));\n    assign S = A ^ B;       // Sum output\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Assign b1 to b0\n  assign b1 = b0;\n\n  // Assign outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n    wire overflow_detected;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next),\n        .overflow(overflow_detected)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg [3:0]    count_out,\n    output reg          overflow\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n            overflow <= 1'b0;\n        end else if (en) begin\n            count_out <= count_out + 1;\n            overflow <= (count_out == 4'b1111);\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed version of b0\n  assign b1 = (rst) ? 0 : b0;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_detection;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_detection)\n    );\n\n    // Assign the output\n    assign count_out = count;\n    assign overflow = overflow_detection;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count_out <= 4'b0000;\n        else if (en)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]   count,\n    output          overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry-lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[1]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[1]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Carry-out is the carry from the last adder\n    assign C_out = C4[1];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G and P\n    assign G = A & B;\n    assign P = A ^ B;\n\n    // Generate C\n    assign C[1] = G[1] | (P[1] & C_in);\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign C[4] = G[4] | (P[4] & C[3]);\n    assign C[5] = G[5] | (P[5] & C[4]);\n\n    // Generate sum\n    assign S = P ^ C_in;\n\n    // Carry-out is the carry from the last carry generation\n    assign C_out = C[5];\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  assign b1 = b0;\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate PEs\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delayed b0 for pe1\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output signals\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed b0 for pe1\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n\n    // Count Control Module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next)\n    );\n\n    // Overflow Detection Module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n    assign overflow = (count_out == 4'b1111);\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delay b0 by one clock cycle\n  assign b1 = rst ? 16'b0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] c;\n\n    // Instantiate 2-bit carry lookahead adders\n    carry_lookahead_2 add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(0),\n        .S(S[2:1]),\n        .C_out(c[1])\n    );\n\n    carry_lookahead_2 add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c[1]),\n        .S(S[4:3]),\n        .C_out(c[2])\n    );\n\n    // Instantiate final 2-bit carry lookahead adder\n    carry_lookahead_2 add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(c[2]),\n        .S(S[5:4]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_2(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(0),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    // Instantiate final 1-bit carry lookahead adder\n    carry_lookahead add2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 1-bit adder\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "accu_v_51", "response": "`timescale 1ns / 1ps\n\nmodule binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n\n    // Count Control Module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Overflow Detection Module\n    overflow_detection u_overflow_detection (\n        .count_in(count_temp),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_in,\n    output              overflow\n);\n\n    assign overflow = (count_in == 4'b1111);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delayed input for pe1\n  assign b1 = (rst) ? 0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] b_out;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b_out[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(b_out[0]), .diff(diff[1]), .bout(b_out[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(b_out[1]), .diff(diff[2]), .bout(b_out[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(b_out[2]), .diff(diff[3]), .bout(b_out[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(b_out[3]), .diff(diff[4]), .bout(b_out[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(b_out[4]), .diff(diff[5]), .bout(b_out[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(b_out[5]), .diff(diff[6]), .bout(b_out[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(b_out[6]), .diff(diff[7]), .bout(b_out[7]));\n\n    assign bout = b_out[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delayed b0 input for pe1\n  assign b1 = (rst) ? 0 : b0;\n\n  // Outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0 (.a(a), .b(b[0]), .p(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .p(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .p(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .p(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] p);\n    assign p = a << b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_left_add SAA0 (.a(a), .b(b[0]), .p(p0));\n    shift_left_add SAA1 (.a(a), .b(b[1]), .p(p1));\n    shift_left_add SAA2 (.a(a), .b(b[2]), .p(p2));\n    shift_left_add SAA3 (.a(a), .b(b[3]), .p(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_left_add(input [3:0] a, input b, output [7:0] p);\n    assign p = a << b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .out(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .out(pe1_out)\n  );\n\n  // Delay b0 by one clock cycle\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 0;\n    else\n      b1 <= b0;\n  end\n\n  // Connect outputs\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] out\n);\n  assign out = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [3:0] c1, c2, c3, c4; // Carry-out signals for each 4-bit block\n\n    // Instantiate 4-bit carry-lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Combine carry-out signals for final carry-out\n    assign C_out = c4;\n\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [3:1] A;       // 4-bit input A\n    input [3:1] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [3:1] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire [4:1] c;        // Carry-out signals for each bit\n\n    // Instantiate 2-bit carry-lookahead adders\n    carry_lookahead_2 add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(c[1])\n    );\n\n    carry_lookahead_2 add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c[1]),\n        .S(S[4:3]),\n        .C_out(c[2])\n    );\n\n    // Combine carry-out signals for final carry-out\n    assign C_out = c[2];\n\nendmodule\n\nmodule carry_lookahead_2(A, B, C_in, S, C_out);\n    input [2:1] A;       // 2-bit input A\n    input [2:1] B;       // 2-bit input B\n    input C_in;          // Carry-in input\n    output [2:1] S;      // 2-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;         // Carry-out signals for each bit\n\n    // Instantiate 1-bit carry-lookahead adder\n    carry_lookahead_1 add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_1 add2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    // Combine carry-out signals for final carry-out\n    assign C_out = c2;\n\nendmodule\n\nmodule carry_lookahead_1(A, B, C_in, S, C_out);\n    input A;             // 1-bit input A\n    input B;             // 1-bit input B\n    input C_in;          // Carry-in input\n    output S;            // 1-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c;              // Carry-out signal\n\n    // Carry-lookahead logic\n    assign C_out = (A & B) | (A & C_in) | (B & C_in);\n    assign S = A ^ B ^ C_in;\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] temp0, temp1, temp2, temp3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .temp(temp0));\n    shift_add SAA1 (.a(a), .b(b[1]), .temp(temp1));\n    shift_add SAA2 (.a(a), .b(b[2]), .temp(temp2));\n    shift_add SAA3 (.a(a), .b(b[3]), .temp(temp3));\n\n    assign product = temp0 + temp1 + temp2 + temp3;\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] temp);\n    assign temp = a << b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_in(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output values\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_in,\n    output              overflow\n);\n\n    assign overflow = (count_in == 4'b1111);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out;\n  wire [31:0] pe1_out;\n\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  assign b1 = rst ? 16'b0 : b0;\n\n  assign c0 = pe0_out;\n  assign c1 = pe1_out;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_and_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_and_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_and_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_and_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_and_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a & {4'b1111, 4'b1110, 4'b1100, 4'b1000} << b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_in(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output values\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_in,\n    output              overflow\n);\n\n    assign overflow = (count_in == 4'b1111);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  reg [15:0] b1_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  // Delayed b0 signal\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 16'b0;\n    else\n      b1_reg <= b0;\n  end\n\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_next;\n    wire overflow_detected;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_next),\n        .overflow(overflow_detected)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_next),\n        .overflow(overflow)\n    );\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out,\n    output             overflow\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output             overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  wire [15:0] b1;\n  wire [31:0] pe0_out, pe1_out;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_out)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_out)\n  );\n\n  // Delay b0 to b1\n  reg [15:0] b1_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1_reg <= 0;\n    else\n      b1_reg <= b0;\n  end\n  assign b1 = b1_reg;\n\nendmodule\n\nmodule processing_element (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0(.a(a[0]), .b(b), .product(p0));\n    shift_add SAA1(.a(a[1]), .b(b), .product(p1));\n    shift_add SAA2(.a(a[2]), .b(b), .product(p2));\n    shift_add SAA3(.a(a[3]), .b(b), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input a, b, output [7:0] product);\n    assign product = a ? b : 0;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire overflow_int;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count(count),\n        .overflow(overflow_int)\n    );\n\n    // Assign the output\n    assign count_out = count;\n    assign overflow = overflow_int;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count_out <= 4'b0000;\n        end else if (en) begin\n            count_out <= count_out + 1;\n        end\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count,\n    output              overflow\n);\n\n    assign overflow = (count == 4'b1111);\n\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] c1, c2, c3, c4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_4 add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .S(S[16:1]),\n        .C_out(c1)\n    );\n\n    carry_lookahead_4 add2(\n        .A(S[16:1]),\n        .B(B[16:1]),\n        .C_in(c1),\n        .S(S[16:1]),\n        .C_out(c2)\n    );\n\n    carry_lookahead_4 add3(\n        .A(S[16:1]),\n        .B(B[16:1]),\n        .C_in(c2),\n        .S(S[16:1]),\n        .C_out(c3)\n    );\n\n    carry_lookahead_4 add4(\n        .A(S[16:1]),\n        .B(B[16:1]),\n        .C_in(c3),\n        .S(S[16:1]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] c;         // Carry-out wire\n\n    // Instantiate 2-bit carry lookahead adders\n    carry_lookahead_2 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c[1])\n    );\n\n    carry_lookahead_2 add2(\n        .A(S[4:1]),\n        .B(B[4:1]),\n        .C_in(c[1]),\n        .S(S[4:1]),\n        .C_out(c[2])\n    );\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add3(\n        .A(S[4:1]),\n        .B(B[4:1]),\n        .C_in(c[2]),\n        .S(S[4:1]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_2(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [1:1] c;         // Carry-out wire\n\n    // Instantiate 1-bit carry lookahead adder\n    carry_lookahead_1 add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(0),\n        .S(S[2:1]),\n        .C_out(c[1])\n    );\n\n    carry_lookahead_1 add2(\n        .A(S[2:1]),\n        .B(B[2:1]),\n        .C_in(c[1]),\n        .S(S[2:1]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule carry_lookahead_1(A, B, C_in, S, C_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    input C_in;           // Carry-in input\n    output [1:1] S;       // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    // Instantiate 1-bit full adder\n    full_adder fa(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .S(S[1:1]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (B & C_in) | (A & C_in); // Carry-out calculation\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count_temp;\n    wire overflow_temp;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count_out(count_temp)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .count_out(count_temp),\n        .overflow(overflow_temp)\n    );\n\n    // Assign the output values\n    assign count_out = count_temp;\n    assign overflow = overflow_temp;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count_out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count_out <= 4'b0000;\n        else if (en)\n            count_out <= count_out + 1;\n    end\n\nendmodule\n\nmodule overflow_detection (\n    input   [3:0]      count_out,\n    output              overflow\n);\n\n    assign overflow = (count_out == 4'b1111);\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [3:0] shifted_a;\n    wire [3:0] shifted_b;\n\n    // Shift A left by 0, 1, 2, 3\n    assign shifted_a[0] = a[0];\n    assign shifted_a[1] = a[0] | a[1];\n    assign shifted_a[2] = a[0] | a[1] | a[2];\n    assign shifted_a[3] = a[0] | a[1] | a[2] | a[3];\n\n    // Shift B left by 0, 1, 2, 3\n    assign shifted_b[0] = b[0];\n    assign shifted_b[1] = b[0] | b[1];\n    assign shifted_b[2] = b[0] | b[1] | b[2];\n    assign shifted_b[3] = b[0] | b[1] | b[2] | b[3];\n\n    // Add A and B shifted by 0, 1, 2, 3\n    wire [7:0] sum0 = shifted_a[0] ? shifted_b[0] : 8'b0;\n    wire [7:0] sum1 = shifted_a[1] ? shifted_b[1] : 8'b0;\n    wire [7:0] sum2 = shifted_a[2] ? shifted_b[2] : 8'b0;\n    wire [7:0] sum3 = shifted_a[3] ? shifted_b[3] : 8'b0;\n\n    // Final sum\n    assign product = sum0 + sum1 + sum2 + sum3;\n\nendmodule\n\nmodule shift_add_assistant(\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] sum);\n\n    assign sum = (a & b) ? 8'b1 : 8'b0;\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n    shift_add SAA0(.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = {8{b}} & {8{a}};\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] C1, C2, C3, C4;\n\n    // Instantiate 4-bit carry lookahead adders\n    carry_lookahead_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(C1)\n    );\n\n    carry_lookahead_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(C1[1]),\n        .S(S[8:5]),\n        .C_out(C2)\n    );\n\n    carry_lookahead_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(C2[1]),\n        .S(S[12:9]),\n        .C_out(C3)\n    );\n\n    carry_lookahead_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(C3[1]),\n        .S(S[16:13]),\n        .C_out(C4)\n    );\n\n    // Output carry\n    assign C_out = C4[1];\nendmodule\n\nmodule carry_lookahead_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [5:1] G, P;\n    wire [5:1] C;\n\n    // Generate G and P\n    genvar i;\n    generate\n        for (i = 1; i < 5; i = i + 1) begin: gen_loop\n            assign G[i] = A[i] & B[i];\n            assign P[i] = A[i] ^ B[i];\n        end\n    endgenerate\n\n    // Generate C\n    assign C[1] = G[1] | (P[1] & C_in);\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign C[4] = G[4] | (P[4] & C[3]);\n    assign C_out = C[5];\n\n    // Generate S\n    assign S[1] = P[1] ^ C_in;\n    assign S[2] = P[2] ^ C[1];\n    assign S[3] = P[3] ^ C[2];\n    assign S[4] = P[4] ^ C[3];\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_res;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .alu_res(alu_res), .op(op));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .rd(rd));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      instr_reg <= instr_mem[pc_reg];\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg, rs2_reg, rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[15:11];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_res\n);\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_res_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_res_reg <= rs1 + rs2;\n        6'b001010: alu_res_reg <= rs1 - rs2;\n        default: alu_res_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= alu_res;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file[rd] <= 0;\n    end\n  end\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(x_parity));\n    parity_8bit gen2(.X(Y), .P(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of X\n    assign x_parity = ^X;\n\n    // Output the parity\n    assign P = x_parity;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .product(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .product(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .product(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .product(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] product);\n    assign product = a << b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;       // 8-bit input\n    output p;             // Parity output\n\n    wire [7:0] x_parity;  // Parity of X\n\n    // Compute the parity of X\n    assign p = ^x;\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0 (.a(a), .b(b[0]), .p(p0));\n    shift_add SAA1 (.a(a), .b(b[1]), .p(p1));\n    shift_add SAA2 (.a(a), .b(b[2]), .p(p2));\n    shift_add SAA3 (.a(a), .b(b[3]), .p(p3));\n\n    assign product = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] p);\n    assign p = a << b;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result, sub_result, and_result, or_result;\n\nadd_module add (.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract (.a(operand_a), .b(operand_b), .result(sub_result));\nbitwise_and_module and (.a(operand_a), .b(operand_b), .result(and_result));\nbitwise_or_module or (.a(operand_a), .b(operand_b), .result(or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case(op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= sub_result;\n            `AND_OP: result <= and_result;\n            `OR_OP: result <= or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] p0, p1, p2, p3;\n\n    shift_add SAA0(.a(a), .b(b[0]), .p(p0));\n    shift_add SAA1(.a(a), .b(b[1]), .p(p1));\n    shift_add SAA2(.a(a), .b(b[2]), .p(p2));\n    shift_add SAA3(.a(a), .b(b[3]), .p(p3));\n\n    assign product = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule shift_add(input [3:0] a, input b, output [7:0] p);\n    assign p = {8{b}} & {8{a}};\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Output parity\n\n    wire [7:0] gen1;     // Output of first generator\n    wire [7:0] gen2;     // Output of second generator\n\n    // Instantiate two 8-bit parity generators\n    parity_8bit gen1_inst(.X(X), .P(gen1));\n    parity_8bit gen2_inst(.X(Y), .P(gen2));\n\n    // Compute the final parity of the combined 16 bits\n    assign P = gen1 ^ gen2;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Output parity\n\n    wire [7:0] gen1;     // Output of first generator\n    wire [7:0] gen2;     // Output of second generator\n\n    // Instantiate two 4-bit parity generators\n    parity_4bit gen1_inst(.X(X[3:0]), .P(gen1));\n    parity_4bit gen2_inst(.X(X[7:4]), .P(gen2));\n\n    // Compute the final parity of the combined 8 bits\n    assign P = gen1 ^ gen2;\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output P;            // Output parity\n\n    wire [3:0] gen1;     // Output of first generator\n    wire [3:0] gen2;     // Output of second generator\n\n    // Instantiate two 2-bit parity generators\n    parity_2bit gen1_inst(.X(X[1:0]), .P(gen1));\n    parity_2bit gen2_inst(.X(X[3:2]), .P(gen2));\n\n    // Compute the final parity of the combined 4 bits\n    assign P = gen1 ^ gen2;\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output P;            // Output parity\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (control_signal) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUB: result <= subtract_result;\n            `AND: result <= bitwise_and_result;\n            `OR: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] p1, p2; // Parity outputs from 8-bit generators\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(p1)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(p2)\n    );\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Parity output\n\n    wire [7:0] p1, p2; // Parity outputs from 4-bit generators\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(\n        .X(X[3:0]),\n        .P(p1)\n    );\n\n    parity_4bit gen2(\n        .X(X[7:4]),\n        .P(p2)\n    );\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;      // 4-bit input X\n    output P;           // Parity output\n\n    wire p1, p2;         // Parity outputs from 2-bit generators\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(\n        .X(X[1:0]),\n        .P(p1)\n    );\n\n    parity_2bit gen2(\n        .X(X[3:2]),\n        .P(p2)\n    );\n\n    // Compute the final parity\n    assign P = p1 ^ p2;\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;      // 2-bit input X\n    output P;           // Parity output\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] x_parity;\n    wire [7:0] y_parity;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the final parity of X and Y\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;      // 8-bit input X\n    output p;           // Parity output\n\n    wire [7:0] x_parity;\n\n    // Compute the parity of X\n    assign p = ^x;\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case(op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (control_signal) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(x_parity)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(y_parity)\n    );\n\n    // Compute the parity of the combined 16 bits\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of X\n    assign x_parity = ^X;\n\n    // Output the parity\n    assign P = x_parity;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUBTRACT 2'b01\n`define BITWISE_AND 2'b10\n`define BITWISE_OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUBTRACT: result <= subtract_result;\n            `BITWISE_AND: result <= bitwise_and_result;\n            `BITWISE_OR: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] alu_result;\n  wire [31:0] next_pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(next_pc));\n  decode_stage decode (.clk(clk), .rst(rst), .alu_result(alu_result), .reg_file(reg_file), .instr(fetch.instr));\n  execute_stage execute (.clk(clk), .rst(rst), .alu_result(alu_result), .reg_file(reg_file), .alu_result(execute.alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(execute.alu_result), .memory_result(memory.memory_result));\n  writeback_stage writeback (.clk(clk), .rst(rst), .alu_result(memory.memory_result), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\n  // Update program counter\n  assign next_pc = fetch.pc + 4;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] instr\n);\n  reg [31:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      pc_reg <= pc;\n      instr_reg <= instr_mem[pc_reg];\n    end\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  input [31:0] instr,\n  output [31:0] alu_result\n);\n  reg [31:0] rs1;\n  reg [31:0] rs2;\n  reg [31:0] rd;\n  reg [31:0] op;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= instr[25:21];\n      rs2 <= instr[20:16];\n      rd <= instr[15:11];\n      op <= instr[31:26];\n    end\n  end\n\n  assign alu_result = (op == 6'b000000) ? (reg_file[rs1] + reg_file[rs2]) : (reg_file[rs1] - reg_file[rs2]);\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  output [31:0] alu_result\n);\n  reg [31:0] alu_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result_reg <= 0;\n    end else begin\n      alu_result_reg <= alu_result;\n    end\n  end\n\n  assign alu_result = alu_result_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output [31:0] memory_result\n);\n  reg [31:0] memory_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      memory_result_reg <= 0;\n    end else begin\n      memory_result_reg <= alu_result;\n    end\n  end\n\n  assign memory_result = memory_result_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[0] <= 0;\n      res_reg_file_reg[1] <= 0;\n      res_reg_file_reg[2] <= 0;\n      res_reg_file_reg[3] <= 0;\n      res_reg_file_reg[4] <= 0;\n      res_reg_file_reg[5] <= 0;\n      res_reg_file_reg[6] <= 0;\n      res_reg_file_reg[7] <= 0;\n      res_reg_file_reg[8] <= 0;\n      res_reg_file_reg[9] <= 0;\n      res_reg_file_reg[10] <= 0;\n      res_reg_file_reg[11] <= 0;\n      res_reg_file_reg[12] <= 0;\n      res_reg_file_reg[13] <= 0;\n      res_reg_file_reg[14] <= 0;\n      res_reg_file_reg[15] <= 0;\n      res_reg_file_reg[16] <= 0;\n      res_reg_file_reg[17] <= 0;\n      res_reg_file_reg[18] <= 0;\n      res_reg_file_reg[19] <= 0;\n      res_reg_file_reg[20] <= 0;\n      res_reg_file_reg[21] <= 0;\n      res_reg_file_reg[22] <= 0;\n      res_reg_file_reg[23] <= 0;\n      res_reg_file_reg[24] <= 0;\n      res_reg_file_reg[25] <= 0;\n      res_reg_file_reg[26] <= 0;\n      res_reg_file_reg[27] <= 0;\n      res_reg_file_reg[28] <= 0;\n      res_reg_file_reg[29] <= 0;\n      res_reg_file_reg[30] <= 0;\n      res_reg_file_reg[31] <= 0;\n    end else begin\n      res_reg_file_reg[0] <= alu_result;\n      res_reg_file_reg[1] <= reg_file[1];\n      res_reg_file_reg[2] <= reg_file[2];\n      res_reg_file_reg[3] <= reg_file[3];\n      res_reg_file_reg[4] <= reg_file[4];\n      res_reg_file_reg[5] <= reg_file[5];\n      res_reg_file_reg[6] <= reg_file[6];\n      res_reg_file_reg[7] <= reg_file[7];\n      res_reg_file_reg[8] <= reg_file[8];\n      res_reg_file_reg[9] <= reg_file[9];\n      res_reg_file_reg[10] <= reg_file[10];\n      res_reg_file_reg[11] <= reg_file[11];\n      res_reg_file_reg[12] <= reg_file[12];\n      res_reg_file_reg[13] <= reg_file[13];\n      res_reg_file_reg[14] <= reg_file[14];\n      res_reg_file_reg[15] <= reg_file[15];\n      res_reg_file_reg[16] <= reg_file[16];\n      res_reg_file_reg[17] <= reg_file[17];\n      res_reg_file_reg[18] <= reg_file[18];\n      res_reg_file_reg[19] <= reg_file[19];\n      res_reg_file_reg[20] <= reg_file[20];\n      res_reg_file_reg[21] <= reg_file[21];\n      res_reg_file_reg[22] <= reg_file[22];\n      res_reg_file_reg[23] <= reg_file[23];\n      res_reg_file_reg[24] <= reg_file[24];\n      res_reg_file_reg[25] <= reg_file[25];\n      res_reg_file_reg[26] <= reg_file[26];\n      res_reg_file_reg[27] <= reg_file[27];\n      res_reg_file_reg[28] <= reg_file[28];\n      res_reg_file_reg[29] <= reg_file[29];\n      res_reg_file_reg[30] <= reg_file[30];\n      res_reg_file_reg[31] <= reg_file[31];\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Output parity\n\n    wire [7:0] x_parity;\n    wire [7:0] y_parity;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the even parity of the combined 16 bits\n    assign P = ^(x_parity ^ y_parity);\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;      // 8-bit input X\n    output p;           // Output parity\n\n    wire [7:0] x_parity;\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(.x(x[7:4]), .p(x_parity[3]));\n    parity_4bit gen2(.x(x[3:0]), .p(x_parity[0]));\n\n    // Compute the even parity of the 8 bits\n    assign p = ^(x_parity);\n\nendmodule\n\nmodule parity_4bit(x, p);\n    input [3:0] x;      // 4-bit input X\n    output p;           // Output parity\n\n    wire [3:0] x_parity;\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(.x(x[3:2]), .p(x_parity[1]));\n    parity_2bit gen2(.x(x[1:0]), .p(x_parity[0]));\n\n    // Compute the even parity of the 4 bits\n    assign p = ^(x_parity);\n\nendmodule\n\nmodule parity_2bit(x, p);\n    input [1:0] x;      // 2-bit input X\n    output p;           // Output parity\n\n    wire x_parity;\n\n    // Compute the even parity of the 2 bits\n    assign p = ^(x);\n\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Output parity\n\n    wire [7:0] parity_x;\n    wire [7:0] parity_y;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(parity_x));\n    parity_8bit gen2(.x(Y), .p(parity_y));\n\n    // Compute the final parity\n    assign P = ^(parity_x ^ parity_y);\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;      // 8-bit input x\n    output p;           // Output parity\n\n    wire [7:0] parity_x;\n\n    // Compute the parity of x\n    assign parity_x = ^x;\n\n    // Output the parity\n    assign p = parity_x;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Parity output\n\n    wire [7:0] x_parity;\n    wire [7:0] y_parity;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(x_parity)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(y_parity)\n    );\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Parity output\n\n    wire [7:0] x_parity;\n\n    // Compute the parity of each bit\n    assign x_parity = X[0] ^ X[1] ^ X[2] ^ X[3] ^ X[4] ^ X[5] ^ X[6] ^ X[7];\n\n    // Output the parity\n    assign P = x_parity;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] alu_result;\n  wire [31:0] next_pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(next_pc)\n  );\n\n  decode_stage decode (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.instr),\n    .alu_result(alu_result)\n  );\n\n  execute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .reg_file(reg_file),\n    .result(res_reg_file)\n  );\n\n  memory_stage memory (\n    .clk(clk),\n    .rst(rst),\n    .alu_result(alu_result),\n    .result(res_reg_file)\n  );\n\n  writeback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .result(res_reg_file),\n    .pc(next_pc)\n  );\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] instr,\n  output [31:0] pc\n);\n  assign instr = instr_mem[pc];\n  assign pc = pc + 1;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [31:0] alu_result\n);\n  // Decode instruction\n  wire [4:0] rs1, rs2, rd;\n  wire [1:0] op;\n  assign {rs1, rs2, rd, op} = instr;\n\n  // Perform operation\n  wire [31:0] rs1_val, rs2_val;\n  assign rs1_val = reg_file[rs1];\n  assign rs2_val = reg_file[rs2];\n  assign alu_result = (op == 2'b00) ? rs1_val + rs2_val : rs1_val - rs2_val;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] reg_file [0:31],\n  output [31:0] result [0:31]\n);\n  // Execute instruction\n  assign result[rd] = alu_result;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [31:0] result [0:31]\n);\n  // Memory stage\n  assign result[rd] = alu_result;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] result [0:31],\n  output [31:0] reg_file [0:31],\n  output [31:0] pc\n);\n  // Writeback stage\n  assign reg_file[rd] = result[rd];\n  assign pc = pc + 1;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(x_parity));\n    parity_8bit gen2(.X(Y), .P(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of X\n    assign x_parity = ^X;\n\n    // Assign the parity to the output\n    assign P = x_parity;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        count_out <= count;\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;       // 8-bit input\n    output p;             // Parity output\n\n    wire [7:0] x_parity;  // Parity of x\n\n    // Compute the parity of x\n    assign p = ^x;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(control_signal),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;      // 8-bit input X\n    input [7:0] Y;      // 8-bit input Y\n    output P;           // Output parity\n\n    wire [7:0] even_parity_x;\n    wire [7:0] even_parity_y;\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(\n        .X(X),\n        .P(even_parity_x)\n    );\n\n    parity_8bit gen2(\n        .X(Y),\n        .P(even_parity_y)\n    );\n\n    // Compute the final parity\n    assign P = even_parity_x ^ even_parity_y;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;      // 8-bit input X\n    output P;           // Output parity\n\n    wire [7:0] even_parity;\n\n    // Compute even parity\n    assign even_parity = X[0] ^ X[1] ^ X[2] ^ X[3] ^ X[4] ^ X[5] ^ X[6] ^ X[7];\n\n    // Output parity\n    assign P = even_parity;\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.X(X), .P(x_parity));\n    parity_8bit gen2(.X(Y), .P(y_parity));\n\n    // Compute the final parity\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(X, P);\n    input [7:0] X;       // 8-bit input X\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Instantiate 4-bit parity generators\n    parity_4bit gen1(.X(X[3:0]), .P(x_parity[3:0]));\n    parity_4bit gen2(.X(X[7:4]), .P(x_parity[7:4]));\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3] ^ x_parity[4] ^ x_parity[5] ^ x_parity[6] ^ x_parity[7];\n\nendmodule\n\nmodule parity_4bit(X, P);\n    input [3:0] X;       // 4-bit input X\n    output P;            // Parity output\n\n    wire [3:0] x_parity; // Parity of X\n\n    // Instantiate 2-bit parity generators\n    parity_2bit gen1(.X(X[1:0]), .P(x_parity[1:0]));\n    parity_2bit gen2(.X(X[3:2]), .P(x_parity[3:2]));\n\n    // Compute the final parity\n    assign P = x_parity[0] ^ x_parity[1] ^ x_parity[2] ^ x_parity[3];\n\nendmodule\n\nmodule parity_2bit(X, P);\n    input [1:0] X;       // 2-bit input X\n    output P;            // Parity output\n\n    assign P = X[0] ^ X[1]; // Compute parity\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the parity of the combined 16 bits\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;       // 8-bit input\n    output p;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of the 8-bit input\n    assign p = ^x;\n\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n`define PC_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [31:0] fetch_out;\nwire [31:0] decode_out;\nwire [31:0] execute_out;\nwire [31:0] memory_out;\nwire [31:0] writeback_out;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(fetch_out));\ndecode_stage decode(.clk(clk), .rst(rst), .decode_in(fetch_out), .decode_out(decode_out));\nexecute_stage execute(.clk(clk), .rst(rst), .execute_in(decode_out), .execute_out(execute_out));\nmemory_stage memory(.clk(clk), .rst(rst), .memory_in(execute_out), .memory_out(memory_out));\nwriteback_stage writeback(.clk(clk), .rst(rst), .writeback_in(memory_out), .writeback_out(writeback_out), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] fetch_out\n);\n  reg [31:0] pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      fetch_out <= 0;\n    end else begin\n      fetch_out <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] decode_in,\n  output reg [31:0] decode_out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      decode_out <= 0;\n    end else begin\n      decode_out <= decode_in;\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] execute_in,\n  output reg [31:0] execute_out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      execute_out <= 0;\n    end else begin\n      execute_out <= execute_in;\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] memory_in,\n  output reg [31:0] memory_out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      memory_out <= 0;\n    end else begin\n      memory_out <= memory_in;\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] writeback_in,\n  output reg [31:0] writeback_out,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_temp [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      writeback_out <= 0;\n      res_reg_file_temp <= 0;\n      res_reg_file <= 0;\n    end else begin\n      writeback_out <= writeback_in;\n      res_reg_file_temp[0] <= reg_file[0];\n      res_reg_file_temp[1] <= reg_file[1];\n      res_reg_file_temp[2] <= reg_file[2];\n      res_reg_file_temp[3] <= reg_file[3];\n      res_reg_file_temp[4] <= reg_file[4];\n      res_reg_file_temp[5] <= reg_file[5];\n      res_reg_file_temp[6] <= reg_file[6];\n      res_reg_file_temp[7] <= reg_file[7];\n      res_reg_file_temp[8] <= reg_file[8];\n      res_reg_file_temp[9] <= reg_file[9];\n      res_reg_file_temp[10] <= reg_file[10];\n      res_reg_file_temp[11] <= reg_file[11];\n      res_reg_file_temp[12] <= reg_file[12];\n      res_reg_file_temp[13] <= reg_file[13];\n      res_reg_file_temp[14] <= reg_file[14];\n      res_reg_file_temp[15] <= reg_file[15];\n      res_reg_file_temp[16] <= reg_file[16];\n      res_reg_file_temp[17] <= reg_file[17];\n      res_reg_file_temp[18] <= reg_file[18];\n      res_reg_file_temp[19] <= reg_file[19];\n      res_reg_file_temp[20] <= reg_file[20];\n      res_reg_file_temp[21] <= reg_file[21];\n      res_reg_file_temp[22] <= reg_file[22];\n      res_reg_file_temp[23] <= reg_file[23];\n      res_reg_file_temp[24] <= reg_file[24];\n      res_reg_file_temp[25] <= reg_file[25];\n      res_reg_file_temp[26] <= reg_file[26];\n      res_reg_file_temp[27] <= reg_file[27];\n      res_reg_file_temp[28] <= reg_file[28];\n      res_reg_file_temp[29] <= reg_file[29];\n      res_reg_file_temp[30] <= reg_file[30];\n      res_reg_file_temp[31] <= reg_file[31];\n      res_reg_file <= res_reg_file_temp;\n    end\n  end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        count_out <= count;\n    end\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n    input [7:0] X;       // 8-bit input X\n    input [7:0] Y;       // 8-bit input Y\n    output P;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n    wire [7:0] y_parity; // Parity of Y\n\n    // Instantiate 8-bit parity generators\n    parity_8bit gen1(.x(X), .p(x_parity));\n    parity_8bit gen2(.x(Y), .p(y_parity));\n\n    // Compute the parity of the combined 16 bits\n    assign P = x_parity ^ y_parity;\n\nendmodule\n\nmodule parity_8bit(x, p);\n    input [7:0] x;       // 8-bit input X\n    output p;            // Parity output\n\n    wire [7:0] x_parity; // Parity of X\n\n    // Compute the parity of X\n    assign p = ^x;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(control_signal),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        if (reset) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module bitwise_and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module bitwise_or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case(op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders for each nibble\n    full_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    full_adder add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    full_adder add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2),\n        .S(S[3:3]),\n        .C_out(c3)\n    );\n\n    full_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(c3),\n        .S(S[4:4]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry from the last full adder\n    assign C_out = c4;\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;     // Inputs\n    output S, C_out;      // Outputs\n\n    assign S = A ^ B ^ C_in; // Sum\n    assign C_out = (A & B) | (B & C_in) | (A & C_in); // Carry-out\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate counter register\n    counter_register u_counter_register (\n        .clk(clk),\n        .toggle(toggle),\n        .count(count),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire toggle,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (toggle) begin\n            count <= next_count;\n        end else begin\n            count <= 0;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic module\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .count(next_count),\n        .count_out(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    output reg [31:0] count\n);\n    always @(*) begin\n        if (toggle) begin\n            count = count + 1;\n        end else begin\n            count = 0;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] count,\n    output reg [31:0] count_out\n);\n    always @(posedge clk) begin\n        if (control_signal) begin\n            count_out <= count;\n        end else begin\n            count_out <= 0;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd add_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(add_result)\n);\n\nsubtract subtract_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(subtract_result)\n);\n\nbitwise_and bitwise_and_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_and_result)\n);\n\nbitwise_or bitwise_or_module (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_or_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD: result <= add_result;\n            `SUB: result <= subtract_result;\n            `AND: result <= bitwise_and_result;\n            `OR: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a + b;\nendmodule\n\nmodule subtract(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(input [31:0] a, input [31:0] b, output [31:0] result);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_res;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .alu_res(alu_res));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .rd(rd));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      instr_reg <= 0;\n    end else begin\n      instr_reg <= instr_mem[pc_reg];\n      pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign instr = instr_reg;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[10:6];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  output [31:0] alu_res,\n  input [5:0] op\n);\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_res_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_res_reg <= rs1 + rs2;\n        6'b001010: alu_res_reg <= rs1 - rs2;\n        default: alu_res_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= alu_res;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= res_reg_file[rd];\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Combine the carry chain to get the final carry-out\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [3:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Combine the carry chain to get the final carry-out\n    assign C_out = carry[2];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C_out_2;          // Carry-out from the second adder\n\n    // Instantiate the 1-bit full adder for the final bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C_out_2)\n    );\n\n    // Combine the carry chain to get the final carry-out\n    assign C_out = C_out_2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the output based on the op_code\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add (\n    .a(operand_a),\n    .b(operand_b),\n    .result(add_result)\n);\n\nsubtract_module subtract (\n    .a(operand_a),\n    .b(operand_b),\n    .result(subtract_result)\n);\n\nbitwise_and_module bitwise_and (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_and_result)\n);\n\nbitwise_or_module bitwise_or (\n    .a(operand_a),\n    .b(operand_b),\n    .result(bitwise_or_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Check for zero result\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry wire for 4-bit adders\n\n    // Instantiate 4-bit full adders for each nibble\n    nibble_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .S(S[16:1]),\n        .C_out(carry[0])\n    );\n\n    nibble_adder add2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .S(S[12:4]),\n        .C_out(carry[1])\n    );\n\n    nibble_adder add3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .S(S[8:8]),\n        .C_out(carry[2])\n    );\n\n    nibble_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .S(S[4:4]),\n        .C_out(carry[3])\n    );\n\n    // Combine carry bits to get final carry-out\n    assign C_out = carry[0] | carry[1] | carry[2] | carry[3];\nendmodule\n\nmodule nibble_adder(A, B, S, C_out);\n    input [4:1] A;         // 4-bit input A\n    input [4:1] B;         // 4-bit input B\n    output [4:1] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [2:0] carry;      // Carry wire for 2-bit adders\n\n    // Instantiate 2-bit full adders for each nibble\n    two_bit_adder add1(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .S(S[4:3]),\n        .C_out(carry[0])\n    );\n\n    two_bit_adder add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .S(S[2:2]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .S(S[1:1]),\n        .C_out(carry[2])\n    );\n\n    // Combine carry bits to get final carry-out\n    assign C_out = carry[0] | carry[1] | carry[2];\nendmodule\n\nmodule two_bit_adder(A, B, S, C_out);\n    input [2:1] A;         // 2-bit input A\n    input [2:1] B;         // 2-bit input B\n    output [2:1] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry wires for 1-bit adders\n\n    // Instantiate 1-bit full adders for each bit\n    one_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .S(S[2:1]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .S(S[1:1]),\n        .C_out(C2)\n    );\n\n    // Combine carry bits to get final carry-out\n    assign C_out = C1 | C2;\nendmodule\n\nmodule one_bit_adder(A, B, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign {C_out, S} = A + B;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine the zero output\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [5:0] next_pc;\nwire [31:0] instr;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\nwire [31:0] alu_res;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .next_pc(next_pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .op(op), .alu_res(alu_res));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .rd(rd), .res_reg_file(res_reg_file), .next_pc(next_pc), .pc(pc));\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [5:0] next_pc,\n  output [31:0] instr\n);\n  reg [5:0] pc_reg;\n  reg [5:0] next_pc_reg;\n  reg [31:0] instr_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc_reg <= 0;\n      next_pc_reg <= 0;\n      instr_reg <= 0;\n    end\n    else begin\n      pc_reg <= next_pc_reg;\n      instr_reg <= instr_mem[pc_reg];\n      next_pc_reg <= pc_reg + 1;\n    end\n  end\n\n  assign pc = pc_reg;\n  assign next_pc = next_pc_reg;\n  assign instr = instr_reg;\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  reg [4:0] rs1_reg;\n  reg [4:0] rs2_reg;\n  reg [4:0] rd_reg;\n  reg [5:0] op_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      rd_reg <= 0;\n      op_reg <= 0;\n    end\n    else begin\n      rs1_reg <= instr[20:16];\n      rs2_reg <= instr[15:11];\n      rd_reg <= instr[10:6];\n      op_reg <= instr[31:26];\n    end\n  end\n\n  assign rs1 = rs1_reg;\n  assign rs2 = rs2_reg;\n  assign rd = rd_reg;\n  assign op = op_reg;\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_res\n);\n  reg [31:0] rs1_reg;\n  reg [31:0] rs2_reg;\n  reg [31:0] alu_res_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_reg <= 0;\n      rs2_reg <= 0;\n      alu_res_reg <= 0;\n    end\n    else begin\n      rs1_reg <= rs1;\n      rs2_reg <= rs2;\n      case (op)\n        6'b000000: alu_res_reg <= rs1_reg + rs2_reg;\n        6'b001010: alu_res_reg <= rs1_reg - rs2_reg;\n        default: alu_res_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_res = alu_res_reg;\nendmodule\n\n// Memory stage\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  output [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [4:0] rd_reg;\n  reg [31:0] alu_res_reg;\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rd_reg <= 0;\n      alu_res_reg <= 0;\n      res_reg_file_reg <= 0;\n    end\n    else begin\n      rd_reg <= 0;\n      alu_res_reg <= alu_res;\n      res_reg_file_reg[rd_reg] <= alu_res_reg;\n    end\n  end\n\n  assign rd = rd_reg;\n  assign res_reg_file = res_reg_file_reg;\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [4:0] rd,\n  input [31:0] res_reg_file [0:31],\n  input [5:0] pc,\n  output [5:0] next_pc\n);\n  reg [5:0] next_pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc_reg <= 0;\n    end\n    else begin\n      res_reg_file[rd] <= res_reg_file[rd] + 1;\n      next_pc_reg <= pc + 1;\n    end\n  end\n\n  assign next_pc = next_pc_reg;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff;\n    wire [31:0] and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry wire for each 4-bit addition\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[2]),\n        .S(S[7:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[3]),\n        .S(S[11:8]),\n        .C_out(carry[4])\n    );\n\n    four_bit_adder add5(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .C_in(carry[4]),\n        .S(S[15:12]),\n        .C_out(carry[5])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[5];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [3:1] carry;      // Carry wire for each bit\n\n    // Instantiate 4-bit half adder for each bit\n    half_adder ha1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(carry[1])\n    );\n\n    half_adder ha2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(carry[1]),\n        .S(S[1]),\n        .C_out(carry[2])\n    );\n\n    half_adder ha3(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(carry[2]),\n        .S(S[2]),\n        .C_out(carry[3])\n    );\n\n    half_adder ha4(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(carry[3]),\n        .S(S[3]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[4];\nendmodule\n\nmodule half_adder(A, B, C_in, S, C_out);\n    input A, B, C_in;     // Inputs\n    output S, C_out;      // Outputs\n\n    assign S = A ^ B ^ C_in; // Sum\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\nwire [31:0] add_result;\nwire [31:0] subtract_result;\nwire [31:0] bitwise_and_result;\nwire [31:0] bitwise_or_result;\n\nadd_module add(.a(operand_a), .b(operand_b), .result(add_result));\nsubtract_module subtract(.a(operand_a), .b(operand_b), .result(subtract_result));\nbitwise_and_module and(.a(operand_a), .b(operand_b), .result(bitwise_and_result));\nbitwise_or_module or(.a(operand_a), .b(operand_b), .result(bitwise_or_result));\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= subtract_result;\n            `AND_OP: result <= bitwise_and_result;\n            `OR_OP: result <= bitwise_or_result;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtract_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\nwire [5:0] pc;\nwire [5:0] next_pc;\nwire [31:0] instr;\nwire [31:0] alu_res;\nwire [4:0] rs1, rs2, rd;\nwire [5:0] op;\n\n// Instantiate pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\nexecute_stage execute(.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .op(op), .alu_res(alu_res));\nmemory_stage memory(.clk(clk), .rst(rst), .alu_res(alu_res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .next_pc(next_pc));\n\n// Update program counter\nalways @(posedge clk or posedge rst) begin\n  if (rst)\n    pc <= 0;\n  else\n    pc <= next_pc;\nend\n\nendmodule\n\n// Pipeline stages\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [5:0] pc,\n  output [31:0] instr\n);\n  assign instr = instr_mem[pc];\n  assign pc = pc + 1;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign {op, rs2, rs1, rd} = instr;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_res\n);\n  assign alu_res = (op == 6'b000000) ? rs1 + rs2 : rs1 - rs2;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_res,\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  assign res_reg_file[rd] = alu_res;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [5:0] next_pc,\n  output [5:0] pc\n);\n  assign pc = next_pc;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Operation selection\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Zero detection\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4;\nassign lt = lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = eq_slice1 & eq_slice2;\nassign gt = gt_slice1 & gt_slice2;\nassign lt = lt_slice1 & lt_slice2;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit0, eq_bit1;\nwire gt_bit0, gt_bit1;\nwire lt_bit0, lt_bit1;\n\nassign eq_bit0 = (a[0] == b[0]);\nassign eq_bit1 = (a[1] == b[1]);\n\nassign gt_bit0 = (a[0] > b[0]);\nassign gt_bit1 = (a[1] > b[1]);\n\nassign lt_bit0 = (a[0] < b[0]);\nassign lt_bit1 = (a[1] < b[1]);\n\nassign eq = eq_bit0 & eq_bit1;\nassign gt = gt_bit0 & gt_bit1;\nassign lt = lt_bit0 & lt_bit1;\n\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c4;\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;         // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last full adder\n    assign C_out = c2;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    input C_in;           // Carry-in input\n    output [1:0] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;              // Carry-out wire\n\n    // Instantiate 1-bit full adder for the final bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the final full adder\n    assign C_out = c1;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] fetch_res;\n  wire [31:0] decode_res;\n  wire [31:0] execute_res;\n  wire [31:0] memory_res;\n  wire [31:0] writeback_res;\n\n  // Instantiate the pipeline stages\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .res_reg_file(res_reg_file));\n  decode_stage decode(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .fetch_res(fetch_res));\n  execute_stage execute(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .decode_res(decode_res));\n  memory_stage memory(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .execute_res(execute_res));\n  writeback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .memory_res(memory_res));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] res_reg_file [0:31]\n);\n  reg [31:0] pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      res_reg_file[0] <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  output reg [31:0] decode_res\n);\n  reg [5:0] rs1;\n  reg [5:0] rs2;\n  reg [5:0] rd;\n  reg [5:0] op;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= res_reg_file[1];\n      rs2 <= res_reg_file[2];\n      rd <= res_reg_file[3];\n      op <= res_reg_file[4];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  output reg [31:0] execute_res\n);\n  reg [31:0] rs1_val;\n  reg [31:0] rs2_val;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_val <= 0;\n      rs2_val <= 0;\n      execute_res <= 0;\n    end else begin\n      rs1_val <= res_reg_file[rs1];\n      rs2_val <= res_reg_file[rs2];\n      if (op == 6'b000000) begin // Addition\n        execute_res <= rs1_val + rs2_val;\n      end else if (op == 6'b001010) begin // Subtraction\n        execute_res <= rs1_val - rs2_val;\n      end\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  output reg [31:0] memory_res\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      memory_res <= 0;\n    end else begin\n      memory_res <= res_reg_file[5];\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  output reg [31:0] writeback_res\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      writeback_res <= 0;\n    end else begin\n      res_reg_file[rd] <= writeback_res;\n    end\n  end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .result(or_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] fetched_instr;\n  wire [31:0] decoded_instr;\n  wire [31:0] executed_result;\n  wire [31:0] memory_result;\n  wire [31:0] writeback_result;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr));\n  decode_stage decode (.clk(clk), .rst(rst), .decoded_instr(fetched_instr), .decoded_instr(decoded_instr));\n  execute_stage execute (.clk(clk), .rst(rst), .decoded_instr(decoded_instr), .executed_result(executed_result));\n  memory_stage memory (.clk(clk), .rst(rst), .executed_result(executed_result), .memory_result(memory_result));\n  writeback_stage writeback (.clk(clk), .rst(rst), .memory_result(memory_result), .reg_file(reg_file), .writeback_result(writeback_result));\n\n  // Connect pipeline registers\n  assign res_reg_file = writeback_result;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] fetched_instr\n);\n  reg [31:0] pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\n\n  assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] decoded_instr,\n  output [31:0] decoded_instr\n);\n  // Decode instruction\n  assign decoded_instr = decoded_instr;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] decoded_instr,\n  output [31:0] executed_result\n);\n  // Execute instruction\n  assign executed_result = decoded_instr;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] executed_result,\n  output [31:0] memory_result\n);\n  // Memory stage\n  assign memory_result = executed_result;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] memory_result,\n  input [31:0] reg_file [0:31],\n  output [31:0] writeback_result\n);\n  // Writeback stage\n  assign writeback_result = memory_result;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry wire for each 4-bit addition\n\n    // Instantiate 4-bit full adders for each 4-bit chunk\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [3:0] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [4:1] carry;     // Carry wire for each bit\n\n    // Instantiate 2-bit full adders for each bit\n    two_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(carry[1]),\n        .S(S[1]),\n        .C_out(carry[2])\n    );\n\n    two_bit_adder add3(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(carry[2]),\n        .S(S[2]),\n        .C_out(carry[3])\n    );\n\n    two_bit_adder add4(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(carry[3]),\n        .S(S[3]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input A;              // 2-bit input A\n    input B;              // 2-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry wires for each bit\n\n    // Instantiate 1-bit full adders for each bit\n    one_bit_adder add1(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(C1),\n        .B(0),\n        .C_in(0),\n        .S(C2),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in input\n    output S;             // 1-bit sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry calculation\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Output the result based on the operation selected\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Output the zero flag\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] pc;\n  wire [31:0] next_pc;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiating pipeline stages\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .next_pc(next_pc));\n  decode_stage decode(.clk(clk), .rst(rst), .pc(pc), .instr_mem(instr_mem), .alu_result(alu_result), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute(.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .alu_result(alu_result), .rd(rd), .op(op), .alu_result(alu_result));\n  memory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .res_reg_file(res_reg_file));\n  writeback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .reg_file(reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] next_pc\n);\n  assign pc = 0;\n  assign next_pc = pc + 1;\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] pc,\n  input [31:0] instr_mem [0:31],\n  output [31:0] alu_result,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign alu_result = instr_mem[pc];\n  assign {op, rs2, rs1, rd} = alu_result;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [31:0] alu_result,\n  input [4:0] rd,\n  input [5:0] op,\n  output [31:0] alu_result\n);\n  reg [31:0] alu_result_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      alu_result_reg <= 0;\n    else begin\n      case (op)\n        6'b000000: alu_result_reg <= alu_result + reg_file[rs1] + reg_file[rs2];\n        6'b001010: alu_result_reg <= alu_result - reg_file[rs1] - reg_file[rs2];\n        default: alu_result_reg <= 0;\n      endcase\n    end\n  end\n  assign alu_result = alu_result_reg;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output [31:0] res_reg_file [0:31]\n);\n  assign res_reg_file = alu_result;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [31:0] reg_file [0:31]\n);\n  reg [31:0] reg_file_reg [0:31];\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      reg_file_reg <= 0;\n    else\n      reg_file_reg <= res_reg_file;\n  end\n  assign reg_file = reg_file_reg;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1, c2;           // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in input\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire c1;               // Carry-out wire\n\n    // Instantiate 1-bit full adder for the last bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c1;\n\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in input\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\n\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq_slice1;\nwire [3:0] eq_slice2;\nwire [3:0] eq_slice3;\nwire [3:0] eq_slice4;\n\nwire [3:0] gt_slice1;\nwire [3:0] gt_slice2;\nwire [3:0] gt_slice3;\nwire [3:0] gt_slice4;\n\nwire [3:0] lt_slice1;\nwire [3:0] lt_slice2;\nwire [3:0] lt_slice3;\nwire [3:0] lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire eq0;\nwire gt0;\nwire lt0;\n\ncomparator_4bit_slice comp_slice1(.a(a[0]), .b(b[0]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_4bit_slice comp_slice2(.a(a[1]), .b(b[1]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_4bit_slice comp_slice3(.a(a[2]), .b(b[2]), .eq(eq0), .gt(gt0), .lt(lt0));\ncomparator_4bit_slice comp_slice4(.a(a[3]), .b(b[3]), .eq(eq0), .gt(gt0), .lt(lt0));\n\nassign eq = eq0;\nassign gt = gt0;\nassign lt = lt0;\n\nendmodule\n\nmodule comparator_4bit_slice(a, b, eq, gt, lt);\ninput a;\ninput b;\noutput eq;\noutput gt;\noutput lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Control logic to select the operation\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result : or_result;\n\n    // Check for zero result\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry output from each 4-bit adder\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C_in(carry[1]),\n        .S(S[7:4]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .C_in(carry[2]),\n        .S(S[11:8]),\n        .C_out(carry[3])\n    );\n\n    // Combine the carry outputs to get the final carry-out\n    assign C_out = carry[3];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in input\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:0] sum;        // 5-bit sum\n\n    // Perform the addition\n    assign {C_out, sum} = A + B + C_in;\n\n    // Output the sum\n    assign S = sum[3:0];\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4;\nassign lt = lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = eq_slice1 & eq_slice2;\nassign gt = gt_slice1 & gt_slice2;\nassign lt = lt_slice1 & lt_slice2;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] fetched_instr;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr));\n  decode_stage decode (.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute (.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op), .alu_result(alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(alu_result), .res_reg_file(res_reg_file));\n  writeback_stage writeback (.clk(clk), .rst(rst), .reg_file(reg_file), .res_reg_file(res_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] fetched_instr\n);\n  reg [31:0] pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      fetched_instr <= 0;\n    end else begin\n      fetched_instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd,\n  output reg [5:0] op\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n      op <= 0;\n    end else begin\n      rs1 <= fetched_instr[25:21];\n      rs2 <= fetched_instr[20:16];\n      rd <= fetched_instr[15:11];\n      op <= fetched_instr[31:26];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output reg [31:0] alu_result\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_result <= reg_file[rs1] + reg_file[rs2];\n        6'b000100: alu_result <= reg_file[rs1] - reg_file[rs2];\n        default: alu_result <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[0] <= alu_result;\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] reg_file [0:31],\n  input [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      reg_file <= 0;\n    end else begin\n      reg_file[0] <= res_reg_file[0];\n    end\n  end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] S;     // 16-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2, c3, c4; // Carry-out wires\n\n    // Instantiate 4-bit full adders for each nibble\n    nibble_adder add1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(1'b0),\n        .S(S[1:1]),\n        .C_out(c1)\n    );\n\n    nibble_adder add2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(c1),\n        .S(S[2:2]),\n        .C_out(c2)\n    );\n\n    nibble_adder add3(\n        .A(A[3:3]),\n        .B(B[3:3]),\n        .C_in(c2),\n        .S(S[3:3]),\n        .C_out(c3)\n    );\n\n    nibble_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(c3),\n        .S(S[4:4]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\nendmodule\n\nmodule nibble_adder(A, B, C_in, S, C_out);\n    input A;\n    input B;\n    input C_in;\n    output S;\n    output C_out;\n\n    wire c1, c2;\n\n    full_adder fa1(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .S(S),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(c1),\n        .B(1'b0),\n        .C_in(1'b0),\n        .S(c2),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;\n    input B;\n    input C_in;\n    output S;\n    output C_out;\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq1, gt1, lt1;\nwire [3:0] eq2, gt2, lt2;\nwire [3:0] eq3, gt3, lt3;\nwire [3:0] eq4, gt4, lt4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq1), .gt(gt1), .lt(lt1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq2), .gt(gt2), .lt(lt2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq3), .gt(gt3), .lt(lt3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq4), .gt(gt4), .lt(lt4));\n\n// Combine outputs from slices\nassign eq = eq1 & eq2 & eq3 & eq4;\nassign gt = gt1 & gt2 & gt3 & gt4;\nassign lt = lt1 & lt2 & lt3 & lt4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [1:0] eq1, gt1, lt1;\nwire [1:0] eq2, gt2, lt2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq1), .gt(gt1), .lt(lt1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq2), .gt(gt2), .lt(lt2));\n\n// Combine outputs from slices\nassign eq = eq1[0] & eq2[0];\nassign gt = gt1[0] & gt2[0];\nassign lt = lt1[0] & lt2[0];\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a;\ninput [1:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire eq0, gt0, lt0;\n\n// Instantiate 1-bit comparator\ncomparator_1bit comp_slice1(.a(a[0]), .b(b[0]), .eq(eq0), .gt(gt0), .lt(lt0));\n\n// Combine outputs from slices\nassign eq = eq0;\nassign gt = gt0;\nassign lt = lt0;\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a;\ninput b;\noutput eq;\noutput gt;\noutput lt;\n\nassign eq = a == b;\nassign gt = a > b;\nassign lt = a < b;\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n  wire [31:0] fetched_instr;\n  wire [31:0] alu_result;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr));\n  decode_stage decode(.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute(.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op), .alu_result(alu_result));\n  memory_stage memory(.clk(clk), .rst(rst), .alu_result(alu_result), .res_reg_file(res_reg_file));\n  writeback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .reg_file(reg_file));\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] fetched_instr\n);\n  reg [31:0] pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      pc <= 0;\n    else\n      pc <= pc + 1;\n  end\n\n  assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  always @* begin\n    rs1 = fetched_instr[25:20];\n    rs2 = fetched_instr[15:10];\n    rd = fetched_instr[4:0];\n    op = fetched_instr[31:26];\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  input [5:0] op,\n  output [31:0] alu_result\n);\n  reg [31:0] rs1_val, rs2_val;\n\n  always @* begin\n    rs1_val = reg_file[rs1];\n    rs2_val = reg_file[rs2];\n  end\n\n  always @* begin\n    case (op)\n      6'b000000: alu_result = rs1_val + rs2_val;\n      6'b001010: alu_result = rs1_val - rs2_val;\n      default: alu_result = 32'b0;\n    endcase\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output [31:0] res_reg_file [0:31]\n);\n  always @* begin\n    res_reg_file[0] = alu_result;\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [31:0] reg_file [0:31]\n);\n  reg [31:0] rd_val;\n\n  always @* begin\n    rd_val = res_reg_file[0];\n  end\n\n  always @* begin\n    reg_file[rd] = rd_val;\n  end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Select the operation based on the control signal\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Intermediate carry signals\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry signal\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Intermediate carry signals\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out is the last carry signal\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Intermediate carry signals\n\n    // Instantiate 1-bit full adder for each bit\n    full_adder fa1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    full_adder fa2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry signal\n    assign C_out = C2;\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;               // Input A\n    input B;               // Input B\n    input C_in;            // Carry-in\n    output S;              // Sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND logic module\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR logic module\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    // Output logic\n    assign result = (op_code == 2'b00) ? sum :\n                    (op_code == 2'b01) ? diff :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq_slice1;\nwire [3:0] eq_slice2;\nwire [3:0] eq_slice3;\nwire [3:0] eq_slice4;\n\nwire [3:0] gt_slice1;\nwire [3:0] gt_slice2;\nwire [3:0] gt_slice3;\nwire [3:0] gt_slice4;\n\nwire [3:0] lt_slice1;\nwire [3:0] lt_slice2;\nwire [3:0] lt_slice3;\nwire [3:0] lt_slice4;\n\n// Instantiating 4-bit comparator slices\ncomparator_4bit comp_slice1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .eq(eq_slice1),\n    .gt(gt_slice1),\n    .lt(lt_slice1)\n);\n\ncomparator_4bit comp_slice2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .eq(eq_slice2),\n    .gt(gt_slice2),\n    .lt(lt_slice2)\n);\n\ncomparator_4bit comp_slice3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .eq(eq_slice3),\n    .gt(gt_slice3),\n    .lt(lt_slice3)\n);\n\ncomparator_4bit comp_slice4(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .eq(eq_slice4),\n    .gt(gt_slice4),\n    .lt(lt_slice4)\n);\n\n// Combining outputs from slices\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4;\nassign lt = lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [1:0] eq_slice1;\nwire [1:0] eq_slice2;\n\nwire [1:0] gt_slice1;\nwire [1:0] gt_slice2;\n\nwire [1:0] lt_slice1;\nwire [1:0] lt_slice2;\n\n// Instantiating 2-bit comparator slices\ncomparator_2bit comp_slice1(\n    .a(a[1:0]),\n    .b(b[1:0]),\n    .eq(eq_slice1),\n    .gt(gt_slice1),\n    .lt(lt_slice1)\n);\n\ncomparator_2bit comp_slice2(\n    .a(a[3:2]),\n    .b(b[3:2]),\n    .eq(eq_slice2),\n    .gt(gt_slice2),\n    .lt(lt_slice2)\n);\n\n// Combining outputs from slices\nassign eq = eq_slice1[0] & eq_slice2[0];\nassign gt = gt_slice1[0] & gt_slice2[0];\nassign lt = lt_slice1[0] & lt_slice2[0];\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a;\ninput [1:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] fetched_instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_result;\n  wire [31:0] next_pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(next_pc), .fetched_instr(fetched_instr));\n  decode_stage decode (.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute (.clk(clk), .rst(rst), .rs1(reg_file[rs1]), .rs2(reg_file[rs2]), .op(op), .alu_result(alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(alu_result), .res_reg_file(res_reg_file));\n  writeback_stage writeback (.clk(clk), .rst(rst), .rd(rd), .res_reg_file(res_reg_file), .next_pc(next_pc));\n\nendmodule\n\n// Fetch stage\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output [31:0] pc,\n  output [31:0] fetched_instr\n);\n  reg [31:0] current_pc;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      current_pc <= 0;\n    end else begin\n      current_pc <= current_pc + 1;\n    end\n  end\n\n  assign pc = current_pc;\n  assign fetched_instr = instr_mem[pc];\nendmodule\n\n// Decode stage\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [5:0] op,\n  output [31:0] rd\n);\n  assign {rd, op, rs2, rs1} = fetched_instr;\nendmodule\n\n// Execute stage\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [31:0] rs1,\n  input [31:0] rs2,\n  input [5:0] op,\n  output [31:0] alu_result\n);\n  reg [31:0] alu_result_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      alu_result_reg <= 0;\n    end else begin\n      case (op)\n        6'b000000: alu_result_reg <= rs1 + rs2;\n        6'b000010: alu_result_reg <= rs1 - rs2;\n        default: alu_result_reg <= 0;\n      endcase\n    end\n  end\n\n  assign alu_result = alu_result_reg;\nendmodule\n\n// Memory stage\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output [31:0] res_reg_file [0:31]\n);\n  assign res_reg_file = alu_result;\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [4:0] rd,\n  input [31:0] res_reg_file [0:31],\n  output [31:0] next_pc\n);\n  reg [31:0] next_pc_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      next_pc_reg <= 0;\n    end else begin\n      next_pc_reg <= next_pc_reg + 1;\n    end\n  end\n\n  assign next_pc = next_pc_reg;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(1'b0),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(c1),\n        .S(S[4:2]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c2),\n        .S(S[8:5]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c3),\n        .S(S[12:9]),\n        .C_out(c4)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c4;\n\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    input C_in;          // Carry-in input\n    output [3:0] S;      // 4-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1, c2;         // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(C_in),\n        .S(S[1:0]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(c1),\n        .S(S[3:2]),\n        .C_out(c2)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c2;\n\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    input C_in;          // Carry-in input\n    output [1:0] S;      // 2-bit sum output\n    output C_out;        // Carry-out output\n\n    wire c1;             // Carry-out wire\n\n    // Instantiate 1-bit full adder for the last bit\n    full_adder fa(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(c1)\n    );\n\n    // Carry-out is the carry-out of the last adder\n    assign C_out = c1;\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;             // Input A\n    input B;             // Input B\n    input C_in;          // Carry-in input\n    output S;            // Sum output\n    output C_out;        // Carry-out output\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | (C_in & (A ^ B)); // Carry-out calculation\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n\n    assign result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n\n    assign result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n\n    assign result = a ^ b;\n\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] fetched_instr;\n  wire [4:0] rs1, rs2, rd;\n  wire [5:0] op;\n  wire [31:0] alu_result;\n  wire [31:0] next_pc;\n\n  // Instantiate pipeline stages\n  fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(next_pc), .fetched_instr(fetched_instr));\n  decode_stage decode (.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .rs1(rs1), .rs2(rs2), .rd(rd), .op(op));\n  execute_stage execute (.clk(clk), .rst(rst), .rs1(rs1), .rs2(rs2), .op(op), .reg_file(reg_file), .alu_result(alu_result));\n  memory_stage memory (.clk(clk), .rst(rst), .alu_result(alu_result), .memory_result(alu_result));\n  writeback_stage writeback (.clk(clk), .rst(rst), .alu_result(alu_result), .rd(rd), .res_reg_file(res_reg_file));\n\n  // Update program counter\n  assign next_pc = fetched_instr[31:28] ? fetched_instr[27:2] : fetched_instr[25:2];\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] pc,\n  output [31:0] fetched_instr\n);\n  assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] fetched_instr,\n  output [4:0] rs1,\n  output [4:0] rs2,\n  output [4:0] rd,\n  output [5:0] op\n);\n  assign {op, rs2, rs1, rd} = fetched_instr;\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [5:0] op,\n  input [31:0] reg_file [0:31],\n  output [31:0] alu_result\n);\n  reg [31:0] rs1_val, rs2_val;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      rs1_val <= 0;\n      rs2_val <= 0;\n    end else begin\n      rs1_val <= reg_file[rs1];\n      rs2_val <= reg_file[rs2];\n    end\n  end\n\n  assign alu_result = (op == 6'b000000) ? rs1_val + rs2_val : rs1_val - rs2_val;\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  output [31:0] memory_result\n);\n  assign memory_result = alu_result;\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] alu_result,\n  input [4:0] rd,\n  output [31:0] res_reg_file [0:31]\n);\n  reg [31:0] res_reg_file_reg [0:31];\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= alu_result;\n    end\n  end\n\n  assign res_reg_file = res_reg_file_reg;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry wire for each 4-bit block\n\n    // Instantiate 4-bit full adders for each 4-bit block\n    four_bit_adder add1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(0),\n        .S(S[16:1]),\n        .C_out(carry[0])\n    );\n\n    four_bit_adder add2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .C_in(carry[0]),\n        .S(S[12:4]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .C_in(carry[1]),\n        .S(S[8:8]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(carry[2]),\n        .S(S[4:4]),\n        .C_out(carry[3])\n    );\n\n    // Output carry\n    assign C_out = carry[3];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:0] carry;     // Carry wire for each bit\n\n    // Instantiate 2-bit full adders for each bit\n    two_bit_adder add1(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(C_in),\n        .S(S[4:3]),\n        .C_out(carry[0])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[0]),\n        .S(S[3:2]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add3(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(carry[1]),\n        .S(S[2:1]),\n        .C_out(carry[2])\n    );\n\n    two_bit_adder add4(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(carry[2]),\n        .S(S[1:1]),\n        .C_out(carry[3])\n    );\n\n    // Output carry\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire C1, C2;          // Carry wires for each bit\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .S(S[2:1]),\n        .C_out(C1)\n    );\n\n    one_bit_adder add2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C1),\n        .S(S[1:1]),\n        .C_out(C2)\n    );\n\n    // Output carry\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A, B;           // Inputs\n    input C_in;           // Carry-in\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiating 4-bit comparator slices\ncomparator_4bit comp_slice1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .eq(eq_slice1),\n    .gt(gt_slice1),\n    .lt(lt_slice1)\n);\n\ncomparator_4bit comp_slice2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .eq(eq_slice2),\n    .gt(gt_slice2),\n    .lt(lt_slice2)\n);\n\ncomparator_4bit comp_slice3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .eq(eq_slice3),\n    .gt(gt_slice3),\n    .lt(lt_slice3)\n);\n\ncomparator_4bit comp_slice4(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .eq(eq_slice4),\n    .gt(gt_slice4),\n    .lt(lt_slice4)\n);\n\n// Combining outputs from slices\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiating 2-bit comparator slices\ncomparator_2bit comp_slice1(\n    .a(a[1:0]),\n    .b(b[1:0]),\n    .eq(eq_slice1),\n    .gt(gt_slice1),\n    .lt(lt_slice1)\n);\n\ncomparator_2bit comp_slice2(\n    .a(a[3:2]),\n    .b(b[3:2]),\n    .eq(eq_slice2),\n    .gt(gt_slice2),\n    .lt(lt_slice2)\n);\n\n// Combining outputs from slices\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit0, eq_bit1;\nwire gt_bit0, gt_bit1;\nwire lt_bit0, lt_bit1;\n\n// Instantiating 1-bit comparator slices\ncomparator_1bit comp_slice1(\n    .a(a[0]),\n    .b(b[0]),\n    .eq(eq_bit0),\n    .gt(gt_bit0),\n    .lt(lt_bit0)\n);\n\ncomparator_1bit comp_slice2(\n    .a(a[1]),\n    .b(b[1]),\n    .eq(eq_bit1),\n    .gt(gt_bit1),\n    .lt(lt_bit1)\n);\n\n// Combining outputs from slices\nassign eq = (eq_bit0 & eq_bit1);\nassign gt = (gt_bit0 & gt_bit1);\nassign lt = (lt_bit0 & lt_bit1);\n\nendmodule\n\nmodule comparator_1bit(a, b, eq, gt, lt);\ninput a, b;\noutput eq, gt, lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n\n    assign xor_result = a ^ b;\n\nendmodule"}
{"task_id": "stagepipe5", "response": "`define WORD_SIZE 32\n`define REG_SIZE 32\n`define PC_SIZE 32\n`define INSTR_SIZE 32\n`define REG_FILE_SIZE 32\n`define INSTR_MEM_SIZE 32\n\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n// Pipeline stages\nfetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(pc), .instr(instr));\ndecode_stage decode(.clk(clk), .rst(rst), .instr(instr), .pc(pc), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd));\nexecute_stage execute(.clk(clk), .rst(rst), .op(op), .rs1(rs1), .rs2(rs2), .rd(rd), .res(res));\nmemory_stage memory(.clk(clk), .rst(rst), .res(res), .rd(rd), .res_reg_file(res_reg_file));\nwriteback_stage writeback(.clk(clk), .rst(rst), .res_reg_file(res_reg_file), .reg_file(reg_file));\n\n// Pipeline registers\nreg [31:0] pc;\nreg [31:0] instr;\nreg [4:0] op;\nreg [4:0] rs1;\nreg [4:0] rs2;\nreg [4:0] rd;\nreg [31:0] res;\n\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  output reg [31:0] pc,\n  output reg [31:0] instr\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      instr <= 0;\n    end else begin\n      instr <= instr_mem[pc];\n      pc <= pc + 1;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n  input clk,\n  input rst,\n  input [31:0] instr,\n  output reg [31:0] pc,\n  output reg [4:0] op,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [4:0] rd\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n      op <= 0;\n      rs1 <= 0;\n      rs2 <= 0;\n      rd <= 0;\n    end else begin\n      op <= instr[6:0];\n      rs1 <= instr[15:11];\n      rs2 <= instr[20:16];\n      rd <= instr[25:21];\n    end\n  end\nendmodule\n\nmodule execute_stage(\n  input clk,\n  input rst,\n  input [4:0] op,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [4:0] rd,\n  output reg [31:0] res\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res <= 0;\n    end else begin\n      case (op)\n        6'b000000: res <= reg_file[rs1] + reg_file[rs2];\n        6'b001010: res <= reg_file[rs1] - reg_file[rs2];\n        default: res <= 0;\n      endcase\n    end\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input rst,\n  input [31:0] res,\n  output reg [31:0] res_reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file <= 0;\n    end else begin\n      res_reg_file[rd] <= res;\n    end\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input rst,\n  input [31:0] res_reg_file [0:31],\n  input [31:0] reg_file [0:31],\n  output reg [31:0] reg_file [0:31]\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      reg_file <= 0;\n    end else begin\n      reg_file[rd] <= res_reg_file[rd];\n    end\n  end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;  // Carry-out wires\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;          // Carry-out wires\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c1),\n        .S(S[4:3]),\n        .C_out(c2)\n    );\n\n    // 2-bit full adder for the last 2 bits\n    assign {C_out, S[2:1]} = A[2:1] + B[2:1] + C_in;\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    assign {C_out, S} = A + B + C_in;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4;\nassign lt = lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = eq_slice1 & eq_slice2;\nassign gt = gt_slice1 & gt_slice2;\nassign lt = lt_slice1 & lt_slice2;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set zero flag if result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b_reg0, b_reg1, b_reg2;\n\n  // Assign delayed values to PEs\n  assign pe1.b_delayed = b_reg0;\n  assign pe2.b_delayed = b_reg1;\n  assign pe3.b_delayed = b_reg2;\n\n  // Update registers\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b_reg0 <= 0;\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n    end\n    else begin\n      b_reg0 <= b0;\n      b_reg1 <= b_reg0;\n      b_reg2 <= b_reg1;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if(rst)\n      c_reg <= 0;\n    else\n      c_reg <= a * b;\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the submodules\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4", "response": "wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  // Instantiate PEs\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  processing_element pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  processing_element pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\n  // Delay b0, b1, b2, b3\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end\n    else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2, c3, c4;\n\n    // Instantiate 4-bit full adders for each 4 bits\n    four_bit_adder add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    four_bit_adder add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    four_bit_adder add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    four_bit_adder add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in input\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1, c2;\n\n    // Instantiate 2-bit full adders for each 2 bits\n    two_bit_adder add1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(1'b0),\n        .S(S[2:1]),\n        .C_out(c1)\n    );\n\n    two_bit_adder add2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(c1),\n        .S(S[4:3]),\n        .C_out(c2)\n    );\n\n    // Instantiate 1-bit full adder for the last bit\n    one_bit_adder add3(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c2),\n        .S(S[4]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in input\n    output [2:1] S;       // 2-bit sum output\n    output C_out;         // Carry-out output\n\n    wire c1;\n\n    // Instantiate 1-bit full adder for each bit\n    one_bit_adder add1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(1'b0),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    one_bit_adder add2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in input\n    output S;             // Sum output\n    output C_out;         // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq_slice1;\nwire [3:0] gt_slice1;\nwire [3:0] lt_slice1;\n\nwire [3:0] eq_slice2;\nwire [3:0] gt_slice2;\nwire [3:0] lt_slice2;\n\nwire [3:0] eq_slice3;\nwire [3:0] gt_slice3;\nwire [3:0] lt_slice3;\n\nwire [3:0] eq_slice4;\nwire [3:0] gt_slice4;\nwire [3:0] lt_slice4;\n\n// Instantiating the 4-bit comparator slices\ncomparator_4bit comp_slice1(\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .eq(eq_slice1),\n    .gt(gt_slice1),\n    .lt(lt_slice1)\n);\n\ncomparator_4bit comp_slice2(\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .eq(eq_slice2),\n    .gt(gt_slice2),\n    .lt(lt_slice2)\n);\n\ncomparator_4bit comp_slice3(\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .eq(eq_slice3),\n    .gt(gt_slice3),\n    .lt(lt_slice3)\n);\n\ncomparator_4bit comp_slice4(\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .eq(eq_slice4),\n    .gt(gt_slice4),\n    .lt(lt_slice4)\n);\n\n// Combining the outputs of the slices\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4) ? 1'b1 : 1'b0;\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4) ? 1'b1 : 1'b0;\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\n// Comparing each nibble\nwire eq_0;\nwire gt_0;\nwire lt_0;\nwire eq_1;\nwire gt_1;\nwire lt_1;\nwire eq_2;\nwire gt_2;\nwire lt_2;\nwire eq_3;\nwire gt_3;\nwire lt_3;\n\n// Instantiating the 4-bit comparator\ncomparator_4bit_nibble comp_0(\n    .a(a[0]),\n    .b(b[0]),\n    .eq(eq_0),\n    .gt(gt_0),\n    .lt(lt_0)\n);\n\ncomparator_4bit_nibble comp_1(\n    .a(a[1]),\n    .b(b[1]),\n    .eq(eq_1),\n    .gt(gt_1),\n    .lt(lt_1)\n);\n\ncomparator_4bit_nibble comp_2(\n    .a(a[2]),\n    .b(b[2]),\n    .eq(eq_2),\n    .gt(gt_2),\n    .lt(lt_2)\n);\n\ncomparator_4bit_nibble comp_3(\n    .a(a[3]),\n    .b(b[3]),\n    .eq(eq_3),\n    .gt(gt_3),\n    .lt(lt_3)\n);\n\n// Combining the outputs of the nibbles\nassign eq = (eq_0 & eq_1 & eq_2 & eq_3) ? 1'b1 : 1'b0;\nassign gt = (gt_0 & gt_1 & gt_2 & gt_3) ? 1'b1 : 1'b0;\nassign lt = (lt_0 & lt_1 & lt_2 & lt_3) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule comparator_4bit_nibble(a, b, eq, gt, lt);\ninput a;\ninput b;\noutput eq;\noutput gt;\noutput lt;\n\nassign eq = (a == b) ? 1'b1 : 1'b0;\nassign gt = (a > b) ? 1'b1 : 1'b0;\nassign lt = (a < b) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "systolic1x4", "response": "wire [15:0] b1, b2, b3;\n  reg [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n\n  // Instantiate processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  processing_element pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n  processing_element pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\n  // Delay b0 to b1, b1 to b2, b2 to b3\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n    end else begin\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\n  assign b1 = b0_reg;\n  assign b2 = b1_reg;\n  assign b3 = b2_reg;\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodule instances\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers to hold the delayed values of b\n  reg [15:0] b_reg1, b_reg2, b_reg3;\n\n  // Assign the delayed values to the processing elements\n  assign pe1.b_delayed = b_reg1;\n  assign pe2.b_delayed = b_reg2;\n  assign pe3.b_delayed = b_reg3;\n\n  // Update the registers on the rising edge of the clock\n  always @(posedge clk) begin\n    if (rst) begin\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n      b_reg3 <= 0;\n    end else begin\n      b_reg1 <= b0;\n      b_reg2 <= b_reg1;\n      b_reg3 <= b_reg2;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry-out output\n\n    wire [3:1] carry;     // Carry chain\n\n    // Instantiate 4-bit full adders for each 4-bit group\n    four_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    four_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    four_bit_adder add3(\n        .A(A[5:4]),\n        .B(B[5:4]),\n        .C_in(carry[2]),\n        .S(S[5:4]),\n        .C_out(carry[3])\n    );\n\n    four_bit_adder add4(\n        .A(A[7:6]),\n        .B(B[7:6]),\n        .C_in(carry[3]),\n        .S(S[7:6]),\n        .C_out(carry[4])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[4];\nendmodule\n\nmodule four_bit_adder(A, B, C_in, S, C_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:0] S;        // 4-bit sum output\n    output C_out;          // Carry-out output\n\n    wire [4:1] carry;      // Carry chain\n\n    // Instantiate 2-bit full adders for each 2-bit group\n    two_bit_adder add1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .C_in(0),\n        .S(S[1:0]),\n        .C_out(carry[1])\n    );\n\n    two_bit_adder add2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(carry[1]),\n        .S(S[3:2]),\n        .C_out(carry[2])\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = carry[3];\nendmodule\n\nmodule two_bit_adder(A, B, C_in, S, C_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [1:0] S;        // 2-bit sum output\n    output C_out;          // Carry-out output\n\n    wire C1, C2;           // Carry chain\n\n    // Instantiate 1-bit full adder for the last bit\n    one_bit_adder add1(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .S(S[0]),\n        .C_out(C1)\n    );\n\n    // Instantiate 1-bit full adder for the carry-out\n    one_bit_adder add2(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C1),\n        .S(S[1]),\n        .C_out(C2)\n    );\n\n    // Carry-out is the last carry from the last adder\n    assign C_out = C2;\nendmodule\n\nmodule one_bit_adder(A, B, C_in, S, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output S;              // 1-bit sum output\n    output C_out;          // Carry-out output\n\n    assign S = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine outputs from slices\nassign eq = &eq_slice1 & &eq_slice2 & &eq_slice3 & &eq_slice4;\nassign gt = &gt_slice1 & &gt_slice2 & &gt_slice3 & &gt_slice4;\nassign lt = &lt_slice1 & &lt_slice2 & &lt_slice3 & &lt_slice4;\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine outputs from slices\nassign eq = &eq_slice1 & &eq_slice2;\nassign gt = &gt_slice1 & &gt_slice2;\nassign lt = &lt_slice1 & &lt_slice2;\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\n// Compare individual bits\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\n// Combine outputs\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set zero flag if result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  PE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  PE pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  PE pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  PE pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  reg [15:0] b_reg0, b_reg1, b_reg2, b_reg3;\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b_reg0 <= 0;\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n      b_reg3 <= 0;\n    end\n    else begin\n      b_reg0 <= b0;\n      b_reg1 <= b_reg0;\n      b_reg2 <= b_reg1;\n      b_reg3 <= b_reg2;\n    end\n  end\n\n  assign pe0.b_delayed = b_reg0;\n  assign pe1.b_delayed = b_reg1;\n  assign pe2.b_delayed = b_reg2;\n  assign pe3.b_delayed = b_reg3;\n\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      c <= 0;\n    end\n    else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\nassign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  reg [15:0] b1, b2, b3;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 32'b0;\n    end else begin\n      c_reg <= a * b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\ncomparator_4bit comp_slice1 (.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2 (.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3 (.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4 (.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\ncomparator_2bit comp_slice1 (.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2 (.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_bit, gt_bit, lt_bit;\n\nassign eq_bit = (a == b);\nassign gt_bit = (a > b);\nassign lt_bit = (a < b);\n\nassign eq = eq_bit;\nassign gt = gt_bit;\nassign lt = lt_bit;\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n    wire [31:0] zero_check;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero_check = result;\n    assign zero = |zero_check;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  reg [15:0] b1, b2, b3;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units instantiated\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  reg [15:0] b_reg0, b_reg1, b_reg2;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_reg0 <= 0;\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n    end else begin\n      b_reg0 <= b0;\n      b_reg1 <= b_reg0;\n      b_reg2 <= b_reg1;\n    end\n  end\n\n  assign pe0.b_delayed = b_reg0;\n  assign pe1.b_delayed = b_reg1;\n  assign pe2.b_delayed = b_reg2;\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      product <= 0;\n    end else begin\n      product <= a * b;\n    end\n  end\n  assign c = product;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a;\ninput [15:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiate 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combine outputs from slices\nassign eq = (eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4);\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a;\ninput [3:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiate 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combine outputs from slices\nassign eq = (eq_slice1 & eq_slice2);\nassign gt = (gt_slice1 & gt_slice2);\nassign lt = (lt_slice1 & lt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a;\ninput [1:0] b;\noutput eq;\noutput gt;\noutput lt;\n\nassign eq = (a == b);\nassign gt = (a > b);\nassign lt = (a < b);\n\nendmodule"}
{"task_id": "systolic1x4", "response": "// Intermediate registers to hold the delayed values\n  reg [15:0] b1, b2, b3;\n  \n  // Instantiate the processing elements\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n  \n  // Update the delayed values\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      product <= 0;\n    end\n    else begin\n      product <= a * b;\n    end\n  end\n  assign c = product;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Intermediate registers\n  reg [15:0] b1, b2, b3;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n\n  // PE0\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c0_reg <= 0;\n    end else begin\n      c0_reg <= a0 * b0;\n    end\n  end\n\n  // PE1\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      c1_reg <= 0;\n    end else begin\n      b1 <= b0;\n      c1_reg <= a1 * b1;\n    end\n  end\n\n  // PE2\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b2 <= 0;\n      c2_reg <= 0;\n    end else begin\n      b2 <= b1;\n      c2_reg <= a2 * b2;\n    end\n  end\n\n  // PE3\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b3 <= 0;\n      c3_reg <= 0;\n    end else begin\n      b3 <= b2;\n      c3_reg <= a3 * b3;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the operation based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n\n    assign xor_result = a ^ b;\n\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\nassign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_reg), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_reg), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_reg), .c(c3));\n\n  // Registers to hold delayed values\n  reg [15:0] b_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_reg <= 0;\n    end else begin\n      b_reg <= b0;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c <= 0;\n    end else begin\n      c <= a * b;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "`timescale 1ns / 1ps\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_slice1, eq_slice2, eq_slice3, eq_slice4;\nwire [3:0] gt_slice1, gt_slice2, gt_slice3, gt_slice4;\nwire [3:0] lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n\n// Instantiating 4-bit comparator slices\ncomparator_4bit comp_slice1(.a(a[3:0]), .b(b[3:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_4bit comp_slice2(.a(a[7:4]), .b(b[7:4]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\ncomparator_4bit comp_slice3(.a(a[11:8]), .b(b[11:8]), .eq(eq_slice3), .gt(gt_slice3), .lt(lt_slice3));\ncomparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq_slice4), .gt(gt_slice4), .lt(lt_slice4));\n\n// Combining outputs from slices\nassign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\nassign gt = (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4) | (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4);\nassign lt = (lt_slice1 & lt_slice2 & lt_slice3 & lt_slice4) | (gt_slice1 & gt_slice2 & gt_slice3 & gt_slice4);\n\nendmodule\n\nmodule comparator_4bit(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [1:0] eq_slice1, eq_slice2;\nwire [1:0] gt_slice1, gt_slice2;\nwire [1:0] lt_slice1, lt_slice2;\n\n// Instantiating 2-bit comparator slices\ncomparator_2bit comp_slice1(.a(a[1:0]), .b(b[1:0]), .eq(eq_slice1), .gt(gt_slice1), .lt(lt_slice1));\ncomparator_2bit comp_slice2(.a(a[3:2]), .b(b[3:2]), .eq(eq_slice2), .gt(gt_slice2), .lt(lt_slice2));\n\n// Combining outputs from slices\nassign eq = eq_slice1 & eq_slice2;\nassign gt = (gt_slice1 & gt_slice2) | (lt_slice1 & lt_slice2);\nassign lt = (lt_slice1 & lt_slice2) | (gt_slice1 & gt_slice2);\n\nendmodule\n\nmodule comparator_2bit(a, b, eq, gt, lt);\ninput [1:0] a, b;\noutput eq, gt, lt;\n\nwire eq_0, eq_1, gt_0, gt_1, lt_0, lt_1;\n\n// Comparing individual bits\nassign eq_0 = (a[0] == b[0]);\nassign eq_1 = (a[1] == b[1]);\nassign gt_0 = (a[0] > b[0]);\nassign gt_1 = (a[1] > b[1]);\nassign lt_0 = (a[0] < b[0]);\nassign lt_1 = (a[1] < b[1]);\n\n// Combining outputs from bits\nassign eq = eq_0 & eq_1;\nassign gt = (gt_0 & gt_1) | (lt_0 & lt_1);\nassign lt = (lt_0 & lt_1) | (gt_0 & gt_1);\n\nendmodule"}
{"task_id": "systolic1x4", "response": "// Intermediate registers to store delayed values\n  reg [15:0] b1, b2, b3;\n\n  // Instantiating processing elements\n  processing_element pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  processing_element pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  processing_element pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  processing_element pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\n  // Delaying b0 to b1, b1 to b2, b2 to b3\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  assign c = a * b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    wire [8:0] temp_sum;\n    assign temp_sum = a + b;\n    assign sum = {temp_sum[8], temp_sum[7:0]};\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set zero flag if result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Intermediate registers to hold the delayed values of b0, b1, b2, and b3\n  reg [15:0] b1, b2, b3;\n  // PEs\n  PE pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  PE pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n  PE pe3(\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n  // Update the delayed values of b0, b1, b2, and b3\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\nendmodule\n\nmodule PE(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] product;\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      product <= 0;\n    end\n    else begin\n      product <= a * b;\n    end\n  end\n  assign c = product;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b), .c(c3));\n\n  reg [15:0] b1, b2, b3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 0;\n      b2 <= 0;\n      b3 <= 0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 0;\n    end\n    else begin\n      c_reg <= a * b;\n    end\n  end\n\n  assign c = c_reg;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set the zero flag if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n\n    assign xor_result = a ^ b;\n\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(.A(A[7:0]), .B(B[7:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_8bit SUB2(.A(A[15:8]), .B(B[15:8]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor_8bit SUB3(.A(A[23:16]), .B(B[23:16]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n    subtractor_8bit SUB4(.A(A[31:24]), .B(B[31:24]), .Bin(Bout2), .D(D3), .Bout(Bout3));\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n\n    wire [4:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n    wire [4:0] D0, D1, D2, D3, D4, D5, D6, D7;\n\n    subtractor_4bit SUB1(.A(A[3:0]), .B(B[3:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_4bit SUB2(.A(A[7:4]), .B(B[7:4]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor_4bit SUB3(.A(A[11:8]), .B(B[11:8]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n    subtractor_4bit SUB4(.A(A[15:12]), .B(B[15:12]), .Bin(Bout2), .D(D3), .Bout(Bout3));\n    subtractor_4bit SUB5(.A(A[19:16]), .B(B[19:16]), .Bin(Bout3), .D(D4), .Bout(Bout4));\n    subtractor_4bit SUB6(.A(A[23:20]), .B(B[23:20]), .Bin(Bout4), .D(D5), .Bout(Bout5));\n    subtractor_4bit SUB7(.A(A[27:24]), .B(B[27:24]), .Bin(Bout5), .D(D6), .Bout(Bout6));\n    subtractor_4bit SUB8(.A(A[31:28]), .B(B[31:28]), .Bin(Bout6), .D(D7), .Bout(Bout7));\n\n    assign D = {D7, D6, D5, D4, D3, D2, D1, D0};\n    assign Bout = Bout7;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [3:0] A;\n    input [3:0] B;\n    input Bin;\n    output [3:0] D;\n    output Bout;\n\n    wire [2:0] Bout0, Bout1, Bout2;\n    wire [2:0] D0, D1, D2;\n\n    subtractor_2bit SUB1(.A(A[1:0]), .B(B[1:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_2bit SUB2(.A(A[3:2]), .B(B[3:2]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor_2bit SUB3(.A(A[3:2]), .B(B[3:2]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n\n    assign D = {D2, D1, D0};\n    assign Bout = Bout2;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Bout;\n\n    wire Bout0, Bout1;\n    wire D0, D1;\n\n    assign {Bout0, D0} = A[1] < B[1] ? {1'b1, A[1] - B[1]} : {1'b0, A[1] - B[1]};\n    assign {Bout1, D1} = A[0] < B[0] ? {1'b1, A[0] - B[0]} : {1'b0, A[0] - B[0]};\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule"}
{"task_id": "systolic1x4", "response": "// Submodules\n  processing_element pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\n  processing_element pe1(.clk(clk), .rst(rst), .a(a1), .b(pe0.b_delayed), .c(c1));\n  processing_element pe2(.clk(clk), .rst(rst), .a(a2), .b(pe1.b_delayed), .c(c2));\n  processing_element pe3(.clk(clk), .rst(rst), .a(a3), .b(pe2.b_delayed), .c(c3));\n\n  // Registers for delayed inputs\n  reg [15:0] b_reg0, b_reg1, b_reg2, b_reg3;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b_reg0 <= 0;\n      b_reg1 <= 0;\n      b_reg2 <= 0;\n      b_reg3 <= 0;\n    end else begin\n      b_reg0 <= b0;\n      b_reg1 <= b_reg0;\n      b_reg2 <= b_reg1;\n      b_reg3 <= b_reg2;\n    end\n  end\n\n  // Outputs\n  assign pe0.b_delayed = b_reg0;\n  assign pe1.b_delayed = b_reg1;\n  assign pe2.b_delayed = b_reg2;\n  assign pe3.b_delayed = b_reg3;\n\nendmodule\n\nmodule processing_element(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output [31:0] c\n);\n  reg [31:0] c_reg;\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      c_reg <= 0;\n    end else begin\n      c_reg <= a * b;\n    end\n  end\n  assign c = c_reg;\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n// 4 Adder Units\nAdderUnit au0(.a(a0), .b(b0), .sum(sum0));\nAdderUnit au1(.a(a1), .b(b1), .sum(sum1));\nAdderUnit au2(.a(a2), .b(b2), .sum(sum2));\nAdderUnit au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AdderUnit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\nassign sum = a + b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    // Instantiate the OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    // Instantiate the XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Determine if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    sub8_32 SUB1(\n        .A(A[32:25]),\n        .B(B[32:25]),\n        .Bin(Bin),\n        .D(D[32:25]),\n        .Bout(Bout0)\n    );\n\n    sub8_32 SUB2(\n        .A(A[24:17]),\n        .B(B[24:17]),\n        .Bin(Bout0),\n        .D(D[24:17]),\n        .Bout(Bout1)\n    );\n\n    sub8_32 SUB3(\n        .A(A[16:9]),\n        .B(B[16:9]),\n        .Bin(Bout1),\n        .D(D[16:9]),\n        .Bout(Bout2)\n    );\n\n    sub8_32 SUB4(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bout2),\n        .D(D[8:1]),\n        .Bout(Bout3)\n    );\n\n    assign Bout = Bout3;\nendmodule\n\nmodule sub8_32(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire [8:0] temp;\n\n    assign {Bout, D} = A - B - Bin;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n\n    subtractor8 SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor8 SUB2(A[32:18], B[32:18], Bout0, D[32:18], Bout1);\n    subtractor8 SUB3(A[32:12], B[32:12], Bout1, D[32:12], Bout2);\n    subtractor8 SUB4(A[32:6], B[32:6], Bout2, D[32:6], Bout3);\n    subtractor8 SUB5(A[32:0], B[32:0], Bout3, D[32:0], Bout4);\n\n    assign Bout = Bout4;\n\nendmodule\n\nmodule subtractor8(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    full_subtractor FSUB(A, B, Bin, D, Cout);\n\n    assign Bout = Cout;\n\nendmodule\n\nmodule full_subtractor(A, B, Bin, D, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Cout;\n\n    assign {Cout, D} = A - B - Bin;\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the bitwise AND module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the bitwise OR module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the bitwise XOR module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Check if the result is zero\n    assign zero = (result == 0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n\n    assign diff = a - b;\n\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n\n    assign and_result = a & b;\n\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n\n    assign or_result = a | b;\n\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n\n    assign xor_result = a ^ b;\n\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define OPCODE 5:0\n`define RD 11:7\n`define OPERAND1 15:12\n`define OPERAND2 20:16\n`define OPERAND3 25:21\n`define IMMEDIATE 31:26\n\n// Register file\n`define ZERO 0\n`define RA 1\n`define SP 2\n`define GP 3\n\n// Instruction memory\n`define PC 0\n\n// Stage modules\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[`PC]),\n    .out_instr(out_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .out_reg_file(out_reg_file)\n);\n\nwire [31:0] out_instr;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] out_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_instr <= 0;\n        else\n            out_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file [0:31]\n);\n    reg [31:0] operand1;\n    reg [31:0] operand2;\n    reg [31:0] operand3;\n    reg [31:0] result;\n    reg [5:0] opcode;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            operand1 <= 0;\n            operand2 <= 0;\n            operand3 <= 0;\n            result <= 0;\n            opcode <= 0;\n        end\n        else begin\n            opcode <= instr[`OPCODE];\n            operand1 <= reg_file[instr[`OPERAND1]];\n            operand2 <= reg_file[instr[`OPERAND2]];\n            operand3 <= instr[`IMMEDIATE];\n            case (opcode)\n                `ADD: result <= operand1 + operand2 + operand3;\n                `SUB: result <= operand1 - operand2 - operand3;\n            endcase\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[`ZERO] <= 0;\n            out_reg_file[`RA] <= 0;\n            out_reg_file[`SP] <= 0;\n            out_reg_file[`GP] <= 0;\n        end\n        else begin\n            out_reg_file[`ZERO] <= 0;\n            out_reg_file[`RA] <= 0;\n            out_reg_file[`SP] <= 0;\n            out_reg_file[`GP] <= 0;\n            out_reg_file[instr[`RD]] <= result;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[`ZERO] <= 0;\n            out_reg_file[`RA] <= 0;\n            out_reg_file[`SP] <= 0;\n            out_reg_file[`GP] <= 0;\n        end\n        else begin\n            out_reg_file[`ZERO] <= 0;\n            out_reg_file[`RA] <= 0;\n            out_reg_file[`SP] <= 0;\n            out_reg_file[`GP] <= 0;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[32:17], B[32:17], Bout0, D[32:17], Bout1);\n    subtractor_8bit SUB3(A[32:11], B[32:11], Bout1, D[32:11], Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D[32:6], Bout3);\n    subtractor_8bit SUB5(A[32:1], B[32:1], Bout3, D[32:1], Bout4);\n    subtractor_8bit SUB6(A[32:25], B[32:25], Bout4, D[32:25], Bout5);\n    subtractor_8bit SUB7(A[32:17], B[32:17], Bout5, D[32:17], Bout6);\n    subtractor_8bit SUB8(A[32:11], B[32:11], Bout6, D[32:11], Bout7);\n    subtractor_8bit SUB9(A[32:6], B[32:6], Bout7, D[32:6], Bout);\n    subtractor_8bit SUB10(A[32:1], B[32:1], Bout, D[32:1], Bout);\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    full_subtractor FSUB(A, B, Bin, D, Cout);\nendmodule\n\nmodule full_subtractor(A, B, Bin, D, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Cout;\n\n    assign {Cout, D} = A - B - Bin;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output [15:0] p\n);\n    assign p = x * y;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, diff, and_result, or_result, xor_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff)\n    );\n\n    // Instantiate the AND bitwise module\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result)\n    );\n\n    // Instantiate the OR bitwise module\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_result(or_result)\n    );\n\n    // Instantiate the XOR bitwise module\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_result(xor_result)\n    );\n\n    // Select the result based on the op_code\n    assign result = (op_code == 3'b000) ? sum :\n                    (op_code == 3'b001) ? diff :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    xor_result;\n\n    // Set zero flag if result is zero\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation to be performed\n`define ADD 4'b0000\n`define SUB 4'b0100\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2, result;\nwire [4:0] rd;\nwire [5:0] opcode;\n\n// Instantiate fetch stage\nfetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(0), .fetched_instr(fetched_instr));\n\n// Instantiate execute stage\nexecute_stage execute (.clk(clk), .rst(rst), .opcode(fetched_instr[31:28]), .op1(fetched_instr[27:23]), .op2(fetched_instr[22:18]), .rd(fetched_instr[15:11]), .op1_val(reg_file[op1]), .op2_val(reg_file[op2]), .result(result));\n\n// Instantiate writeback stage\nwriteback_stage writeback (.clk(clk), .rst(rst), .rd(fetched_instr[15:11]), .result(result), .out_reg_file(out_reg_file));\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [5:0] opcode,\n    input [4:0] op1,\n    input [4:0] op2,\n    input [4:0] rd,\n    input [31:0] op1_val,\n    input [31:0] op2_val,\n    output [31:0] result\n);\n    reg [31:0] result_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result_reg <= 0;\n        end else begin\n            case (opcode)\n                `ADD: result_reg <= op1_val + op2_val;\n                `SUB: result_reg <= op1_val - op2_val;\n                default: result_reg <= 0;\n            endcase\n        end\n    end\n\n    assign result = result_reg;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] rd,\n    input [31:0] result,\n    output reg [31:0] out_reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file <= 0;\n        end else begin\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[32:17], B[32:17], Bout0, D[32:17], Bout1);\n    subtractor_8bit SUB3(A[32:11], B[32:11], Bout1, D[32:11], Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D[32:6], Bout3);\n    subtractor_8bit SUB5(A[32:1], B[32:1], Bout3, D[32:1], Bout4);\n    subtractor_8bit SUB6(A[32:25], B[32:25], Bout4, D[32:25], Bout5);\n    subtractor_8bit SUB7(A[32:17], B[32:17], Bout5, D[32:17], Bout6);\n    subtractor_8bit SUB8(A[32:11], B[32:11], Bout6, D[32:11], Bout7);\n    subtractor_8bit SUB9(A[32:6], B[32:6], Bout7, D[32:6], Bout);\n\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [8:1] temp;\n\n    assign {Bout, temp} = A - B - Bin;\n    assign D = temp;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation to perform\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire [31:0] or_result\n);\n    assign result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n`define NOP 6'b000100\n`define HALT 6'b000101\n\n// Stage modules\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(out_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .out_reg_file(out_reg_file)\n);\n\n// Output\nassign out_reg_file = out_reg_file;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    reg [31:0] op1, op2, result;\n    reg [5:0] opcode;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 0;\n            op2 <= 0;\n            result <= 0;\n            opcode <= 0;\n        end else begin\n            op1 <= reg_file[instr[20:16]];\n            op2 <= reg_file[instr[15:11]];\n            opcode <= instr[31:26];\n            case (opcode)\n                `ADD: result <= op1 + op2;\n                `SUB: result <= op1 - op2;\n                `NOP: result <= 0;\n                `HALT: result <= 0;\n                default: result <= 0;\n            endcase\n        end\n    end\n\n    assign out_reg_file[instr[15:11]] = result;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file [0:31]\n);\n    // No operation\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .control(op_code)\n    );\n\n    // Control logic to determine the result\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire [1:0] control\n);\n\n    always @(posedge clk) begin\n        if (control == 2'b00) begin\n            result <= a & b;\n        end else begin\n            result <= a | b;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n    wire [7:0] D0, D1, D2, D3, D4, D5, D6, D7;\n\n    subtractor_8bit SUB1(A[32:1], B[32:1], Bin, D0, Bout0);\n    subtractor_8bit SUB2(A[24:1], B[24:1], Bout0, D1, Bout1);\n    subtractor_8bit SUB3(A[16:1], B[16:1], Bout1, D2, Bout2);\n    subtractor_8bit SUB4(A[8:1], B[8:1], Bout2, D3, Bout3);\n    subtractor_8bit SUB5(A[8:1], B[8:1], Bout3, D4, Bout4);\n    subtractor_8bit SUB6(A[8:1], B[8:1], Bout4, D5, Bout5);\n    subtractor_8bit SUB7(A[8:1], B[8:1], Bout5, D6, Bout6);\n    subtractor_8bit SUB8(A[8:1], B[8:1], Bout6, D7, Bout7);\n\n    assign D = {D7, D6, D5, D4, D3, D2, D1, D0};\n    assign Bout = Bout7;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [4:1] Bout0, Bout1, Bout2, Bout3;\n\n    subtractor_4bit SUB1(A[8:1], B[8:1], Bin, D[8:1], Bout0);\n    subtractor_4bit SUB2(A[4:1], B[4:1], Bout0[2], D[4:1], Bout1);\n    subtractor_4bit SUB3(A[4:1], B[4:1], Bout1[1], D[4:1], Bout2);\n    subtractor_4bit SUB4(A[4:1], B[4:1], Bout2[0], D[4:1], Bout3);\n\n    assign D = {D[4:1], D[4:1], D[4:1], D[4:1]};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [4:1] A;\n    input [4:1] B;\n    input Bin;\n    output [4:1] D;\n    output Bout;\n    wire [2:1] Bout0, Bout1;\n\n    subtractor_2bit SUB1(A[4:1], B[4:1], Bin, D[2:1], Bout0);\n    subtractor_2bit SUB2(A[2:1], B[2:1], Bout0[1], D[2:1], Bout1);\n\n    assign D = {D[2:1], D[2:1]};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [2:1] A;\n    input [2:1] B;\n    input Bin;\n    output [2:1] D;\n    output Bout;\n\n    assign {Bout, D} = A - B - Bin;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Stage modules\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(out_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_instr),\n    .reg_file(out_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    wire [5:0] opcode = instr[31:26];\n    wire [5:0] rd = instr[11:6];\n    wire [5:0] rs1 = instr[20:15];\n    wire [5:0] rs2 = instr[25:20];\n    wire [31:0] op1 = reg_file[rs1];\n    wire [31:0] op2 = reg_file[rs2];\n    wire [31:0] result;\n\n    assign out_reg_file[rd] = (opcode == `ADD) ? op1 + op2 : op1 - op2;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31]\n);\n    wire [5:0] rd = instr[11:6];\n    wire [31:0] result = reg_file[rd];\n\n    assign reg_file[rd] = result;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .product(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .product(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .product(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .product(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] product\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            product <= 0;\n        else\n            product <= x * y;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result : or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    input wire [1:0] op_code\n);\n    assign result = (op_code == 2'b00) ? a & b : a | b;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Stage modules\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(execute.out_reg_file),\n    .out_reg_file(writeback.out_reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    wire [5:0] opcode = instr[31:26];\n    wire [5:0] rd = instr[11:6];\n    wire [5:0] rs1 = instr[20:15];\n    wire [5:0] rs2 = instr[25:20];\n    wire [31:0] operand1 = reg_file[rs1];\n    wire [31:0] operand2 = reg_file[rs2];\n    wire [31:0] result;\n\n    assign out_reg_file[rd] = (opcode == `ADD) ? operand1 + operand2 : operand1 - operand2;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    assign out_reg_file = reg_file;\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D0, Bout0);\n    subtractor_8bit SUB2(A[32:18], B[32:18], Bout0, D1, Bout1);\n    subtractor_8bit SUB3(A[32:12], B[32:12], Bout1, D2, Bout2);\n    subtractor_8bit SUB4(A[32:6], B[32:6], Bout2, D3, Bout3);\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [8:1] D0, D1;\n    wire Bout0, Bout1;\n\n    subtractor_4bit SUB1(A[8:5], B[8:5], Bin, D0, Bout0);\n    subtractor_4bit SUB2(A[8:2], B[8:2], Bout0, D1, Bout1);\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [4:1] A;\n    input [4:1] B;\n    input Bin;\n    output [4:1] D;\n    output Bout;\n    wire [4:1] D0, D1;\n    wire Bout0, Bout1;\n\n    subtractor_2bit SUB1(A[4:3], B[4:3], Bin, D0, Bout0);\n    subtractor_2bit SUB2(A[4:2], B[4:2], Bout0, D1, Bout1);\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [2:1] A;\n    input [2:1] B;\n    input Bin;\n    output [2:1] D;\n    output Bout;\n    wire [2:1] D0, D1;\n    wire Bout0, Bout1;\n\n    subtractor_1bit SUB1(A[2:1], B[2:1], Bin, D0, Bout0);\n    subtractor_1bit SUB2(A[2:1], B[2:1], Bin, D1, Bout1);\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Bout;\n    wire Bout0, Bout1;\n\n    assign {Bout0, D} = A - B - Bin;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    output reg [31:0] or_result\n);\n\n    always @(a or b) begin\n        result = a & b;\n        or_result = a | b;\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .product(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .product(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .product(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .product(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] product\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            product <= 0;\n        else\n            product <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    // Instantiate 8-bit subtractors\n    subtractor SUB1(A[32:25], B[24:17], Bin, D[32:25], Bout0);\n    subtractor SUB2(A[32:24], B[23:16], Bout0, D[32:24], Bout1);\n    subtractor SUB3(A[32:22], B[22:15], Bout1, D[32:22], Bout2);\n    subtractor SUB4(A[32:18], B[17:10], Bout2, D[32:18], Bout3);\n\n    // Output borrow-out\n    assign Bout = Bout3;\n\nendmodule\n\nmodule subtractor(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    // Subtractor logic\n    assign {Cout, D} = A - B - Bin;\n    assign Bout = Cout;\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation to perform\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire [31:0] or_result\n);\n    assign result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define OPCODE 5:0\n`define RD 11:7\n`define OPERAND1 19:15\n`define OPERAND2 24:20\n`define IMMEDIATE 31:25\n\n// Register file\n`define REG_FILE_SIZE 32\n\n// Fetch stage\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            fetched_instr <= 0;\n        else\n            fetched_instr <= instr_mem[0];\n    end\nendmodule\n\n// Execute stage\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else begin\n            case (fetched_instr[`OPCODE])\n                `ADD: result <= reg_file[fetched_instr[`OPERAND1]] + reg_file[fetched_instr[`OPERAND2]];\n                `SUB: result <= reg_file[fetched_instr[`OPERAND1]] - reg_file[fetched_instr[`OPERAND2]];\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] out_reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file <= 0;\n        else\n            out_reg_file[fetched_instr[`RD]] <= result;\n    end\nendmodule\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    wire [31:0] fetched_instr;\n    wire [31:0] result;\n\n    fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr));\n    execute_stage execute (.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .reg_file(reg_file), .result(result));\n    writeback_stage writeback (.clk(clk), .rst(rst), .result(result), .out_reg_file(out_reg_file));\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .control(op_code)\n    );\n\n    // Control logic to determine the operation to perform\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire [1:0] control\n);\n\n    always @(a or b or control) begin\n        case (control)\n            2'b00: result = a & b;\n            2'b01: result = a | b;\n            default: result = 32'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(.A(A[7:0]), .B(B[7:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_8bit SUB2(.A(A[15:8]), .B(B[15:8]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor_8bit SUB3(.A(A[23:16]), .B(B[23:16]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n    subtractor_8bit SUB4(.A(A[31:24]), .B(B[31:24]), .Bin(Bout2), .D(D3), .Bout(Bout3));\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire [7:0] D0, D1;\n    wire Bout0, Bout1;\n\n    subtractor_4bit SUB1(.A(A[3:0]), .B(B[3:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_4bit SUB2(.A(A[7:4]), .B(B[7:4]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [3:0] A;\n    input [3:0] B;\n    input Bin;\n    output [3:0] D;\n    output Bout;\n    wire [3:0] D0, D1;\n    wire Bout0, Bout1;\n\n    subtractor_2bit SUB1(.A(A[1:0]), .B(B[1:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_2bit SUB2(.A(A[3:2]), .B(B[3:2]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [1:0] A;\n    input [1:0] B;\n    input Bin;\n    output [1:0] D;\n    output Bout;\n    wire [1:0] D0, D1;\n    wire Bout0, Bout1;\n\n    subtractor_1bit SUB1(.A(A[0]), .B(B[0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_1bit SUB2(.A(A[1]), .B(B[1]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n    wire Bout0;\n\n    assign {Bout0, D} = A - B - Bin;\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n// 4 multiplier units\nmultiplier mult0(.clk(clk), .rst(rst), .x(x0), .y(y0), .p(p0));\nmultiplier mult1(.clk(clk), .rst(rst), .x(x1), .y(y0), .p(p1));\nmultiplier mult2(.clk(clk), .rst(rst), .x(x0), .y(y1), .p(p2));\nmultiplier mult3(.clk(clk), .rst(rst), .x(x1), .y(y1), .p(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] x,\n    input [7:0] y,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    subtractor_8bit SUB1(A[32:25], B[32:25], Bin, D[32:25], Bout0);\n    subtractor_8bit SUB2(A[32:17], B[32:17], Bout0, D[32:17], Bout1);\n    subtractor_8bit SUB3(A[32:11], B[32:11], Bout1, D[32:11], Bout2);\n    subtractor_8bit SUB4(A[32:4], B[32:4], Bout2, D[32:4], Bout3);\n\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] bitwise_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .op_code(op_code),\n        .result(bitwise_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    bitwise_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] sum\n);\n    always @(posedge sum) begin\n        sum <= a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] diff\n);\n    always @(posedge diff) begin\n        diff <= a - b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire [1:0] op_code,\n    output reg [31:0] result\n);\n    always @(posedge result) begin\n        case (op_code)\n            2'b00: result <= a & b; // Bitwise AND\n            2'b01: result <= a | b; // Bitwise OR\n            default: result <= 32'b0; // Default case\n        endcase\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] rot_left;\nwire [3:0] rot_right;\n\nleft_rotate lr(.en(en), .in_data(in_data), .out_data(rot_left));\nright_rotate rr(.en(en), .in_data(in_data), .out_data(rot_right));\n\nassign out_data = rot_dir ? rot_right : rot_left;\n\nendmodule\n\nmodule left_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .out_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .out_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Bin(Bin),\n        .D(D0),\n        .Bout(Bout0)\n    );\n\n    subtractor_8bit SUB2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Bin(Bout0),\n        .D(D1),\n        .Bout(Bout1)\n    );\n\n    subtractor_8bit SUB3(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Bin(Bout1),\n        .D(D2),\n        .Bout(Bout2)\n    );\n\n    subtractor_8bit SUB4(\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Bin(Bout2),\n        .D(D3),\n        .Bout(Bout3)\n    );\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n\n    wire [4:0] borrow;\n    wire [7:0] temp;\n\n    assign borrow = {Bin, Bin, Bin, Bin, Bin, Bin, Bin, Bin};\n\n    assign temp = A - B - borrow;\n    assign D = temp[7:0];\n    assign Bout = temp[8];\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction structure\ntypedef struct packed {\n    reg [5:0] opcode;\n    reg [4:0] rs;\n    reg [4:0] rt;\n    reg [11:0] imm;\n} inst_t;\n\n// Fetch stage\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output reg [31:0] fetched_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            fetched_instr <= 32'b0;\n        else\n            fetched_instr <= instr_mem[0];\n    end\nendmodule\n\n// Execute stage\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] result\n);\n    reg [31:0] op1, op2;\n    reg [5:0] opcode;\n    reg [4:0] rs, rt;\n    reg [11:0] imm;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1 <= 32'b0;\n            op2 <= 32'b0;\n            opcode <= 6'b0;\n            rs <= 5'b0;\n            rt <= 5'b0;\n            imm <= 12'b0;\n            result <= 32'b0;\n        end else begin\n            inst_t inst = fetched_instr;\n            op1 <= reg_file[inst.rs];\n            op2 <= reg_file[inst.rt];\n            opcode <= inst.opcode;\n            rs <= inst.rs;\n            rt <= inst.rt;\n            imm <= inst.imm;\n            if (opcode == `ADD)\n                result <= op1 + op2 + imm;\n            else if (opcode == `SUB)\n                result <= op1 - op2 - imm;\n            else\n                result <= 32'b0;\n        end\n    end\nendmodule\n\n// Writeback stage\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    output reg [31:0] out_reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[0] <= 32'b0;\n            out_reg_file[1] <= 32'b0;\n            out_reg_file[2] <= 32'b0;\n            out_reg_file[3] <= 32'b0;\n            out_reg_file[4] <= 32'b0;\n            out_reg_file[5] <= 32'b0;\n            out_reg_file[6] <= 32'b0;\n            out_reg_file[7] <= 32'b0;\n            out_reg_file[8] <= 32'b0;\n            out_reg_file[9] <= 32'b0;\n            out_reg_file[10] <= 32'b0;\n            out_reg_file[11] <= 32'b0;\n            out_reg_file[12] <= 32'b0;\n            out_reg_file[13] <= 32'b0;\n            out_reg_file[14] <= 32'b0;\n            out_reg_file[15] <= 32'b0;\n            out_reg_file[16] <= 32'b0;\n            out_reg_file[17] <= 32'b0;\n            out_reg_file[18] <= 32'b0;\n            out_reg_file[19] <= 32'b0;\n            out_reg_file[20] <= 32'b0;\n            out_reg_file[21] <= 32'b0;\n            out_reg_file[22] <= 32'b0;\n            out_reg_file[23] <= 32'b0;\n            out_reg_file[24] <= 32'b0;\n            out_reg_file[25] <= 32'b0;\n            out_reg_file[26] <= 32'b0;\n            out_reg_file[27] <= 32'b0;\n            out_reg_file[28] <= 32'b0;\n            out_reg_file[29] <= 32'b0;\n            out_reg_file[30] <= 32'b0;\n            out_reg_file[31] <= 32'b0;\n        end else\n            out_reg_file[rt] <= result;\n    end\nendmodule\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file [0:31]\n);\n    wire [31:0] fetched_instr;\n    wire [31:0] result;\n\n    fetch_stage fetch(.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr));\n    execute_stage execute(.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .reg_file(reg_file), .result(result));\n    writeback_stage writeback(.clk(clk), .rst(rst), .result(result), .out_reg_file(out_reg_file));\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = rot_dir ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control signal for the bitwise operation\n    wire [31:0] bitwise_result;\n    assign bitwise_result = (op_code == 2'b00) ? add_result :\n                            (op_code == 2'b01) ? sub_result :\n                            (op_code == 2'b10) ? and_result :\n                            or_result;\n\n    // Output the result\n    assign result = bitwise_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        result <= a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        result <= a - b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire [1:0] op_code\n);\n    always @(posedge clk) begin\n        if (op_code == 2'b00) begin\n            result <= a & b;\n        end else begin\n            result <= a | b;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.en(en), .data(in_data), .rot_dir(rot_dir), .out_data(left_rot));\nright_rotate rr(.en(en), .data(in_data), .rot_dir(rot_dir), .out_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input en,\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input en,\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .out_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .out_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation to perform\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result : or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(a or b) begin\n        result = a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(a or b) begin\n        result = a - b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    output reg [31:0] or_result\n);\n    always @(a or b) begin\n        result = a & b;\n        or_result = a | b;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation code for addition\n  localparam ADD = 6'b000000;\n  // Operation code for subtraction\n  localparam SUB = 6'b000001;\n\n  wire [31:0] instr;\n  wire [5:0] rd;\n  wire [31:0] op1, op2, result;\n  wire [5:0] rs1, rs2;\n  wire [1:0] opcode;\n\n  // Fetch stage\n  fetch_stage fetch (\n      .clk(clk),\n      .rst(rst),\n      .instr_mem(instr_mem),\n      .pc(reg_file[31]),\n      .instr(instr)\n  );\n\n  // Execute stage\n  execute_stage execute (\n      .clk(clk),\n      .rst(rst),\n      .instr(instr),\n      .op1(op1),\n      .op2(op2),\n      .result(result),\n      .opcode(opcode),\n      .rd(rd),\n      .rs1(rs1),\n      .rs2(rs2)\n  );\n\n  // Writeback stage\n  writeback_stage writeback (\n      .clk(clk),\n      .rst(rst),\n      .result(result),\n      .rd(rd),\n      .reg_file(reg_file),\n      .out_reg_file(out_reg_file)\n  );\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] instr\n);\n    assign instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result,\n    output [1:0] opcode,\n    output [5:0] rd,\n    output [5:0] rs1,\n    output [5:0] rs2\n);\n    assign {opcode, rd, rs1, rs2} = instr;\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n\n    always @(opcode) begin\n        case (opcode)\n            ADD: result = op1 + op2;\n            SUB: result = op1 - op2;\n            default: result = 32'b0;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [5:0] rd,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out_reg_file <= 32'b0;\n        else\n            out_reg_file[rd] <= result;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor_8bit SUB1(.A(A[7:0]), .B(B[7:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_8bit SUB2(.A(A[15:8]), .B(B[15:8]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor_8bit SUB3(.A(A[23:16]), .B(B[23:16]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n    subtractor_8bit SUB4(.A(A[31:24]), .B(B[31:24]), .Bin(Bout2), .D(D3), .Bout(Bout3));\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor_8bit(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n\n    wire [4:0] Bout0, Bout1, Bout2;\n    wire [4:0] D0, D1, D2;\n\n    subtractor_4bit SUB1(.A(A[3:0]), .B(B[3:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_4bit SUB2(.A(A[7:4]), .B(B[7:4]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor_4bit SUB3(.A(A[11:8]), .B(B[11:8]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n\n    assign D = {D2, D1, D0};\n    assign Bout = Bout2;\nendmodule\n\nmodule subtractor_4bit(A, B, Bin, D, Bout);\n    input [4:0] A;\n    input [4:0] B;\n    input Bin;\n    output [4:0] D;\n    output Bout;\n\n    wire [2:0] Bout0, Bout1;\n    wire [2:0] D0, D1;\n\n    subtractor_2bit SUB1(.A(A[1:0]), .B(B[1:0]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor_2bit SUB2(.A(A[3:2]), .B(B[3:2]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor_2bit(A, B, Bin, D, Bout);\n    input [2:0] A;\n    input [2:0] B;\n    input Bin;\n    output [2:0] D;\n    output Bout;\n\n    wire [1:0] Bout0;\n    wire [1:0] D0;\n\n    subtractor_1bit SUB1(.A(A[1]), .B(B[1]), .Bin(Bin), .D(D0), .Bout(Bout0));\n\n    assign D = {D0, D0};\n    assign Bout = Bout0;\nendmodule\n\nmodule subtractor_1bit(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n\n    assign D = A - B - Bin;\n    assign Bout = (A < B) ? 1 : 0;\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire [31:0] or_result\n);\n    assign result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] rot_left;\nwire [3:0] rot_right;\n\nleft_rotate lr(.data(in_data), .rot(rot_left));\nright_rotate rr(.data(in_data), .rot(rot_right));\n\nassign out_data = (rot_dir) ? rot_right : rot_left;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  output [3:0] rot\n);\nassign rot = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] rot\n);\nassign rot = {data[2:0], data[3]};\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction structure\ntypedef struct {\n    reg [5:0] opcode;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [4:0] rd;\n    reg [31:0] imm;\n} inst_t;\n\n// Instruction memory\nreg [31:0] inst_mem [0:31];\n\n// Register file\nreg [31:0] reg_file [0:31];\n\n// Program counter\nreg [4:0] pc;\n\n// Instruction fetch\nwire [31:0] fetched_inst;\nwire [4:0] rs1_val, rs2_val;\nwire [31:0] op1, op2, result;\n\n// Instantiate the stages\nfetch_stage fetch (.clk(clk), .rst(rst), .inst_mem(instr_mem), .pc(pc), .fetched_inst(fetched_inst));\nexecute_stage execute (.clk(clk), .rst(rst), .fetched_inst(fetched_inst), .reg_file(reg_file), .op1(op1), .op2(op2), .result(result));\nwriteback_stage writeback (.clk(clk), .rst(rst), .result(result), .rd(fetched_inst.rd), .reg_file(reg_file));\n\n// Assign output\nassign out_reg_file = reg_file[fetched_inst.rd];\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] inst_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_inst\n);\n    assign fetched_inst = inst_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_inst,\n    input [31:0] reg_file [0:31],\n    output [31:0] op1,\n    output [31:0] op2,\n    output [31:0] result\n);\n    assign op1 = reg_file[fetched_inst.rs1];\n    assign op2 = reg_file[fetched_inst.rs2];\n    assign result = (fetched_inst.opcode == `ADD) ? op1 + op2 : op1 - op2;\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [4:0] rd,\n    output reg [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            reg_file[rd] <= 0;\n        else\n            reg_file[rd] <= result;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, bitwise_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(bitwise_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? bitwise_result :\n                    32'b0;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a & b;\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_out, right_out;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .out(left_out));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .out(right_out));\n\nassign out_data = rot_dir ? left_out : right_out;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out\n);\n  assign out = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out\n);\n  assign out = {data[2:0], data[3]};\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot, right_rot;\n\nleft_rotate lr(.data(in_data), .rot(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot(rot_dir), .rot_data(right_rot));\n\nassign out_data = (rot_dir) ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .op_code(op_code)\n    );\n\n    // Control logic to determine the operation based on op_code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire [1:0] op_code\n);\n\n    always @(a or b or op_code) begin\n        if (op_code == 2'b00) begin\n            result = a & b;\n        end else begin\n            result = a | b;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_out, right_out;\n\nleft_rotate lr(.en(en), .in_data(in_data), .out_data(left_out));\nright_rotate rr(.en(en), .in_data(in_data), .out_data(right_out));\n\nassign out_data = rot_dir ? left_out : right_out;\n\nendmodule\n\nmodule left_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input en,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation to be performed\n`define ADD 4'b0000\n`define SUB 4'b1000\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] fetched_instr;\nwire [31:0] op1, op2, result;\nwire [4:0] rd;\nwire [4:0] opcode;\nwire [5:0] funct;\nwire [31:0] write_value;\n\n// Instantiate fetch stage\nfetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .pc(0), .fetched_instr(fetched_instr));\n\n// Instantiate execute stage\nexecute_stage execute (.clk(clk), .rst(rst), .opcode(fetched_instr[31:28]), .funct(fetched_instr[15:11]), .op1(op1), .op2(op2), .result(result));\n\n// Instantiate writeback stage\nwriteback_stage writeback (.clk(clk), .rst(rst), .opcode(fetched_instr[31:28]), .funct(fetched_instr[15:11]), .result(result), .rd(fetched_instr[25:21]), .reg_file(reg_file), .write_value(write_value));\n\n// Connect outputs\nassign out_reg_file = write_value;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [4:0] pc,\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[pc];\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [4:0] opcode,\n    input [5:0] funct,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    reg [31:0] op1_reg, op2_reg;\n    reg [4:0] opcode_reg;\n    reg [5:0] funct_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op1_reg <= 0;\n            op2_reg <= 0;\n            opcode_reg <= 0;\n            funct_reg <= 0;\n        end\n        else begin\n            op1_reg <= op1;\n            op2_reg <= op2;\n            opcode_reg <= opcode;\n            funct_reg <= funct;\n        end\n    end\n\n    always @(opcode_reg or op1_reg or op2_reg or funct_reg) begin\n        case (opcode_reg)\n            `ADD: result <= op1_reg + op2_reg;\n            `SUB: result <= op1_reg - op2_reg;\n            default: result <= 0;\n        endcase\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [4:0] opcode,\n    input [5:0] funct,\n    input [31:0] result,\n    input [4:0] rd,\n    input [31:0] reg_file [0:31],\n    output [31:0] write_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            write_value <= 0;\n        end\n        else begin\n            write_value <= result;\n        end\n    end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n\n    sub8_32 SUB1(\n        .A(A[32:1]),\n        .B(B[32:1]),\n        .Bin(Bin),\n        .D(D[32:1]),\n        .Bout(Bout0)\n    );\n\n    sub8_32 SUB2(\n        .A(A[32:8]),\n        .B(B[32:8]),\n        .Bin(Bout0),\n        .D(D[32:8]),\n        .Bout(Bout1)\n    );\n\n    sub8_32 SUB3(\n        .A(A[32:16]),\n        .B(B[32:16]),\n        .Bin(Bout1),\n        .D(D[32:16]),\n        .Bout(Bout2)\n    );\n\n    sub8_32 SUB4(\n        .A(A[32:24]),\n        .B(B[32:24]),\n        .Bin(Bout2),\n        .D(D[32:24]),\n        .Bout(Bout3)\n    );\n\nendmodule\n\nmodule sub8_32(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1;\n\n    sub8_8 SUB1(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bin),\n        .D(D[8:1]),\n        .Bout(Bout0)\n    );\n\n    sub8_8 SUB2(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .Bin(Bout0),\n        .D(D[8:8]),\n        .Bout(Bout1)\n    );\n\nendmodule\n\nmodule sub8_8(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n    wire [7:0] Bout0;\n\n    sub8_4 SUB1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Bin(Bin),\n        .D(D[4:1]),\n        .Bout(Bout0)\n    );\n\n    sub8_4 SUB2(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .Bin(Bout0),\n        .D(D[4:4]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub8_4(A, B, Bin, D, Bout);\n    input [4:1] A;\n    input [4:1] B;\n    input Bin;\n    output [4:1] D;\n    output Bout;\n    wire [3:0] Bout0;\n\n    sub8 SUB1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .Bin(Bin),\n        .D(D[2:1]),\n        .Bout(Bout0)\n    );\n\n    sub8 SUB2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .Bin(Bout0),\n        .D(D[2:2]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub8(A, B, Bin, D, Bout);\n    input [2:1] A;\n    input [2:1] B;\n    input Bin;\n    output [2:1] D;\n    output Bout;\n    wire [1:0] Bout0;\n\n    sub4 SUB1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bin),\n        .D(D[1:1]),\n        .Bout(Bout0)\n    );\n\n    sub4 SUB2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bout0),\n        .D(D[1:1]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub4(A, B, Bin, D, Bout);\n    input [1:1] A;\n    input [1:1] B;\n    input Bin;\n    output [1:1] D;\n    output Bout;\n    wire Bout0;\n\n    sub2 SUB1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bin),\n        .D(D[1:1]),\n        .Bout(Bout0)\n    );\n\n    sub2 SUB2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .Bin(Bout0),\n        .D(D[1:1]),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub2(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n    wire Bout0;\n\n    sub1 SUB1(\n        .A(A),\n        .B(B),\n        .Bin(Bin),\n        .D(D),\n        .Bout(Bout0)\n    );\n\n    sub1 SUB2(\n        .A(A),\n        .B(B),\n        .Bin(Bout0),\n        .D(D),\n        .Bout(Bout)\n    );\n\nendmodule\n\nmodule sub1(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n    wire Bout0;\n\n    assign D = A - B - Bin;\n    assign Bout0 = (A < B) ? 1 : 0;\n    assign Bout = (D < 0) ? 1 : 0;\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] rot_left;\nwire [3:0] rot_right;\n\nleft_rotate lr(.data(in_data), .rot(rot_left));\nright_rotate rr(.data(in_data), .rot(rot_right));\n\nassign out_data = (rot_dir) ? rot_right : rot_left;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  output [3:0] rot\n);\nassign rot = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] rot\n);\nassign rot = {data[2:0], data[3]};\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] rot_left, rot_right;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .out_data(rot_left));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .out_data(rot_right));\n\nassign out_data = rot_dir ? rot_right : rot_left;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] out_data\n);\n  assign out_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .control(op_code[1])\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a + b;\n    end\n\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n\n    always @(a or b) begin\n        result = a - b;\n    end\n\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result,\n    input wire control\n);\n\n    always @(a or b or control) begin\n        if (control) begin\n            result = a & b;\n        end else begin\n            result = a | b;\n        end\n    end\n\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3, Bout4, Bout5, Bout6, Bout7;\n    wire [7:0] D0, D1, D2, D3, D4, D5, D6, D7;\n\n    // Instantiate 8-bit subtractor blocks\n    subtractor SUB1(A[32:25], B[32:25], Bin, D0, Bout0);\n    subtractor SUB2(A[32:18], B[32:18], Bout0, D1, Bout1);\n    subtractor SUB3(A[32:12], B[32:12], Bout1, D2, Bout2);\n    subtractor SUB4(A[32:6], B[32:6], Bout2, D3, Bout3);\n    subtractor SUB5(A[32:0], B[32:0], Bout3, D4, Bout4);\n\n    // Assign outputs\n    assign D = {D4, D3, D2, D1, D0};\n    assign Bout = Bout7;\n\nendmodule\n\nmodule subtractor(A, B, Bin, D, Bout);\n    input [7:0] A;\n    input [7:0] B;\n    input Bin;\n    output [7:0] D;\n    output Bout;\n    wire Cout;\n\n    // Subtract A and B with borrow-in\n    assign {Cout, D} = A - B - Bin;\n\n    // Output borrow-out\n    assign Bout = Cout;\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\nwire [3:0] left_rot;\nwire [3:0] right_rot;\n\nleft_rotate lr(.data(in_data), .rot_dir(rot_dir), .rot_data(left_rot));\nright_rotate rr(.data(in_data), .rot_dir(rot_dir), .rot_data(right_rot));\n\nassign out_data = rot_dir ? left_rot : right_rot;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[0], data[3:1]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  input rot_dir,\n  output [3:0] rot_data\n);\n  assign rot_data = {data[2:0], data[3]};\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Define the stages\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(execute.out_reg_file),\n    .out_reg_file(writeback.out_reg_file)\n);\n\n// Connect the stages\nassign out_reg_file = writeback.out_reg_file;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [5:0] pc,\n    output reg [31:0] out_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_instr <= 0;\n        else\n            out_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file [0:31]\n);\n    reg [5:0] opcode;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [31:0] operand1;\n    reg [31:0] operand2;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            opcode <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            operand1 <= 0;\n            operand2 <= 0;\n            result <= 0;\n        end\n        else begin\n            opcode <= instr[31:26];\n            rd <= instr[20:16];\n            rs1 <= instr[15:11];\n            rs2 <= instr[25:21];\n            operand1 <= reg_file[rs1];\n            operand2 <= reg_file[rs2];\n            case(opcode)\n                `ADD: result <= operand1 + operand2;\n                `SUB: result <= operand1 - operand2;\n            endcase\n            out_reg_file[rd] <= result;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            out_reg_file <= 0;\n        end\n        else begin\n            out_reg_file <= reg_file;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (~mode);\n  end\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .and_result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_result,\n    output wire [31:0] or_result\n);\n    assign and_result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255)\n        count <= 0;\n      else if (mode == 0)\n        count <= count + 1;\n      else\n        count <= count - 1;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (~mode);\n  end\nendmodule"}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n    wire [7:0] Bout0, Bout1, Bout2, Bout3;\n    wire [7:0] D0, D1, D2, D3;\n\n    subtractor8 BIT0(.A(A[1:8]), .B(B[1:8]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor8 BIT1(.A(A[9:16]), .B(B[9:16]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor8 BIT2(.A(A[17:24]), .B(B[17:24]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n    subtractor8 BIT3(.A(A[25:32]), .B(B[25:32]), .Bin(Bout2), .D(D3), .Bout(Bout3));\n\n    assign D = {D3, D2, D1, D0};\n    assign Bout = Bout3;\nendmodule\n\nmodule subtractor8(A, B, Bin, D, Bout);\n    input [7:1] A;\n    input [7:1] B;\n    input Bin;\n    output [7:1] D;\n    output Bout;\n    wire [3:1] Bout0, Bout1, Bout2;\n    wire [3:1] D0, D1, D2;\n\n    subtractor4 BIT0(.A(A[1:4]), .B(B[1:4]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor4 BIT1(.A(A[5:8]), .B(B[5:8]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n    subtractor4 BIT2(.A(A[9:12]), .B(B[9:12]), .Bin(Bout1), .D(D2), .Bout(Bout2));\n\n    assign D = {D2, D1, D0};\n    assign Bout = Bout2;\nendmodule\n\nmodule subtractor4(A, B, Bin, D, Bout);\n    input [3:1] A;\n    input [3:1] B;\n    input Bin;\n    output [3:1] D;\n    output Bout;\n    wire [1:1] Bout0, Bout1;\n    wire [1:1] D0, D1;\n\n    subtractor2 BIT0(.A(A[1]), .B(B[1]), .Bin(Bin), .D(D0), .Bout(Bout0));\n    subtractor2 BIT1(.A(A[2]), .B(B[2]), .Bin(Bout0), .D(D1), .Bout(Bout1));\n\n    assign D = {D1, D0};\n    assign Bout = Bout1;\nendmodule\n\nmodule subtractor2(A, B, Bin, D, Bout);\n    input A;\n    input B;\n    input Bin;\n    output D;\n    output Bout;\n    wire Bout0;\n    wire D0;\n\n    assign {Bout0, D0} = A - B - Bin;\n\n    assign D = D0;\n    assign Bout = Bout0;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate the subtractor module\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate the bitwise operator module\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result),\n        .or_result(or_result)\n    );\n\n    // Control logic to determine the operation\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire [31:0] or_result\n);\n    assign result = a & b;\n    assign or_result = a | b;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Generate count values based on mode\n  assign count_value_up = mode ? 8'h00 : count_value;\n  assign count_value_down = mode ? count_value : 8'h00;\n\n  // Assign the output value\n  assign count = count_value_up + count_value_down;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 8'h00;\n    end else if (enable) begin\n      count <= count + 1;\n    end\n  end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Instruction format\n`define OPCODE 5:0\n`define RD 11:7\n`define RS1 19:15\n`define RS2 24:20\n`define IMMEDIATE 31:25\n\n// Register file\n`define REG_SIZE 32\n\n// Instruction memory\n`define INSTR_MEM_SIZE 32\n\n// Pipeline stages\nstage_fetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(fetch.out_instr)\n);\n\nstage_execute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(fetch.out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(execute.out_reg_file)\n);\n\nstage_writeback writeback (\n    .clk(clk),\n    .rst(rst),\n    .reg_file(execute.out_reg_file),\n    .out_reg_file(writeback.out_reg_file)\n);\n\nendmodule\n\nmodule stage_fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output [31:0] out_instr\n);\n    assign out_instr = instr_mem[pc];\nendmodule\n\nmodule stage_execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    wire [31:0] op1, op2;\n    wire [5:0] opcode;\n    wire [4:0] rd, rs1, rs2;\n    wire [20:0] immediate;\n\n    assign opcode = instr[`OPCODE];\n    assign rd = instr[`RD];\n    assign rs1 = instr[`RS1];\n    assign rs2 = instr[`RS2];\n    assign immediate = instr[`IMMEDIATE];\n\n    assign op1 = reg_file[rs1];\n    assign op2 = reg_file[rs2];\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out_reg_file[rd] <= 0;\n        end else begin\n            case (opcode)\n                `ADD: out_reg_file[rd] <= op1 + op2;\n                `SUB: out_reg_file[rd] <= op1 - op2;\n                default: out_reg_file[rd] <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule stage_writeback(\n    input clk,\n    input rst,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file [0:31]\n);\n    assign out_reg_file = reg_file;\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 0;\n        end else if (t) begin\n            q <= ~q;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Assign the count value based on mode\n  assign count_value_up = count_value + 1;\n  assign count_value_down = count_value - 1;\n  assign count_value = mode ? count_value_down : count_value_up;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + (count ? 1 : 0);\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  \n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Assign the output based on mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= count + (mode == 0);\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter submodule\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Generate the count value based on mode\n  assign count_value_up = enable ? count_value + 1 : count_value;\n  assign count_value_down = enable ? count_value - 1 : count_value;\n  assign count_value = mode ? count_value_down : count_value_up;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + 1;\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  \n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n  \n  // Select the counter output based on mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n  \nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else if (mode == 0) begin\n        count <= count + 1;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b001000\n\n// Define stages\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(out_reg_file)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_reg_file),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .rst(rst),\n    .out_reg_file(out_reg_file),\n    .reg_file(reg_file)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] out_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_instr <= 0;\n        else\n            out_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    reg [5:0] opcode;\n    reg [4:0] rd;\n    reg [4:0] rs1;\n    reg [4:0] rs2;\n    reg [31:0] imm;\n    reg [31:0] result;\n\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            opcode <= 0;\n            rd <= 0;\n            rs1 <= 0;\n            rs2 <= 0;\n            imm <= 0;\n            result <= 0;\n            out_reg_file <= 0;\n        end\n        else begin\n            opcode <= instr[31:26];\n            rd <= instr[11:7];\n            rs1 <= instr[19:15];\n            rs2 <= instr[24:20];\n            imm <= instr[31:20];\n            case(opcode)\n                `ADD: result <= reg_file[rs1] + reg_file[rs2];\n                `SUB: result <= reg_file[rs1] - reg_file[rs2];\n            endcase\n            out_reg_file <= result;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file,\n    output reg [31:0] reg_file [0:31]\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) begin\n            reg_file[0] <= 0;\n            reg_file[1] <= 0;\n            reg_file[2] <= 0;\n            reg_file[3] <= 0;\n            reg_file[4] <= 0;\n            reg_file[5] <= 0;\n            reg_file[6] <= 0;\n            reg_file[7] <= 0;\n            reg_file[8] <= 0;\n            reg_file[9] <= 0;\n            reg_file[10] <= 0;\n            reg_file[11] <= 0;\n            reg_file[12] <= 0;\n            reg_file[13] <= 0;\n            reg_file[14] <= 0;\n            reg_file[15] <= 0;\n            reg_file[16] <= 0;\n            reg_file[17] <= 0;\n            reg_file[18] <= 0;\n            reg_file[19] <= 0;\n            reg_file[20] <= 0;\n            reg_file[21] <= 0;\n            reg_file[22] <= 0;\n            reg_file[23] <= 0;\n            reg_file[24] <= 0;\n            reg_file[25] <= 0;\n            reg_file[26] <= 0;\n            reg_file[27] <= 0;\n            reg_file[28] <= 0;\n            reg_file[29] <= 0;\n            reg_file[30] <= 0;\n            reg_file[31] <= 0;\n        end\n        else begin\n            reg_file[rd] <= out_reg_file;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n  \n  assign count = mode ? ~count_value + 1 : count_value;\n  \nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (~mode);\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  \n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the counter output based on mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else if (mode == 0) begin\n        count <= count + 1;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  assign count = mode ? ~count_value + 1 : count_value;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 0;\n    else if (enable)\n      count <= count + (~mode);\n  end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Fetch stage\nfetch fetch (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .pc(reg_file[31]),\n    .out_instr(out_instr)\n);\n\n// Execute stage\nexecute execute (\n    .clk(clk),\n    .rst(rst),\n    .instr(out_instr),\n    .reg_file(reg_file),\n    .out_reg_file(out_reg_file)\n);\n\n// Writeback stage\nwriteback writeback (\n    .clk(clk),\n    .rst(rst),\n    .out_reg_file(out_reg_file)\n);\n\nwire [31:0] out_instr;\n\nendmodule\n\nmodule fetch(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] pc,\n    output reg [31:0] out_instr\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_instr <= 0;\n        else\n            out_instr <= instr_mem[pc];\n    end\nendmodule\n\nmodule execute(\n    input clk,\n    input rst,\n    input [31:0] instr,\n    input [31:0] reg_file [0:31],\n    output reg [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_reg_file <= 0;\n        else begin\n            case(instr[5:0])\n                `ADD: out_reg_file <= reg_file[instr[10:6]] + reg_file[instr[15:11]];\n                `SUB: out_reg_file <= reg_file[instr[10:6]] - reg_file[instr[15:11]];\n                default: out_reg_file <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule writeback(\n    input clk,\n    input rst,\n    input [31:0] out_reg_file\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            out_reg_file <= 0;\n        else\n            out_reg_file <= out_reg_file;\n    end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(count[2]));\n\n    // Toggle t0 on every clock cycle\n    assign t0 = 1'b1;\n\n    // Toggle t1 when all lower bits are high\n    assign t1 = count[0] & count[1] & count[2];\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter submodule\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Generate the count value based on mode\n  assign count_value_up = mode ? 8'h00 : count_value;\n  assign count_value_down = mode ? count_value : 8'h00;\n\n  // Assign the count value based on mode\n  assign count = mode ? count_value_down : count_value_up;\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'h00;\n    else if (enable)\n      count <= count + 1;\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Generate the count value based on the mode\n  assign count_value_up = count_value + 1;\n  assign count_value_down = count_value - 1;\n  assign count_value = (mode == 0) ? count_value_up : count_value_down;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      count <= (mode == 0) ? count + 1 : count - 1;\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(count[0]));\n    my_tff u1 (.clk(clk), .reset(reset), .t(count[0]), .q(count[1]));\n    my_tff u2 (.clk(clk), .reset(reset), .t(count[1] & count[0]), .q(count[2]));\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "stagepipe3", "response": "// Operation codes\n`define ADD 6'b000000\n`define SUB 6'b000010\n\n// Module to fetch instructions from memory\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    output [31:0] fetched_instr\n);\n    assign fetched_instr = instr_mem[0];\nendmodule\n\n// Module to execute instructions\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] fetched_instr,\n    input [31:0] reg_file [0:31],\n    output [31:0] result\n);\n    wire [5:0] opcode = fetched_instr[31:26];\n    wire [5:0] rd = fetched_instr[11:6];\n    wire [5:0] rs1 = fetched_instr[20:15];\n    wire [5:0] rs2 = fetched_instr[25:20];\n    wire [31:0] operand1 = reg_file[rs1];\n    wire [31:0] operand2 = reg_file[rs2];\n\n    assign result = (opcode == `ADD) ? operand1 + operand2 : operand1 - operand2;\nendmodule\n\n// Module to write back the result to the register file\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] result,\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    assign out_reg_file[rd] = result;\nendmodule\n\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file\n);\n    wire [31:0] fetched_instr;\n    wire [31:0] result;\n\n    fetch_stage fetch (.clk(clk), .rst(rst), .instr_mem(instr_mem), .fetched_instr(fetched_instr));\n    execute_stage execute (.clk(clk), .rst(rst), .fetched_instr(fetched_instr), .reg_file(reg_file), .result(result));\n    writeback_stage writeback (.clk(clk), .rst(rst), .result(result), .reg_file(reg_file), .out_reg_file(out_reg_file));\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b0), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Output the count\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n\n  // Instantiate the counter module\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Select the appropriate count value based on mode\n  assign count = (mode == 0) ? count_value : ~count_value + 1;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else if (mode == 0) begin\n        count <= count + 1;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate the T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_value;\n  wire [7:0] count_value_up;\n  wire [7:0] count_value_down;\n\n  // Instantiate the counter\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .count(count_value)\n  );\n\n  // Assign the count value based on the mode\n  assign count_value_up = count_value + 1;\n  assign count_value_down = count_value - 1;\n\n  assign count = (mode == 0) ? count_value_up : count_value_down;\n\nendmodule\n\n// Counter module\nmodule Counter (\n  input clk,\n  input rst,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end else if (enable) begin\n      if (count == 255) begin\n        count <= 0;\n      end else if (count == 0) begin\n        count <= 255;\n      end else if (count < 255) begin\n        count <= count + 1;\n      end else begin\n        count <= count - 1;\n      end\n    end\n  end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .data_in(d0),\n        .load(load0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .data_in(d1),\n        .load(load1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] data_in,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= data_in;\n    end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate the T flip-flops\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[1] & count[0]),\n        .q(count[2])\n    );\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2;\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .reset(reset), .t(1'b1), .q(t0));\n    my_tff u1 (.clk(clk), .reset(reset), .t(t0), .q(t1));\n    my_tff u2 (.clk(clk), .reset(reset), .t(t1), .q(t2));\n\n    // Assign the output\n    assign count = {t2, t1, t0};\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input reset,\n    input t,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 1'b0;\n        else if (t)\n            q <= ~q;\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\n// Submodule for initialization\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\n// Submodule for counting\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\n// Submodule for initializing the counter to zero\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\n// Submodule for counting up\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in && (count == 0))\n            data_out <= data_in;\n        else if (valid_in && (count > 0))\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (valid_in && (count == 4))\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for increment\n    wire [3:0] inc_out;\n    increment_count inc_count (\n        .clk(clk),\n        .reset(reset),\n        .out(inc_out)\n    );\n\n    // Output\n    assign out = init_out + inc_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule increment_count (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_up count_up (\n        .clk(clk),\n        .reset(reset),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = init_out + count_out;\n\nendmodule\n\n// Submodule for initialization\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\n// Submodule for counting\nmodule count_up (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    input       [2:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [2:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] l0_out, l1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(l0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(l1_out)\n    );\n\n    assign q0 = l0_out;\n    assign q1 = l1_out;\n\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b00000000;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b00000000;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    // Instantiate two latches\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(q0)\n    );\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(q1)\n    );\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b00000000;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .valid_in(valid_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\n// Counter module\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\n// Data accumulator module\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\n// Valid output module\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    increment_count increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\n// Submodule for initialization\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\n// Submodule for counting\nmodule increment_count (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end else begin\n            out <= init_out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] q0_int, q1_int;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(q0_int)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(q1_int)\n    );\n\n    assign q0 = q0_int;\n    assign q1 = q1_int;\n\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b00000000;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    increment_count inc_count (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule increment_count (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_count(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_count;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    // Instantiating two latches\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    // Outputs\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\n\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 8'b0;\n        end else if (load) begin\n            q <= d;\n        end\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    increment_count inc_count (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        if (reset) begin\n            out <= 4'b0000;\n        end\n    end\nendmodule\n\nmodule increment_count (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    wire [7:0] latch0_out;\n    wire [7:0] latch1_out;\n\n    latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(latch0_out)\n    );\n\n    latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(latch1_out)\n    );\n\n    assign q0 = latch0_out;\n    assign q1 = latch1_out;\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0(\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1(\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for a single shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 8'b0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    // Submodule for initialization\n    wire [3:0] init_out;\n    initial_count init_count (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for counting\n    wire [3:0] count_out;\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .init_value(init_out),\n        .out(count_out)\n    );\n\n    // Output\n    assign out = count_out;\n\nendmodule\n\nmodule initial_count (\n    input wire reset,\n    output reg [3:0] out\n);\n    always @(posedge reset) begin\n        out <= 4'b0000;\n    end\nendmodule\n\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] init_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_value;\n        end else begin\n            out <= out + 1;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .accumulated_data(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulated_data <= 0;\n        else if (valid_in)\n            accumulated_data <= accumulated_data + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        out <= 8'b00000000;\n    else if (load)\n        out <= data;\n    else if (shift)\n        out <= out >> 1;\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .count(count),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    input       [3:0]   count,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 8'b00000000;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= {1'b0, out[7:1]};\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodule instances\ncounter_logic u_counter_logic (\n    .count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count)\n);\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\nreg [15:0] next_count_reg;\n\nalways @(*) begin\n    if (up_down) begin\n        next_count_reg = count + 1;\n    end else begin\n        next_count_reg = count - 1;\n    end\nend\n\nassign next_count = next_count_reg;\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_reg\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_reg <= 0;\n    end else begin\n        count_reg <= count;\n    end\nend\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .accumulated_data(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   accumulated_data\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            accumulated_data <= 0;\n        else if (valid_in)\n            accumulated_data <= accumulated_data + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodule instances\ncounter_logic u_counter_logic (\n    .current_count(count),\n    .next_count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .current_count(count),\n    .next_count(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    output reg [15:0] next_count,\n    input wire up_down\n);\n\nalways @(*) begin\n    if (up_down)\n        next_count = current_count + 1;\n    else\n        next_count = current_count - 1;\nend\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        next_count <= 0;\n    else\n        next_count <= current_count;\nend\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (count == 4)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 8'b00000000;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_product_bit GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_product_bit GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_product_bit GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_product_bit GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_product_bit GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_product_bit GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_product_bit GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_2 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_2 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_2 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_2 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_2 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_2 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_2 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_2 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_2(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_3 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_3 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_3 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_3 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_3 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_3 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_3 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_3 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_3(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_4 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_4 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_4 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_4 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_4 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_4 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_4 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_4 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_4(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_5 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_5 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_5 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_5 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_5 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_5 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_5 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_5 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_5(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_6 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_6 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_6 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_6 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_6 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_6 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_6 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_6 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_6(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_7 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_7 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_7 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_7 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_7 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_7 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_7 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_7 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_7(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_8 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_8 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_8 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_8 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_8 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_8 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_8 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_8 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_8(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_9 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_9 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_9 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_9 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_9 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_9 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_9 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_9 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_9(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_10 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_10 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_10 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_10 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_10 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_10 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_10 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_10 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_10(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_11 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_11 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_11 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_11 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_11 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_11 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_11 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_11 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_11(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_12 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_12 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_12 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_12 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_12 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_12 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_12 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_12 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_12(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_13 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_13 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_13 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_13 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_13 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_13 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_13 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_13 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_13(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_14 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_14 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_14 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_14 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_14 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_14 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_14 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_14 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_14(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_15 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_15 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_15 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_15 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_15 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_15 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_15 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_15 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_15(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_16 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_16 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_16 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_16 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_16 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_16 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_16 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_16 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_16(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_17 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_17 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_17 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_17 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_17 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_17 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_17 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_17 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_17(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_18 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_18 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_18 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_18 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_18 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_18 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_18 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_18 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_18(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_19 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_19 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_19 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_19 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_19 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_19 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_19 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_19 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_19(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_20 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_20 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_20 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_20 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_20 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_20 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_20 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_20 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_20(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_21 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_21 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_21 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_21 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_21 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_21 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_21 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_21 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_21(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_22 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_22 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_22 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_22 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_22 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_22 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_22 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_22 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_22(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_23 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_23 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_23 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_23 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_23 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_23 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_23 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_23 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_23(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_24 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_24 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_24 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_24 GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_24 GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_24 GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_24 GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_24 GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_24(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_25 GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_25 GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_25 GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_25 GP"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 8'b0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= out >> 1;\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [2:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        out <= 8'b00000000;\n    else if (load)\n        out <= data;\n    else if (shift)\n        out <= {1'b0, out[7:1]};\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input [7:0] X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input [7:0] X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 8'b0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodule instances\ncounter_logic u_counter_logic (\n    .count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count)\n);\n\nendmodule\n\n// Submodule for counter logic\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\nreg [15:0] next_count_reg;\n\nalways @(*) begin\n    if (up_down) begin\n        next_count_reg = count + 1;\n    end else begin\n        next_count_reg = count - 1;\n    end\nend\n\nassign next_count = next_count_reg;\n\nendmodule\n\n// Submodule for counter register\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count,\n    output reg [15:0] count_reg\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        count_reg <= 0;\n    end else begin\n        count_reg <= count;\n    end\nend\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 8'b0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n// Submodule instances\ncounter_logic u_counter_logic (\n    .count(count),\n    .up_down(up_down)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .count(count)\n);\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\nassign next_count = (up_down) ? count + 1 : count - 1;\n\nendmodule\n\n// Counter register module\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 0;\n    else\n        count <= next_count;\nend\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        out <= 0;\n    end else if (load) begin\n        out <= data;\n    end else if (shift) begin\n        out <= out >> 1;\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "accu", "response": "`timescale 1ns / 1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [3:0] count;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .count(count)\n    );\n\n    // Instantiate the data accumulator module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .valid_in(valid_in),\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .valid_out(valid_out)\n    );\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    output reg  [3:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (valid_in)\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n    input       [7:0]   data_in,\n    output reg  [9:0]   data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 0;\n        else if (valid_in)\n            data_out <= data_out + data_in;\n    end\n\nendmodule\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   count,\n    output reg          valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (count == 4)\n            valid_out <= 1;\n        else\n            valid_out <= 0;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    // Submodule instances\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            out <= 0;\n        end else if (load) begin\n            out <= data;\n        end else if (shift) begin\n            out <= out >> 1;\n        end\n    end\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .count(next_count),\n        .up_down(up_down)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n\n    assign next_count = up_down ? count + 1 : count - 1;\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 0;\n        else\n            count <= next_count;\n    end\n\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n// Submodule instances\nshift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .data(data0),\n    .shift(shift0),\n    .out(out0)\n);\n\nshift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .data(data1),\n    .shift(shift1),\n    .out(out1)\n);\n\nendmodule\n\n// Submodule for a single shift register\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        out <= 0;\n    else if (load)\n        out <= data;\n    else if (shift)\n        out <= out >> 1;\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic module\n    counter_logic u_counter_logic (\n        .up_down(up_down),\n        .count(next_count)\n    );\n\n    // Instantiate the counter register module\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire up_down,\n    output reg [15:0] count\n);\n    always @(*) begin\n        if (up_down) begin\n            count = count + 1;\n        end else begin\n            count = count - 1;\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= next_count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product_bit GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_product_bit GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_product_bit GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_product_bit GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_product_bit GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_product_bit GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_product_bit GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_product_bit GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    // Instantiate the partial product generators\n    gen_product_bit_shift GP0(.X(X), .Y(Y), .P(p0));\n    gen_product_bit_shift GP1(.X(X), .Y(Y), .P(p1));\n    gen_product_bit_shift GP2(.X(X), .Y(Y), .P(p2));\n    gen_product_bit_shift GP3(.X(X), .Y(Y), .P(p3));\n    gen_product_bit_shift GP4(.X(X), .Y(Y), .P(p4));\n    gen_product_bit_shift GP5(.X(X), .Y(Y), .P(p5));\n    gen_product_bit_shift GP6(.X(X), .Y(Y), .P(p6));\n    gen_product_bit_shift GP7(.X(X), .Y(Y), .P(p7));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_shift(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .init_state(init_out),\n        .out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire [7:0] init_state,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= init_state;\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Instantiating submodules\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .abs_value(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .neg_value(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] abs_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        abs_value <= 8'd0;\n    end else begin\n        if (sign) begin\n            abs_value <= -value;\n        end else begin\n            abs_value <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for calculating negated absolute value\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] neg_value\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        neg_value <= 8'd0;\n    end else begin\n        if (sign) begin\n            neg_value <= value;\n        end else begin\n            neg_value <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for managing division control\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter;\nreg [7:0] shift_reg;\nreg [15:0] quotient_reg;\nreg [15:0] remainder_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 4'd0;\n        shift_reg <= 8'd0;\n        quotient_reg <= 16'd0;\n        remainder_reg <= 16'd0;\n    end else begin\n        if (opn_valid) begin\n            if (res_ready) begin\n                counter <= 4'd0;\n                shift_reg <= 8'd0;\n                quotient_reg <= 16'd0;\n                remainder_reg <= 16'd0;\n            end else begin\n                if (counter < 4'd15) begin\n                    counter <= counter + 4'd1;\n                    shift_reg <= shift_reg << 1;\n                    if (shift_reg[7]) begin\n                        shift_reg[7] <= 1'b0;\n                        quotient_reg[counter] <= 1'b1;\n                    end else begin\n                        quotient_reg[counter] <= 1'b0;\n                    end\n                    remainder_reg <= remainder_reg - (shift_reg ^ neg_divisor);\n                end else begin\n                    counter <= 4'd0;\n                    shift_reg <= 8'd0;\n                    quotient_reg <= 16'd0;\n                    remainder_reg <= remainder_reg - (shift_reg ^ neg_divisor);\n                end\n            end\n        end\n    end\nend\n\nalways @(*) begin\n    quotient = quotient_reg;\n    remainder = remainder_reg;\nend\n\nendmodule\n\n// Submodule for managing result validity\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 1'b0;\n        result <= 16'd0;\n    end else begin\n        if (res_ready) begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n        end else begin\n            if (opn_valid) begin\n                res_valid <= 1'b1;\n                result <= {remainder, quotient};\n            end else begin\n                res_valid <= 1'b0;\n                result <= 16'd0;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Cin,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Cin;\n    assign Carry_out = (X & Y) | (Y & Cin) | (X & Cin);\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    cyclic_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(transition_out)\n    );\n\n    // Output\n    assign out = init_out | transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule cyclic_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {~out[0], out[7:1]};\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        res_valid <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else begin\n        if (opn_valid) begin\n            if (res_ready) begin\n                res_valid <= 1;\n                quotient <= shift_reg;\n                remainder <= dividend;\n            end else begin\n                res_valid <= 0;\n                quotient <= 0;\n                remainder <= 0;\n            end\n            counter <= counter + 1;\n            shift_reg <= {shift_reg[14:0], dividend[7]};\n            if (counter == 8) begin\n                shift_reg <= {shift_reg[14:0], 1'b0};\n                counter <= 0;\n            end else begin\n                remainder <= remainder - divisor;\n            end\n        end else begin\n            res_valid <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= {remainder, quotient};\n        end else begin\n            result <= 0;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Carry_in(1'b0), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Carry_in(carry[0]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Carry_in(carry[1]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Carry_in(carry[2]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    input Carry_in,   // Carry input\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Carry_in(1'b0), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Carry_in(carry[0]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Carry_in(carry[1]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Carry_in(carry[2]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    input Carry_in,   // Carry input\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Carry_in(1'b0), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Carry_in(carry[0]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    input Carry_in,   // Carry input\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    adder_1bit adder(.X(X[0]), .Y(Y[0]), .Carry_in(Carry_in), .Sum(Sum[0]), .Carry_out(Carry_out));\n\nendmodule\n\nmodule adder_1bit(\n    input X,    // First 1-bit input operand\n    input Y,    // Second 1-bit input operand\n    input Carry_in,   // Carry input\n    output Sum, // 1-bit output sum\n    output Carry_out  // Carry output\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] initial_state;\n    wire [7:0] next_state;\n\n    // Submodule for initialization\n    initial_state_module init (\n        .clk(clk),\n        .reset(reset),\n        .out(initial_state)\n    );\n\n    // Submodule for state transition\n    state_transition_module transition (\n        .clk(clk),\n        .reset(reset),\n        .initial_state(initial_state),\n        .next_state(next_state)\n    );\n\n    // Output the current state of the ring counter\n    assign out = next_state;\n\nendmodule\n\nmodule initial_state_module (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition_module (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] initial_state,\n    output reg [7:0] next_state\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_state <= initial_state;\n        end else begin\n            next_state <= {next_state[6:0], ~next_state[7]};\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\n\n// Instantiate the absolute value calculation module\nabs_value abs_dividend (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\n// Instantiate the negative divisor calculation module\nneg_value neg_divisor_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\n// Instantiate the division control logic module\ndivider_control ctrl (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .quotient(quotient),\n    .res_valid(res_valid)\n);\n\n// Instantiate the result management module\nresult_management res_mgmt (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .result(result)\n);\n\n// Connect the absolute dividend to the quotient calculation\nassign quotient[15:8] = abs_dividend;\n\n// Connect the negated divisor to the quotient calculation\nassign quotient[7:0] = neg_divisor;\n\nendmodule\n\n// Absolute value calculation module\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Negative value calculation module\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Division control logic module\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [15:0] quotient,\n    output reg res_valid\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        res_valid <= 0;\n    end else begin\n        if (opn_valid && !res_valid) begin\n            counter <= 4'd0;\n            shift_reg <= {8'd0, dividend};\n            res_valid <= 1;\n        end else if (res_ready) begin\n            if (counter < 4'd15) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[14:0], 1'b0};\n            end else begin\n                res_valid <= 0;\n            end\n        end\n    end\nend\n\nendmodule\n\n// Result management module\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            if (res_valid) begin\n                result <= quotient;\n            end else begin\n                result <= 0;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP00(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP01(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP02(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP03(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP04(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP05(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP06(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP07(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 2 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Sum(Sum[1:0]), .Carry_out(Carry_out));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Sum(Sum[3:2]), .Carry_out(Carry_out));\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit full adder\n    full_adder fa(.X(X), .Y(Y), .Sum(Sum), .Carry_out(Carry_out));\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Carry_in,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .out(transition_out)\n    );\n\n    // Combine the two outputs\n    assign out = init_out | transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    cyclic_state transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .out(transition_out)\n    );\n\n    // Output\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule cyclic_state (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Carry_in(1'b0), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Carry_in(carry[0]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Carry_in(carry[1]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Carry_in(carry[2]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    input Carry_in,   // Carry input\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] temp_sum;\n\n    // Full adder for 8-bit numbers\n    assign {Carry_out, temp_sum} = X + Y + Carry_in;\n    assign Sum = temp_sum[7:0];\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_initialization init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_initialization (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Submodule for initialization\n    initial_state init (\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output of the ring counter\n    assign out = transition_out;\n\nendmodule\n\nmodule initial_state (\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge reset) begin\n        out <= 8'b0000_0001;\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire [15:0] quotient;\n    wire [7:0] remainder;\n\n    // Submodule instances\n    abs_value abs_dividend (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .dividend(abs_dividend),\n        .divisor(neg_divisor),\n        .counter(counter),\n        .shift_reg(shift_reg)\n    );\n\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .quotient(quotient),\n        .remainder(remainder),\n        .result(result)\n    );\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg\n);\n\n    reg [3:0] counter_reg;\n    reg [7:0] shift_reg_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_reg <= 0;\n            shift_reg_reg <= 0;\n        end else begin\n            if (counter_reg == 0) begin\n                counter_reg <= 15;\n                shift_reg_reg <= dividend;\n            end else begin\n                counter_reg <= counter_reg - 1;\n                shift_reg_reg <= {shift_reg_reg[6:0], 1'b0};\n            end\n        end\n    end\n\n    always @* begin\n        counter = counter_reg;\n        shift_reg = shift_reg_reg;\n    end\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [15:0] quotient,\n    input wire [7:0] remainder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    reg [15:0] quotient_reg;\n    reg [7:0] remainder_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n            quotient_reg <= 0;\n            remainder_reg <= 0;\n        end else begin\n            if (res_ready) begin\n                res_valid <= opn_valid;\n                result <= {remainder, quotient};\n                quotient_reg <= quotient;\n                remainder_reg <= remainder;\n            end else begin\n                res_valid <= 0;\n                result <= 0;\n                quotient_reg <= 0;\n                remainder_reg <= 0;\n            end\n        end\n    end\n\n    always @* begin\n        if (counter == 0) begin\n            result <= {remainder_reg, quotient_reg};\n        end else begin\n            result <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit GP0(.x(x), .y(y[0]), .p(p0));\n    gen_product_bit GP1(.x(x), .y(y[1]), .p(p1));\n    gen_product_bit GP2(.x(x), .y(y[2]), .p(p2));\n    gen_product_bit GP3(.x(x), .y(y[3]), .p(p3));\n    gen_product_bit GP4(.x(x), .y(y[4]), .p(p4));\n    gen_product_bit GP5(.x(x), .y(y[5]), .p(p5));\n    gen_product_bit GP6(.x(x), .y(y[6]), .p(p6));\n    gen_product_bit GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product_bit_shift GP0(.x(x), .y(y), .p(p0));\n    gen_product_bit_shift GP1(.x(x), .y(y), .p(p1));\n    gen_product_bit_shift GP2(.x(x), .y(y), .p(p2));\n    gen_product_bit_shift GP3(.x(x), .y(y), .p(p3));\n    gen_product_bit_shift GP4(.x(x), .y(y), .p(p4));\n    gen_product_bit_shift GP5(.x(x), .y(y), .p(p5));\n    gen_product_bit_shift GP6(.x(x), .y(y), .p(p6));\n    gen_product_bit_shift GP7(.x(x), .y(y), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product_bit_shift(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = (x & y) << 1;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the final state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [30:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit full adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input [1:0] X,    // First input operand\n    input [1:0] Y,    // Second input operand\n    output [1:0] Sum, // Output sum\n    output Carry_out  // Carry output\n);\n\n    assign Sum = X ^ Y;\n    assign Carry_out = (X & Y) | (X & Sum) | (Y & Sum);\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_out;\n    wire [7:0] transition_out;\n\n    // Instantiate the state initialization module\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .out(init_out)\n    );\n\n    // Instantiate the state transition module\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .init_out(init_out),\n        .transition_out(transition_out)\n    );\n\n    // Output the transitioned state\n    assign out = transition_out;\n\nendmodule\n\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= 8'b0000_0001;\n        end\n    end\nendmodule\n\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] init_out,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            out <= init_out;\n        end else begin\n            out <= {out[6:0], out[7]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate wires and registers\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\nwire [3:0] counter;\nwire [15:0] shift_reg;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .shift_reg(shift_reg),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .result(result),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Assigning intermediate values\nassign result = {remainder, quotient};\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 8'd0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negating divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 8'd0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [15:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter_reg;\nreg [15:0] shift_reg_reg;\nreg [15:0] quotient_reg;\nreg [15:0] remainder_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter_reg <= 4'd0;\n        shift_reg_reg <= 16'd0;\n        quotient_reg <= 16'd0;\n        remainder_reg <= 16'd0;\n    end else begin\n        if (opn_valid) begin\n            if (sign) begin\n                // Signed division\n                if (shift_reg_reg[15] == 1) begin\n                    shift_reg_reg <= shift_reg_reg - {1'b0, neg_divisor};\n                end else begin\n                    shift_reg_reg <= shift_reg_reg + {1'b0, neg_divisor};\n                end\n            end else begin\n                // Unsigned division\n                shift_reg_reg <= shift_reg_reg >> 1;\n            end\n            if (shift_reg_reg[15] == 1) begin\n                quotient_reg <= quotient_reg + 16'd1;\n            end\n            remainder_reg <= remainder_reg - {1'b0, neg_divisor};\n            counter_reg <= counter_reg + 1;\n        end\n    end\nend\n\nassign counter = counter_reg;\nassign shift_reg = shift_reg_reg;\nassign quotient = quotient_reg;\nassign remainder = remainder_reg;\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    output reg res_valid,\n    input wire [15:0] result,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 1'b0;\n    end else begin\n        if (res_ready) begin\n            res_valid <= 1'b0;\n        end else if (opn_valid) begin\n            res_valid <= 1'b1;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    // Carry propagation\n    assign Carry_out = carry[4];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    // Carry propagation\n    assign Carry_out = carry[2];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Perform addition\n    assign Sum = X + Y;\n    assign Carry_out = (X[1] & Y[1]) | (X[1] & Sum[1]) | (Y[1] & Sum[1]);\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_out;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .count_out(count_out),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    input [3:0] count_out,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product GP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product GP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product GP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product GP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product GP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product GP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product GP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\n\n// Instantiate the absolute value calculation module\nabs_value abs_dividend (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(dividend),\n    .result(abs_dividend)\n);\n\n// Instantiate the negative divisor calculation module\nneg_value neg_divisor_mod (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .divisor(divisor),\n    .result(neg_divisor)\n);\n\n// Instantiate the division control logic module\ndivider_control ctrl (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient)\n);\n\n// Instantiate the result management module\nresult_management res_mgmt (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .abs_dividend(abs_dividend),\n    .neg_divisor(neg_divisor),\n    .sign(sign),\n    .result(result)\n);\n\nendmodule\n\n// Absolute value calculation module\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -dividend;\n            end else begin\n                result <= dividend;\n            end\n        end\n    end\nendmodule\n\n// Negative divisor calculation module\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] divisor,\n    output reg [7:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -divisor;\n            end else begin\n                result <= divisor;\n            end\n        end\n    end\nendmodule\n\n// Division control logic module\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient\n);\n    reg [3:0] counter;\n    reg [7:0] shift_reg;\n    reg [15:0] remainder;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            remainder <= 0;\n            res_valid <= 0;\n            quotient <= 0;\n        end else begin\n            if (opn_valid && !res_valid) begin\n                counter <= 4'd0;\n                shift_reg <= dividend;\n                remainder <= 0;\n                res_valid <= 0;\n                quotient <= 0;\n            end else if (counter < 4'd15) begin\n                counter <= counter + 1;\n                shift_reg <= shift_reg << 1;\n                remainder <= remainder + (shift_reg[0] ? neg_divisor : abs_divisor);\n                res_valid <= 0;\n                quotient <= 0;\n            end else begin\n                res_valid <= 1;\n                quotient <= remainder;\n            end\n        end\n    end\nendmodule\n\n// Result management module\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    input wire sign,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (res_ready && res_valid) begin\n                if (sign) begin\n                    result <= {quotient, -remainder};\n                end else begin\n                    result <= {quotient, remainder};\n                end\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry)\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry)\n    );\n\n    // Carry propagation\n    assign Carry_out = carry;\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    output Sum,\n    output Carry_out\n);\n\n    wire c1;\n\n    xor xor0 (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum)\n    );\n\n    and and0 (\n        .X(X),\n        .Y(Y),\n        .Sum(c1)\n    );\n\n    and and1 (\n        .X(Sum),\n        .Y(Y),\n        .Sum(Carry_out)\n    );\n\n    or or0 (\n        .X(c1),\n        .Y(Sum),\n        .Sum(Carry_out)\n    );\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.x(X[0]), .y(Y), .p(p0));\n    gen_product GP1(.x(X[1]), .y(Y), .p(p1));\n    gen_product GP2(.x(X[2]), .y(Y), .p(p2));\n    gen_product GP3(.x(X[3]), .y(Y), .p(p3));\n    gen_product GP4(.x(X[4]), .y(Y), .p(p4));\n    gen_product GP5(.x(X[5]), .y(Y), .p(p5));\n    gen_product GP6(.x(X[6]), .y(Y), .p(p6));\n    gen_product GP7(.x(X[7]), .y(Y), .p(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(x, y, p);\n    input x;\n    input [7:0] y;\n    output [15:0] p;\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product PP0(.x(x), .y(y[0]), .p(p0));\n    gen_partial_product PP1(.x(x), .y(y[1]), .p(p1));\n    gen_partial_product PP2(.x(x), .y(y[2]), .p(p2));\n    gen_partial_product PP3(.x(x), .y(y[3]), .p(p3));\n    gen_partial_product PP4(.x(x), .y(y[4]), .p(p4));\n    gen_partial_product PP5(.x(x), .y(y[5]), .p(p5));\n    gen_partial_product PP6(.x(x), .y(y[6]), .p(p6));\n    gen_partial_product PP7(.x(x), .y(y[7]), .p(p7));\n\n    assign p = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(x, y, p);\n    input x;\n    input y;\n    output [15:0] p;\n\n    assign p = x * y;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_value(count_value)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out is the last carry\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 2 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n\n    // Carry out is the last carry\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Sum(Sum[1:0]), .Carry_out(Carry_out));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Sum(Sum[3:2]), .Carry_out(Carry_out));\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit full adder\n    full_adder fa(.X(X), .Y(Y), .Sum(Sum), .Carry_out(Carry_out));\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Carry_in,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .result(result),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg [15:0] result,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [7:0] counter;\nreg [15:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient <= 0;\n        remainder <= 0;\n        result <= 0;\n    end else begin\n        if (opn_valid && !res_ready) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            result <= 0;\n        end else begin\n            if (counter < 8) begin\n                counter <= counter + 1;\n                shift_reg <= shift_reg << 1;\n                quotient <= quotient << 1;\n                remainder <= remainder << 1;\n                if (shift_reg[0]) begin\n                    quotient <= quotient | 1;\n                end\n                if (remainder[0]) begin\n                    remainder <= remainder | 1;\n                end\n            end else begin\n                result <= {remainder[7:0], quotient[7:0]};\n            end\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 0;\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            res_valid <= 0;\n            result <= 0;\n        end else begin\n            if (opn_valid) begin\n                res_valid <= 1;\n                result <= {remainder[7:0], quotient[7:0]};\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_value(count_value)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_product GP0(.X(X[0]), .Y(Y), .P(p0));\n    gen_product GP1(.X(X[1]), .Y(Y), .P(p1));\n    gen_product GP2(.X(X[2]), .Y(Y), .P(p2));\n    gen_product GP3(.X(X[3]), .Y(Y), .P(p3));\n    gen_product GP4(.X(X[4]), .Y(Y), .P(p4));\n    gen_product GP5(.X(X[5]), .Y(Y), .P(p5));\n    gen_product GP6(.X(X[6]), .Y(Y), .P(p6));\n    gen_product GP7(.X(X[7]), .Y(Y), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_product(X, Y, P);\n    input X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] p0, p1, p2, p3, p4, p5, p6, p7;\n\n    gen_partial_product GP0(.X(X), .Y(Y[0]), .P(p0));\n    gen_partial_product GP1(.X(X), .Y(Y[1]), .P(p1));\n    gen_partial_product GP2(.X(X), .Y(Y[2]), .P(p2));\n    gen_partial_product GP3(.X(X), .Y(Y[3]), .P(p3));\n    gen_partial_product GP4(.X(X), .Y(Y[4]), .P(p4));\n    gen_partial_product GP5(.X(X), .Y(Y[5]), .P(p5));\n    gen_partial_product GP6(.X(X), .Y(Y[6]), .P(p6));\n    gen_partial_product GP7(.X(X), .Y(Y[7]), .P(p7));\n\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3) + (p4 << 4) + (p5 << 5) + (p6 << 6) + (p7 << 7);\n\nendmodule\n\nmodule gen_partial_product(X, Y, P);\n    input X;\n    input Y;\n    output [15:0] P;\n\n    assign P = X * Y;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_value(count_value)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] as0, as1, as2, as3, as4, as5, as6, as7;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.A(X), .B(Y), .C(as0));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.A(X), .B(Y), .C(as1));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.A(X), .B(Y), .C(as2));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.A(X), .B(Y), .C(as3));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.A(X), .B(Y), .C(as4));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.A(X), .B(Y), .C(as5));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.A(X), .B(Y), .C(as6));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.A(X), .B(Y), .C(as7));\n\n    // Assign the final product\n    assign P = as0 + (as1 << 1) + (as2 << 2) + (as3 << 3) + (as4 << 4) + (as5 << 5) + (as6 << 6) + (as7 << 7);\n\nendmodule\n\nmodule add_shift(A, B, C);\n    input [7:0] A;\n    input [7:0] B;\n    output [15:0] C;\n    wire [15:0] temp;\n\n    assign temp = (B[0]) ? (A << 0) : 16'b0;\n    assign C = (B[1]) ? (temp + (A << 1)) : temp;\n    assign temp = (B[2]) ? (A << 2) : 16'b0;\n    assign C = (B[3]) ? (C + (temp + (A << 3))) : C;\n    assign temp = (B[4]) ? (A << 4) : 16'b0;\n    assign C = (B[5]) ? (C + (temp + (A << 5))) : C;\n    assign temp = (B[6]) ? (A << 6) : 16'b0;\n    assign C = (B[7]) ? (C + (temp + (A << 7))) : C;\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    output Sum,\n    output Carry_out\n);\n\n    wire c1;\n\n    xor xor0 (\n        .A(X),\n        .B(Y),\n        .Z(Sum)\n    );\n\n    xor xor1 (\n        .A(X),\n        .B(Y),\n        .Z(c1)\n    );\n\n    and and0 (\n        .A(Sum),\n        .B(Y),\n        .Z(Carry_out)\n    );\n\n    and and1 (\n        .A(c1),\n        .B(X),\n        .Z(Carry_out)\n    );\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_value;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_value(count_value)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            count_value <= count_value + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] acc;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.x(X), .y(Y), .acc(acc));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.x(X), .y(Y), .acc(acc));\n\n    // Assign the product to the output\n    assign P = acc;\nendmodule\n\nmodule add_shift(x, y, acc);\n    input [7:0] x;\n    input [7:0] y;\n    output [15:0] acc;\n    reg [15:0] acc_reg;\n\n    always @(*) begin\n        acc_reg = acc;\n        if (y[0])\n            acc_reg = acc_reg + (x << 0);\n        if (y[1])\n            acc_reg = acc_reg + (x << 1);\n        if (y[2])\n            acc_reg = acc_reg + (x << 2);\n        if (y[3])\n            acc_reg = acc_reg + (x << 3);\n        if (y[4])\n            acc_reg = acc_reg + (x << 4);\n        if (y[5])\n            acc_reg = acc_reg + (x << 5);\n        if (y[6])\n            acc_reg = acc_reg + (x << 6);\n        if (y[7])\n            acc_reg = acc_reg + (x << 7);\n    end\n\n    assign acc = acc_reg;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire [15:0] quotient;\n    wire [7:0] remainder;\n\n    // Instantiate submodules\n    abs_value abs_dividend (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result),\n        .counter(counter),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\nendmodule\n\n// Submodule for calculating absolute value\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\n\nendmodule\n\n// Submodule for calculating negative divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 8'd0;\n        end else if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\n\nendmodule\n\n// Submodule for managing division control\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [7:0] remainder\n);\n\n    reg [3:0] counter_reg;\n    reg [7:0] shift_reg_reg;\n    reg [15:0] quotient_reg;\n    reg [7:0] remainder_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'd0;\n            shift_reg <= 8'd0;\n            quotient <= 16'd0;\n            remainder <= 8'd0;\n        end else if (opn_valid) begin\n            counter <= counter_reg + 1;\n            shift_reg <= shift_reg_reg;\n            quotient <= quotient_reg;\n            remainder <= remainder_reg;\n        end else begin\n            counter <= 4'd0;\n            shift_reg <= 8'd0;\n            quotient <= 16'd0;\n            remainder <= 8'd0;\n        end\n    end\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_reg <= 4'd0;\n            shift_reg_reg <= 8'd0;\n            quotient_reg <= 16'd0;\n            remainder_reg <= 8'd0;\n        end else if (opn_valid) begin\n            counter_reg <= counter + 1;\n            shift_reg_reg <= {shift_reg[6:0], dividend[7]};\n            quotient_reg <= {quotient[14:0], shift_reg};\n            remainder_reg <= dividend - quotient_reg;\n        end else begin\n            counter_reg <= 4'd0;\n            shift_reg_reg <= 8'd0;\n            quotient_reg <= 16'd0;\n            remainder_reg <= 8'd0;\n        end\n    end\n\nendmodule\n\n// Submodule for managing result validity\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    output reg res_valid,\n    input wire [15:0] result,\n    input wire [3:0] counter,\n    input wire [15:0] quotient,\n    input wire [7:0] remainder\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n        end else if (res_ready) begin\n            res_valid <= 1'b0;\n        end else if (opn_valid) begin\n            res_valid <= 1'b1;\n        end else if (counter == 4'd0) begin\n            res_valid <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] acc;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.x(X), .y(Y), .shift(0), .acc(acc));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.x(X), .y(Y), .shift(1), .acc(acc));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.x(X), .y(Y), .shift(2), .acc(acc));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.x(X), .y(Y), .shift(3), .acc(acc));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.x(X), .y(Y), .shift(4), .acc(acc));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.x(X), .y(Y), .shift(5), .acc(acc));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.x(X), .y(Y), .shift(6), .acc(acc));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.x(X), .y(Y), .shift(7), .acc(acc));\n\n    // Output the final product\n    assign P = acc;\nendmodule\n\nmodule add_shift(x, y, shift, acc);\n    input [7:0] x;\n    input [7:0] y;\n    input [3:0] shift;\n    output reg [15:0] acc;\n\n    always @(*) begin\n        if (y[shift])\n            acc = acc + (x << shift);\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [1:0] carry;\n\n    // Instantiate 2 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Sum(Sum[1:0]), .Carry_out(Carry_out));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Sum(Sum[3:2]), .Carry_out(Carry_out));\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit full adder\n    full_adder fa(.X(X), .Y(Y), .Sum(Sum), .Carry_out(Carry_out));\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Carry_in,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Carry_in;\n    assign Carry_out = (X & Y) | (X & Carry_in) | (Y & Carry_in);\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_out;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_out(count_out)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count_out(count_out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 4'b0000;\n        end else if (valid_count) begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_out;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y[0]), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y[1]), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y[2]), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y[3]), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y[4]), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y[5]), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y[6]), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y[7]), .accumulator(accumulator));\n\n    // Output the product\n    assign P = accumulator;\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input Y;\n    output [15:0] accumulator;\n\n    wire [15:0] shifted_X;\n\n    assign shifted_X = (Y) ? {X[6:0], 1'b0} : {8'b0, X[7:0]};\n\n    assign accumulator = shifted_X + accumulator;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            if (count == 4'd11) begin\n                count <= 4'b0000;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.A(A0), .B(X), .C(Y[0]), .S(0));\n    add_shift AS1(.A(A1), .B(A0), .C(Y[1]), .S(1));\n    add_shift AS2(.A(A2), .B(A1), .C(Y[2]), .S(2));\n    add_shift AS3(.A(A3), .B(A2), .C(Y[3]), .S(3));\n    add_shift AS4(.A(A4), .B(A3), .C(Y[4]), .S(4));\n    add_shift AS5(.A(A5), .B(A4), .C(Y[5]), .S(5));\n    add_shift AS6(.A(A6), .B(A5), .C(Y[6]), .S(6));\n    add_shift AS7(.A(A7), .B(A6), .C(Y[7]), .S(7));\n\n    // Combine the results\n    assign P = A7;\n\nendmodule\n\nmodule add_shift(A, B, C, S);\n    input [15:0] B;\n    input C;\n    input [3:0] S;\n    output [15:0] A;\n\n    assign A = C ? (B << S) : 16'b0;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\nwire [3:0] counter;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control div_ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .opn_valid(opn_valid),\n    .counter(counter),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .counter(counter),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result),\n    .res_valid(res_valid)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 8'd0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negating the divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 8'd0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter_reg;\nreg [15:0] quotient_reg;\nreg [15:0] remainder_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter_reg <= 4'd0;\n        quotient_reg <= 16'd0;\n        remainder_reg <= 16'd0;\n    end else begin\n        if (opn_valid) begin\n            counter_reg <= 4'd0;\n            quotient_reg <= 16'd0;\n            remainder_reg <= 16'd0;\n        end else begin\n            if (counter_reg < 4'd10) begin\n                counter_reg <= counter_reg + 4'd1;\n                quotient_reg <= quotient_reg << 1;\n                remainder_reg <= remainder_reg << 1;\n                if (remainder_reg[15] == 1) begin\n                    remainder_reg[15] <= 0;\n                    remainder_reg[14] <= 1;\n                end\n            end else begin\n                counter_reg <= 4'd0;\n                quotient_reg <= quotient_reg + 16'd1;\n                remainder_reg <= remainder_reg - quotient_reg;\n            end\n        end\n    end\nend\n\nassign counter = counter_reg;\nassign quotient = quotient_reg;\nassign remainder = remainder_reg;\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire [3:0] counter,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        res_valid <= 1'b0;\n        result <= 16'd0;\n    end else begin\n        if (res_ready) begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n        end else begin\n            if (counter == 4'd10) begin\n                res_valid <= 1'b1;\n                result <= {remainder, quotient};\n            end else begin\n                res_valid <= 1'b0;\n                result <= 16'd0;\n            end\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Perform addition\n    assign Sum = X + Y;\n    assign Carry_out = (X[3] & Y[3]) | (X[3] & Sum[3]) | (Y[3] & Sum[3]);\n\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y[0]), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y[1]), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y[2]), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y[3]), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y[4]), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y[5]), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y[6]), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y[7]), .accumulator(accumulator));\n\n    // Assign the product to the output\n    assign P = accumulator;\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input Y;\n    output [15:0] accumulator;\n    reg [15:0] temp;\n\n    always @(*) begin\n        if (Y) begin\n            temp = X << 1;\n            accumulator = temp + accumulator;\n        end else begin\n            accumulator = temp;\n        end\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    // Instance of the counter logic\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    // Instance of the output register\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .out(out),\n        .count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0000;\n        end else if (valid_count) begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out,\n    input [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count;\n        end\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the second add_shift module\n    add_shift AS1(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the third add_shift module\n    add_shift AS2(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(\n        .X(X),\n        .Y(Y),\n        .accumulator(accumulator)\n    );\n\n    // Output the final product\n    assign P = accumulator;\n\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input [7:0] Y;\n    output reg [15:0] accumulator;\n\n    always @(*) begin\n        if (Y[0])\n            accumulator = accumulator + (X << 0);\n        if (Y[1])\n            accumulator = accumulator + (X << 1);\n        if (Y[2])\n            accumulator = accumulator + (X << 2);\n        if (Y[3])\n            accumulator = accumulator + (X << 3);\n        if (Y[4])\n            accumulator = accumulator + (X << 4);\n        if (Y[5])\n            accumulator = accumulator + (X << 5);\n        if (Y[6])\n            accumulator = accumulator + (X << 6);\n        if (Y[7])\n            accumulator = accumulator + (X << 7);\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output reg [63:0]    next_state\n);\n\n    always @(*) begin\n        next_state = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate 1 1-bit adder\n    full_adder fa (\n        .X(X),\n        .Y(Y),\n        .Sum(Sum),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    input Cin,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y ^ Cin;\n    assign Carry_out = (X & Y) | (Y & Cin) | (X & Cin);\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] shift_reg;\n    wire [3:0] counter;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Submodule instances\n    abs_value abs_dividend (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .abs_value(abs_dividend)\n    );\n\n    neg_value neg_divisor_mod (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .neg_value(neg_divisor)\n    );\n\n    div_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    result_mgmt res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] abs_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            abs_value <= 8'd0;\n        end else if (sign) begin\n            abs_value <= -value;\n        end else begin\n            abs_value <= value;\n        end\n    end\n\nendmodule\n\n// Submodule for negative value calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] neg_value\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            neg_value <= 8'd0;\n        end else if (sign) begin\n            neg_value <= ~value + 1;\n        end else begin\n            neg_value <= value;\n        end\n    end\n\nendmodule\n\n// Submodule for division control logic\nmodule div_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\n    reg [3:0] next_counter;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 4'd0;\n            shift_reg <= 8'd0;\n            quotient <= 16'd0;\n            remainder <= 16'd0;\n        end else if (opn_valid) begin\n            next_counter <= counter + 1;\n            shift_reg <= shift_reg << 1;\n            quotient <= quotient << 1;\n            remainder <= remainder << 1;\n            if (next_counter == 4'd0) begin\n                shift_reg <= 8'd0;\n                quotient <= 16'd0;\n                remainder <= 16'd0;\n            end\n            if (next_counter == 4'd1) begin\n                shift_reg <= 8'd1;\n                quotient <= 16'd0;\n                remainder <= 16'd0;\n            end\n            if (next_counter == 4'd2) begin\n                shift_reg <= 8'd1;\n                quotient <= 16'd1;\n                remainder <= 16'd0;\n            end\n            if (next_counter == 4'd3) begin\n                shift_reg <= 8'd1;\n                quotient <= 16'd1;\n                remainder <= 16'd1;\n            end\n            counter <= next_counter;\n        end\n    end\n\nendmodule\n\n// Submodule for result management\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n        end else if (res_ready) begin\n            res_valid <= 1'b0;\n            result <= 16'd0;\n        end else if (opn_valid) begin\n            res_valid <= 1'b1;\n            result <= {remainder[7:0], quotient[7:0]};\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y[0]), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y[1]), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y[2]), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y[3]), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y[4]), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y[5]), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y[6]), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y[7]), .accumulator(accumulator));\n\n    // Output the product\n    assign P = accumulator;\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input Y;\n    output [15:0] accumulator;\n\n    // Shift the multiplicand left by the number of bits in the multiplier\n    wire [15:0] shifted_X = {X, 1'b0};\n\n    // Add the shifted multiplicand to the accumulator\n    assign accumulator = shifted_X + (Y << 3);\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y[0]), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y[1]), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y[2]), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y[3]), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y[4]), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y[5]), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y[6]), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y[7]), .accumulator(accumulator));\n\n    // Assign the product to the output\n    assign P = accumulator;\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input Y;\n    output [15:0] accumulator;\n    reg [15:0] accumulator_reg;\n\n    always @(*) begin\n        if (Y) begin\n            accumulator_reg = accumulator_reg + (X << 1);\n        end\n    end\n\n    assign accumulator = accumulator_reg;\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output reg [63:0]   next_Q\n);\n\n    always @(*) begin\n        next_Q = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0(.X(X[7:0]), .Y(Y[7:0]), .Carry_in(1'b0), .Sum(Sum[7:0]), .Carry_out(carry[0]));\n    adder_8bit adder1(.X(X[15:8]), .Y(Y[15:8]), .Carry_in(carry[0]), .Sum(Sum[15:8]), .Carry_out(carry[1]));\n    adder_8bit adder2(.X(X[23:16]), .Y(Y[23:16]), .Carry_in(carry[1]), .Sum(Sum[23:16]), .Carry_out(carry[2]));\n    adder_8bit adder3(.X(X[31:24]), .Y(Y[31:24]), .Carry_in(carry[2]), .Sum(Sum[31:24]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    input Carry_in,    // Carry input\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0(.X(X[3:0]), .Y(Y[3:0]), .Carry_in(1'b0), .Sum(Sum[3:0]), .Carry_out(carry[0]));\n    adder_4bit adder1(.X(X[7:4]), .Y(Y[7:4]), .Carry_in(carry[0]), .Sum(Sum[7:4]), .Carry_out(carry[1]));\n    adder_4bit adder2(.X(X[11:8]), .Y(Y[11:8]), .Carry_in(carry[1]), .Sum(Sum[11:8]), .Carry_out(carry[2]));\n    adder_4bit adder3(.X(X[15:12]), .Y(Y[15:12]), .Carry_in(carry[2]), .Sum(Sum[15:12]), .Carry_out(carry[3]));\n\n    // Carry out\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    input Carry_in,    // Carry input\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0(.X(X[1:0]), .Y(Y[1:0]), .Carry_in(1'b0), .Sum(Sum[1:0]), .Carry_out(carry[0]));\n    adder_2bit adder1(.X(X[3:2]), .Y(Y[3:2]), .Carry_in(carry[0]), .Sum(Sum[3:2]), .Carry_out(carry[1]));\n\n    // Carry out\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    input Carry_in,    // Carry input\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out   // Carry output\n);\n\n    // 2-bit full adder\n    assign Sum = X + Y + Carry_in;\n    assign Carry_out = (X[1] & Y[1]) | (X[1] & Carry_in) | (Y[1] & Carry_in);\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.A(A0), .B(X), .Y(Y[0]), .shift(0));\n    add_shift AS1(.A(A1), .B(A0), .Y(Y[1]), .shift(1));\n    add_shift AS2(.A(A2), .B(A1), .Y(Y[2]), .shift(2));\n    add_shift AS3(.A(A3), .B(A2), .Y(Y[3]), .shift(3));\n    add_shift AS4(.A(A4), .B(A3), .Y(Y[4]), .shift(4));\n    add_shift AS5(.A(A5), .B(A4), .Y(Y[5]), .shift(5));\n    add_shift AS6(.A(A6), .B(A5), .Y(Y[6]), .shift(6));\n    add_shift AS7(.A(A7), .B(A6), .Y(Y[7]), .shift(7));\n\n    // Assign the product\n    assign P = A7;\n\nendmodule\n\nmodule add_shift(A, B, Y, shift);\n    input [15:0] B;\n    input [7:0] Y;\n    input [3:0] shift;\n    output [15:0] A;\n\n    wire [15:0] temp;\n\n    // Shift B left by shift positions\n    assign temp = B << shift;\n\n    // Add B to A if Y is set\n    assign A = (Y) ? (temp + B) : temp;\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] shift;\n    wire [3:0] next_counter;\n    wire [3:0] next_shift;\n    wire [15:0] next_remainder;\n    wire [15:0] next_quotient;\n    wire [15:0] next_result;\n\n    // Absolute value calculation\n    abs_value abs_dividend_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(dividend),\n        .output(abs_dividend)\n    );\n\n    // Negative divisor calculation\n    neg_value neg_divisor_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .input(divisor),\n        .output(neg_divisor)\n    );\n\n    // Division control logic\n    divider_control div_ctrl_module (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift(shift),\n        .next_counter(next_counter),\n        .next_shift(next_shift),\n        .next_remainder(next_remainder),\n        .next_quotient(next_quotient)\n    );\n\n    // Result management\n    result_management res_mgmt_module (\n        .clk(clk),\n        .rst(rst),\n        .counter(counter),\n        .shift(shift),\n        .remainder(remainder),\n        .quotient(quotient),\n        .next_remainder(next_remainder),\n        .next_quotient(next_quotient),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .result(result)\n    );\n\n    // Assigning the output values\n    assign remainder = {abs_dividend, 8'b0};\n    assign quotient = {16'b0, neg_divisor};\n    assign next_result = {next_remainder, next_quotient};\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            output <= 8'b0;\n        end else begin\n            if (sign) begin\n                output <= -input;\n            end else begin\n                output <= input;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] input,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            output <= 8'b0;\n        end else begin\n            if (sign) begin\n                output <= input;\n            end else begin\n                output <= -input;\n            end\n        end\n    end\n\nendmodule\n\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire [3:0] counter,\n    input wire [3:0] shift,\n    output reg [3:0] next_counter,\n    output reg [3:0] next_shift,\n    output reg [15:0] next_remainder,\n    output reg [15:0] next_quotient\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            next_counter <= 4'b0;\n            next_shift <= 4'b0;\n            next_remainder <= 16'b0;\n            next_quotient <= 16'b0;\n        end else begin\n            if (opn_valid) begin\n                if (counter == 4'b0) begin\n                    next_counter <= 4'b1;\n                    next_shift <= 4'b1;\n                    next_remainder <= 16'b0;\n                    next_quotient <= 16'b0;\n                end else begin\n                    next_counter <= counter;\n                    next_shift <= shift;\n                    next_remainder <= {next_remainder[14:0], 1'b0};\n                    next_quotient <= {next_quotient[14:0], next_remainder[shift]};\n                end\n            end else begin\n                next_counter <= 4'b0;\n                next_shift <= 4'b0;\n                next_remainder <= 16'b0;\n                next_quotient <= 16'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] counter,\n    input wire [3:0] shift,\n    input wire [15:0] remainder,\n    input wire [15:0] quotient,\n    input wire res_ready,\n    input wire opn_valid,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 1'b0;\n            result <= 16'b0;\n        end else begin\n            if (res_ready) begin\n                res_valid <= 1'b0;\n                result <= 16'b0;\n            end else if (opn_valid) begin\n                if (counter == 4'b0) begin\n                    res_valid <= 1'b1;\n                    result <= quotient;\n                end else begin\n                    res_valid <= 1'b0;\n                    result <= 16'b0;\n                end\n            end else begin\n                res_valid <= 1'b0;\n                result <= 16'b0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]   Q_next\n);\n\n    always @(*) begin\n        Q_next = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] A0, A1, A2, A3, A4, A5, A6, A7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.A(X), .B(Y[0]), .S(0), .C(A0));\n    add_shift AS1(.A(A0), .B(Y[1]), .S(1), .C(A1));\n    add_shift AS2(.A(A1), .B(Y[2]), .S(2), .C(A2));\n    add_shift AS3(.A(A2), .B(Y[3]), .S(3), .C(A3));\n    add_shift AS4(.A(A3), .B(Y[4]), .S(4), .C(A4));\n    add_shift AS5(.A(A4), .B(Y[5]), .S(5), .C(A5));\n    add_shift AS6(.A(A5), .B(Y[6]), .S(6), .C(A6));\n    add_shift AS7(.A(A6), .B(Y[7]), .S(7), .C(A7));\n\n    // Assign the product to the output\n    assign P = A7;\n\nendmodule\n\nmodule add_shift(A, B, S, C);\n    input [15:0] A;\n    input B;\n    input [3:0] S;\n    output [15:0] C;\n\n    wire [15:0] shifted;\n\n    assign shifted = (S == 0) ? A : (S == 1) ? (A << 1) : (S == 2) ? (A << 2) : (S == 3) ? (A << 3) :\n                     (S == 4) ? (A << 4) : (S == 5) ? (A << 5) : (S == 6) ? (A << 6) : (S == 7) ? (A << 7) : 0;\n\n    assign C = shifted + (B << S);\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]       Q,\n    output [63:0]       next_Q\n);\n\n    assign next_Q = {Q[62:0], Q[63]};\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] AS0, AS1, AS2, AS3, AS4, AS5, AS6, AS7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.X(X), .Y(Y), .shift(0), .P(AS0));\n    add_shift AS1(.X(X), .Y(Y), .shift(1), .P(AS1));\n    add_shift AS2(.X(X), .Y(Y), .shift(2), .P(AS2));\n    add_shift AS3(.X(X), .Y(Y), .shift(3), .P(AS3));\n    add_shift AS4(.X(X), .Y(Y), .shift(4), .P(AS4));\n    add_shift AS5(.X(X), .Y(Y), .shift(5), .P(AS5));\n    add_shift AS6(.X(X), .Y(Y), .shift(6), .P(AS6));\n    add_shift AS7(.X(X), .Y(Y), .shift(7), .P(AS7));\n\n    // Combine the intermediate products\n    assign P = AS0 + AS1 + AS2 + AS3 + AS4 + AS5 + AS6 + AS7;\n\nendmodule\n\nmodule add_shift(X, Y, shift, P);\n    input [7:0] X;\n    input [7:0] Y;\n    input [3:0] shift;\n    output [15:0] P;\n\n    wire [15:0] shifted_X;\n\n    // Shift the multiplicand X\n    assign shifted_X = X << shift;\n\n    // Add the shifted multiplicand to the accumulator\n    assign P = shifted_X + (Y[shift] ? shifted_X : 0);\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate 4 4-bit adders\n    adder_4bit adder0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_4bit adder1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    adder_4bit adder2 (\n        .X(X[11:8]),\n        .Y(Y[11:8]),\n        .Sum(Sum[11:8]),\n        .Carry_out(carry[2])\n    );\n\n    adder_4bit adder3 (\n        .X(X[15:12]),\n        .Y(Y[15:12]),\n        .Sum(Sum[15:12]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_4bit(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [4:0] carry;\n\n    // Instantiate 2 2-bit adders\n    adder_2bit adder0 (\n        .X(X[1:0]),\n        .Y(Y[1:0]),\n        .Sum(Sum[1:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_2bit adder1 (\n        .X(X[3:2]),\n        .Y(Y[3:2]),\n        .Sum(Sum[3:2]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule adder_2bit(\n    input [1:0] X,    // First 2-bit input operand\n    input [1:0] Y,    // Second 2-bit input operand\n    output [1:0] Sum, // 2-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Instantiate a 1-bit adder\n    full_adder fa (\n        .X(X[0]),\n        .Y(Y[0]),\n        .Sum(Sum[0]),\n        .Carry_out(Carry_out)\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(\n    input X,\n    input Y,\n    output Sum,\n    output Carry_out\n);\n\n    assign Sum = X ^ Y;\n    assign Carry_out = (X & Y) | (X & Carry_out) | (Y & Carry_out);\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    output reg [63:0]    next_state\n);\n\n    always @(*) begin\n        next_state = {Q[62:0], Q[63]};\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] accumulator;\n\n    // Instantiate the first add_shift module\n    add_shift AS0(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the second add_shift module\n    add_shift AS1(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the third add_shift module\n    add_shift AS2(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the fourth add_shift module\n    add_shift AS3(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the fifth add_shift module\n    add_shift AS4(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the sixth add_shift module\n    add_shift AS5(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the seventh add_shift module\n    add_shift AS6(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Instantiate the eighth add_shift module\n    add_shift AS7(.X(X), .Y(Y), .accumulator(accumulator));\n\n    // Assign the product to the output\n    assign P = accumulator;\n\nendmodule\n\nmodule add_shift(X, Y, accumulator);\n    input [7:0] X;\n    input [7:0] Y;\n    output reg [15:0] accumulator;\n\n    always @(*) begin\n        if (Y[0])\n            accumulator = accumulator + (X << 0);\n        if (Y[1])\n            accumulator = accumulator + (X << 1);\n        if (Y[2])\n            accumulator = accumulator + (X << 2);\n        if (Y[3])\n            accumulator = accumulator + (X << 3);\n        if (Y[4])\n            accumulator = accumulator + (X << 4);\n        if (Y[5])\n            accumulator = accumulator + (X << 5);\n        if (Y[6])\n            accumulator = accumulator + (X << 6);\n        if (Y[7])\n            accumulator = accumulator + (X << 7);\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders for each 8-bit group\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Sum(Sum[7:0]),\n        .Carry_out(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Sum(Sum[15:8]),\n        .Carry_out(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Sum(Sum[23:16]),\n        .Carry_out(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Sum(Sum[31:24]),\n        .Carry_out(carry[3])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,    // First 8-bit input operand\n    input [7:0] Y,    // Second 8-bit input operand\n    output [7:0] Sum, // 8-bit output sum\n    output Carry_out  // Carry output\n);\n\n    wire [8:0] carry;\n\n    // Instantiate a 4-bit full adder for each 4-bit group\n    full_adder fa0 (\n        .X(X[3:0]),\n        .Y(Y[3:0]),\n        .Sum(Sum[3:0]),\n        .Carry_out(carry[0])\n    );\n\n    full_adder fa1 (\n        .X(X[7:4]),\n        .Y(Y[7:4]),\n        .Sum(Sum[7:4]),\n        .Carry_out(carry[1])\n    );\n\n    // Carry propagation\n    assign Carry_out = carry[1];\n\nendmodule\n\nmodule full_adder(\n    input [3:0] X,    // First 4-bit input operand\n    input [3:0] Y,    // Second 4-bit input operand\n    output [3:0] Sum, // 4-bit output sum\n    output Carry_out  // Carry output\n);\n\n    // Calculate sum and carry\n    assign Sum = X + Y;\n    assign Carry_out = (X[3] & Y[3]) | (X[3] & Sum[3]) | (Y[3] & Sum[3]);\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(next_Q),\n        .Q_next(Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]   Q_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q_next <= 64'b0;\n        end else begin\n            Q_next <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] AS0, AS1, AS2, AS3, AS4, AS5, AS6, AS7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.X(X), .Y(Y[0]), .shift(0), .P(AS0));\n    add_shift AS1(.X(X), .Y(Y[1]), .shift(1), .P(AS1));\n    add_shift AS2(.X(X), .Y(Y[2]), .shift(2), .P(AS2));\n    add_shift AS3(.X(X), .Y(Y[3]), .shift(3), .P(AS3));\n    add_shift AS4(.X(X), .Y(Y[4]), .shift(4), .P(AS4));\n    add_shift AS5(.X(X), .Y(Y[5]), .shift(5), .P(AS5));\n    add_shift AS6(.X(X), .Y(Y[6]), .shift(6), .P(AS6));\n    add_shift AS7(.X(X), .Y(Y[7]), .shift(7), .P(AS7));\n\n    // Combine the results\n    assign P = AS0 + AS1 + AS2 + AS3 + AS4 + AS5 + AS6 + AS7;\n\nendmodule\n\nmodule add_shift(X, Y, shift, P);\n    input [7:0] X;\n    input Y;\n    input [3:0] shift;\n    output [15:0] P;\n\n    wire [15:0] shifted_X;\n\n    // Shift the multiplicand\n    assign shifted_X = X << shift;\n\n    // Add the shifted multiplicand to the accumulator\n    assign P = shifted_X + (Y << shift);\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire [7:0] shifted_divisor;\n    wire [7:0] shifted_dividend;\n    wire [7:0] shifted_remainder;\n    wire [7:0] shifted_quotient;\n    wire [7:0] shifted_result;\n    wire [7:0] result_quotient;\n    wire [7:0] result_remainder;\n    wire [7:0] result_shifted_remainder;\n    wire [7:0] result_shifted_quotient;\n    wire [7:0] result_shifted_result;\n\n    // Absolute value calculation\n    abs_value abs_dividend_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    // Negative divisor calculation\n    neg_value neg_divisor_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    // Division control logic\n    divider_control div_ctrl_module (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .shifted_divisor(shifted_divisor),\n        .shifted_dividend(shifted_dividend),\n        .shifted_remainder(shifted_remainder),\n        .shifted_quotient(shifted_quotient),\n        .shifted_result(shifted_result)\n    );\n\n    // Result management\n    result_mgmt res_mgmt_module (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .res_valid(res_valid),\n        .counter(counter),\n        .shifted_remainder(shifted_remainder),\n        .shifted_quotient(shifted_quotient),\n        .shifted_result(shifted_result),\n        .result_quotient(result_quotient),\n        .result_remainder(result_remainder),\n        .result_shifted_remainder(result_shifted_remainder),\n        .result_shifted_quotient(result_shifted_quotient),\n        .result_shifted_result(result_shifted_result),\n        .result(result)\n    );\n\nendmodule\n\n// Absolute value calculation module\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\n// Negative value calculation module\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\n// Division control logic module\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg [7:0] shifted_divisor,\n    output reg [7:0] shifted_dividend,\n    output reg [7:0] shifted_remainder,\n    output reg [7:0] shifted_quotient,\n    output reg [7:0] shifted_result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            shifted_divisor <= 0;\n            shifted_dividend <= 0;\n            shifted_remainder <= 0;\n            shifted_quotient <= 0;\n            shifted_result <= 0;\n        end else begin\n            if (opn_valid) begin\n                counter <= 4;\n                shift_reg <= 0;\n                shifted_divisor <= 0;\n                shifted_dividend <= 0;\n                shifted_remainder <= 0;\n                shifted_quotient <= 0;\n                shifted_result <= 0;\n            end else begin\n                if (counter > 0) begin\n                    counter <= counter - 1;\n                    shift_reg <= shift_reg << 1;\n                    shifted_divisor <= shifted_divisor << 1;\n                    shifted_dividend <= shifted_dividend << 1;\n                    shifted_remainder <= shifted_remainder << 1;\n                    shifted_quotient <= shifted_quotient << 1;\n                    shifted_result <= shifted_result << 1;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Result management module\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire opn_valid,\n    input wire [3:0] counter,\n    input wire [7:0] shifted_remainder,\n    input wire [7:0] shifted_quotient,\n    input wire [7:0] shifted_result,\n    input wire [7:0] result_quotient,\n    input wire [7:0] result_remainder,\n    input wire [7:0] result_shifted_remainder,\n    input wire [7:0] result_shifted_quotient,\n    input wire [7:0] result_shifted_result,\n    output reg res_valid,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            res_valid <= 0;\n            result <= 0;\n        end else begin\n            if (res_ready) begin\n                res_valid <= 0;\n                result <= 0;\n            end else begin\n                if (opn_valid && counter == 0) begin\n                    res_valid <= 1;\n                    result <= {result_shifted_remainder, result_shifted_quotient};\n                end\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .Q(next_state),\n        .clk(clk),\n        .rst_n(rst_n)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input [63:0]        Q,\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    next_state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state[0] <= Q[0];\n            next_state[63:1] <= Q[63:1];\n        end\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= Q;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output reg [63:0]   next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if(!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input [7:0] X;\n    input [7:0] Y;\n    output [15:0] P;\n\n    wire [15:0] AS0, AS1, AS2, AS3, AS4, AS5, AS6, AS7;\n\n    // Instantiate the add_shift modules\n    add_shift AS0(.A(X), .B(Y[0]), .S(0), .P(AS0));\n    add_shift AS1(.A(X), .B(Y[1]), .S(1), .P(AS1));\n    add_shift AS2(.A(X), .B(Y[2]), .S(2), .P(AS2));\n    add_shift AS3(.A(X), .B(Y[3]), .S(3), .P(AS3));\n    add_shift AS4(.A(X), .B(Y[4]), .S(4), .P(AS4));\n    add_shift AS5(.A(X), .B(Y[5]), .S(5), .P(AS5));\n    add_shift AS6(.A(X), .B(Y[6]), .S(6), .P(AS6));\n    add_shift AS7(.A(X), .B(Y[7]), .S(7), .P(AS7));\n\n    // Combine the outputs of the add_shift modules\n    assign P = AS0 + AS1 + AS2 + AS3 + AS4 + AS5 + AS6 + AS7;\n\nendmodule\n\nmodule add_shift(A, B, S, P);\n    input [7:0] A;\n    input B;\n    input [3:0] S;\n    output [15:0] P;\n\n    wire [15:0] shifted_A;\n\n    assign shifted_A = (S == 0) ? {8'b0, A} : (S == 1) ? {A[6:0], 1'b0} :\n                       (S == 2) ? {A[5:0], 2'b00} : (S == 3) ? {A[4:0], 3'b000} :\n                       (S == 4) ? {A[3:0], 4'b0000} : (S == 5) ? {A[2:0], 5'b00000} :\n                       (S == 6) ? {A[1:0], 6'b000000} : {A[0], 7'b0000000};\n\n    assign P = shifted_A + (B << S);\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry signals for each submodule\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] temp_sum; // Temporary sum to hold intermediate results\n\n    assign temp_sum = A + B + Cin;\n    assign Sum = temp_sum[7:0];\n    assign Cout = temp_sum[8];\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    assign p0 = X[0] & Y;\n    assign p1 = X[1] & Y << 1;\n    assign p2 = X[2] & Y << 2;\n    assign p3 = X[3] & Y << 3;\n\n    // Adders\n    adder_8bit add1(.a(p0), .b(p1), .c(0), .sum(P[0]), .carry(P[1]));\n    adder_8bit add2(.a(p2), .b(p3), .c(P[1]), .sum(P[2]), .carry(P[3]));\n    adder_8bit add3(.a(p0 + p2), .b(p1 + p3), .c(P[2]), .sum(P[4]), .carry(P[5]));\n    adder_8bit add4(.a(p1 + p3), .b(p2 + p0), .c(P[3]), .sum(P[6]), .carry(P[7]));\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum, carry);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n    output carry;\n\n    assign {carry, sum} = a + b + c;\nendmodule\n\nmodule full_adder_8bit(a, b, c, sum, carry);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n    output carry;\n\n    assign {carry, sum} = a + b + c;\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_mod_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_valid(res_valid),\n    .res_ready(res_ready),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negative divisor calculation\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control logic\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [15:0] shift_reg;\nreg [3:0] counter;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        quotient <= 0;\n        remainder <= 0;\n        res_valid <= 0;\n    end else begin\n        if (opn_valid) begin\n            if (res_ready) begin\n                res_valid <= 1;\n                quotient <= quotient;\n                remainder <= remainder;\n            end else begin\n                res_valid <= 0;\n            end\n            if (counter < 8) begin\n                counter <= counter + 1;\n                shift_reg <= {shift_reg[14:0], dividend[7]};\n                quotient <= quotient;\n                remainder <= remainder;\n            end else begin\n                counter <= 0;\n                shift_reg <= {shift_reg[14:0], dividend[7]};\n                quotient <= quotient;\n                remainder <= remainder;\n            end\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_valid,\n    input wire res_ready,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= {remainder, quotient};\n        end else begin\n            result <= 0;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Intermediate carry chain\n\n    // Instantiate 8-bit adders\n    adder_8bit add0(.A(A[7:0]), .B(B[7:0]), .Cin(Cin), .Sum(Sum[7:0]), .Cout(carry[0]));\n    adder_8bit add1(.A(A[15:8]), .B(B[15:8]), .Cin(carry[0]), .Sum(Sum[15:8]), .Cout(carry[1]));\n    adder_8bit add2(.A(A[23:16]), .B(B[23:16]), .Cin(carry[1]), .Sum(Sum[23:16]), .Cout(carry[2]));\n    adder_8bit add3(.A(A[31:24]), .B(B[31:24]), .Cin(carry[2]), .Sum(Sum[31:24]), .Cout(carry[3]));\n\n    // Output carry\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry; // Intermediate carry chain\n\n    // Perform 8-bit addition\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    assign p0 = X[0] & Y;\n    assign p1 = X[1] & Y << 1;\n    assign p2 = X[2] & Y << 2;\n    assign p3 = X[3] & Y << 3;\n\n    // Adders\n    adder_8bit add1(.a(p0), .b(p1), .c(p2), .sum(P[0]));\n    adder_8bit add2(.a(p1), .b(p2), .c(p3), .sum(P[1]));\n    adder_8bit add3(.a(p2), .b(p3), .c(0), .sum(P[2]));\n    adder_8bit add4(.a(p3), .b(0), .c(0), .sum(P[3]));\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a, b, c;\n    output [7:0] sum;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .c(c[0]), .sum(sum[0]), .carry(sum[1]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c(c[1]), .sum(sum[2]), .carry(sum[3]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c(c[2]), .sum(sum[4]), .carry(sum[5]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c(c[3]), .sum(sum[6]), .carry(sum[7]));\nendmodule\n\nmodule full_adder(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n\n    assign sum = a ^ b ^ c;\n    assign carry = (a & b) | (b & c) | (a & c);\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry_chain;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_chain[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_chain[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_chain[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_chain[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_chain[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_chain[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    // 8-bit adder logic\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    assign p0 = X[0] & Y[0];\n    assign p1 = X[1] & Y[1];\n    assign p2 = X[2] & Y[2];\n    assign p3 = X[3] & Y[3];\n\n    // Shift and add\n    adder_8bit add1(.a(p0), .b(p1), .c(p2), .p(P[0]));\n    adder_8bit add2(.a(p1), .b(p2), .c(p3), .p(P[1]));\n    adder_8bit add3(.a(p2), .b(p3), .c(8'b0), .p(P[2]));\n    adder_8bit add4(.a(p3), .b(8'b0), .c(8'b0), .p(P[3]));\n\nendmodule\n\nmodule adder_8bit(a, b, c, p);\n    input [7:0] a, b, c;\n    output [7:0] p;\n\n    wire [8:0] sum;\n\n    // Full adder logic\n    assign sum = a + b + c;\n    assign p = sum[7] ? sum[7:0] + 1 : sum[7:0];\n\nendmodule\n\nmodule full_adder(a, b, c, sum, c_out);\n    input a, b, c;\n    output sum, c_out;\n    assign sum = a ^ b ^ c;\n    assign c_out = (a & b) | (a & c) | (b & c);\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_state;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_state(next_state)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]   next_state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_state <= 64'b0;\n        end else begin\n            next_state[0] <= Q[0];\n            next_state[1] <= Q[0] ^ Q[1];\n            next_state[2] <= Q[1] ^ Q[2];\n            next_state[3] <= Q[2] ^ Q[3];\n            next_state[4] <= Q[3] ^ Q[4];\n            next_state[5] <= Q[4] ^ Q[5];\n            next_state[6] <= Q[5] ^ Q[6];\n            next_state[7] <= Q[6] ^ Q[7];\n            next_state[8] <= Q[7] ^ Q[8];\n            next_state[9] <= Q[8] ^ Q[9];\n            next_state[10] <= Q[9] ^ Q[10];\n            next_state[11] <= Q[10] ^ Q[11];\n            next_state[12] <= Q[11] ^ Q[12];\n            next_state[13] <= Q[12] ^ Q[13];\n            next_state[14] <= Q[13] ^ Q[14];\n            next_state[15] <= Q[14] ^ Q[15];\n            next_state[16] <= Q[15] ^ Q[16];\n            next_state[17] <= Q[16] ^ Q[17];\n            next_state[18] <= Q[17] ^ Q[18];\n            next_state[19] <= Q[18] ^ Q[19];\n            next_state[20] <= Q[19] ^ Q[20];\n            next_state[21] <= Q[20] ^ Q[21];\n            next_state[22] <= Q[21] ^ Q[22];\n            next_state[23] <= Q[22] ^ Q[23];\n            next_state[24] <= Q[23] ^ Q[24];\n            next_state[25] <= Q[24] ^ Q[25];\n            next_state[26] <= Q[25] ^ Q[26];\n            next_state[27] <= Q[26] ^ Q[27];\n            next_state[28] <= Q[27] ^ Q[28];\n            next_state[29] <= Q[28] ^ Q[29];\n            next_state[30] <= Q[29] ^ Q[30];\n            next_state[31] <= Q[30] ^ Q[31];\n            next_state[32] <= Q[31] ^ Q[32];\n            next_state[33] <= Q[32] ^ Q[33];\n            next_state[34] <= Q[33] ^ Q[34];\n            next_state[35] <= Q[34] ^ Q[35];\n            next_state[36] <= Q[35] ^ Q[36];\n            next_state[37] <= Q[36] ^ Q[37];\n            next_state[38] <= Q[37] ^ Q[38];\n            next_state[39] <= Q[38] ^ Q[39];\n            next_state[40] <= Q[39] ^ Q[40];\n            next_state[41] <= Q[40] ^ Q[41];\n            next_state[42] <= Q[41] ^ Q[42];\n            next_state[43] <= Q[42] ^ Q[43];\n            next_state[44] <= Q[43] ^ Q[44];\n            next_state[45] <= Q[44] ^ Q[45];\n            next_state[46] <= Q[45] ^ Q[46];\n            next_state[47] <= Q[46] ^ Q[47];\n            next_state[48] <= Q[47] ^ Q[48];\n            next_state[49] <= Q[48] ^ Q[49];\n            next_state[50] <= Q[49] ^ Q[50];\n            next_state[51] <= Q[50] ^ Q[51];\n            next_state[52] <= Q[51] ^ Q[52];\n            next_state[53] <= Q[52] ^ Q[53];\n            next_state[54] <= Q[53] ^ Q[54];\n            next_state[55] <= Q[54] ^ Q[55];\n            next_state[56] <= Q[55] ^ Q[56];\n            next_state[57] <= Q[56] ^ Q[57];\n            next_state[58] <= Q[57] ^ Q[58];\n            next_state[59] <= Q[58] ^ Q[59];\n            next_state[60] <= Q[59] ^ Q[60];\n            next_state[61] <= Q[60] ^ Q[61];\n            next_state[62] <= Q[61] ^ Q[62];\n            next_state[63] <= Q[62] ^ Q[63];\n        end\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry_chain;\n\n    // Instantiate 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_chain[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_chain[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_chain[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_chain[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_chain[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_chain[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n\n    wire [63:0] next_Q;\n\n    // Instantiate the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q)\n    );\n\n    // Instantiate the logic module\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q),\n        .next_Q(next_Q)\n    );\n\nendmodule\n\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]    Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            Q <= 64'b0;\n        end else begin\n            Q <= 64'b0;\n        end\n    end\n\nendmodule\n\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]         Q,\n    output reg [63:0]    next_Q\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            next_Q <= 64'b0;\n        end else begin\n            next_Q <= {Q[62:0], Q[63]};\n        end\n    end\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n// Intermediate signals\nwire [7:0] abs_dividend;\nwire [7:0] neg_divisor;\nwire [15:0] quotient;\nwire [15:0] remainder;\n\n// Submodule instances\nabs_value abs_dividend_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(dividend),\n    .result(abs_dividend)\n);\n\nneg_value neg_divisor_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .value(divisor),\n    .result(neg_divisor)\n);\n\ndivider_control ctrl_inst (\n    .clk(clk),\n    .rst(rst),\n    .sign(sign),\n    .dividend(abs_dividend),\n    .divisor(neg_divisor),\n    .opn_valid(opn_valid),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\nresult_management res_mgmt_inst (\n    .clk(clk),\n    .rst(rst),\n    .res_ready(res_ready),\n    .res_valid(res_valid),\n    .quotient(quotient),\n    .remainder(remainder),\n    .result(result)\n);\n\nendmodule\n\n// Submodule for absolute value calculation\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= -value;\n        end else begin\n            result <= value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for negating the divisor\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (sign) begin\n            result <= value;\n        end else begin\n            result <= -value;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for division control\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] dividend,\n    input wire [7:0] divisor,\n    input wire opn_valid,\n    input wire res_ready,\n    output reg res_valid,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n\nreg [3:0] counter;\nreg [15:0] shift_reg;\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        counter <= 0;\n        shift_reg <= 0;\n        res_valid <= 0;\n        quotient <= 0;\n        remainder <= 0;\n    end else begin\n        if (opn_valid) begin\n            if (res_ready) begin\n                counter <= 0;\n                shift_reg <= dividend;\n                res_valid <= 1;\n                quotient <= 0;\n                remainder <= 0;\n            end else begin\n                if (counter < 8) begin\n                    shift_reg <= {shift_reg[6:0], 1'b0};\n                    counter <= counter + 1;\n                end else begin\n                    quotient <= quotient << 1;\n                    remainder <= remainder << 1;\n                    if (shift_reg[15]) begin\n                        quotient <= quotient | 1;\n                    end\n                    if (shift_reg[15] ^ divisor[7]) begin\n                        remainder <= remainder | 1;\n                    end\n                    shift_reg <= {shift_reg[14:0], 1'b0};\n                    counter <= counter + 1;\n                end\n            end\n        end else begin\n            res_valid <= 0;\n        end\n    end\nend\n\nendmodule\n\n// Submodule for result management\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire res_valid,\n    input wire [15:0] quotient,\n    input wire [15:0] remainder,\n    output reg [15:0] result\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        if (res_ready) begin\n            result <= {remainder, quotient};\n        end else begin\n            result <= result;\n        end\n    end\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Intermediate carry chain\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3]; // Final carry out\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    // 8-bit adder logic\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift and AND operations\n    assign p0_0 = X[0] & Y[0];\n    assign p0_1 = X[0] & Y[1];\n    assign p0_2 = X[0] & Y[2];\n    assign p0_3 = X[0] & Y[3];\n\n    assign p1_0 = X[1] & Y[0];\n    assign p1_1 = X[1] & Y[1];\n    assign p1_2 = X[1] & Y[2];\n    assign p1_3 = X[1] & Y[3];\n\n    assign p2_0 = X[2] & Y[0];\n    assign p2_1 = X[2] & Y[1];\n    assign p2_2 = X[2] & Y[2];\n    assign p2_3 = X[2] & Y[3];\n\n    assign p3_0 = X[3] & Y[0];\n    assign p3_1 = X[3] & Y[1];\n    assign p3_2 = X[3] & Y[2];\n    assign p3_3 = X[3] & Y[3];\n\n    // Adders\n    adder_8bit add1(.a(p0_0), .b(p0_1), .c(p0_2), .d(p0_3), .sum(p0));\n    adder_8bit add2(.a(p1_0), .b(p1_1), .c(p1_2), .d(p1_3), .sum(p1));\n    adder_8bit add3(.a(p2_0), .b(p2_1), .c(p2_2), .d(p2_3), .sum(p2));\n    adder_8bit add4(.a(p3_0), .b(p3_1), .c(p3_2), .d(p3_3), .sum(p3));\n\n    // Final sum\n    assign P = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, d, sum);\n    input a, b, c, d;\n    output sum;\n    assign sum = a ^ b ^ c ^ d;\nendmodule\n\nmodule full_adder_8bit(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n    assign {carry, sum} = a + b + c;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    // Instantiate the frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the outputs\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry;\n\n    // Add 8-bit numbers\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    assign p0 = X[0] & Y;\n    assign p1 = X[1] & Y;\n    assign p2 = X[2] & Y;\n    assign p3 = X[3] & Y;\n\n    // Shift and add\n    adder_8bit add1(.a(p0), .b(p1 << 1), .c(p2 << 2), .sum(P[7:0]));\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a, b, c;\n    output [7:0] sum;\n\n    wire [8:0] temp;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .c(c[0]), .sum(temp[0]), .c_out(temp[1]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c(c[1]), .sum(temp[2]), .c_out(temp[3]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c(c[2]), .sum(temp[4]), .c_out(temp[5]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c(c[3]), .sum(temp[6]), .c_out(temp[7]));\n    full_adder fa4(.a(a[4]), .b(b[4]), .c(c[4]), .sum(temp[8]), .c_out(temp[9]));\n    full_adder fa5(.a(a[5]), .b(b[5]), .c(c[5]), .sum(temp[10]), .c_out(temp[11]));\n    full_adder fa6(.a(a[6]), .b(b[6]), .c(c[6]), .sum(temp[12]), .c_out(temp[13]));\n    full_adder fa7(.a(a[7]), .b(b[7]), .c(c[7]), .sum(temp[14]), .c_out(temp[15]));\n\n    assign sum = temp[7:0];\n\nendmodule\n\nmodule full_adder(a, b, c, sum, c_out);\n    input a, b, c;\n    output sum, c_out;\n\n    assign sum = a ^ b ^ c;\n    assign c_out = (a & b) | (a & c) | (b & c);\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] abs_dividend;\n    wire [7:0] neg_divisor;\n    wire [7:0] quotient;\n    wire [7:0] remainder;\n    wire [3:0] counter;\n    wire [7:0] shift_reg;\n    wire div_complete;\n\n    // Absolute value calculation\n    abs_value abs_dividend_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(dividend),\n        .result(abs_dividend)\n    );\n\n    // Negative divisor calculation\n    neg_value neg_divisor_module (\n        .clk(clk),\n        .rst(rst),\n        .sign(sign),\n        .value(divisor),\n        .result(neg_divisor)\n    );\n\n    // Division control logic\n    div_control div_control_module (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .sign(sign),\n        .abs_dividend(abs_dividend),\n        .neg_divisor(neg_divisor),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .div_complete(div_complete)\n    );\n\n    // Result management\n    result_mgmt result_mgmt_module (\n        .clk(clk),\n        .rst(rst),\n        .res_ready(res_ready),\n        .div_complete(div_complete),\n        .counter(counter),\n        .shift_reg(shift_reg),\n        .remainder(remainder),\n        .quotient(quotient),\n        .result(result),\n        .res_valid(res_valid)\n    );\n\nendmodule\n\nmodule abs_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= -value;\n            end else begin\n                result <= value;\n            end\n        end\n    end\n\nendmodule\n\nmodule neg_value(\n    input wire clk,\n    input wire rst,\n    input wire sign,\n    input wire [7:0] value,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            if (sign) begin\n                result <= value;\n            end else begin\n                result <= -value;\n            end\n        end\n    end\n\nendmodule\n\nmodule div_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    input wire sign,\n    input wire [7:0] abs_dividend,\n    input wire [7:0] neg_divisor,\n    output reg [3:0] counter,\n    output reg [7:0] shift_reg,\n    output reg div_complete\n);\n\n    reg [7:0] quotient;\n    reg [7:0] remainder;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n            div_complete <= 0;\n        end else begin\n            if (opn_valid) begin\n                counter <= 4;\n                shift_reg <= abs_dividend;\n                quotient <= 0;\n                remainder <= 0;\n                div_complete <= 0;\n            end else begin\n                if (counter > 0) begin\n                    counter <= counter - 1;\n                    shift_reg <= shift_reg << 1;\n                    if (shift_reg[8]) begin\n                        quotient <= quotient + 1;\n                    end\n                    if (sign) begin\n                        remainder <= remainder - neg_divisor;\n                    end else begin\n                        remainder <= remainder + abs_dividend;\n                    end\n                    if (remainder[8]) begin\n                        remainder <= remainder - neg_divisor;\n                    end\n                    if (counter == 1) begin\n                        div_complete <= 1;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule\n\nmodule result_mgmt(\n    input wire clk,\n    input wire rst,\n    input wire res_ready,\n    input wire div_complete,\n    input wire [3:0] counter,\n    input wire [7:0] shift_reg,\n    input wire [7:0] remainder,\n    input wire [7:0] quotient,\n    output reg [15:0] result,\n    output reg res_valid\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            res_valid <= 0;\n        end else begin\n            if (res_ready) begin\n                result <= {remainder, quotient};\n                res_valid <= div_complete;\n            end else begin\n                result <= 0;\n                res_valid <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    // Instantiate the frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry;\n\n    // 8-bit adder logic\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    partial_product p00(\n        .a(X[0]),\n        .b(Y[0]),\n        .p(p0)\n    );\n\n    partial_product p01(\n        .a(X[0]),\n        .b(Y[1]),\n        .p(p1)\n    );\n\n    partial_product p02(\n        .a(X[0]),\n        .b(Y[2]),\n        .p(p2)\n    );\n\n    partial_product p03(\n        .a(X[0]),\n        .b(Y[3]),\n        .p(p3)\n    );\n\n    // Shift and add\n    adder_8bit add1(\n        .a(p0),\n        .b(p1),\n        .c(1'b0),\n        .p(P[0])\n    );\n\n    adder_8bit add2(\n        .a(p2),\n        .b(p3),\n        .c(1'b0),\n        .p(P[1])\n    );\n\n    adder_8bit add3(\n        .a(p0),\n        .b(p2),\n        .c(1'b0),\n        .p(P[2])\n    );\n\n    adder_8bit add4(\n        .a(p1),\n        .b(p3),\n        .c(1'b0),\n        .p(P[3])\n    );\n\n    adder_8bit add5(\n        .a(p0),\n        .b(p3),\n        .c(1'b0),\n        .p(P[4])\n    );\n\n    adder_8bit add6(\n        .a(p1),\n        .b(p2),\n        .c(1'b0),\n        .p(P[5])\n    );\n\n    adder_8bit add7(\n        .a(p0),\n        .b(p2),\n        .c(1'b0),\n        .p(P[6])\n    );\n\n    adder_8bit add8(\n        .a(p1),\n        .b(p3),\n        .c(1'b0),\n        .p(P[7])\n    );\n\nendmodule\n\nmodule partial_product(a, b, p);\n    input a;\n    input b;\n    output p;\n\n    assign p = a & b;\nendmodule\n\nmodule adder_8bit(a, b, c, p);\n    input a;\n    input b;\n    input c;\n    output p;\n\n    wire c1, c2;\n\n    full_adder fa0(\n        .a(a),\n        .b(b),\n        .c_in(c),\n        .sum(p),\n        .c_out(c1)\n    );\n\n    full_adder fa1(\n        .a(a),\n        .b(b),\n        .c_in(c1),\n        .sum(p),\n        .c_out(c2)\n    );\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a;\n    input b;\n    input c_in;\n    output sum;\n    output c_out;\n\n    wire c1, c2;\n\n    assign {c_out, sum} = a + b + c_in;\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry_chain;\n\n    // Instantiate 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_chain[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_chain[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_chain[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_chain[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_chain[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_chain[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [31:0] divisor  // 32-bit divisor\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0};\n        divisor = {B, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [31:0] divisor, // 32-bit divisor\n    output reg [31:0] quotient, // 32-bit quotient\n    output reg [31:0] remainder // 32-bit remainder\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [4:0] shift_count;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        shift_count = 0;\n        temp_quotient = 0;\n        temp_remainder = 0;\n\n        while (shifted_dividend >= shifted_divisor) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            shift_count = shift_count + 1;\n        end\n\n        quotient = shift_count;\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\n// Submodule for dividing by 2\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for dividing by 10\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for dividing by 100\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry_chain;\n\n    // Instantiate 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_chain[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_chain[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_chain[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_chain[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_chain[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_chain[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry_chain;\n\n    // Instantiate 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry_chain[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry_chain[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry_chain[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry_chain[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry_chain[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry_chain[2]),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_product1, partial_product2, partial_product3;\n\n    // Partial products\n    partial_product partial_product1_inst(\n        .a(X[0]),\n        .b(Y),\n        .p(partial_product1)\n    );\n\n    partial_product partial_product2_inst(\n        .a(X[1]),\n        .b(Y),\n        .p(partial_product2)\n    );\n\n    partial_product partial_product3_inst(\n        .a(X[2]),\n        .b(Y),\n        .p(partial_product3)\n    );\n\n    // Full product\n    adder_8bit adder_inst(\n        .a(partial_product1),\n        .b(partial_product2),\n        .c(partial_product3),\n        .p(P)\n    );\n\nendmodule\n\nmodule partial_product(a, b, p);\n    input a, b;\n    output [7:0] p;\n\n    assign p = {1'b0, a} & {1'b0, b};\nendmodule\n\nmodule adder_8bit(a, b, c, p);\n    input [7:0] a, b;\n    input c;\n    output [7:0] p;\n\n    wire [8:0] sum;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .c_in(c), .sum(sum[0]), .c_out(sum[8]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c_in(sum[8]), .sum(sum[1]), .c_out(sum[9]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c_in(sum[9]), .sum(sum[2]), .c_out(sum[10]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c_in(sum[10]), .sum(sum[3]), .c_out(sum[11]));\n    full_adder fa4(.a(a[4]), .b(b[4]), .c_in(sum[11]), .sum(sum[4]), .c_out(sum[12]));\n    full_adder fa5(.a(a[5]), .b(b[5]), .c_in(sum[12]), .sum(sum[5]), .c_out(sum[13]));\n    full_adder fa6(.a(a[6]), .b(b[6]), .c_in(sum[13]), .sum(sum[6]), .c_out(sum[14]));\n    full_adder fa7(.a(a[7]), .b(b[7]), .c_in(sum[14]), .sum(sum[7]), .c_out(sum[15]));\n\n    assign p = sum[7:0];\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n\n    wire c1, c2;\n\n    xor x1(a, b, sum);\n    and a1(a, b, c_out);\n    and a2(a, c_in, c1);\n    and a3(b, c_in, c2);\n    or o1(c1, c2, c_out);\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [31:0] divisor  // 32-bit divisor\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0};\n        divisor = {B, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [31:0] divisor,  // 32-bit divisor\n    output reg [31:0] quotient,  // 32-bit quotient\n    output reg [31:0] remainder  // 32-bit remainder\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [4:0] shift_count;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        shift_count = 0;\n        quotient = 0;\n        remainder = 0;\n\n        while (shifted_dividend >= shifted_divisor) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            shift_count = shift_count + 1;\n        end\n\n        temp_quotient = shifted_dividend >> shift_count;\n        temp_remainder = shifted_divisor << shift_count;\n\n        quotient = quotient | temp_quotient;\n        remainder = remainder | temp_remainder;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignment\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for 50MHz clock generation\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10MHz clock generation\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 1MHz clock generation\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 49) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry; // Declare carry wire for each submodule\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3(\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3]; // Output carry from the last submodule\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    // Perform addition\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    assign dividend = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        quotient = 0;\n        remainder = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                quotient[i] = 1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end else begin\n                quotient[i] = 0;\n            end\n\n            shifted_divisor = shifted_divisor >> 1;\n        end\n\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for 50MHz clock\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10MHz clock\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 3'b100) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 1MHz clock\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 6'b111111) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit input operand X\n    input [3:0] Y;       // 4-bit input operand Y\n    output [7:0] P;      // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift and AND operations\n    assign p0_0 = X[0] & Y[0];\n    assign p0_1 = X[0] & Y[1];\n    assign p0_2 = X[0] & Y[2];\n    assign p0_3 = X[0] & Y[3];\n\n    assign p1_0 = X[1] & Y[0];\n    assign p1_1 = X[1] & Y[1];\n    assign p1_2 = X[1] & Y[2];\n    assign p1_3 = X[1] & Y[3];\n\n    assign p2_0 = X[2] & Y[0];\n    assign p2_1 = X[2] & Y[1];\n    assign p2_2 = X[2] & Y[2];\n    assign p2_3 = X[2] & Y[3];\n\n    assign p3_0 = X[3] & Y[0];\n    assign p3_1 = X[3] & Y[1];\n    assign p3_2 = X[3] & Y[2];\n    assign p3_3 = X[3] & Y[3];\n\n    // Adders\n    adder_8bit add1(.a(p0), .b(p1), .c(p0), .sum(p1));\n    adder_8bit add2(.a(p1), .b(p2), .c(p1), .sum(p2));\n    adder_8bit add3(.a(p2), .b(p3), .c(p2), .sum(p3));\n\n    // Final sum\n    assign P = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a, b;\n    input [7:0] c;\n    output [7:0] sum;\n\n    wire [7:0] sum_temp;\n\n    full_adder fa0(.a(a[0]), .b(b[0]), .c(c[0]), .sum(sum_temp[0]), .carry(sum_temp[1]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c(c[1]), .sum(sum_temp[2]), .carry(sum_temp[3]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c(c[2]), .sum(sum_temp[4]), .carry(sum_temp[5]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c(c[3]), .sum(sum_temp[6]), .carry(sum_temp[7]));\n\n    assign sum = sum_temp;\n\nendmodule\n\nmodule full_adder(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n\n    assign sum = a ^ b ^ c;\n    assign carry = (a & b) | (b & c) | (a & c);\n\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire [31:0] carry;\n\n    // Instantiate 4 8-bit adders\n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(carry[0])\n    );\n\n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(carry[0]),\n        .Sum(Sum[15:8]),\n        .Cout(carry[1])\n    );\n\n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(carry[1]),\n        .Sum(Sum[23:16]),\n        .Cout(carry[2])\n    );\n\n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(carry[2]),\n        .Sum(Sum[31:24]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry;\n\n    // 8-bit addition\n    assign {Cout, Sum} = A + B + Cin;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'h0000, A}; // Prepare dividend\n        dividend = dividend >> B; // Shift dividend\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        quotient = dividend / divisor; // Divide\n        remainder = dividend % divisor; // Remainder\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                CLK_out <= ~CLK_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                CLK_out <= ~CLK_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, B};\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        remainder = dividend;\n        quotient = 0;\n        while (remainder >= divisor) begin\n            remainder = remainder - divisor;\n            quotient = quotient + 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Shift operations\n    assign p0_0 = X[0] & Y[0];\n    assign p0_1 = X[0] & Y[1];\n    assign p0_2 = X[0] & Y[2];\n    assign p0_3 = X[0] & Y[3];\n\n    assign p1_0 = X[1] & Y[0];\n    assign p1_1 = X[1] & Y[1];\n    assign p1_2 = X[1] & Y[2];\n    assign p1_3 = X[1] & Y[3];\n\n    assign p2_0 = X[2] & Y[0];\n    assign p2_1 = X[2] & Y[1];\n    assign p2_2 = X[2] & Y[2];\n    assign p2_3 = X[2] & Y[3];\n\n    assign p3_0 = X[3] & Y[0];\n    assign p3_1 = X[3] & Y[1];\n    assign p3_2 = X[3] & Y[2];\n    assign p3_3 = X[3] & Y[3];\n\n    // Adders\n    adder_8bit add1(.a(p0_0), .b(p0_1), .c(p0_2), .d(p0_3), .sum(p0));\n    adder_8bit add2(.a(p1_0), .b(p1_1), .c(p1_2), .d(p1_3), .sum(p1));\n    adder_8bit add3(.a(p2_0), .b(p2_1), .c(p2_2), .d(p2_3), .sum(p2));\n    adder_8bit add4(.a(p3_0), .b(p3_1), .c(p3_2), .d(p3_3), .sum(p3));\n\n    // Final sum\n    assign P = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_8bit(a, b, c, d, sum);\n    input a, b, c, d;\n    output sum;\n    assign sum = a ^ b ^ c ^ d;\nendmodule\n\nmodule full_adder_8bit(a, b, c, sum, carry);\n    input a, b, c;\n    output sum, carry;\n    assign {carry, sum} = a + b + c;\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select result based on operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is selected based on operation\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    // Instantiate the frequency dividers\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output signals\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [31:0] divisor  // 32-bit divisor\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0};\n        divisor = {B, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [31:0] divisor,  // 32-bit divisor\n    output reg [31:0] quotient,  // 32-bit quotient\n    output reg [31:0] remainder  // 32-bit remainder\n);\n    integer i;\n    always @(*) begin\n        quotient = 0;\n        remainder = dividend;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = quotient | (1 << i);\n            end\n            divisor = {divisor[30:0], divisor[31]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_product1, partial_product2, partial_product3;\n\n    // Partial products\n    partial_product partial_product1_inst (\n        .a(X[0]),\n        .b(Y),\n        .p(partial_product1)\n    );\n\n    partial_product partial_product2_inst (\n        .a(X[1]),\n        .b(Y),\n        .p(partial_product2)\n    );\n\n    partial_product partial_product3_inst (\n        .a(X[2]),\n        .b(Y),\n        .p(partial_product3)\n    );\n\n    // Full adder for the partial products\n    adder_8bit adder_inst (\n        .a(partial_product1),\n        .b(partial_product2),\n        .c(partial_product3),\n        .p(P)\n    );\n\nendmodule\n\nmodule partial_product(a, b, p);\n    input a;\n    input [3:0] b;\n    output [7:0] p;\n\n    assign p = {b[3], b[3], b[3], b[3], b[3], b[3], b[3], b[3]} & {a, a, a, a, a, a, a, a};\nendmodule\n\nmodule adder_8bit(a, b, c, p);\n    input a;\n    input b;\n    input c;\n    output p;\n\n    wire [7:0] sum;\n\n    full_adder fa0 (.a(a), .b(b), .c(c), .sum(sum[0]), .c_out(sum[1]));\n    full_adder fa1 (.a(sum[0]), .b(sum[1]), .c(sum[1]), .sum(sum[2]), .c_out(sum[3]));\n    full_adder fa2 (.a(sum[2]), .b(sum[3]), .c(sum[3]), .sum(sum[4]), .c_out(sum[5]));\n    full_adder fa3 (.a(sum[4]), .b(sum[5]), .c(sum[5]), .sum(sum[6]), .c_out(sum[7]));\n\n    assign p = sum[7];\nendmodule\n\nmodule full_adder(a, b, c, sum, c_out);\n    input a;\n    input b;\n    input c;\n    output sum;\n    output c_out;\n\n    assign sum = a ^ b ^ c;\n    assign c_out = (a & b) | (a & c) | (b & c);\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op[0]),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op[1]),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the output\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is the carry out of the adder\n    assign carry_out = add_carry;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A + (B << op);\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output borrow_out\n);\n    assign {borrow_out, result} = A - (B << op);\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignment\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products[3:0];\n\n    // Generate partial products\n    genvar i;\n    for (i = 0; i < 4; i = i + 1) begin\n        assign partial_products[i] = (X[i] & Y) << i;\n    end\n\n    // Add partial products\n    wire [7:0] sum;\n    assign sum = partial_products[0] + partial_products[1] + partial_products[2] + partial_products[3];\n\n    // Assign output\n    assign P = sum;\n\nendmodule\n\nmodule adder_8bit(a, b, sum);\n    input [7:0] a;\n    input [7:0] b;\n    output [7:0] sum;\n\n    wire [8:0] temp_sum;\n    assign temp_sum = a + b;\n    assign sum = temp_sum[7:0];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    wire c1, c2;\n    assign {cout, c1} = a + b + cin;\n    assign sum = c1 ^ cin;\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepare the dividend\n        divisor = {16'b0, B}; // Prepare the divisor\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        remainder = dividend; // Initialize the remainder\n        quotient = 0; // Initialize the quotient\n        integer i;\n        for (i = 0; i < 32; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = {quotient[30:0], 1'b0}; // Shift the quotient\n            end\n            remainder = {remainder[30:0], dividend[31]}; // Shift the remainder\n            dividend = {dividend[30:0], 1'b0}; // Shift the dividend\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepend 16 zeros to the dividend\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        quotient = dividend >> divisor; // Shift and divide\n        remainder = dividend - (quotient * divisor); // Compute remainder\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate the adder\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting the result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting the carry/borrow output\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignment\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for 50MHz clock\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10MHz clock\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for 1MHz clock\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    partial_product p0_wire(\n        .a(X[0]),\n        .b(Y),\n        .p(p0)\n    );\n\n    partial_product p1_wire(\n        .a(X[1]),\n        .b(Y),\n        .p(p1)\n    );\n\n    partial_product p2_wire(\n        .a(X[2]),\n        .b(Y),\n        .p(p2)\n    );\n\n    partial_product p3_wire(\n        .a(X[3]),\n        .b(Y),\n        .p(p3)\n    );\n\n    // Full adder for the 4 partial products\n    adder_8bit add1(\n        .a(p0),\n        .b(p1),\n        .c_in(0),\n        .sum(P[0]),\n        .c_out(P[1])\n    );\n\n    adder_8bit add2(\n        .a(p2),\n        .b(p3),\n        .c_in(P[1]),\n        .sum(P[2]),\n        .c_out(P[3])\n    );\n\n    adder_8bit add3(\n        .a(0),\n        .b(0),\n        .c_in(P[3]),\n        .sum(P[4]),\n        .c_out(P[5])\n    );\n\n    adder_8bit add4(\n        .a(0),\n        .b(0),\n        .c_in(P[5]),\n        .sum(P[6]),\n        .c_out(P[7])\n    );\n\nendmodule\n\nmodule partial_product(a, b, p);\n    input a;\n    input [3:0] b;\n    output [7:0] p;\n\n    assign p = {b[3], b[3], b[2], b[2], b[1], b[1], b[0], b[0]};\n    assign p = a ? {8{1'b1}} : {8{1'b0}};\nendmodule\n\nmodule adder_8bit(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n    wire c1, c2;\n\n    full_adder fa0(.a(a), .b(b), .c_in(c_in), .sum(sum), .c_out(c1));\n    full_adder fa1(.a(sum), .b(0), .c_in(c1), .sum(sum), .c_out(c2));\n    full_adder fa2(.a(sum), .b(0), .c_in(c2), .sum(sum), .c_out(c_out));\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n    wire c1, c2;\n\n    assign {c_out, sum} = a + b + c_in;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .dividend(dividend)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    output reg [31:0] dividend\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0}; // Prepare dividend\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = {divisor, 16'b0}; // Prepare divisor\n\n        quotient = 0;\n        remainder = 0;\n\n        // Perform division\n        for (i = 0; i < 16; i = i + 1) begin\n            shifted_dividend = shifted_dividend << 1;\n            shifted_divisor = shifted_divisor << 1;\n\n            if (shifted_dividend >= shifted_divisor) begin\n                temp_quotient = quotient + (1 << i);\n                temp_remainder = shifted_dividend - shifted_divisor;\n            end else begin\n                temp_quotient = quotient;\n                temp_remainder = shifted_dividend;\n            end\n\n            quotient = temp_quotient;\n            remainder = temp_remainder;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] carry;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry(carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry(carry)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is the carry from the adder\n    assign carry_out = carry[31];\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output [31:0] carry\n);\n\n    assign {carry, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output [31:0] carry\n);\n\n    assign {carry, result} = A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    assign p0 = X[0] & Y;\n    assign p1 = X[1] & Y << 1;\n    assign p2 = X[2] & Y << 2;\n    assign p3 = X[3] & Y << 3;\n\n    // Adders\n    adder_8bit add1(.a(p0), .b(p1), .c(0), .p(P[0]));\n    adder_8bit add2(.a(p2), .b(p3), .c(0), .p(P[1]));\n    adder_8bit add3(.a(p0 + p2), .b(p1 + p3), .c(0), .p(P[2]));\n    adder_8bit add4(.a(p0 + p1 + p2), .b(p3), .c(0), .p(P[3]));\n    adder_8bit add5(.a(p0 + p1 + p2 + p3), .b(0), .c(0), .p(P[4]));\n    adder_8bit add6(.a(p0 + p2 + p3), .b(p1 + p3), .c(0), .p(P[5]));\n    adder_8bit add7(.a(p0 + p1 + p3), .b(p2 + p3), .c(0), .p(P[6]));\n    adder_8bit add8(.a(p0 + p1 + p2 + p3), .b(0), .c(0), .p(P[7]));\n\nendmodule\n\nmodule adder_8bit(a, b, c, p);\n    input [7:0] a, b;\n    input c;\n    output [7:0] p;\n    assign p = a + b + c;\nendmodule\n\nmodule full_adder_8bit(a, b, c, p, g);\n    input [7:0] a, b;\n    input c;\n    output [7:0] p;\n    output g;\n    assign {g, p} = a + b + c;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4'd9) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 7'd49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend,\n    output reg [15:0] divisor\n);\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] result,\n    output reg [31:0] odd\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [4:0] counter;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        counter = 0;\n\n        while (shifted_dividend >= shifted_divisor) begin\n            shifted_dividend = shifted_dividend - shifted_divisor;\n            shifted_divisor = shifted_divisor >> 1;\n            counter = counter + 1;\n        end\n\n        result = counter;\n        odd = shifted_dividend;\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is the carry out of the adder\n    assign carry_out = (op == 2'b00) ? add_carry : 1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n    assign {borrow_out, result} = A - B;\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodules\n    wire clk_50_int, clk_10_int, clk_1_int;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] remainder;\n\n    // Instantiate the dividend preparation module\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    // Instantiate the division operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .remainder(remainder),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [15:0] divisor  // 16-bit divisor\n);\n    assign dividend = {A[31:16], 16'b0};\n    assign divisor = B;\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,  // 16-bit divisor\n    output reg [31:0] remainder, // 32-bit remainder\n    output reg [31:0] result,    // 32-bit quotient\n    output reg [31:0] odd        // 32-bit remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_result;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        remainder = 0;\n        result = 0;\n        odd = 0;\n\n        // Shift the dividend and divisor to the left by one bit\n        for (i = 0; i < 32; i = i + 1) begin\n            shifted_dividend = shifted_dividend << 1;\n            shifted_divisor = shifted_divisor << 1;\n\n            // Compare the shifted dividend with the divisor\n            if (shifted_dividend >= shifted_divisor) begin\n                shifted_dividend = shifted_dividend - shifted_divisor;\n                remainder = remainder | (1 << i);\n            end\n        end\n\n        // Compute the quotient and remainder\n        result = remainder >> 1;\n        odd = remainder[0];\n    end\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    // Instantiate the frequency divider for 50MHz\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    // Instantiate the frequency divider for 10MHz\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    // Instantiate the frequency divider for 1MHz\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            counter <= 0;\n        end else begin\n            if (counter == 4) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate the adder\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for the result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for the carry/borrow output\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\n// AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Partial products\n    wire [3:0] p0_0, p0_1, p0_2, p0_3;\n    wire [3:0] p1_0, p1_1, p1_2, p1_3;\n    wire [3:0] p2_0, p2_1, p2_2, p2_3;\n    wire [3:0] p3_0, p3_1, p3_2, p3_3;\n\n    // Bitwise AND operations\n    and gate_0(X[0], Y[0], p0_0);\n    and gate_1(X[1], Y[1], p0_1);\n    and gate_2(X[2], Y[2], p0_2);\n    and gate_3(X[3], Y[3], p0_3);\n\n    and gate_0(X[0], Y[1], p1_0);\n    and gate_1(X[1], Y[2], p1_1);\n    and gate_2(X[2], Y[3], p1_2);\n    and gate_3(X[3], 4'b0000, p1_3);\n\n    and gate_0(X[0], Y[2], p2_0);\n    and gate_1(X[1], Y[3], p2_1);\n    and gate_2(X[2], 4'b0000, p2_2);\n    and gate_3(X[3], 4'b0000, p2_3);\n\n    and gate_0(X[0], Y[3], p3_0);\n    and gate_1(X[1], 4'b0000, p3_1);\n    and gate_2(X[2], 4'b0000, p3_2);\n    and gate_3(X[3], 4'b0000, p3_3);\n\n    // Shift operations\n    shift_left shift_0(p0_0, 0, p0);\n    shift_left shift_1(p0_1, 1, p0);\n    shift_left shift_2(p0_2, 2, p0);\n    shift_left shift_3(p0_3, 3, p0);\n\n    shift_left shift_0(p1_0, 0, p1);\n    shift_left shift_1(p1_1, 1, p1);\n    shift_left shift_2(p1_2, 2, p1);\n    shift_left shift_3(p1_3, 3, p1);\n\n    shift_left shift_0(p2_0, 0, p2);\n    shift_left shift_1(p2_1, 1, p2);\n    shift_left shift_2(p2_2, 2, p2);\n    shift_left shift_3(p2_3, 3, p2);\n\n    shift_left shift_0(p3_0, 0, p3);\n    shift_left shift_1(p3_1, 1, p3);\n    shift_left shift_2(p3_2, 2, p3);\n    shift_left shift_3(p3_3, 3, p3);\n\n    // Adder module instantiation\n    adder_8bit add1(.a(p0), .b(p1), .sum(p0));\n    adder_8bit add2(.a(p2), .b(p3), .sum(p1));\n    adder_8bit add3(.a(p0), .b(p2), .sum(p2));\n    adder_8bit add4(.a(p1), .b(p3), .sum(p3));\n\nendmodule\n\nmodule adder_8bit(a, b, sum);\n    input [7:0] a, b;\n    output [7:0] sum;\n\n    wire [7:0] c;\n    full_adder fa0(.a(a[0]), .b(b[0]), .c_in(c[0]), .sum(sum[0]), .c_out(c[1]));\n    full_adder fa1(.a(a[1]), .b(b[1]), .c_in(c[1]), .sum(sum[1]), .c_out(c[2]));\n    full_adder fa2(.a(a[2]), .b(b[2]), .c_in(c[2]), .sum(sum[2]), .c_out(c[3]));\n    full_adder fa3(.a(a[3]), .b(b[3]), .c_in(c[3]), .sum(sum[3]), .c_out(c[4]));\n    full_adder fa4(.a(a[4]), .b(b[4]), .c_in(c[4]), .sum(sum[4]), .c_out(c[5]));\n    full_adder fa5(.a(a[5]), .b(b[5]), .c_in(c[5]), .sum(sum[5]), .c_out(c[6]));\n    full_adder fa6(.a(a[6]), .b(b[6]), .c_in(c[6]), .sum(sum[6]), .c_out(c[7]));\n    full_adder fa7(.a(a[7]), .b(b[7]), .c_in(c[7]), .sum(sum[7]), .c_out(c[8]));\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n\n    wire c_out_temp;\n\n    xor xor0(a, b, sum);\n    xor xor1(sum, c_in, c_out_temp);\n    or or0(a, b, c_out);\n    or or1(c_in, c_out_temp, c_out);\nendmodule\n\nmodule and(a, b, sum);\n    input a, b;\n    output sum;\n\n    assign sum = a & b;\nendmodule\n\nmodule shift_left(a, shift, sum);\n    input [3:0] a;\n    input [1:0] shift;\n    output [3:0] sum;\n\n    assign sum = a << shift;\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out, clk_10_out, clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Output assignments\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 4'd9) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 7'd49) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module mul_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input operand X\n    input [3:0] Y;      // 4-bit input operand Y\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] partial_products;\n\n    // Generate partial products\n    wire [3:0] p0, p1, p2, p3;\n    assign p0 = X & Y;\n    assign p1 = X << 1 & Y;\n    assign p2 = X << 2 & Y;\n    assign p3 = X << 3 & Y;\n\n    // Add partial products\n    wire [7:0] sum0, sum1, sum2, sum3;\n    adder_8bit add1(.a(p0), .b(p1), .c(0), .sum(sum0));\n    adder_8bit add2(.a(p2), .b(p3), .c(0), .sum(sum1));\n    adder_8bit add3(.a(sum0), .b(sum1), .c(0), .sum(sum2));\n    assign P = sum2;\n\nendmodule\n\nmodule adder_8bit(a, b, c, sum);\n    input [7:0] a, b;\n    input c;\n    output [7:0] sum;\n\n    wire c1, c2;\n    assign {c1, sum} = a + b + c;\n    assign c = c1;\nendmodule\n\nmodule full_adder(a, b, c, sum, c_out);\n    input a, b, c;\n    output sum, c_out;\n\n    wire c1, c2;\n    assign {c1, sum} = a + b + c;\n    assign c_out = c1;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the submodules\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend),\n        .divisor(divisor)\n    );\n\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output reg [31:0] dividend, // 32-bit dividend\n    output reg [31:0] divisor  // 32-bit divisor\n);\n    always @(*) begin\n        dividend = {A[31:16], 16'b0};\n        divisor = {B, 16'b0};\n    end\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [31:0] divisor,  // 32-bit divisor\n    output reg [31:0] quotient, // 32-bit quotient\n    output reg [31:0] remainder // 32-bit remainder\n);\n    reg [31:0] shifted_dividend;\n    reg [31:0] shifted_divisor;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        // Shift the dividend and divisor\n        shifted_dividend = {dividend[31], dividend[31:1]};\n        shifted_divisor = {divisor, 16'b0};\n\n        // Initialize quotient and remainder\n        quotient = 32'b0;\n        remainder = dividend;\n\n        // Loop for division\n        integer i;\n        for (i = 0; i < 16; i = i + 1) begin\n            // Shift the divisor\n            shifted_divisor = {shifted_divisor[31], shifted_divisor[31:1]};\n\n            // Compare the shifted divisor with the shifted dividend\n            if (shifted_dividend >= shifted_divisor) begin\n                // Add the divisor to the quotient and remainder\n                temp_quotient = quotient + 1;\n                temp_remainder = remainder - shifted_divisor;\n            end else begin\n                // Add 0 to the quotient and remainder\n                temp_quotient = quotient;\n                temp_remainder = remainder;\n            end\n\n            // Assign the temporary values to the final outputs\n            quotient = temp_quotient;\n            remainder = temp_remainder;\n\n            // Shift the dividend\n            shifted_dividend = {shifted_dividend[31], shifted_dividend[31:1]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is the carry out of the adder\n    assign carry_out = add_carry;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\n// AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire clk_50_int;\n    wire clk_10_int;\n    wire clk_1_int;\n\n    // Instantiate the frequency divider modules\n    clk_div clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_int)\n    );\n\n    clk_div clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_int)\n    );\n\n    clk_div clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_int)\n    );\n\n    // Assign the output clocks\n    assign CLK_50 = clk_50_int;\n    assign CLK_10 = clk_10_int;\n    assign CLK_1 = clk_1_int;\n\nendmodule\n\nmodule clk_div (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [3:0] x_shifted;\n    wire [3:0] y_shifted;\n\n    // Shift X left by 0, 1, 2, and 3 positions\n    assign x_shifted[0] = X[0];\n    assign x_shifted[1] = X[0] | X[1];\n    assign x_shifted[2] = X[0] | X[1] | X[2];\n    assign x_shifted[3] = X[0] | X[1] | X[2] | X[3];\n\n    // Shift Y left by 0, 1, 2, and 3 positions\n    assign y_shifted[0] = Y[0];\n    assign y_shifted[1] = Y[0] | Y[1];\n    assign y_shifted[2] = Y[0] | Y[1] | Y[2];\n    assign y_shifted[3] = Y[0] | Y[1] | Y[2] | Y[3];\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(x_shifted[0]), .y(y_shifted[0]), .sum(P[0]));\n    adder_4bit adder_1(.x(x_shifted[1]), .y(y_shifted[1]), .sum(P[1]));\n    adder_4bit adder_2(.x(x_shifted[2]), .y(y_shifted[2]), .sum(P[2]));\n    adder_4bit adder_3(.x(x_shifted[3]), .y(y_shifted[3]), .sum(P[3]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input x;\n    input y;\n    output sum;\n\n    assign sum = x ^ y;\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A};\n        divisor = B;\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] shifted_dividend;\n    reg [15:0] shifted_divisor;\n\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        quotient = 0;\n        remainder = 0;\n\n        for (i = 0; i < 32; i = i + 1) begin\n            if (shifted_dividend >= shifted_divisor) begin\n                quotient[i] = 1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end else begin\n                quotient[i] = 0;\n            end\n\n            shifted_divisor = shifted_divisor << 1;\n        end\n\n        remainder = shifted_dividend;\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate bitwise AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the result based on the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Select the carry or borrow output based on the operation\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    assign clk_average[0] = counter_out[3];\n    assign clk_average[1] = counter_out[2];\n    assign clk_average[2] = counter_out[1];\n    assign clk_average[3] = counter_out[0];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = ~counter_out[3];\n    assign clk_adjusted[1] = ~counter_out[2];\n    assign clk_adjusted[2] = ~counter_out[1];\n    assign clk_adjusted[3] = ~counter_out[0];\n\n    // Logical OR for final output\n    assign clk_div = clk_average | clk_adjusted;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input [3:0] clk_in,\n    output reg [3:0] clk_out\n);\n    always @(*) begin\n        clk_out[0] = clk_in[3];\n        clk_out[1] = clk_in[2];\n        clk_out[2] = clk_in[1];\n        clk_out[3] = clk_in[0];\n    end\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk_in,\n    output reg [3:0] clk_out\n);\n    always @(*) begin\n        clk_out[0] = ~clk_in[3];\n        clk_out[1] = ~clk_in[2];\n        clk_out[2] = ~clk_in[1];\n        clk_out[3] = ~clk_in[0];\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend, divisor;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(A),\n        .B(B),\n        .result(dividend),\n        .odd(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .result(result),\n        .odd(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Adjust the dividend and divisor to 32 bits\n    assign result = A >> 16;\n    assign odd = A & 32'hFFFF;\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend, // 32-bit dividend\n    input wire [15:0] divisor,  // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Perform the division operation\n    assign result = dividend >> divisor;\n    assign odd = dividend & (1 << divisor);\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Assign the product\n    assign P = p0 + (p1 << 1) + (p2 << 2);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_2bit adder_1(.x(x), .y(y), .p(p1));\n\n    // Assign the product\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_1bit adder_1(.x(x), .y(y), .p(p1));\n\n    // Assign the product\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    assign p = x + (y << 4);\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n    wire [31:0] dividend;\n    wire [31:0] divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    // Instantiate the prep_dividend module\n    prep_dividend prep_dividend (\n        .A(dividend),\n        .B(divisor)\n    );\n\n    // Instantiate the div_operation module\n    div_operation div_op (\n        .dividend(dividend),\n        .divisor(divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign the output signals\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    output reg [31:0] dividend,\n    input [15:0] B\n);\n    always @(*) begin\n        dividend = {16'b0, A}; // Prepare dividend\n    end\nendmodule\n\nmodule div_operation(\n    input [31:0] dividend,\n    input [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        remainder = dividend; // Initialize remainder\n        quotient = 0; // Initialize quotient\n        integer i;\n        for (i = 0; i < 16; i = i + 1) begin\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient = {quotient[30:0], 1'b0};\n            end\n            remainder = remainder << 1;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate the adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the output based on the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    assign clk_average[0] = counter_out[3];\n    assign clk_average[1] = counter_out[2];\n    assign clk_average[2] = counter_out[1];\n    assign clk_average[3] = counter_out[0];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = ~counter_out[3];\n    assign clk_adjusted[1] = ~counter_out[2];\n    assign clk_adjusted[2] = ~counter_out[1];\n    assign clk_adjusted[3] = ~counter_out[0];\n\n    // Output logic\n    assign clk_div = clk_average[0] | clk_adjusted[0];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input [3:0] clk_count,\n    output reg [3:0] clk_average\n);\n    always @(*) begin\n        clk_average[0] = clk_count[3];\n        clk_average[1] = clk_count[2];\n        clk_average[2] = clk_count[1];\n        clk_average[3] = clk_count[0];\n    end\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk_count,\n    output reg [3:0] clk_adjusted\n);\n    always @(*) begin\n        clk_adjusted[0] = ~clk_count[3];\n        clk_adjusted[1] = ~clk_count[2];\n        clk_adjusted[2] = ~clk_count[1];\n        clk_adjusted[3] = ~clk_count[0];\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(p0), .y(Y[1]), .p(p1));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(p1), .y(Y[2]), .p(p2));\n\n    // Assign the final product\n    assign P = {p2, p1, p0};\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_2bit adder_1(.x(p0), .y(x[1]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the first adder\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the second adder\n    adder_1bit adder_1(.x(p0), .y(x[2]), .p(p1));\n\n    // Assign the final product\n    assign p = {p1, p0};\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    assign p = x + (y << 4);\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize the dividend and divisor\n    initial begin\n        dividend = A;\n        divisor = B;\n    end\n\n    // Perform the division algorithm\n    always @(*) begin\n        // Initialize the quotient and remainder\n        temp_quotient = 16'b0;\n        temp_remainder = 16'b0;\n\n        // Shift the dividend and compare with the divisor\n        for (int i = 0; i < 16; i = i + 1) begin\n            if (dividend >= divisor) begin\n                temp_quotient[i] = 1;\n                dividend = dividend - divisor;\n            end\n            divisor = {divisor[6:0], 1'b0};\n        end\n\n        // Assign the final quotient and remainder\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj;\n\n    // Counter submodule\n    counter #(.limit(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(clk_4)\n    );\n\n    // Clock average generator submodule\n    clk_average #(.limit(MUL2_DIV_CLK / 2)) u_clk_average (\n        .clk(clk),\n        .clk_4(clk_4),\n        .clk_3(clk_3),\n        .clk_avg(clk_avg)\n    );\n\n    // Clock adjustment submodule\n    clk_adjustment #(.limit(MUL2_DIV_CLK / 2)) u_clk_adjustment (\n        .clk(clk),\n        .clk_avg(clk_avg),\n        .clk_adj(clk_adj)\n    );\n\n    // Logical OR of the two intermediate clock signals\n    assign clk_div = clk_4 | clk_adj;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MUL2_DIV_CLK) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input [3:0] clk_4,\n    input [3:0] clk_3,\n    output reg clk_avg\n);\n    always @(posedge clk) begin\n        if (clk_4 == 4'b1111) begin\n            clk_avg <= 1;\n        end else if (clk_3 == 4'b1111) begin\n            clk_avg <= 1;\n        end else begin\n            clk_avg <= 0;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_avg,\n    output reg clk_adj\n);\n    always @(posedge clk) begin\n        if (clk_avg) begin\n            clk_adj <= 1;\n        end else begin\n            clk_adj <= 0;\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select output based on op\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the outputs\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the shift and add modules\n    shift_and_add_4bit shift_0(.x(x), .y(y), .p(p0));\n    shift_and_add_4bit shift_1(.x(x), .y(y), .p(p1));\n\n    // Combine the outputs\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule shift_and_add_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the add modules\n    add_4bit add_0(.x(x), .y(y), .p(p0));\n    add_4bit add_1(.x(x), .y(y), .p(p1));\n\n    // Combine the outputs\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule add_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product\n\n    assign p = x + (y << 3);\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .result(temp_quotient),\n        .odd(temp_remainder)\n    );\n\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (A >= B) begin\n            temp_quotient = 1;\n            temp_remainder = A - B;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = A;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate 4 adder_4bit modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the outputs of the adder_4bit modules\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [3:0] p;     // 4-bit output representing the sum of x and y\n\n    wire [3:0] temp;\n\n    // Shift x left by y bits\n    assign temp = x << y;\n\n    // Add x and temp\n    assign p = x + temp;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average_gen #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MAX_COUNT(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the two intermediate clock signals\n    assign clk_div = clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_gen(\n    input clk,\n    input rst_n,\n    input [3:0] count_out,\n    output reg [3:0] clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average <= {count_out[3], count_out[2], count_out[1], count_out[0]};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input rst_n,\n    input [3:0] count_out,\n    output reg [3:0] clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted <= {count_out[3], count_out[2], count_out[1], ~count_out[0]};\n        end\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n    wire [31:0] sub_result;\n    wire sub_borrow;\n    wire [31:0] and_result;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Carry out is selected based on the operation\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4, clk_3;\n    wire clk_4_neg, clk_3_neg;\n    wire clk_4_avg, clk_3_avg;\n    wire clk_4_adj, clk_3_adj;\n\n    // Counter module\n    reg [3:0] count;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == MUL2_DIV_CLK - 1)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\n\n    // Clock average module\n    assign clk_4 = (count % 4) == 0;\n    assign clk_3 = (count % 3) == 0;\n    assign clk_4_avg = clk_4;\n    assign clk_3_avg = clk_3;\n\n    // Clock adjustment module\n    assign clk_4_adj = clk_4_neg;\n    assign clk_3_adj = clk_3_neg;\n\n    // Clock divider module\n    assign clk_div = clk_4_avg | clk_3_avg;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_q;\n    wire [15:0] temp_r;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .result(temp_q),\n        .odd(temp_r)\n    );\n\n    // Assign the output ports\n    assign result = temp_q;\n    assign odd = temp_r;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_shifted_dividend;\n    reg [15:0] temp_shifted_remainder;\n    reg [15:0] temp_shifted_quotient;\n    reg [15:0] temp_shifted_odd;\n    reg [15:0] temp_shifted_remainder_final;\n    reg [15:0] temp_shifted_quotient_final;\n    reg [15:0] temp_shifted_odd_final;\n    reg [15:0] temp_shifted_remainder_final_final;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_shifted_dividend = 16'b0;\n        temp_shifted_remainder = 16'b0;\n        temp_shifted_quotient = 16'b0;\n        temp_shifted_odd = 16'b0;\n        temp_shifted_remainder_final = 16'b0;\n        temp_shifted_quotient_final = 16'b0;\n        temp_shifted_odd_final = 16'b0;\n        temp_shifted_remainder_final_final = 16'b0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        // Shift dividend and remainder\n        temp_shifted_dividend = {temp_dividend[14:0], 1'b0};\n        temp_shifted_remainder = temp_shifted_dividend - temp_divisor;\n        temp_shifted_quotient = temp_shifted_dividend / temp_divisor;\n        temp_shifted_odd = temp_shifted_remainder - temp_shifted_quotient * temp_divisor;\n\n        // Shift quotient and remainder\n        temp_shifted_quotient_final = temp_shifted_quotient;\n        temp_shifted_odd_final = temp_shifted_odd;\n        temp_shifted_remainder_final = temp_shifted_remainder;\n        temp_shifted_remainder_final_final = temp_shifted_remainder_final;\n\n        // Update results\n        result = temp_shifted_quotient_final;\n        odd = temp_shifted_odd_final;\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;        // 4-bit input multiplicand\n    input [3:0] Y;        // 4-bit input multiplier\n    output [7:0] P;       // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the adder_4bit modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Generate the product\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;        // 4-bit input multiplicand\n    input y;              // 1-bit input multiplier\n    output [3:0] p;        // 4-bit output representing the sum of x and y\n\n    wire [3:0] p0, p1;\n\n    // Instantiate the adder_2bit modules\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n    adder_2bit adder_1(.x(x), .y(x), .p(p1));\n\n    // Generate the sum\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [1:0] x;        // 2-bit input multiplicand\n    input y;              // 1-bit input multiplier\n    output [1:0] p;        // 2-bit output representing the sum of x and y\n\n    wire [1:0] p0, p1;\n\n    // Instantiate the adder_1bit module\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n    adder_1bit adder_1(.x(x), .y(x), .p(p1));\n\n    // Generate the sum\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input x;              // 1-bit input multiplicand\n    input y;              // 1-bit input multiplier\n    output p;             // 1-bit output representing the sum of x and y\n\n    assign p = x ^ y;     // Simple XOR operation\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] sum0, sum1, sum2;\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.X(X), .Y(Y[0]), .P(sum0));\n    adder_4bit adder_1(.X(X), .Y(Y[1]), .P(sum1));\n    adder_4bit adder_2(.X(X), .Y(Y[2]), .P(sum2));\n\n    // Calculate the product\n    assign P = sum0 << 3 | sum1 << 2 | sum2 << 1;\n\nendmodule\n\nmodule adder_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input Y;            // 1-bit input multiplier\n    output [3:0] P;     // 4-bit output representing the sum of X and Y\n\n    // Calculate the sum\n    assign P = X + Y;\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op[0]),\n        .result(add_result),\n        .carry(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op[1]),\n        .result(sub_result),\n        .borrow(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting result\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting carry/borrow\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output carry\n);\n\n    assign {carry, result} = (op) ? B + A : A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input op,\n    output [31:0] result,\n    output borrow\n);\n\n    assign {borrow, result} = (op) ? B - A : A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize temporary variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\n    // Update quotient and remainder\n    always @(*) begin\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire clk_4, clk_3;\n    wire clk_avg, clk_adj;\n\n    // Counter module\n    counter #(.limit(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average u_clk_average (\n        .clk(clk),\n        .count(counter_out),\n        .clk_avg(clk_avg)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MUL2_DIV_CLK(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .clk_avg(clk_avg),\n        .clk_adj(clk_adj)\n    );\n\n    // Logic to generate divided clock signal\n    assign clk_4 = counter_out[3];\n    assign clk_3 = counter_out[2];\n    assign clk_div = clk_4 | clk_3;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input [3:0] count,\n    output reg clk_avg\n);\n    always @(posedge clk) begin\n        if (count[3]) begin\n            clk_avg <= 1;\n        end else if (count[2]) begin\n            clk_avg <= 0;\n        end else begin\n            clk_avg <= 1;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_avg,\n    output reg clk_adj\n);\n    always @(posedge clk) begin\n        clk_adj <= clk_avg;\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate adder and subtractor modules\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.limit(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average #(.limit(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average(clk_average)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.limit(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted(clk_adjusted)\n    );\n\n    // Logical OR of the two clock signals\n    assign clk_div = clk_average[0] | clk_adjusted[0];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]   count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input   [3:0]       count_out,\n    output reg  [3:0]   clk_average\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average <= 0;\n        end else begin\n            clk_average <= {count_out[3], count_out[2:1]};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input   [3:0]       count_out,\n    output reg  [3:0]   clk_adjusted\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted <= 0;\n        end else begin\n            clk_adjusted <= {count_out[3], count_out[2:1]};\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the adder_4bit modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(p0), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(p1), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(p2), .y(Y[3]), .p(p3));\n\n    // Assemble the product\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the adder for the first bit\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the adder for the second bit\n    adder_2bit adder_1(.x(p0), .y(x[1]), .p(p1));\n\n    // Assemble the product\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the adder for the first bit\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n\n    // Instantiate the adder for the second bit\n    adder_1bit adder_1(.x(p0), .y(x[2]), .p(p1));\n\n    // Assemble the product\n    assign p = p0 + (p1 << 2);\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0;\n\n    // Instantiate the adder for the first bit\n    full_adder fa_0(.x(x), .y(y), .c_in(0), .p(p0));\n\n    // Assemble the product\n    assign p = p0;\n\nendmodule\n\nmodule full_adder(x, y, c_in, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    input c_in;         // Carry-in\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] sum;\n    wire c_out;\n\n    // Calculate the sum\n    assign sum = x + y + c_in;\n\n    // Calculate the carry out\n    assign c_out = (x[3] & y) | (x[3] & c_in) | (y & c_in);\n\n    // Assign the product\n    assign p = sum;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_remainder = 16'b0;\n        quotient = 16'b0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n            temp_dividend = temp_divisor;\n        end else begin\n            quotient = 16'b0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [3:0] shifted_X;\n    wire [3:0] shifted_Y;\n\n    // Shift X left by 0, 1, 2, 3\n    assign shifted_X[0] = X[0];\n    assign shifted_X[1] = X[0] | X[1];\n    assign shifted_X[2] = X[0] | X[1] | X[2];\n    assign shifted_X[3] = X[0] | X[1] | X[2] | X[3];\n\n    // Shift Y left by 0, 1, 2, 3\n    assign shifted_Y[0] = Y[0];\n    assign shifted_Y[1] = Y[0] | Y[1];\n    assign shifted_Y[2] = Y[0] | Y[1] | Y[2];\n    assign shifted_Y[3] = Y[0] | Y[1] | Y[2] | Y[3];\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(shifted_X[0]), .y(shifted_Y[0]), .sum(P[0]));\n    adder_4bit adder_1(.x(shifted_X[1]), .y(shifted_Y[1]), .sum(P[1]));\n    adder_4bit adder_2(.x(shifted_X[2]), .y(shifted_Y[2]), .sum(P[2]));\n    adder_4bit adder_3(.x(shifted_X[3]), .y(shifted_Y[3]), .sum(P[3]));\n\nendmodule\n\nmodule adder_4bit(x, y, sum);\n    input [3:0] x;      // 4-bit input for X\n    input [3:0] y;      // 4-bit input for Y\n    output [3:0] sum;   // 4-bit output for sum\n\n    assign sum = x ^ y;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4, clk_3;\n    wire [3:0] counter_value;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_value)\n    );\n\n    // Clock average generator module\n    clk_average u_clk_average (\n        .clk(clk),\n        .count_value(counter_value),\n        .clk_4(clk_4),\n        .clk_3(clk_3)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.MUL2_DIV_CLK(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .clk_4(clk_4),\n        .clk_3(clk_3),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input [3:0] count_value,\n    output reg clk_4,\n    output reg clk_3\n);\n    always @(posedge clk) begin\n        if (count_value == 4) begin\n            clk_4 <= 1;\n            clk_3 <= 0;\n        end else if (count_value == 3) begin\n            clk_4 <= 0;\n            clk_3 <= 1;\n        end else begin\n            clk_4 <= 0;\n            clk_3 <= 0;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_4,\n    input clk_3,\n    output reg clk_div\n);\n    always @(posedge clk) begin\n        clk_div <= clk_4 | clk_3;\n    end\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_borrow;\n\n    // Instantiate adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    // Instantiate subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .borrow_out(sub_borrow)\n    );\n\n    // Instantiate AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer for selecting operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer for selecting carry/borrow\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry_out\n);\n\n    assign {carry_out, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output borrow_out\n);\n\n    assign {borrow_out, result} = A - B;\n\nendmodule\n\n// Bitwise AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] shifted_dividend;\n    reg [7:0] shifted_divisor;\n    reg [7:0] shifted_divisor_mask;\n    reg [7:0] shifted_divisor_mask_inv;\n\n    // Initialize the temporary variables\n    initial begin\n        quotient = 0;\n        remainder = 0;\n        shifted_dividend = 0;\n        shifted_divisor = 0;\n        shifted_divisor_mask = 0;\n        shifted_divisor_mask_inv = 0;\n    end\n\n    // Shift the dividend and divisor\n    always @(*) begin\n        shifted_dividend = A << 1;\n        shifted_divisor = B << 1;\n        shifted_divisor_mask = {8{1'b1}};\n        shifted_divisor_mask_inv = ~shifted_divisor_mask;\n    end\n\n    // Perform the division algorithm\n    always @(*) begin\n        if (shifted_dividend[15:8] == shifted_divisor) begin\n            quotient = quotient + 1;\n            remainder = remainder + shifted_divisor_mask;\n        end else if (shifted_dividend[15:8] == shifted_divisor_mask_inv) begin\n            quotient = quotient + 1;\n            remainder = remainder + shifted_divisor_mask_inv;\n        end\n\n        shifted_dividend = shifted_dividend << 1;\n        shifted_divisor = shifted_divisor >> 1;\n        shifted_divisor_mask = shifted_divisor_mask >> 1;\n        shifted_divisor_mask_inv = shifted_divisor_mask_inv >> 1;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    assign clk_average[0] = counter_out[0];\n    assign clk_average[1] = counter_out[1];\n    assign clk_average[2] = counter_out[2];\n    assign clk_average[3] = counter_out[3];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = ~counter_out[0];\n    assign clk_adjusted[1] = ~counter_out[1];\n    assign clk_adjusted[2] = ~counter_out[2];\n    assign clk_adjusted[3] = ~counter_out[3];\n\n    // Logical OR to generate final frequency divided clock\n    assign clk_div = clk_average | clk_adjusted;\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  count_out\n);\n    parameter MAX_COUNT = 4;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input [3:0] clk_in,\n    output [3:0] clk_out\n);\n    assign clk_out[0] = clk_in[0];\n    assign clk_out[1] = clk_in[1];\n    assign clk_out[2] = clk_in[2];\n    assign clk_out[3] = clk_in[3];\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk_in,\n    output [3:0] clk_out\n);\n    assign clk_out[0] = ~clk_in[0];\n    assign clk_out[1] = ~clk_in[1];\n    assign clk_out[2] = ~clk_in[2];\n    assign clk_out[3] = ~clk_in[3];\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the 4-bit adder for the first bit of Y\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the 4-bit adder for the second bit of Y\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n\n    // Instantiate the 4-bit adder for the third bit of Y\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Instantiate the 4-bit adder for the fourth bit of Y\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the outputs of each adder\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the 2-bit adder for the first 2 bits of X\n    adder_2bit adder_0(.x(x[1:0]), .y(y), .p(p0));\n\n    // Instantiate the 2-bit adder for the second 2 bits of X\n    adder_2bit adder_1(.x(x[3:2]), .y(y), .p(p1));\n\n    // Combine the outputs of each adder\n    assign p = p0 + (p1 << 2);\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [1:0] x;      // 2-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [3:0] p;     // 4-bit output representing the product\n\n    wire [3:0] p0, p1;\n\n    // Instantiate the 1-bit adder for the first bit of X\n    adder_1bit adder_0(.x(x[0]), .y(y), .p(p0));\n\n    // Instantiate the 1-bit adder for the second bit of X\n    adder_1bit adder_1(.x(x[1]), .y(y), .p(p1));\n\n    // Combine the outputs of each adder\n    assign p = p0 + (p1 << 1);\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input x;            // 1-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output p;           // 1-bit output representing the product\n\n    assign p = x + y;\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiate the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .result(temp_quotient),\n    .odd(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] result,  // 16-bit quotient\n    output reg [15:0] odd      // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [15:0] quotient;\nreg [15:0] remainder;\n\n// Initialize variables\ninitial begin\n    dividend = A;\n    divisor = B;\n    quotient = 0;\n    remainder = 0;\nend\n\n// Perform division algorithm\nalways @(*) begin\n    if (dividend >= divisor) begin\n        quotient = dividend / divisor;\n        remainder = dividend % divisor;\n    end else begin\n        quotient = 0;\n        remainder = dividend;\n    end\nend\n\n// Assign results\nalways @(*) begin\n    result = quotient;\n    odd = remainder;\nend\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "`timescale 1ns / 1ps\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] add_result;\n    wire add_carry;\n\n    wire [31:0] sub_result;\n    wire sub_borrow;\n\n    wire [31:0] and_result;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(add_result),\n        .carry(add_carry)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .op(op),\n        .result(sub_result),\n        .borrow(sub_borrow)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    // Multiplexer to select the result based on the operation\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    and_result;\n\n    // Multiplexer to select the carry/borrow output based on the operation\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_borrow :\n                       1'b0;\n\nendmodule\n\n// Adder module\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry\n);\n\n    assign {carry, result} = A + B;\n\nendmodule\n\n// Subtractor module\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output borrow\n);\n\n    assign {borrow, result} = A - B;\n\nendmodule\n\n// AND module\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n\n    assign result = A & B;\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selection logic\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'b00000000;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    wire clk_4, clk_3;\n    reg [3:0] counter;\n\n    // Counter module\n    counter #(4) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_limit(7),\n        .count_out(counter)\n    );\n\n    // Clock average generator module\n    clk_average #(4, 3) u_clk_average (\n        .clk(clk),\n        .counter(counter),\n        .clk_out(clk_4)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(3) u_clk_adjustment (\n        .clk(clk),\n        .clk_in(clk_4),\n        .clk_out(clk_3)\n    );\n\n    // Logical OR for final clock output\n    assign clk_div = clk_4 | clk_3;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    input [3:0] count_limit,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == count_limit) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input [3:0] counter,\n    output reg clk_out\n);\n    reg [3:0] counter_reg;\n    reg [3:0] counter_next;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_reg <= 0;\n            clk_out <= 0;\n        end else begin\n            counter_reg <= counter_next;\n            clk_out <= counter_reg[0];\n        end\n    end\n\n    always @* begin\n        counter_next = counter_reg;\n        if (counter_reg[0] == 1) begin\n            counter_next[0] = 0;\n            counter_next[1] = 1;\n        end else begin\n            counter_next[0] = 0;\n            counter_next[1] = 0;\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_in,\n    output reg clk_out\n);\n    reg [3:0] counter;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_out <= 0;\n        end else if (counter == 3) begin\n            counter <= 0;\n            clk_out <= ~clk_in;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiating the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [15:0] shifted_dividend;\nreg [7:0] shifted_divisor;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\nreg [15:0] temp_remainder_shifted;\n\ninteger i;\n\nalways @(*) begin\n    dividend = A;\n    divisor = B;\n    shifted_dividend = {16{1'b0}};\n    shifted_divisor = {8{1'b0}};\n    temp_quotient = {16{1'b0}};\n    temp_remainder = {16{1'b0}};\n    temp_remainder_shifted = {16{1'b0}};\n\n    // Shift dividend and divisor\n    for (i = 0; i < 16; i = i + 1) begin\n        shifted_dividend[i] = dividend[15 - i];\n        shifted_divisor[i] = divisor[7 - i];\n    end\n\n    // Perform division algorithm\n    for (i = 0; i < 16; i = i + 1) begin\n        if (shifted_dividend >= shifted_divisor) begin\n            temp_quotient[i] = 1'b1;\n            temp_remainder_shifted = shifted_dividend - shifted_divisor;\n        end else begin\n            temp_quotient[i] = 1'b0;\n            temp_remainder_shifted = shifted_dividend;\n        end\n\n        shifted_dividend = temp_remainder_shifted;\n    end\n\n    // Assign results\n    quotient = temp_quotient;\n    remainder = temp_remainder_shifted;\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the adder modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Shift and add the results\n    assign P = p0 << 0 | p1 << 1 | p2 << 2 | p3 << 3;\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [3:0] p;     // 4-bit output representing the sum of x and y\n\n    wire [3:0] sum;\n\n    // Instantiate the 4-bit full adder\n    full_adder fa(.a(x[0]), .b(y), .c_in(0), .sum(sum[0]), .c_out(p[0]));\n    full_adder fa1(.a(x[1]), .b(y), .c_in(sum[0]), .sum(sum[1]), .c_out(p[1]));\n    full_adder fa2(.a(x[2]), .b(y), .c_in(sum[1]), .sum(sum[2]), .c_out(p[2]));\n    full_adder fa3(.a(x[3]), .b(y), .c_in(sum[2]), .sum(sum[3]), .c_out(p[3]));\n\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;  // Inputs\n    output sum, c_out; // Outputs\n\n    wire c1, c2;        // Carry outputs\n\n    // Instantiate the half adder\n    half_adder ha(.a(a), .b(b), .sum(sum), .c_out(c1));\n\n    // Instantiate the carry-in adder\n    carry_in_adder ci_adder(.a(sum), .b(c_in), .c_in(c1), .sum(sum), .c_out(c2));\n\n    assign c_out = c2;\n\nendmodule\n\nmodule carry_in_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;  // Inputs\n    input c_in;        // Carry-in\n    output sum, c_out; // Outputs\n\n    wire c1, c2;       // Carry outputs\n\n    // Instantiate the half adder\n    half_adder ha(.a(a), .b(b), .sum(sum), .c_out(c1));\n\n    // Instantiate the carry-in adder\n    carry_in_adder ci_adder(.a(sum), .b(c_in), .c_in(c1), .sum(sum), .c_out(c2));\n\n    assign c_out = c2;\n\nendmodule\n\nmodule half_adder(a, b, sum, c_out);\n    input a, b;        // Inputs\n    output sum, c_out; // Outputs\n\n    assign sum = a ^ b;\n    assign c_out = a & b;\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate the first adder\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the second adder\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n\n    // Instantiate the third adder\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Combine the results\n    assign P = p0 << 3 | p1 << 2 | p2 << 1;\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;\n    input y;\n    output [3:0] p;\n\n    assign p = x + y;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator\n    assign clk_average[0] = counter_out[0];\n    assign clk_average[1] = counter_out[1];\n    assign clk_average[2] = counter_out[2];\n    assign clk_average[3] = counter_out[3];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = counter_out[0];\n    assign clk_adjusted[1] = counter_out[1];\n    assign clk_adjusted[2] = counter_out[2];\n    assign clk_adjusted[3] = counter_out[3];\n\n    // Output clock signal\n    assign clk_div = clk_average[0] | clk_adjusted[0];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  count_out\n);\n    parameter MAX_COUNT = 4;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input [3:0] clk_in,\n    output [3:0] clk_out\n);\n    assign clk_out[0] = clk_in[0];\n    assign clk_out[1] = clk_in[1];\n    assign clk_out[2] = clk_in[2];\n    assign clk_out[3] = clk_in[3];\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] clk_in,\n    output [3:0] clk_out\n);\n    assign clk_out[0] = clk_in[0];\n    assign clk_out[1] = clk_in[1];\n    assign clk_out[2] = clk_in[2];\n    assign clk_out[3] = clk_in[3];\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;       // 4-bit input multiplicand\n    input [3:0] Y;       // 4-bit input multiplier\n    output [7:0] P;      // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2;\n\n    // Instantiate 4 adder_4bit modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Combine the outputs\n    assign P = p0 + (p1 << 1) + (p2 << 2);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;       // 4-bit input multiplicand\n    input y;             // 1-bit input multiplier\n    output [7:0] p;      // 8-bit output representing the product of X and Y\n\n    assign p = x + (y << 4);\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    // Instantiate the three data input multiplexers\n    mux_path0 mux0 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d1),\n        .d1(d2),\n        .data_out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d2),\n        .d1(d0),\n        .data_out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for the first data path\nmodule mux_path0 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 3'b000) begin\n            data_out <= d0;\n        end else begin\n            data_out <= d1;\n        end\n    end\n\nendmodule\n\n// Submodule for the second data path\nmodule mux_path1 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 3'b001) begin\n            data_out <= d0;\n        end else begin\n            data_out <= d1;\n        end\n    end\n\nendmodule\n\n// Submodule for the third data path\nmodule mux_path2 (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 3'b010) begin\n            data_out <= d0;\n        end else begin\n            data_out <= d1;\n        end\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiating the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\nreg [15:0] dividend;\nreg [7:0] divisor;\nreg [15:0] shifted_dividend;\nreg [7:0] shifted_divisor;\nreg [15:0] temp_quotient;\nreg [15:0] temp_remainder;\nreg [15:0] temp_remainder_shifted;\nreg [15:0] temp_quotient_shifted;\nreg [15:0] temp_quotient_shifted_remainder;\nreg [15:0] temp_remainder_shifted_divisor;\nreg [15:0] temp_quotient_shifted_divisor;\nreg [15:0] temp_quotient_shifted_remainder_shifted_divisor;\n\ninitial begin\n    dividend = A;\n    divisor = B;\n    shifted_dividend = {1'b0, dividend[15:0]};\n    shifted_divisor = {divisor[7:0], 8'b0};\n    temp_quotient = 16'b0;\n    temp_remainder = 16'b0;\n    temp_remainder_shifted = 16'b0;\n    temp_quotient_shifted = 16'b0;\n    temp_quotient_shifted_remainder = 16'b0;\n    temp_remainder_shifted_divisor = 16'b0;\n    temp_quotient_shifted_divisor = 16'b0;\n    temp_quotient_shifted_remainder_shifted_divisor = 16'b0;\nend\n\nalways @(*) begin\n    temp_remainder_shifted = shifted_dividend - shifted_divisor;\n    temp_quotient_shifted = dividend - shifted_divisor;\n    temp_quotient_shifted_remainder = temp_quotient_shifted - temp_remainder_shifted;\n    temp_remainder_shifted_divisor = shifted_divisor - temp_remainder_shifted;\n    temp_quotient_shifted_divisor = temp_quotient_shifted - temp_remainder_shifted_divisor;\n    temp_quotient_shifted_remainder_shifted_divisor = temp_quotient_shifted_remainder - temp_remainder_shifted_divisor;\n    quotient = temp_quotient_shifted_remainder_shifted_divisor;\n    remainder = temp_remainder_shifted;\nend\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the 4-bit adder for the first bit\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n\n    // Instantiate the 4-bit adder for the second bit\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n\n    // Instantiate the 4-bit adder for the third bit\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n\n    // Instantiate the 4-bit adder for the fourth bit\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Combine the partial products\n    assign P = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;           // 1-bit input multiplier\n    output [3:0] p;    // 4-bit output representing the sum\n\n    assign p = x + y;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average_out;\n    wire [3:0] clk_adjusted_out;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    clk_average #(.DIV_FACTOR(MUL2_DIV_CLK)) u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_average_out(clk_average_out)\n    );\n\n    // Clock adjustment module\n    clk_adjustment #(.DIV_FACTOR(MUL2_DIV_CLK)) u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out),\n        .clk_adjusted_out(clk_adjusted_out)\n    );\n\n    // Logical OR of the two intermediate clock signals\n    assign clk_div = clk_average_out[3] | clk_adjusted_out[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg [3:0]    count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input               clk,\n    input               rst_n,\n    input [3:0]         count_out,\n    output reg [3:0]    clk_average_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_average_out <= 0;\n        end else begin\n            clk_average_out <= {count_out[2:0], 1'b0};\n        end\n    end\nendmodule\n\nmodule clk_adjustment(\n    input               clk,\n    input               rst_n,\n    input [3:0]         count_out,\n    output reg [3:0]    clk_adjusted_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjusted_out <= 0;\n        end else begin\n            clk_adjusted_out <= {count_out[2:0], 1'b0};\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    // Instantiate the submodules\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux0_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d1),\n        .d1(d2),\n        .data_out(mux1_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel),\n        .d0(d2),\n        .d1(d0),\n        .data_out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'b00000000;\n\nendmodule\n\n// Submodule for a single data path\nmodule mux_path (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            3'b000: data_out <= d0;\n            3'b001: data_out <= d1;\n            default: data_out <= 8'b00000000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] shifted_dividend;\n    reg [7:0] shifted_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        dividend = A;\n        divisor = B;\n        shifted_dividend = {16{1'b0}};\n        shifted_divisor = {8{1'b0}};\n        temp_quotient = {16{1'b0}};\n        temp_remainder = {16{1'b0}};\n    end\n\n    // Divide algorithm\n    always @(*) begin\n        shifted_dividend = dividend;\n        shifted_divisor = divisor;\n        temp_quotient = {16{1'b0}};\n        temp_remainder = {16{1'b0}};\n\n        for (int i = 0; i < 16; i = i + 1) begin\n            if (shifted_dividend[15:8] >= shifted_divisor) begin\n                temp_quotient[i] = 1'b1;\n                shifted_dividend = shifted_dividend - shifted_divisor;\n            end\n            shifted_divisor = {shifted_divisor[6:0], shifted_divisor[7]};\n            shifted_dividend = {shifted_dividend[14:0], shifted_dividend[15]};\n        end\n\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4;\n    wire clk_3;\n    wire clk_avg;\n    wire clk_adj_neg;\n    wire clk_adj_pos;\n\n    // Counter module\n    reg [3:0] counter;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n        end else if (counter == MUL2_DIV_CLK - 1) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    // Clock average generator module\n    assign clk_avg = (counter == 0) || (counter == 4);\n\n    // Clock adjustment module\n    assign clk_adj_neg = clk_avg && (counter == 3);\n    assign clk_adj_pos = clk_avg && (counter == 2);\n\n    // Intermediate clock signals\n    assign clk_4 = counter == 4;\n    assign clk_3 = counter == 3;\n\n    // Final clock signal\n    assign clk_div = clk_4 | clk_3;\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selection logic\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'h00;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "sub_8bit_v_17", "response": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand\n    input [3:0] Y;      // 4-bit input multiplier\n    output [7:0] P;     // 8-bit output representing the product of X and Y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the adder_4bit modules\n    adder_4bit adder_0(.x(X), .y(Y[0]), .p(p0));\n    adder_4bit adder_1(.x(X), .y(Y[1]), .p(p1));\n    adder_4bit adder_2(.x(X), .y(Y[2]), .p(p2));\n    adder_4bit adder_3(.x(X), .y(Y[3]), .p(p3));\n\n    // Shift and add the products\n    assign P[0] = p0;\n    assign P[1] = p0 + p1;\n    assign P[2] = p0 + p1 + p2;\n    assign P[3] = p0 + p1 + p2 + p3;\n    assign P[4] = p1 + p2 + p3;\n    assign P[5] = p2 + p3;\n    assign P[6] = p3;\n    assign P[7] = p0 + p1 + p2 + p3 + p4 + p5 + p6;\n\nendmodule\n\nmodule adder_4bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1, p2, p3;\n\n    // Instantiate the adder_2bit modules\n    adder_2bit adder_0(.x(x), .y(y), .p(p0));\n    adder_2bit adder_1(.x(x), .y(y), .p(p1));\n    adder_2bit adder_2(.x(x), .y(y), .p(p2));\n    adder_2bit adder_3(.x(x), .y(y), .p(p3));\n\n    // Shift and add the products\n    assign p = p0 + p1 + p2 + p3;\n\nendmodule\n\nmodule adder_2bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    wire [7:0] p0, p1;\n\n    // Instantiate the adder_1bit module\n    adder_1bit adder_0(.x(x), .y(y), .p(p0));\n    adder_1bit adder_1(.x(x), .y(y), .p(p1));\n\n    // Shift and add the products\n    assign p = p0 + p1;\n\nendmodule\n\nmodule adder_1bit(x, y, p);\n    input [3:0] x;      // 4-bit input multiplicand\n    input y;            // 1-bit input multiplier\n    output [7:0] p;     // 8-bit output representing the product of x and y\n\n    assign p = x + y;   // Simple addition\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\nwire [15:0] temp_quotient;\nwire [15:0] temp_remainder;\n\n// Instantiating the control unit\ncontrol_unit ctrl (\n    .A(A),\n    .B(B),\n    .quotient(temp_quotient),\n    .remainder(temp_remainder)\n);\n\nassign result = temp_quotient;\nassign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\nreg [15:0] shifted_dividend;\nreg [7:0] shifted_divisor;\n\n// Initialization\ninitial begin\n    shifted_dividend = A;\n    shifted_divisor = B;\n    quotient = 0;\n    remainder = 0;\nend\n\n// Division algorithm\nalways @(*) begin\n    if (shifted_dividend >= shifted_divisor) begin\n        quotient = quotient + 1;\n        shifted_dividend = shifted_dividend - shifted_divisor;\n    end\nend\n\n// Remainder calculation\nalways @(*) begin\n    remainder = shifted_dividend;\nend\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for data path multiplexing\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum;\nwire [3:0] diff;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder adder(\"A\", operand_a, operand_b, sum);\nsubtractor subtractor(\"A\", operand_a, operand_b, diff);\nand_logical and_logical(\"A\", operand_a, operand_b, and_result);\nor_logical or_logical(\"A\", operand_a, operand_b, or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire [3:0] counter_out;\n    wire [3:0] clk_average;\n    wire [3:0] clk_adjusted;\n\n    // Counter module\n    counter #(.MAX_COUNT(MUL2_DIV_CLK)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count_out(counter_out)\n    );\n\n    // Clock average generator module\n    assign clk_average[0] = counter_out[3];\n    assign clk_average[1] = counter_out[2];\n    assign clk_average[2] = counter_out[1];\n    assign clk_average[3] = counter_out[0];\n\n    // Clock adjustment module\n    assign clk_adjusted[0] = counter_out[3] ? ~counter_out[2] : counter_out[2];\n    assign clk_adjusted[1] = counter_out[3] ? ~counter_out[1] : counter_out[1];\n    assign clk_adjusted[2] = counter_out[3] ? ~counter_out[0] : counter_out[0];\n    assign clk_adjusted[3] = counter_out[3];\n\n    // Logical OR to generate final clock signal\n    assign clk_div = clk_average[3] | clk_adjusted[3];\n\nendmodule\n\nmodule counter(\n    input               clk,\n    input               rst_n,\n    output reg  [3:0]  count_out\n);\n    parameter MAX_COUNT = 4;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == MAX_COUNT) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_average_generator(\n    input [3:0] count_out,\n    output [3:0] clk_average\n);\n    assign clk_average[0] = count_out[3];\n    assign clk_average[1] = count_out[2];\n    assign clk_average[2] = count_out[1];\n    assign clk_average[3] = count_out[0];\nendmodule\n\nmodule clk_adjustment(\n    input [3:0] count_out,\n    output [3:0] clk_adjusted\n);\n    assign clk_adjusted[0] = count_out[3] ? ~count_out[2] : count_out[2];\n    assign clk_adjusted[1] = count_out[3] ? ~count_out[1] : count_out[1];\n    assign clk_adjusted[2] = count_out[3] ? ~count_out[0] : count_out[0];\n    assign clk_adjusted[3] = count_out[3];\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        quotient = 0;\n        remainder = 0;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        // Shift dividend\n        temp_quotient = A;\n        temp_remainder = 0;\n\n        // Compare with divisor\n        while (temp_quotient >= B) begin\n            temp_quotient = temp_quotient - B;\n            temp_remainder = temp_remainder + 1;\n        end\n\n        // Update quotient and remainder\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selection logic\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'h00;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical module\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical module\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder  // 16-bit remainder\n);\n\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [4:0] i;\n\n    // Initialize variables\n    initial begin\n        temp_quotient = 0;\n        temp_remainder = 0;\n        temp_dividend = A;\n        temp_divisor = B;\n        i = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient[i] = 1;\n            temp_remainder = temp_dividend - temp_divisor;\n            temp_dividend = temp_remainder;\n        end else begin\n            temp_quotient[i] = 0;\n            temp_remainder = temp_dividend;\n        end\n\n        i = i + 1;\n    end\n\n    // Update quotient and remainder\n    always @(temp_quotient or temp_remainder) begin\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(mux2_out)\n    );\n\n    // Output selection\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'b00000000;\n\nendmodule\n\n// Submodule for first data path\nmodule mux_path0 (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule\n\n// Submodule for second data path\nmodule mux_path1 (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule\n\n// Submodule for third data path\nmodule mux_path2 (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n    wire clk_4, clk_3;\n    reg [2:0] counter;\n\n    // Counter module\n    counter #(MUL2_DIV_CLK) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(counter)\n    );\n\n    // Clock average generator module\n    clk_average u_clk_average (\n        .clk(clk),\n        .counter(counter),\n        .clk_4(clk_4),\n        .clk_3(clk_3)\n    );\n\n    // Clock adjustment module\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .clk_4(clk_4),\n        .clk_3(clk_3),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] count,\n    input limit\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else if (count == limit) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_average(\n    input clk,\n    input [2:0] counter,\n    output reg clk_4,\n    output reg clk_3\n);\n    always @(posedge clk) begin\n        case (counter)\n            3'b000: begin\n                clk_4 <= 1'b0;\n                clk_3 <= 1'b0;\n            end\n            3'b001: begin\n                clk_4 <= 1'b1;\n                clk_3 <= 1'b0;\n            end\n            3'b010: begin\n                clk_4 <= 1'b0;\n                clk_3 <= 1'b1;\n            end\n            3'b011: begin\n                clk_4 <= 1'b1;\n                clk_3 <= 1'b1;\n            end\n            3'b100: begin\n                clk_4 <= 1'b0;\n                clk_3 <= 1'b0;\n            end\n            3'b101: begin\n                clk_4 <= 1'b1;\n                clk_3 <= 1'b0;\n            end\n            3'b110: begin\n                clk_4 <= 1'b0;\n                clk_3 <= 1'b1;\n            end\n            3'b111: begin\n                clk_4 <= 1'b1;\n                clk_3 <= 1'b1;\n            end\n        endcase\n    end\nendmodule\n\nmodule clk_adjustment(\n    input clk,\n    input clk_4,\n    input clk_3,\n    output reg clk_div\n);\n    reg clk_4_neg, clk_3_neg;\n\n    always @(negedge clk) begin\n        clk_4_neg <= clk_4;\n        clk_3_neg <= clk_3;\n    end\n\n    always @(posedge clk) begin\n        clk_div <= clk_4_neg | clk_3_neg;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] temp_quotient;\n    wire [15:0] temp_remainder;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(temp_quotient),\n        .remainder(temp_remainder)\n    );\n\n    // Assign the results to the output ports\n    assign result = temp_quotient;\n    assign odd = temp_remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output reg [15:0] quotient, // 16-bit quotient\n    output reg [15:0] remainder // 16-bit remainder\n);\n\n    reg [15:0] temp_dividend;\n    reg [7:0] temp_divisor;\n    reg [15:0] temp_quotient;\n    reg [15:0] temp_remainder;\n\n    // Initialize variables\n    initial begin\n        temp_dividend = A;\n        temp_divisor = B;\n        temp_quotient = 0;\n        temp_remainder = 0;\n    end\n\n    // Perform division algorithm\n    always @(*) begin\n        if (temp_dividend >= temp_divisor) begin\n            temp_quotient = temp_dividend / temp_divisor;\n            temp_remainder = temp_dividend % temp_divisor;\n        end else begin\n            temp_quotient = 0;\n            temp_remainder = temp_dividend;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiating the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiating the AND logical operation submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiating the OR logical operation submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Selecting the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical operation submodule\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical operation submodule\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for data path multiplexing\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            1'b0: data_out <= d0;\n            1'b1: data_out <= d1;\n            default: data_out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;    // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    full_adder adder_inst[7:0];\n    assign sum = {1'b0, adder_inst[7].sum};\n    assign carry = {1'b0, adder_inst[7].carry};\n\n    // Generate the final difference and borrow\n    assign D = sum ^ B_comp;\n    assign B_out = carry[7];\n\nendmodule\n\nmodule full_adder(a, b, c_in, sum, carry);\n    input a, b, c_in;\n    output sum, carry;\n\n    assign {carry, sum} = a + b + c_in;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Generate the divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for path 0\nmodule mux_path0 (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule\n\n// Submodule for path 1\nmodule mux_path1 (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule\n\n// Submodule for path 2\nmodule mux_path2 (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate adder and subtractor\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate and_logical and or_logical\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select result based on op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule instances\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Generate the divided clock signal\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selection logic\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'b00000000;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // 9-bit sum\n    wire carry_out;      // Carry out indicating if a carry was generated\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder module instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry_out(carry_out)\n    );\n\n    // Output assignment\n    assign D = sum[7:0];\n    assign B_out = carry_out;\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 9-bit sum\n    output carry_out;    // Carry out indicating if a carry was generated\n\n    wire [8:0] temp_sum; // Temporary sum for carry propagation\n\n    // Full adder instantiation for each bit\n    full_adder fa0 (.A(A[0]), .B(B[0]), .Cin(0), .Sum(temp_sum[0]), .Cout(temp_sum[1]));\n    full_adder fa1 (.A(A[1]), .B(B[1]), .Cin(temp_sum[0]), .Sum(temp_sum[2]), .Cout(temp_sum[3]));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .Cin(temp_sum[2]), .Sum(temp_sum[4]), .Cout(temp_sum[5]));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .Cin(temp_sum[4]), .Sum(temp_sum[6]), .Cout(temp_sum[7]));\n    full_adder fa4 (.A(A[4]), .B(B[4]), .Cin(temp_sum[6]), .Sum(temp_sum[8]), .Cout(temp_sum[9]));\n    full_adder fa5 (.A(A[5]), .B(B[5]), .Cin(temp_sum[8]), .Sum(temp_sum[10]), .Cout(temp_sum[11]));\n    full_adder fa6 (.A(A[6]), .B(B[6]), .Cin(temp_sum[10]), .Sum(temp_sum[12]), .Cout(temp_sum[13]));\n    full_adder fa7 (.A(A[7]), .B(B[7]), .Cin(temp_sum[12]), .Sum(temp_sum[14]), .Cout(temp_sum[15]));\n\n    // Carry out assignment\n    assign carry_out = temp_sum[8];\n\n    // Sum assignment\n    assign sum = temp_sum[7:0];\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;             // Input A\n    input B;             // Input B\n    input Cin;           // Carry in\n    output Sum;          // Sum output\n    output Cout;         // Carry out\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .data_in0(d0),\n        .data_in1(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .data_in0(d1),\n        .data_in1(d2),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .data_in0(d2),\n        .data_in1(d0),\n        .data_out(data_out)\n    );\n\nendmodule\n\n// Submodule for data path multiplexing\nmodule mux_path (\n    input clk,\n    input sel,\n    input [7:0] data_in0,\n    input [7:0] data_in1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            1'b0: data_out <= data_in0;\n            1'b1: data_out <= data_in1;\n            default: data_out <= 8'h00; // Default case\n        endcase\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\n// AND logical submodule\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\nassign and_result = a & b;\nendmodule\n\n// OR logical submodule\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\nassign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule for counting positive edges\n    wire clk_div1;\n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Submodule for counting negative edges\n    wire clk_div2;\n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR operation for divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    reg [NUM_DIV - 1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < NUM_DIV - 1) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the difference of A and B\n    output B_out;       // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [7:0] B_comp;  // 2's complement of B\n    wire [7:0] sum;     // Sum of A and B_comp\n    wire carry_out;     // Carry out from the full adder\n\n    // Generate 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Perform subtraction using full adder\n    full_adder adder_inst (.a(A), .b(B_comp), .cin(0), .sum(sum), .cout(carry_out));\n\n    // Assign outputs\n    assign D = sum;\n    assign B_out = carry_out;\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selecting the active data path based on the selection signal\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out : 8'h00;\n\nendmodule\n\n// Submodule for data path selection\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR to generate divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter for counting up to NUM_DIV - 1\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter for counting up to NUM_DIV - 1\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\n// Adder submodule\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor submodule\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical submodule\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical submodule\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;    // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output D and B_out\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\n// Full adder module\nmodule full_adder(A, B, C, sum, carry);\n    input A, B, C;       // Inputs\n    output sum, carry;   // Outputs\n\n    assign sum = A ^ B ^ C;\n    assign carry = (A & B) | (A & C) | (B & C);\nendmodule\n\n// 8-bit adder module\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // Input A\n    input [7:0] B;       // Input B\n    output [7:0] sum;   // Sum output\n    output carry;       // Carry output\n\n    wire [8:0] temp_sum; // Temporary sum\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .C(carry),\n        .sum(temp_sum[0]),\n        .carry(temp_sum[8])\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C(temp_sum[8]),\n        .sum(temp_sum[1]),\n        .carry(temp_sum[9])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C(temp_sum[9]),\n        .sum(temp_sum[2]),\n        .carry(temp_sum[10])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C(temp_sum[10]),\n        .sum(temp_sum[3]),\n        .carry(temp_sum[11])\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C(temp_sum[11]),\n        .sum(temp_sum[4]),\n        .carry(temp_sum[12])\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .C(temp_sum[12]),\n        .sum(temp_sum[5]),\n        .carry(temp_sum[13])\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .C(temp_sum[13]),\n        .sum(temp_sum[6]),\n        .carry(temp_sum[14])\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .C(temp_sum[14]),\n        .sum(temp_sum[7]),\n        .carry(temp_sum[15])\n    );\n\n    assign sum = temp_sum[7:0];\n    assign carry = temp_sum[8];\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 mux0 (\n        .clk(clk),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .sel(sel),\n        .out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .sel(sel),\n        .out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .sel(sel),\n        .out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for first data path\nmodule mux_path0 (\n    input clk,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [2:0] sel,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            3'b000: out <= d0;\n            3'b001: out <= d1;\n            3'b010: out <= d2;\n            default: out <= 8'h00;\n        endcase\n    end\n\nendmodule\n\n// Submodule for second data path\nmodule mux_path1 (\n    input clk,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [2:0] sel,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            3'b000: out <= d0;\n            3'b001: out <= d1;\n            3'b010: out <= d2;\n            default: out <= 8'h00;\n        endcase\n    end\n\nendmodule\n\n// Submodule for third data path\nmodule mux_path2 (\n    input clk,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [2:0] sel,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        case(sel)\n            3'b000: out <= d0;\n            3'b001: out <= d1;\n            3'b010: out <= d2;\n            default: out <= 8'h00;\n        endcase\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule interfaces\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Generate the divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Counter value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (clk_div == DIV_VALUE) begin\n                clk_div <= 0;\n            end else begin\n                clk_div <= clk_div + 1;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Counter value\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (clk_div == DIV_VALUE) begin\n                clk_div <= 0;\n            end else begin\n                clk_div <= clk_div + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"sum\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"diff\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", operand_b, \"and_result\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", operand_b, \"or_result\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Max count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Max count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    // Instantiate the data multiplexing submodules\n    mux_path0 mux0 (\n        .clk(clk),\n        .sel(sel[0]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux0_out)\n    );\n\n    mux_path1 mux1 (\n        .clk(clk),\n        .sel(sel[1]),\n        .d0(d0),\n        .d1(d1),\n        .data_out(mux1_out)\n    );\n\n    mux_path2 mux2 (\n        .clk(clk),\n        .sel(sel[2]),\n        .d0(d2),\n        .d1(d1),\n        .data_out(mux2_out)\n    );\n\n    // Output assignment\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'h00;\n\nendmodule\n\n// Submodule for data path 0\nmodule mux_path0 (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel)\n            data_out <= d1;\n        else\n            data_out <= d0;\n    end\n\nendmodule\n\n// Submodule for data path 1\nmodule mux_path1 (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel)\n            data_out <= d0;\n        else\n            data_out <= d1;\n    end\n\nendmodule\n\n// Submodule for data path 2\nmodule mux_path2 (\n    input clk,\n    input sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel)\n            data_out <= d1;\n        else\n            data_out <= d0;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder module\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor module\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical module\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical module\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical module\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical module\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;   // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .C_in(0),\n        .sum(sum),\n        .C_out(carry)\n    );\n\n    // Output\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\nmodule adder_8bit(A, B, C_in, sum, C_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input C_in;           // Carry input\n    output [8:0] sum;    // 9-bit sum\n    output C_out;        // Carry output\n\n    wire [8:0] carry;    // Intermediate carry\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .C_in(C_in),\n        .sum(sum[0]),\n        .C_out(carry[0])\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(carry[0]),\n        .sum(sum[1]),\n        .C_out(carry[1])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(carry[1]),\n        .sum(sum[2]),\n        .C_out(carry[2])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(carry[2]),\n        .sum(sum[3]),\n        .C_out(carry[3])\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(carry[3]),\n        .sum(sum[4]),\n        .C_out(carry[4])\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .C_in(carry[4]),\n        .sum(sum[5]),\n        .C_out(carry[5])\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .C_in(carry[5]),\n        .sum(sum[6]),\n        .C_out(carry[6])\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .C_in(carry[6]),\n        .sum(sum[7]),\n        .C_out(carry[7])\n    );\n\n    // Output carry\n    assign C_out = carry[7];\n\nendmodule\n\nmodule full_adder(A, B, C_in, sum, C_out);\n    input A;             // Input A\n    input B;             // Input B\n    input C_in;          // Carry input\n    output sum;          // Sum output\n    output C_out;        // Carry output\n\n    assign sum = A ^ B ^ C_in;\n    assign C_out = (A & B) | (C_in & (A ^ B));\n\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule instances\n    mux_path mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(data_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(data_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(data_out)\n    );\n\n    // Selecting the data path based on the selection signal\n    assign data_out = (sel == 3'b000) ? mux0.data_out :\n                      (sel == 3'b001) ? mux1.data_out :\n                      (sel == 3'b010) ? mux2.data_out :\n                      8'h00; // Default to 0 if invalid selection\n\nendmodule\n\n// Submodule for data path multiplexing\nmodule mux_path (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule interfaces\n    wire clk_div1, clk_div2;\n\n    // Submodules\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count < COUNT_MAX) begin\n                count <= count + 1;\n                clk_div <= 0;\n            end else begin\n                count <= 0;\n                clk_div <= 1;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count < COUNT_MAX) begin\n                count <= count + 1;\n                clk_div <= 0;\n            end else begin\n                count <= 0;\n                clk_div <= 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_data;\n    wire [7:0] hold1_data;\n    wire [7:0] hold2_data;\n    wire [7:0] hold3_data;\n\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0_data)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1_data)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2_data)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3_data)\n    );\n\n    // Output selection logic\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                  hold3_data;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", operand_a, operand_b, sum);\nsubtractor subtractor (\"-\", operand_a, operand_b, diff);\nand_logical and_logical (\"&\", operand_a, operand_b, and_result);\nor_logical or_logical (\"|\", operand_a, operand_b, or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule and_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule or_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Divisor value\n\n    // Submodule instances\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Generate the divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3_out)\n    );\n\n    // Output selection\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                  hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;   // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output D and B_out\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\n// Submodule for 8-bit full adder\nmodule full_adder(A, B, C, sum, carry);\n    input A;\n    input B;\n    input C;\n    output sum;\n    output carry;\n\n    assign sum = A ^ B ^ C;\n    assign carry = (A & B) | (A & C) | (B & C);\nendmodule\n\n// Submodule for 8-bit adder\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] sum;    // 8-bit output representing the sum of A and B\n    output carry;        // Carry output indicating if a carry was generated during the addition\n\n    wire [8:0] temp_sum; // Intermediate sum\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .C(carry),\n        .sum(temp_sum[0]),\n        .carry(temp_sum[1])\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C(temp_sum[0]),\n        .sum(temp_sum[2]),\n        .carry(temp_sum[3])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C(temp_sum[2]),\n        .sum(temp_sum[4]),\n        .carry(temp_sum[5])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C(temp_sum[4]),\n        .sum(temp_sum[6]),\n        .carry(temp_sum[7])\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C(temp_sum[6]),\n        .sum(temp_sum[8]),\n        .carry(temp_sum[9])\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .C(temp_sum[8]),\n        .sum(temp_sum[10]),\n        .carry(temp_sum[11])\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .C(temp_sum[10]),\n        .sum(temp_sum[12]),\n        .carry(temp_sum[13])\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .C(temp_sum[12]),\n        .sum(temp_sum[14]),\n        .carry(temp_sum[15])\n    );\n\n    assign sum = temp_sum[7:0];\n    assign carry = temp_sum[8];\nendmodule\n\nmodule full_adder(A, B, C, sum, carry);\n    input A;\n    input B;\n    input C;\n    output sum;\n    output carry;\n\n    assign sum = A ^ B ^ C;\n    assign carry = (A & B) | (A & C) | (B & C);\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Output generation\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical operation\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical operation\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical operation module\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical operation module\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from source 0\n    wire [7:0] hold0_data;\n    wire hold0_valid;\n    data_hold hold0 (\n        .clk(clk),\n        .data(in0),\n        .valid(hold0_valid),\n        .out(hold0_data)\n    );\n\n    // Submodule for holding data from source 1\n    wire [7:0] hold1_data;\n    wire hold1_valid;\n    data_hold hold1 (\n        .clk(clk),\n        .data(in1),\n        .valid(hold1_valid),\n        .out(hold1_data)\n    );\n\n    // Submodule for holding data from source 2\n    wire [7:0] hold2_data;\n    wire hold2_valid;\n    data_hold hold2 (\n        .clk(clk),\n        .data(in2),\n        .valid(hold2_valid),\n        .out(hold2_data)\n    );\n\n    // Submodule for holding data from source 3\n    wire [7:0] hold3_data;\n    wire hold3_valid;\n    data_hold hold3 (\n        .clk(clk),\n        .data(in3),\n        .valid(hold3_valid),\n        .out(hold3_data)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                 hold3_data;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data,\n    output reg valid,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (valid) begin\n            out <= data;\n        end else begin\n            out <= 8'b0;\n        end\n        valid <= 1;\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd number to divide the clock frequency\n\n    wire clk_div1, clk_div2;\n\n    // Submodule for counting rising edges\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Submodule for counting falling edges\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR to generate divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1;\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1;\n\n    reg [3:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output selection logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                  hold3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [7:0] B_comp;   // 2's complement of B\n    wire [7:0] sum;      // Sum of A and B_comp\n    wire carry;          // Carry output from the full adder\n\n    // Calculate 2's complement of B\n    assign B_comp = ~B + 1;\n\n    // Calculate sum of A and B_comp\n    assign sum = A + B_comp;\n\n    // Calculate borrow output\n    assign B_out = carry;\n\n    // Calculate difference\n    assign D = sum;\n\nendmodule\n\nmodule adder_8bit(A, B, carry, sum);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input carry;         // Carry input from the previous adder\n    output [7:0] sum;    // 8-bit output representing the sum of A and B\n    output carry;        // Carry output indicating if a carry was generated during the addition\n\n    wire [7:0] sum_temp; // Temporary sum output\n    wire carry_temp;     // Temporary carry output\n\n    // Instantiate full adder for each bit\n    full_adder fa0(.A(A[0]), .B(B[0]), .Cin(carry), .Sum(sum_temp[0]), .Cout(carry_temp));\n    full_adder fa1(.A(A[1]), .B(B[1]), .Cin(carry_temp), .Sum(sum_temp[1]), .Cout(carry_temp));\n    full_adder fa2(.A(A[2]), .B(B[2]), .Cin(carry_temp), .Sum(sum_temp[2]), .Cout(carry_temp));\n    full_adder fa3(.A(A[3]), .B(B[3]), .Cin(carry_temp), .Sum(sum_temp[3]), .Cout(carry_temp));\n    full_adder fa4(.A(A[4]), .B(B[4]), .Cin(carry_temp), .Sum(sum_temp[4]), .Cout(carry_temp));\n    full_adder fa5(.A(A[5]), .B(B[5]), .Cin(carry_temp), .Sum(sum_temp[5]), .Cout(carry_temp));\n    full_adder fa6(.A(A[6]), .B(B[6]), .Cin(carry_temp), .Sum(sum_temp[6]), .Cout(carry_temp));\n    full_adder fa7(.A(A[7]), .B(B[7]), .Cin(carry_temp), .Sum(sum_temp[7]), .Cout(carry_temp));\n\n    assign sum = sum_temp;\n    assign carry = carry_temp;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;             // Input A\n    input B;             // Input B\n    input Cin;           // Carry input\n    output Sum;          // Sum output\n    output Cout;         // Carry output\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder(.a(operand_a), .b(operand_b), .sum(sum));\nsubtractor subtractor(.a(operand_a), .b(operand_b), .diff(diff));\nand_logical and_logical(.a(operand_a), .b(operand_b), .and_result(and_result));\nor_logical or_logical(.a(operand_a), .b(operand_b), .or_result(or_result));\n\nalways @(posedge clk) begin\n    case(op_code)\n        `ADD_OP: result <= sum;\n        `SUB_OP: result <= diff;\n        `AND_OP: result <= and_result;\n        `OR_OP: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR operation to generate the divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1;\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1;\n\n    reg [3:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from source 0\n    wire [7:0] hold0_data;\n    wire hold0_valid;\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .sel(sel),\n        .data_out(hold0_data),\n        .valid_out(hold0_valid)\n    );\n\n    // Submodule for holding data from source 1\n    wire [7:0] hold1_data;\n    wire hold1_valid;\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .sel(sel),\n        .data_out(hold1_data),\n        .valid_out(hold1_valid)\n    );\n\n    // Submodule for holding data from source 2\n    wire [7:0] hold2_data;\n    wire hold2_valid;\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .sel(sel),\n        .data_out(hold2_data),\n        .valid_out(hold2_valid)\n    );\n\n    // Submodule for holding data from source 3\n    wire [7:0] hold3_data;\n    wire hold3_valid;\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .sel(sel),\n        .data_out(hold3_data),\n        .valid_out(hold3_valid)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                  hold3_data;\n\nendmodule\n\n// Submodule for holding data from a source\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    input [1:0] sel,\n    output reg [7:0] data_out,\n    output reg valid_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            data_out <= data_in;\n            valid_out <= 1;\n        end else begin\n            valid_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder module\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor module\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical module\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical module\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\n// Select the result based on the op_code\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical module\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical module\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    // Submodule interfaces\n    wire clk_div1, clk_div2;\n\n    // Submodules\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Divisor value\n\n    reg [DIV_VALUE:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count == DIV_VALUE) begin\n            count <= 0;\n            clk_div <= 1;\n        end else begin\n            count <= count + 1;\n            clk_div <= 0;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;   // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .Cin(0),\n        .Sum(sum),\n        .Cout(carry)\n    );\n\n    // Output D and B_out\n    assign D = sum[7:0];\n    assign B_out = carry[8];\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input Cin;            // Carry-in\n    output [7:0] Sum;    // 8-bit output representing the sum of A and B\n    output Cout;          // Carry-out indicating if a carry was generated during the addition\n\n    wire [8:0] temp_sum; // Intermediate sum\n    wire temp_carry;     // Intermediate carry\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .Sum(temp_sum[0]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[1]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[2]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[3]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[4]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[5]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[6]),\n        .Cout(temp_carry)\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(temp_carry),\n        .Sum(temp_sum[7]),\n        .Cout(temp_carry)\n    );\n\n    assign Sum = temp_sum[7:0];\n    assign Cout = temp_carry;\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;             // Input A\n    input B;             // Input B\n    input Cin;            // Carry-in\n    output Sum;          // Sum output\n    output Cout;         // Carry-out\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from source 0\n    wire [7:0] hold0_data;\n    wire [7:0] hold1_data;\n    wire [7:0] hold2_data;\n    wire [7:0] hold3_data;\n\n    // Instantiate the submodules\n    data_hold hold0 (\n        .clk(clk),\n        .data(in0),\n        .selected(sel[0]),\n        .out(hold0_data)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data(in1),\n        .selected(sel[1]),\n        .out(hold1_data)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data(in2),\n        .selected(sel[0]),\n        .out(hold2_data)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data(in3),\n        .selected(sel[1]),\n        .out(hold3_data)\n    );\n\n    // Output the selected data\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                  hold3_data;\n\nendmodule\n\n// Submodule for holding data from a specific source\nmodule data_hold (\n    input clk,\n    input [7:0] data,\n    input selected,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (selected) begin\n            out <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Instantiate the positive edge counter\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR the two clock outputs to generate the divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Adjusted to match the parameter in the original module\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter DIV_VALUE = NUM_DIV - 1; // Adjusted to match the parameter in the original module\n\n    reg [DIV_VALUE:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < DIV_VALUE) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", operand_a, operand_b, sum);\nsubtractor subtractor (\"-\", operand_a, operand_b, diff);\nand_logical and_logical (\"&\", operand_a, operand_b, and_result);\nor_logical or_logical (\"|\", operand_a, operand_b, or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] sum\n);\n    assign sum = operand_a + operand_b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] diff\n);\n    assign diff = operand_a - operand_b;\nendmodule\n\nmodule and_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] and_result\n);\n    assign and_result = operand_a & operand_b;\nendmodule\n\nmodule or_logical(\n    input [1:0] operation,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] or_result\n);\n    assign or_result = operand_a | operand_b;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Submodule for holding data from input 0\n    data_holder #(.HOLD_DATA(in0)) hold0 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    // Submodule for holding data from input 1\n    data_holder #(.HOLD_DATA(in1)) hold1 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    // Submodule for holding data from input 2\n    data_holder #(.HOLD_DATA(in2)) hold2 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    // Submodule for holding data from input 3\n    data_holder #(.HOLD_DATA(in3)) hold3 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output selection\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 : hold3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_holder (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Divided clock output\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Maximum count value\n\n    reg [3:0] count; // Counter register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;   // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .Cin(0),\n        .Sum(sum),\n        .Cout(carry)\n    );\n\n    // Assign output\n    assign D = sum[7:0];\n    assign B_out = carry[8];\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    input Cin;           // Carry-in for the first bit\n    output [7:0] Sum;    // 8-bit output representing the sum of A and B\n    output Cout;         // Carry-out for the last bit\n\n    wire [8:0] carry;    // Intermediate carry\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .Sum(Sum[0]),\n        .Cout(carry[0])\n    );\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry[0]),\n        .Sum(Sum[1]),\n        .Cout(carry[1])\n    );\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry[1]),\n        .Sum(Sum[2]),\n        .Cout(carry[2])\n    );\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry[2]),\n        .Sum(Sum[3]),\n        .Cout(carry[3])\n    );\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry[3]),\n        .Sum(Sum[4]),\n        .Cout(carry[4])\n    );\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry[4]),\n        .Sum(Sum[5]),\n        .Cout(carry[5])\n    );\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry[5]),\n        .Sum(Sum[6]),\n        .Cout(carry[6])\n    );\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry[6]),\n        .Sum(Sum[7]),\n        .Cout(carry[7])\n    );\n\n    // Assign carry-out\n    assign Cout = carry[7];\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;     // Inputs\n    output Sum, Cout;    // Outputs\n\n    wire C1, C2;          // Intermediate carry\n\n    xor xor0(A, B, Sum);\n    and and0(A, B, C1);\n    and and1(A, Cin, C2);\n    or or0(C1, C2, Cout);\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_out;\n    data_hold hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    // Submodule for holding data from input 1\n    wire [7:0] hold1_out;\n    data_hold hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    // Submodule for holding data from input 2\n    wire [7:0] hold2_out;\n    data_hold hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    // Submodule for holding data from input 3\n    wire [7:0] hold3_out;\n    data_hold hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    // Output assignment\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                 hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            out <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", operand_a, \"B\", operand_b, \"SUM\", sum);\nsubtractor subtractor (\"A\", operand_a, \"B\", operand_b, \"DIFF\", diff);\nand_logical and_logical (\"A\", operand_a, \"B\", and_result);\nor_logical or_logical (\"A\", operand_a, \"B\", or_result);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] SUM\n);\n    assign SUM = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] DIFF\n);\n    assign DIFF = A - B;\nendmodule\n\nmodule and_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] AND\n);\n    assign AND = A & B;\nendmodule\n\nmodule or_logical(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] OR\n);\n    assign OR = A | B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    data_hold hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    // Output assignment\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                  hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            out <= in;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5; // Odd divisor value\n\n    wire clk_div1, clk_div2;\n\n    // Submodule instances\n    pos_edge_counter u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    // Logical OR to generate the divided clock\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Max count value\n\n    reg [3:0] count; // Counter to count up to COUNT_MAX\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    parameter COUNT_MAX = NUM_DIV - 1; // Max count value\n\n    reg [3:0] count; // Counter to count up to COUNT_MAX\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            clk_div <= 0;\n        end else if (count < COUNT_MAX) begin\n            count <= count + 1;\n            clk_div <= 0;\n        end else begin\n            count <= 0;\n            clk_div <= 1;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder submodule\nadder adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor submodule\nsubtractor subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\n// Instantiate the AND logical operation submodule\nand_logical and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR logical operation submodule\nor_logical or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .or_result(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\nendmodule\n\n// Adder module\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// AND logical operation module\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\n// OR logical operation module\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;    // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 8-bit output representing the sum of A and B\n    output [8:0] carry; // 9-bit output representing the carry out\n\n    wire [8:0] carry_temp; // Temporary carry\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(carry[0]),\n        .Sum(sum[0]),\n        .Cout(carry_temp[0])\n    );\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry_temp[0]),\n        .Sum(sum[1]),\n        .Cout(carry_temp[1])\n    );\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry_temp[1]),\n        .Sum(sum[2]),\n        .Cout(carry_temp[2])\n    );\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry_temp[2]),\n        .Sum(sum[3]),\n        .Cout(carry_temp[3])\n    );\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry_temp[3]),\n        .Sum(sum[4]),\n        .Cout(carry_temp[4])\n    );\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry_temp[4]),\n        .Sum(sum[5]),\n        .Cout(carry_temp[5])\n    );\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry_temp[5]),\n        .Sum(sum[6]),\n        .Cout(carry_temp[6])\n    );\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry_temp[6]),\n        .Sum(sum[7]),\n        .Cout(carry[7])\n    );\n\n    // Carry out\n    assign carry = {carry_temp[7:0], carry_temp[8]};\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n    assign {Cout, Sum} = A + B + Cin;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter counter_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out),\n    .limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider clk_divider_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    parameter NUM_DIV = 8; // Even number used for division\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\n    assign limit = (count_out == NUM_DIV / 2 - 1);\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 0) begin\n                clk_div <= 1;\n            end else begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input source 0\n    wire [7:0] hold0_data;\n    wire [7:0] hold0_prev_data;\n    wire hold0_sel;\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .prev_data_in(hold0_prev_data),\n        .sel(sel[0]),\n        .data_out(hold0_data),\n        .prev_data_out(hold0_prev_data)\n    );\n\n    // Submodule for holding data from input source 1\n    wire [7:0] hold1_data;\n    wire [7:0] hold1_prev_data;\n    wire hold1_sel;\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .prev_data_in(hold1_prev_data),\n        .sel(sel[1]),\n        .data_out(hold1_data),\n        .prev_data_out(hold1_prev_data)\n    );\n\n    // Submodule for holding data from input source 2\n    wire [7:0] hold2_data;\n    wire [7:0] hold2_prev_data;\n    wire hold2_sel;\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .prev_data_in(hold2_prev_data),\n        .sel(sel[0]),\n        .data_out(hold2_data),\n        .prev_data_out(hold2_prev_data)\n    );\n\n    // Submodule for holding data from input source 3\n    wire [7:0] hold3_data;\n    wire [7:0] hold3_prev_data;\n    wire hold3_sel;\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .prev_data_in(hold3_prev_data),\n        .sel(sel[1]),\n        .data_out(hold3_data),\n        .prev_data_out(hold3_prev_data)\n    );\n\n    // Output data from the selected submodule\n    assign out = (sel[0]) ? hold0_data : ((sel[1]) ? hold1_data : ((sel[0]) ? hold2_data : hold3_data));\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    input [7:0] prev_data_in,\n    input sel,\n    output reg [7:0] data_out,\n    output reg [7:0] prev_data_out\n);\n\n    always @(posedge clk) begin\n        if (sel) begin\n            data_out <= data_in;\n            prev_data_out <= prev_data_in;\n        end else begin\n            data_out <= prev_data_out;\n            prev_data_out <= data_in;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during the subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;   // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    full_adder adder_inst[7:0];\n    assign {carry[7], sum[7]} = adder_inst[7].sum;\n    assign {carry[6], sum[6]} = adder_inst[6].sum;\n    assign {carry[5], sum[5]} = adder_inst[5].sum;\n    assign {carry[4], sum[4]} = adder_inst[4].sum;\n    assign {carry[3], sum[3]} = adder_inst[3].sum;\n    assign {carry[2], sum[2]} = adder_inst[2].sum;\n    assign {carry[1], sum[1]} = adder_inst[1].sum;\n    assign {carry[0], sum[0]} = adder_inst[0].sum;\n\n    // Outputs\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\nmodule full_adder(a, b, c_in, sum, c_out);\n    input a, b, c_in;\n    output sum, c_out;\n    assign {c_out, sum} = a + b + c_in;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"+\", a, b, sum);\n    subtractor subtractor (\"-\", a, b, diff);\n    and_module and_op (\"&\", a, b, and_result);\n    or_module or_op (\"|\", a, b, or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter_module u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_q(counter_q),\n    .counter_limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider_module u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_q(counter_q),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_q,\n    output counter_limit\n);\n    localparam NUM_DIV = 4; // Even number that divides the input clock frequency\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_q <= 0;\n        end else if (counter_limit) begin\n            counter_q <= 0;\n        end else begin\n            counter_q <= counter_q + 1;\n        end\n    end\n\n    assign counter_limit = (counter_q == (NUM_DIV / 2) - 1);\nendmodule\n\nmodule clk_divider_module(\n    input clk,\n    input rst_n,\n    input [3:0] counter_q,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (counter_q == 0) begin\n            clk_div <= 1;\n        end else begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input source 0\n    wire [7:0] hold0;\n    wire [7:0] hold1;\n    wire [7:0] hold2;\n    wire [7:0] hold3;\n\n    // Instantiate submodules\n    data_hold hold0_inst (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_hold hold1_inst (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_hold hold2_inst (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_hold hold3_inst (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                 hold3;\n\nendmodule\n\n// Submodule for holding data from input source\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out),\n    .limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider u_clk_divider (\n    .clk_in(clk),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    parameter NUM_DIV = 8; // Even number used for division\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\n    assign limit = (count_out == NUM_DIV / 2 - 1);\nendmodule\n\nmodule clk_divider(\n    input clk_in,\n    input counter_limit,\n    output reg clk_div\n);\n    always @(posedge clk_in) begin\n        if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate submodules\nadder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor subtractor_inst (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nand_module and_inst (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\nor_module or_inst (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Multiplexer to select result based on op\nalways @(*) begin\n    case(op)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_data;\n    wire hold0_valid;\n    data_hold hold0 (\n        .clk(clk),\n        .data(in0),\n        .valid(hold0_valid),\n        .out(hold0_data)\n    );\n\n    // Submodule for holding data from input 1\n    wire [7:0] hold1_data;\n    wire hold1_valid;\n    data_hold hold1 (\n        .clk(clk),\n        .data(in1),\n        .valid(hold1_valid),\n        .out(hold1_data)\n    );\n\n    // Submodule for holding data from input 2\n    wire [7:0] hold2_data;\n    wire hold2_valid;\n    data_hold hold2 (\n        .clk(clk),\n        .data(in2),\n        .valid(hold2_valid),\n        .out(hold2_data)\n    );\n\n    // Submodule for holding data from input 3\n    wire [7:0] hold3_data;\n    wire hold3_valid;\n    data_hold hold3 (\n        .clk(clk),\n        .data(in3),\n        .valid(hold3_valid),\n        .out(hold3_data)\n    );\n\n    // Output selection\n    assign out = (sel == 2'b00) ? hold0_data :\n                 (sel == 2'b01) ? hold1_data :\n                 (sel == 2'b10) ? hold2_data :\n                                  hold3_data;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data,\n    output reg valid,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (valid) begin\n            out <= data;\n        end else begin\n            out <= 8'h00;\n        end\n        valid <= 1;\n    end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // 9-bit sum\n    wire [8:0] carry;   // 9-bit carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output D and B_out\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\n// Full adder module\nmodule full_adder(A, B, C, sum, carry);\n    input A, B, C;\n    output sum, carry;\n\n    assign sum = A ^ B ^ C;\n    assign carry = (A & B) | (A & C) | (B & C);\nendmodule\n\n// 8-bit adder module\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 9-bit sum\n    output carry;        // Carry output\n\n    wire [7:0] carry_level;\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .C(carry),\n        .sum(sum[0]),\n        .carry(carry_level[0])\n    );\n\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C(carry_level[0]),\n        .sum(sum[1]),\n        .carry(carry_level[1])\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C(carry_level[1]),\n        .sum(sum[2]),\n        .carry(carry_level[2])\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C(carry_level[2]),\n        .sum(sum[3]),\n        .carry(carry_level[3])\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C(carry_level[3]),\n        .sum(sum[4]),\n        .carry(carry_level[4])\n    );\n\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .C(carry_level[4]),\n        .sum(sum[5]),\n        .carry(carry_level[5])\n    );\n\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .C(carry_level[5]),\n        .sum(sum[6]),\n        .carry(carry_level[6])\n    );\n\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .C(carry_level[6]),\n        .sum(sum[7]),\n        .carry(carry)\n    );\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 4'd10) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 4'd10) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @* begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    // Instantiate submodules\n    data_hold hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_hold hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_hold hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_hold hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 :\n                                 hold3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 2**4 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 2**4 / 2 - 1) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule instances\n    wire [7:0] hold0, hold1, hold2, hold3;\n\n    data_holder hold0_inst (\n        .clk(clk),\n        .data_in(in0),\n        .data_out(hold0)\n    );\n\n    data_holder hold1_inst (\n        .clk(clk),\n        .data_in(in1),\n        .data_out(hold1)\n    );\n\n    data_holder hold2_inst (\n        .clk(clk),\n        .data_in(in2),\n        .data_out(hold2)\n    );\n\n    data_holder hold3_inst (\n        .clk(clk),\n        .data_in(in3),\n        .data_out(hold3)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0 :\n                 (sel == 2'b01) ? hold1 :\n                 (sel == 2'b10) ? hold2 : hold3;\n\nendmodule\n\n// Submodule for data storage\nmodule data_holder (\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire carry;          // Carry output from the adder\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Adder module instantiation\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output assignment\n    assign D = sum[7:0];\n    assign B_out = carry;\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 9-bit output representing the sum of A and B\n    output carry;        // Carry output indicating if a carry was generated during addition\n\n    wire [8:0] temp_sum; // Temporary sum\n\n    // Full adder instantiation for each bit\n    full_adder fa0 (.A(A[0]), .B(B[0]), .Cin(0), .Sum(temp_sum[0]), .Cout(carry));\n    full_adder fa1 (.A(A[1]), .B(B[1]), .Cin(carry), .Sum(temp_sum[1]), .Cout(carry));\n    full_adder fa2 (.A(A[2]), .B(B[2]), .Cin(carry), .Sum(temp_sum[2]), .Cout(carry));\n    full_adder fa3 (.A(A[3]), .B(B[3]), .Cin(carry), .Sum(temp_sum[3]), .Cout(carry));\n    full_adder fa4 (.A(A[4]), .B(B[4]), .Cin(carry), .Sum(temp_sum[4]), .Cout(carry));\n    full_adder fa5 (.A(A[5]), .B(B[5]), .Cin(carry), .Sum(temp_sum[5]), .Cout(carry));\n    full_adder fa6 (.A(A[6]), .B(B[6]), .Cin(carry), .Sum(temp_sum[6]), .Cout(carry));\n    full_adder fa7 (.A(A[7]), .B(B[7]), .Cin(carry), .Sum(temp_sum[7]), .Cout(carry));\n\n    // Carry out from the last full adder\n    assign carry = temp_sum[8];\n\n    // Sum output\n    assign sum = temp_sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;     // Inputs\n    output Sum, Cout;    // Outputs\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Counter module\ncounter counter_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Clock divider module\nclk_divider clk_divider_module (\n    .clk_in(clk),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter module\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    localparam NUM_DIV = 8; // Even number for division\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == (NUM_DIV / 2 - 1)) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\n\n    assign limit = (count_out == (NUM_DIV / 2 - 1));\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk_in,\n    input counter_limit,\n    output reg clk_div\n);\n    always @(posedge clk_in) begin\n        if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter_module u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .counter_limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider_module u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out,\n    output reg counter_limit\n);\n    localparam NUM_DIV = 8; // Even number that divides the input clock frequency\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_out <= 0;\n            counter_limit <= 0;\n        end else begin\n            if (counter_out == (NUM_DIV / 2) - 1) begin\n                counter_out <= 0;\n                counter_limit <= 1;\n            end else begin\n                counter_out <= counter_out + 1;\n                counter_limit <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider_module(\n    input clk,\n    input rst_n,\n    input counter_limit,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_limit) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    // Submodule for holding data from input 0\n    wire [7:0] hold0_out;\n    wire [7:0] hold0_prev_out;\n    wire hold0_active;\n    data_hold hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(hold0_out),\n        .prev_out(hold0_prev_out),\n        .active(hold0_active)\n    );\n\n    // Submodule for holding data from input 1\n    wire [7:0] hold1_out;\n    wire [7:0] hold1_prev_out;\n    wire hold1_active;\n    data_hold hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(hold1_out),\n        .prev_out(hold1_prev_out),\n        .active(hold1_active)\n    );\n\n    // Submodule for holding data from input 2\n    wire [7:0] hold2_out;\n    wire [7:0] hold2_prev_out;\n    wire hold2_active;\n    data_hold hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(hold2_out),\n        .prev_out(hold2_prev_out),\n        .active(hold2_active)\n    );\n\n    // Submodule for holding data from input 3\n    wire [7:0] hold3_out;\n    wire [7:0] hold3_prev_out;\n    wire hold3_active;\n    data_hold hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(hold3_out),\n        .prev_out(hold3_prev_out),\n        .active(hold3_active)\n    );\n\n    // Output logic\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                                 hold3_out;\n\nendmodule\n\n// Submodule for holding data\nmodule data_hold (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out,\n    output reg [7:0] prev_out,\n    output reg active\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            out <= in;\n            prev_out <= in;\n            active <= 1;\n        end else if (sel == 2'b01) begin\n            out <= in;\n            prev_out <= in;\n            active <= 1;\n        end else if (sel == 2'b10) begin\n            out <= in;\n            prev_out <= in;\n            active <= 1;\n        end else if (sel == 2'b11) begin\n            out <= in;\n            prev_out <= in;\n            active <= 1;\n        end else begin\n            out <= prev_out;\n            active <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter_4bit u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk_in(clk),\n    .counter_limit(counter_limit),\n    .clk_out(clk_div)\n);\n\n// Limit the counter to half of the division factor\nassign counter_limit = (counter_q == (NUM_DIV / 2 - 1));\n\nendmodule\n\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input counter_limit,\n    output reg clk_out\n);\n    always @(posedge clk) begin\n        if (counter_limit) begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"A\", \"B\", sum);\nsubtractor subtractor (\"A\", \"B\", diff);\nand_module and_op (\"A\", \"B\", and_result);\nor_module or_op (\"A\", \"B\", or_result);\n\nalways @(*) begin\n    case(op)\n        `ADD_OP: result = sum;\n        `SUB_OP: result = diff;\n        `AND_OP: result = and_result;\n        `OR_OP: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;    // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output D and B_out\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\n// Adder module for 8-bit numbers\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;    // 9-bit sum\n    output [8:0] carry;  // 9-bit carry\n\n    wire [8:0] carry_temp;\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(carry[0]),\n        .Sum(sum[0]),\n        .Cout(carry_temp[0])\n    );\n\n    // Full adder for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry_temp[1]),\n        .Sum(sum[1]),\n        .Cout(carry_temp[2])\n    );\n\n    // Full adder for each bit\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry_temp[2]),\n        .Sum(sum[2]),\n        .Cout(carry_temp[3])\n    );\n\n    // Full adder for each bit\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry_temp[3]),\n        .Sum(sum[3]),\n        .Cout(carry_temp[4])\n    );\n\n    // Full adder for each bit\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry_temp[4]),\n        .Sum(sum[4]),\n        .Cout(carry_temp[5])\n    );\n\n    // Full adder for each bit\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry_temp[5]),\n        .Sum(sum[5]),\n        .Cout(carry_temp[6])\n    );\n\n    // Full adder for each bit\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry_temp[6]),\n        .Sum(sum[6]),\n        .Cout(carry_temp[7])\n    );\n\n    // Full adder for each bit\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry_temp[7]),\n        .Sum(sum[7]),\n        .Cout(carry[8])\n    );\n\nendmodule\n\n// Full adder module\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_out;\nwire counter_limit;\n\n// Instantiating the counter module\ncounter_module u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .counter_limit(counter_limit)\n);\n\n// Instantiating the clock divider module\nclk_divider_module u_clk_divider (\n    .clk(clk),\n    .counter_limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_module(\n    input clk,\n    input rst_n,\n    output reg [3:0] counter_out,\n    output counter_limit\n);\n    parameter NUM_DIV = 8; // Even number for division\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter_out <= 0;\n        end else begin\n            if (counter_out == NUM_DIV / 2 - 1) begin\n                counter_out <= 0;\n            end else begin\n                counter_out <= counter_out + 1;\n            end\n        end\n    end\n\n    assign counter_limit = (counter_out == NUM_DIV / 2 - 1);\n\nendmodule\n\nmodule clk_divider_module(\n    input clk,\n    input counter_limit,\n    output reg clk_div\n);\n    always @(posedge clk) begin\n        if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", a, b, sum);\nsubtractor subtractor (\"-\", a, b, diff);\nand_module and_op (\"AND\", a, b, and_result);\nor_module or_op (\"OR\", a, b, or_result);\n\nalways @(*) begin\n    case(op)\n        `ADD: result = sum;\n        `SUB: result = diff;\n        `AND: result = and_result;\n        `OR: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\nassign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\nassign or_result = a | b;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter_4bit u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk_in(clk),\n    .limit(counter_limit),\n    .clk_div(clk_div)\n);\n\nendmodule\n\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    parameter NUM_DIV = 4; // Even number that divides the clock frequency\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == NUM_DIV / 2 - 1) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\n    assign limit = (count_out == NUM_DIV / 2 - 1);\nendmodule\n\nmodule clk_divider(\n    input clk_in,\n    input limit,\n    output reg clk_div\n);\n    always @(posedge clk_in) begin\n        if (limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] D;      // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow output indicating if a borrow was generated during subtraction\n\n    wire [8:0] sum;     // Intermediate sum\n    wire [8:0] carry;   // Intermediate carry\n\n    // 2's complement of B\n    wire [7:0] B_comp;\n    assign B_comp = ~B + 1;\n\n    // Full adder for each bit\n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_comp),\n        .sum(sum),\n        .carry(carry)\n    );\n\n    // Output D and B_out\n    assign D = sum[7:0];\n    assign B_out = carry[8];\n\nendmodule\n\nmodule adder_8bit(A, B, sum, carry);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [8:0] sum;   // 9-bit sum\n    output [8:0] carry; // 9-bit carry\n\n    wire [8:0] carry_temp; // Temporary carry\n\n    // Full adder for each bit\n    full_adder fa0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(carry[0]),\n        .Sum(sum[0]),\n        .Cout(carry_temp[0])\n    );\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry_temp[1]),\n        .Sum(sum[1]),\n        .Cout(carry_temp[2])\n    );\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry_temp[2]),\n        .Sum(sum[2]),\n        .Cout(carry_temp[3])\n    );\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry_temp[3]),\n        .Sum(sum[3]),\n        .Cout(carry_temp[4])\n    );\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .Cin(carry_temp[4]),\n        .Sum(sum[4]),\n        .Cout(carry_temp[5])\n    );\n    full_adder fa5(\n        .A(A[5]),\n        .B(B[5]),\n        .Cin(carry_temp[5]),\n        .Sum(sum[5]),\n        .Cout(carry_temp[6])\n    );\n    full_adder fa6(\n        .A(A[6]),\n        .B(B[6]),\n        .Cin(carry_temp[6]),\n        .Sum(sum[6]),\n        .Cout(carry_temp[7])\n    );\n    full_adder fa7(\n        .A(A[7]),\n        .B(B[7]),\n        .Cin(carry_temp[7]),\n        .Sum(sum[7]),\n        .Cout(carry[8])\n    );\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;       // Input A\n    input B;       // Input B\n    input Cin;     // Carry-in\n    output Sum;    // Sum output\n    output Cout;   // Carry-out\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_count;\nwire counter_limit;\nwire counter_reset;\n\n// Instantiating the counter submodule\ncounter_4bit u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(counter_count),\n    .limit(counter_limit),\n    .reset(counter_reset)\n);\n\n// Instantiating the clock divider submodule\nclock_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(counter_count),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter submodule\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count,\n    output limit,\n    output reset\n);\n\nparameter NUM_DIV = 4; // Even number used for division\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        count <= 0;\n    end else if (count == (NUM_DIV / 2) - 1) begin\n        count <= 0;\n    end else begin\n        count <= count + 1;\n    end\nend\n\nassign limit = (count == (NUM_DIV / 2) - 1);\nassign reset = (count == (NUM_DIV / 2) - 1);\n\nendmodule\n\n// Clock divider submodule\nmodule clock_divider(\n    input clk,\n    input rst_n,\n    input [3:0] count,\n    output reg clk_div\n);\n\nparameter NUM_DIV = 4; // Even number used for division\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        clk_div <= 0;\n    end else if (count == (NUM_DIV / 2) - 1) begin\n        clk_div <= ~clk_div;\n    end\nend\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wire to hold the divided clock signal\nwire divided_clk;\n\n// Instantiate the counter module\ncounter u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(divided_clk)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk_in(divided_clk),\n    .clk_out(clk_div)\n);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    parameter NUM_DIV = 8; // Even number that divides the input clock frequency\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == NUM_DIV / 2 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_divider(\n    input clk_in,\n    output reg clk_out\n);\n    always @(posedge clk_in) begin\n        clk_out <= ~clk_out;\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Intermediate wires\nwire [3:0] counter_q;\nwire counter_limit;\n\n// Instantiate the counter module\ncounter_4bit u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_q),\n    .limit(counter_limit)\n);\n\n// Instantiate the clock divider module\nclk_divider u_clk_divider (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div),\n    .counter_limit(counter_limit)\n);\n\nendmodule\n\nmodule counter_4bit(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out,\n    output limit\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else if (count_out == 10) begin\n            count_out <= 0;\n        end else begin\n            count_out <= count_out + 1;\n        end\n    end\n\n    assign limit = (count_out == 5);\nendmodule\n\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    output reg clk_div,\n    input counter_limit\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else if (counter_limit) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] sum, diff, and_result, or_result;\n\n// Instantiate the adder module\nadder adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiate the subtractor module\nsubtractor subtractor (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\n// Instantiate the AND module\nand_module and_module (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiate the OR module\nor_module or_module (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\n// Multiplexer to select the result\nalways @(*) begin\n    case(op)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\n// Submodules\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;  // 16-bit difference from first subtractor\n\n    // Instantiate 16-bit subtractor for first 16 bits\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    // Instantiate 16-bit subtractor for last 16 bits\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from first subtractor to the final borrow-out\n    assign B_out = B_out_16;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out from first subtractor\n    wire [7:0] Diff_8;    // 8-bit difference from first subtractor\n\n    // Instantiate 8-bit subtractor for first 8 bits\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n\n    // Instantiate 8-bit subtractor for last 8 bits\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from first subtractor to the final borrow-out\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;         // 8-bit input A\n    input [7:0] B;         // 8-bit input B\n    output [7:0] Diff;     // 8-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [3:0] B_out_4;    // 4-bit borrow-out from first subtractor\n    wire [3:0] Diff_4;     // 4-bit difference from first subtractor\n\n    // Instantiate 4-bit subtractor for first 4 bits\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff_4),\n        .B_out(B_out_4)\n    );\n\n    // Instantiate 4-bit subtractor for last 4 bits\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from first subtractor to the final borrow-out\n    assign B_out = B_out_4;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [1:0] B_out_2;    // 2-bit borrow-out from first subtractor\n    wire [1:0] Diff_2;     // 2-bit difference from first subtractor\n\n    // Instantiate 2-bit subtractor for first 2 bits\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff_2),\n        .B_out(B_out_2)\n    );\n\n    // Instantiate 2-bit subtractor for last 2 bits\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from first subtractor to the final borrow-out\n    assign B_out = B_out_2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit difference output\n    output B_out;          // Borrow-out output\n\n    assign {B_out, Diff} = A - B; // Subtraction and borrow-out\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Internal wires\nwire [3:0] counter_out;\n\n// Instantiate the counter module\ncounter counter_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider clk_divider_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter module\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 2'b10) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 2'b10) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case (op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n// Internal wires\nwire [3:0] counter_out;\n\n// Instantiate the counter module\ncounter_even counter_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count_out(counter_out)\n);\n\n// Instantiate the clock divider module\nclk_divider clk_divider_module (\n    .clk(clk),\n    .rst_n(rst_n),\n    .counter_out(counter_out),\n    .clk_div(clk_div)\n);\n\nendmodule\n\n// Counter module\nmodule counter_even(\n    input clk,\n    input rst_n,\n    output reg [3:0] count_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_out <= 0;\n        end else begin\n            if (count_out == 2**4 - 1) begin\n                count_out <= 0;\n            end else begin\n                count_out <= count_out + 1;\n            end\n        end\n    end\nendmodule\n\n// Clock divider module\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] counter_out,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n        end else begin\n            if (counter_out == 2**4 - 1) begin\n                clk_div <= ~clk_div;\n            end\n        end\n    end\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    // Multiplexer\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"A\", \"B\", sum);\n    subtractor subtractor (\"A\", \"B\", diff);\n    and_module and_op (\"A\", \"B\", and_result);\n    or_module or_op (\"A\", \"B\", or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] sum\n);\n    assign sum = A + B;\nendmodule\n\nmodule subtractor(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] diff\n);\n    assign diff = A - B;\nendmodule\n\nmodule and_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n\nmodule or_module(\n    input [3:0] A,\n    input [3:0] B,\n    output [3:0] or_result\n);\n    assign or_result = A | B;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // 16-bit output from subtraction block 1\n    wire [15:0] S2_out;   // 16-bit output from subtraction block 2\n    wire [15:0] B_out_int; // Internal borrow-out\n\n    // Instantiate subtraction blocks\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Assign outputs\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [7:0] S1_out;    // 8-bit output from subtraction block 1\n    wire [7:0] S2_out;    // 8-bit output from subtraction block 2\n    wire [7:0] B_out_int; // Internal borrow-out\n\n    // Instantiate subtraction blocks\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Assign outputs\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output [7:0] Diff;   // 8-bit output representing the difference of A and B\n    output B_out;        // Borrow-out output\n\n    wire [3:0] S1_out;   // 4-bit output from subtraction block 1\n    wire [3:0] S2_out;   // 4-bit output from subtraction block 2\n    wire [3:0] B_out_int; // Internal borrow-out\n\n    // Instantiate subtraction blocks\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Assign outputs\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n    output B_out;        // Borrow-out output\n\n    wire [1:0] S1_out;   // 2-bit output from subtraction block 1\n    wire [1:0] S2_out;   // 2-bit output from subtraction block 2\n    wire [1:0] B_out_int; // Internal borrow-out\n\n    // Instantiate subtraction blocks\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Assign outputs\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n    output B_out;        // Borrow-out output\n\n    wire [0:0] S1_out;   // 1-bit output from subtraction block 1\n    wire [0:0] S2_out;   // 1-bit output from subtraction block 2\n    wire [0:0] B_out_int; // Internal borrow-out\n\n    // Instantiate subtraction blocks\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    // Assign outputs\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;       // 1-bit input operand A\n    input B;       // 1-bit input operand B\n    output Diff;   // 1-bit output representing the difference of A and B\n    output B_out;  // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR 2'b11\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum, diff, and_result, or_result;\n\nadder adder (\"+\", a, b, sum);\nsubtractor subtractor (\"-\", a, b, diff);\nand_module and_op (\"AND\", a, b, and_result);\nor_module or_op (\"OR\", a, b, or_result);\n\nalways @(*) begin\n    case(op)\n        `ADD: result = sum;\n        `SUB: result = diff;\n        `AND: result = and_result;\n        `OR: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\nassign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [1:0] operation,\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\nassign or_result = a | b;\nendmodule"}
{"task_id": "alu", "response": "`define ADD 6'b100000\n`define ADDU 6'b100001\n`define SUB 6'b100010\n`define SUBU 6'b100011\n`define AND 6'b100100\n`define OR 6'b100101\n`define XOR 6'b100110\n`define NOR 6'b100111\n`define SLT 6'b101010\n`define SLTU 6'b101011\n`define SLL 6'b000000\n`define SRL 6'b000010\n`define SRA 6'b000011\n`define SLLV 6'b000100\n`define SRLV 6'b000110\n`define SRAV 6'b000111\n`define LUI 6'b001111\n\nwire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\nwire [31:0] sll_result, srl_result, sra_result;\nwire [31:0] slt_result, sltu_result;\nwire [31:0] lui_result;\nwire [31:0] l_result;\nwire [31:0] r_result;\nwire [31:0] l_result_slt, l_result_sltu;\nwire [31:0] l_result_sll, l_result_srl, l_result_sra;\nwire [31:0] l_result_sllv, l_result_srlv, l_result_srav;\nwire [31:0] l_result_lui;\n\n// Instantiate submodules\nadd addu_inst(\n    .a(a),\n    .b(b),\n    .r(add_result)\n);\nsub sub_inst(\n    .a(a),\n    .b(b),\n    .r(sub_result)\n);\nand and_inst(\n    .a(a),\n    .b(b),\n    .r(and_result)\n);\nor or_inst(\n    .a(a),\n    .b(b),\n    .r(or_result)\n);\nxor xor_inst(\n    .a(a),\n    .b(b),\n    .r(xor_result)\n);\nnor nor_inst(\n    .a(a),\n    .b(b),\n    .r(nor_result)\n);\nslt slt_inst(\n    .a(a),\n    .b(b),\n    .r(slt_result)\n);\nsltu sltu_inst(\n    .a(a),\n    .b(b),\n    .r(sltu_result)\n);\nsll sll_inst(\n    .a(a),\n    .b(b),\n    .r(sll_result)\n);\nsrl srl_inst(\n    .a(a),\n    .b(b),\n    .r(srl_result)\n);\nsra sra_inst(\n    .a(a),\n    .b(b),\n    .r(sra_result)\n);\nsllv sllv_inst(\n    .a(a),\n    .b(b),\n    .r(l_result_sllv)\n);\nsrlv srlv_inst(\n    .a(a),\n    .b(b),\n    .r(l_result_srlv)\n);\nsrav srav_inst(\n    .a(a),\n    .b(b),\n    .r(l_result_srav)\n);\nlui lui_inst(\n    .a(a),\n    .r(lui_result)\n);\n\nassign l_result = {lui_result[31:0], 12'b0};\nassign l_result_slt = {l_result[31], l_result[30:0]};\nassign l_result_sltu = {l_result[31], l_result[30:0]};\nassign l_result_sll = {l_result[31:0], 12'b0};\nassign l_result_srl = {l_result[31:12], 12'b0};\nassign l_result_sra = {l_result[31], l_result[30:12], 12'b0};\n\n// Select the operation based on aluc\nassign r_result = (aluc == `ADD) ? add_result :\n                  (aluc == `ADDU) ? add_result :\n                  (aluc == `SUB) ? sub_result :\n                  (aluc == `SUBU) ? sub_result :\n                  (aluc == `AND) ? and_result :\n                  (aluc == `OR) ? or_result :\n                  (aluc == `XOR) ? xor_result :\n                  (aluc == `NOR) ? nor_result :\n                  (aluc == `SLT) ? slt_result :\n                  (aluc == `SLTU) ? sltu_result :\n                  (aluc == `SLL) ? sll_result :\n                  (aluc == `SRL) ? srl_result :\n                  (aluc == `SRA) ? sra_result :\n                  (aluc == `SLLV) ? l_result_sllv :\n                  (aluc == `SRLV) ? l_result_srlv :\n                  (aluc == `SRAV) ? l_result_srav :\n                  (aluc == `LUI) ? lui_result : 32'b0;\n\n// Compute flags\nassign zero = (r_result == 0);\nassign carry = (r_result[31] == 1);\nassign negative = (r_result[31] == 1);\nassign overflow = (r_result[31] == 1 && r_result[30] == 1);\nassign flag = (aluc == `SLT) ? (l_result_slt[31] == 1) : (aluc == `SLTU) ? (l_result_sltu[31] == 1) : 0;\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] sum, diff, and_result, or_result;\n\n    adder adder (\"\", a, b, sum);\n    subtractor subtractor (\"\", a, b, diff);\n    and_module and_op (\"\", a, b, and_result);\n    or_module or_op (\"\", a, b, or_result);\n\n    always @(*) begin\n        case(op)\n            2'b00: result = sum;\n            2'b01: result = diff;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count == (freq - 1)) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b; // Addition\n            2'b01: result = data_a - data_b; // Subtraction\n            2'b10: result = data_a & data_b; // AND\n            2'b11: result = data_a | data_b; // OR\n            default: result = 4'b0000; // Default case\n        endcase\n    end\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // 16-bit output from subtraction block 1\n    wire [15:0] S2_out;   // 16-bit output from subtraction block 2\n    wire [15:0] B_out_int; // Internal borrow-out from subtraction block 2\n\n    // Instantiate 16-bit subtraction blocks\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S1_out),\n        .B_out(B_out)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S2_out),\n        .B_out(B_out_int)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\n    assign B_out = B_out_int;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [7:0] S1_out;    // 8-bit output from subtraction block 1\n    wire [7:0] S2_out;    // 8-bit output from subtraction block 2\n    wire [7:0] B_out_int; // Internal borrow-out from subtraction block 2\n\n    // Instantiate 8-bit subtraction blocks\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S1_out),\n        .B_out(B_out)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S2_out),\n        .B_out(B_out_int)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\n    assign B_out = B_out_int;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;         // 8-bit input A\n    input [7:0] B;         // 8-bit input B\n    output [7:0] Diff;     // 8-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [3:0] S1_out;     // 4-bit output from subtraction block 1\n    wire [3:0] S2_out;     // 4-bit output from subtraction block 2\n    wire [3:0] B_out_int;  // Internal borrow-out from subtraction block 2\n\n    // Instantiate 4-bit subtraction blocks\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S1_out),\n        .B_out(B_out)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S2_out),\n        .B_out(B_out_int)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\n    assign B_out = B_out_int;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [1:0] S1_out;     // 2-bit output from subtraction block 1\n    wire [1:0] S2_out;     // 2-bit output from subtraction block 2\n    wire [1:0] B_out_int;  // Internal borrow-out from subtraction block 2\n\n    // Instantiate 2-bit subtraction blocks\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S1_out),\n        .B_out(B_out)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S2_out),\n        .B_out(B_out_int)\n    );\n\n    // Combine outputs\n    assign Diff = {S1_out, S2_out};\n    assign B_out = B_out_int;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire C_out;            // Carry-out output\n\n    // Instantiate 1-bit subtraction block\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff[1]),\n        .C_out(C_out)\n    );\n\n    // Instantiate 1-bit subtraction block\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff[0]),\n        .C_out(B_out)\n    );\n\n    // Carry-out logic\n    assign C_out = (A[1] & B[1]) | (A[1] & C_out) | (B[1] & C_out);\nendmodule\n\nmodule sub_1bit(A, B, Diff, C_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    output Diff;           // 1-bit output Diff\n    output C_out;          // Carry-out output\n\n    assign Diff = A ^ B;   // Difference\n    assign C_out = A & B;  // Carry-out\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_temp;\n\n// Submodule for decoding operation\nop_decoder decoder (\n    .op_code(op_code),\n    .result(result_temp)\n);\n\n// Submodule for managing result and zero flag\nresult_manager manager (\n    .result(result_temp),\n    .zero(zero)\n);\n\nendmodule\n\n// Submodule for decoding operation\nmodule op_decoder(\n    input [1:0] op_code,\n    output reg [3:0] result\n);\nalways @(*) begin\n    case(op_code)\n        2'b00: result = data_a + data_b;\n        2'b01: result = data_a - data_b;\n        2'b10: result = data_a & data_b;\n        2'b11: result = data_a | data_b;\n        default: result = 4'b0000;\n    endcase\nend\nendmodule\n\n// Submodule for managing result and zero flag\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\nalways @(*) begin\n    zero = (result == 4'b0000);\nend\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM Counter Module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM Signal Generator Module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_temp;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_temp)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_temp),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result\n);\n\nreg [3:0] result_temp;\n\nalways @(*) begin\n    case(op_code)\n        2'b00: result_temp = data_a + data_b;\n        2'b01: result_temp = data_a - data_b;\n        2'b10: result_temp = data_a & data_b;\n        2'b11: result_temp = data_a | data_b;\n        default: result_temp = 4'b0000;\n    endcase\nend\n\nassign result = result_temp;\n\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output zero\n);\n\nassign zero = (result == 4'b0000) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    wire [31:0] nor_result;\n    wire [31:0] slt_result;\n    wire [31:0] sltu_result;\n    wire [31:0] sll_result;\n    wire [31:0] srl_result;\n    wire [31:0] sra_result;\n    wire [31:0] lui_result;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result));\n    addu addu_inst(.a(a), .b(b), .r(add_result));\n    sub sub_inst(.a(a), .b(b), .r(sub_result));\n    subu subu_inst(.a(a), .b(b), .r(sub_result));\n    and and_inst(.a(a), .b(b), .r(and_result));\n    or or_inst(.a(a), .b(b), .r(or_result));\n    xor xor_inst(.a(a), .b(b), .r(xor_result));\n    nor nor_inst(.a(a), .b(b), .r(nor_result));\n    slt slt_inst(.a(a), .b(b), .r(slt_result));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result));\n    sll sll_inst(.a(a), .b(b), .r(sll_result));\n    srl srl_inst(.a(a), .b(b), .r(srl_result));\n    sra sra_inst(.a(a), .b(b), .r(sra_result));\n    lui lui_inst(.a(a), .r(lui_result));\n\n    // Select operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 0)) ||\n                       ((a[31] == 0) && (b[31] == 1) && (r[31] == 1)));\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule subu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a & b;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a | b;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a ^ b;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = ~(a | b);\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 1'b1 : 1'b0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 1'b1 : 1'b0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule sllv(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srlv(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule srav(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule lui(input [31:0] a, output [31:0] r);\n    assign r = {a, 12'b0};\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] count;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else if (count == (freq - 1)) begin\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_diff; // 16-bit difference output from subtraction block\n    wire [15:0] S2_diff; // 16-bit difference output from subtraction block\n    wire [15:0] S1_borrow; // 16-bit borrow output from subtraction block\n    wire [15:0] S2_borrow; // 16-bit borrow output from subtraction block\n\n    // Instantiate subtraction blocks for 16-bit subtraction\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_diff),\n        .Borrow_out(S1_borrow)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_diff),\n        .Borrow_out(S2_borrow)\n    );\n\n    // Combine the outputs of the subtraction blocks\n    assign Diff = {S2_diff, S1_diff};\n    assign B_out = {S2_borrow, S1_borrow};\nendmodule\n\nmodule sub_16bit(A, B, Diff, Borrow_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output [15:0] Borrow_out; // 16-bit borrow output\n\n    wire [15:0] temp_diff; // Temporary difference\n    wire [15:0] temp_borrow; // Temporary borrow\n\n    // Subtract A and B\n    assign temp_diff = A - B;\n    assign temp_borrow = (A < B) ? 1 : 0;\n\n    // Assign outputs\n    assign Diff = temp_diff;\n    assign Borrow_out = temp_borrow;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        if(result == 4'b0000)\n            zero = 1'b1;\n        else\n            zero = 1'b0;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] pulse_width;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            pulse_width <= duty_cycle;\n        end else begin\n            pwm_out <= 1'b0;\n            pulse_width <= 8'b0;\n        end\n\n        if (counter < duty_cycle + 1) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] op_result;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .result(op_result)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(op_result),\n    .zero(zero)\n);\n\n// Assign the result to the output\nassign result = op_result;\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b;\n            2'b01: result = data_a - data_b;\n            2'b10: result = data_a & data_b;\n            2'b11: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        if(result == 4'b0000)\n            zero = 1'b1;\n        else\n            zero = 1'b0;\n    end\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output zero\n);\n    assign zero = (result == 4'b0000);\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n        if (counter >= 255) begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out for first subtraction\n    wire [15:0] Diff_16;  // 16-bit difference for first subtraction\n\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[31:16]),\n        .B_out(B_out)\n    );\n\n    assign Diff[15:0] = Diff_16;\n    assign B_out = B_out_16;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out for first subtraction\n    wire [15:0] Diff_16;  // 16-bit difference for first subtraction\n\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[15:8]),\n        .B_out(B_out)\n    );\n\n    assign Diff[7:0] = Diff_16;\n    assign B_out = B_out_16;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;       // 8-bit input A\n    input [7:0] B;       // 8-bit input B\n    output [7:0] Diff;   // 8-bit output Diff\n    output B_out;        // Borrow-out output\n\n    wire [7:0] B_out_8; // 8-bit borrow-out for first subtraction\n    wire [7:0] Diff_8;  // 8-bit difference for first subtraction\n\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[7:4]),\n        .B_out(B_out)\n    );\n\n    assign Diff[3:0] = Diff_8;\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    output [3:0] Diff;   // 4-bit output Diff\n    output B_out;        // Borrow-out output\n\n    wire [3:0] B_out_4; // 4-bit borrow-out for first subtraction\n    wire [3:0] Diff_4;  // 4-bit difference for first subtraction\n\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff_4),\n        .B_out(B_out_4)\n    );\n\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff[3:2]),\n        .B_out(B_out)\n    );\n\n    assign Diff[1:0] = Diff_4;\n    assign B_out = B_out_4;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    output [1:0] Diff;   // 2-bit output Diff\n    output B_out;        // Borrow-out output\n\n    wire [1:0] B_out_2; // 2-bit borrow-out for first subtraction\n    wire [1:0] Diff_2;  // 2-bit difference for first subtraction\n\n    assign {B_out, Diff} = A - B;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b;\n            2'b01: result = data_a - data_b;\n            2'b10: result = data_a & data_b;\n            2'b11: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of the pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .pwm_out(pwm_out)\n    );\n\n    // Instance of the duty cycle controller module\n    duty_ctrl duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] adjusted_duty;\n\n    always @(posedge clk) begin\n        if (counter < adjusted_duty) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        counter <= counter + 1;\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add_sub add(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    add_sub addu(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    sub_sub sub(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    sub_sub subu(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    and_or andor(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero), .negative(and_negative), .overflow(and_overflow));\n    and_or oror(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero), .negative(or_negative), .overflow(or_overflow));\n    and_or xoror(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero), .negative(xor_negative), .overflow(xor_overflow));\n    and_or noror(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero), .negative(nor_negative), .overflow(nor_overflow));\n    slt_sltu slt(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero), .negative(slt_negative), .overflow(slt_overflow));\n    slt_sltu sltu(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero), .negative(sltu_negative), .overflow(sltu_overflow));\n    sll_srl sll(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero), .negative(sll_negative), .overflow(sll_overflow));\n    sll_srl srl(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero), .negative(srl_negative), .overflow(srl_overflow));\n    sra_srav sra(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero), .negative(sra_negative), .overflow(sra_overflow));\n    sra_srav srav(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero), .negative(srav_negative), .overflow(srav_overflow));\n    lui lui(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .zero(lui_zero), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || sub_carry || or_carry || xor_carry || nor_carry);\n    assign negative = (r[31]);\n    assign overflow = (add_overflow || sub_overflow || slt_overflow || sltu_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] : (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule and_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\nendmodule\n\nmodule slt_sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sll_srl(\n    input [31:0] a,\n    input [5:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b == 0) ? a : (b[5] == 1) ? {a[31:0], {b[4:0]}} : {a[31:b], 5'b0};\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sra_srav(\n    input [31:0] a,\n    input [5:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b == 0) ? a : (b[5] == 1) ? {a[31:0], {b[4:0]}} : {a[31:b], {b[4:0]}};\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [5:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[4:0], 27'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    reg [7:0] counter;\n    reg pwm_out_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out_reg <= 1'b1;\n            counter <= counter + 1;\n        end else begin\n            pwm_out_reg <= 1'b0;\n            counter <= 0;\n        end\n    end\n\n    assign pwm_out = pwm_out_reg;\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // Output from the 16-bit subtractor for A[15:0]\n    wire [15:0] S2_out;   // Output from the 16-bit subtractor for A[31:16]\n    wire B1_out;          // Output from the 16-bit subtractor for B[15:0]\n    wire B2_out;          // Output from the 16-bit subtractor for B[31:16]\n\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // Output from the 8-bit subtractor for A[7:0]\n    wire [15:0] S2_out;   // Output from the 8-bit subtractor for A[15:8]\n    wire B1_out;          // Output from the 8-bit subtractor for B[7:0]\n    wire B2_out;          // Output from the 8-bit subtractor for B[15:8]\n\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input operand A\n    input [7:0] B;        // 8-bit input operand B\n    output [7:0] Diff;    // 8-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [7:0] S1_out;    // Output from the 4-bit subtractor for A[3:0]\n    wire [7:0] S2_out;    // Output from the 4-bit subtractor for A[7:4]\n    wire B1_out;          // Output from the 4-bit subtractor for B[3:0]\n    wire B2_out;          // Output from the 4-bit subtractor for B[7:4]\n\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;        // 4-bit input operand A\n    input [3:0] B;        // 4-bit input operand B\n    output [3:0] Diff;    // 4-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [3:0] S1_out;    // Output from the 2-bit subtractor for A[1:0]\n    wire [3:0] S2_out;    // Output from the 2-bit subtractor for A[3:2]\n    wire B1_out;          // Output from the 2-bit subtractor for B[1:0]\n    wire B2_out;          // Output from the 2-bit subtractor for B[3:2]\n\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;        // 2-bit input operand A\n    input [1:0] B;        // 2-bit input operand B\n    output [1:0] Diff;    // 2-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [1:0] S1_out;    // Output from the 1-bit subtractor for A[0]\n    wire [1:0] S2_out;    // Output from the 1-bit subtractor for A[1]\n    wire B1_out;          // Output from the 1-bit subtractor for B[0]\n    wire B2_out;          // Output from the 1-bit subtractor for B[1]\n\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_1bit S2(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;              // 1-bit input operand A\n    input B;              // 1-bit input operand B\n    output Diff;          // 1-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n\nalways @(*) begin\n    case(op_code)\n        `ADD_OP: result = data_a + data_b;\n        `SUB_OP: result = data_a - data_b;\n        `AND_OP: result = data_a & data_b;\n        `OR_OP: result = data_a | data_b;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n\nalways @(*) begin\n    zero = (result == 4'b0000);\nend\n\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of the duty cycle controller module\n    duty_ctrl duty_ctrl_inst (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of the pulse generator module\n    pulse_gen pulse_gen_inst (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] pulse_width;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            counter <= counter + 1;\n        end else begin\n            pwm_out <= 1'b0;\n            counter <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_temp;\n\n// Instantiate the operation decoder\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_temp)\n);\n\n// Instantiate the result manager\nresult_manager manager (\n    .result(result_temp),\n    .result_out(result),\n    .zero(zero)\n);\n\nendmodule\n\n// Operation decoder module\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            2'b00: result = data_a + data_b;\n            2'b01: result = data_a - data_b;\n            2'b10: result = data_a & data_b;\n            2'b11: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\n// Result manager module\nmodule result_manager(\n    input [3:0] result,\n    output reg [3:0] result_out,\n    output reg zero\n);\n    always @(*) begin\n        result_out = result;\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of the duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of the pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            counter <= counter + 1;\n        end else begin\n            pwm_out <= 1'b0;\n            counter <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] result_int;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(result_int)\n);\n\nresult_manager manager (\n    .result(result_int),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @(*) begin\n        case(op_code)\n            `ADD_OP: result = data_a + data_b;\n            `SUB_OP: result = data_a - data_b;\n            `AND_OP: result = data_a & data_b;\n            `OR_OP: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input [3:0] result,\n    output reg zero\n);\n    always @(*) begin\n        zero = (result == 4'b0000);\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] A16;      // 16-bit part of A\n    wire [15:0] B16;      // 16-bit part of B\n    wire [15:0] Diff16;   // 16-bit difference output\n    wire B16_out;         // 16-bit borrow-out output\n\n    // Subtractor for the 16-bit part\n    sub_16bit S16(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff16),\n        .B_out(B16_out)\n    );\n\n    // Subtractor for the 16-bit part\n    sub_16bit S16_2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine the 16-bit differences\n    assign Diff = {Diff16, B16_out} + {16'b0, B16};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [7:0] A8;        // 8-bit part of A\n    wire [7:0] B8;        // 8-bit part of B\n    wire [7:0] Diff8;     // 8-bit difference output\n    wire B8_out;          // 8-bit borrow-out output\n\n    // Subtractor for the 8-bit part\n    sub_8bit S8(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff8),\n        .B_out(B8_out)\n    );\n\n    // Subtractor for the 8-bit part\n    sub_8bit S8_2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine the 8-bit differences\n    assign Diff = {Diff8, B8_out} + {8'b0, B8};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;         // 8-bit input A\n    input [7:0] B;         // 8-bit input B\n    output [7:0] Diff;     // 8-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [3:0] A4;         // 4-bit part of A\n    wire [3:0] B4;         // 4-bit part of B\n    wire [3:0] Diff4;      // 4-bit difference output\n    wire B4_out;           // 4-bit borrow-out output\n\n    // Subtractor for the 4-bit part\n    sub_4bit S4(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff4),\n        .B_out(B4_out)\n    );\n\n    // Subtractor for the 4-bit part\n    sub_4bit S4_2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine the 4-bit differences\n    assign Diff = {Diff4, B4_out} + {4'b0, B4};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [1:0] A2;         // 2-bit part of A\n    wire [1:0] B2;         // 2-bit part of B\n    wire [1:0] Diff2;      // 2-bit difference output\n    wire B2_out;           // 2-bit borrow-out output\n\n    // Subtractor for the 2-bit part\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff2),\n        .B_out(B2_out)\n    );\n\n    // Subtractor for the 2-bit part\n    sub_2bit S2_2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine the 2-bit differences\n    assign Diff = {Diff2, B2_out} + {2'b0, B2};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [0:0] A1;         // 1-bit part of A\n    wire [0:0] B1;         // 1-bit part of B\n    wire [0:0] Diff1;      // 1-bit difference output\n    wire B1_out;           // 1-bit borrow-out output\n\n    // Subtractor for the 1-bit part\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff1),\n        .B_out(B1_out)\n    );\n\n    // Subtractor for the 1-bit part\n    sub_1bit S1_2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine the 1-bit differences\n    assign Diff = {Diff1, B1_out} + {1'b0, B1};\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    output Diff;           // 1-bit difference output\n    output B_out;          // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\n\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n    addu addu_inst(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n    sub sub_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n    subu subu_inst(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n    and and_inst(\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow)\n    );\n    or or_inst(\n        .a(a),\n        .b(b),\n        .r(or_result),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow)\n    );\n    xor xor_inst(\n        .a(a),\n        .b(b),\n        .r(xor_result),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow)\n    );\n    nor nor_inst(\n        .a(a),\n        .b(b),\n        .r(nor_result),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow)\n    );\n    slt slt_inst(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .zero(slt_zero),\n        .carry(slt_carry),\n        .negative(slt_negative),\n        .overflow(slt_overflow)\n    );\n    sltu sltu_inst(\n        .a(a),\n        .b(b),\n        .r(sltu_result),\n        .zero(sltu_zero),\n        .carry(sltu_carry),\n        .negative(sltu_negative),\n        .overflow(sltu_overflow)\n    );\n    sll sll_inst(\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .zero(sll_zero),\n        .carry(sll_carry),\n        .negative(sll_negative),\n        .overflow(sll_overflow)\n    );\n    srl srl_inst(\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .zero(srl_zero),\n        .carry(srl_carry),\n        .negative(srl_negative),\n        .overflow(srl_overflow)\n    );\n    sra sra_inst(\n        .a(a),\n        .b(b),\n        .r(sra_result),\n        .zero(sra_zero),\n        .carry(sra_carry),\n        .negative(sra_negative),\n        .overflow(sra_overflow)\n    );\n    sllv sllv_inst(\n        .a(a),\n        .b(b),\n        .r(sllv_result),\n        .zero(sllv_zero),\n        .carry(sllv_carry),\n        .negative(sllv_negative),\n        .overflow(sllv_overflow)\n    );\n    srlv srlv_inst(\n        .a(a),\n        .b(b),\n        .r(srlv_result),\n        .zero(srlv_zero),\n        .carry(srlv_carry),\n        .negative(srlv_negative),\n        .overflow(srlv_overflow)\n    );\n    srav srav_inst(\n        .a(a),\n        .b(b),\n        .r(srav_result),\n        .zero(srav_zero),\n        .carry(srav_carry),\n        .negative(srav_negative),\n        .overflow(srav_overflow)\n    );\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .zero(lui_zero),\n        .carry(lui_carry),\n        .negative(lui_negative),\n        .overflow(lui_overflow)\n    );\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry | sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow | sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] :\n                  1'b0;\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate arithmetic operations\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a / b;\n    always @(result) begin\n        if (result == 0) valid <= 0;\n        else valid <= 1;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        counter <= counter + 1;\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    adder add_module(\n        .a(data_a),\n        .b(data_b),\n        .sum(add_result)\n    );\n\n    subtractor sub_module(\n        .a(data_a),\n        .b(data_b),\n        .difference(sub_result)\n    );\n\n    multiplier mul_module(\n        .a(data_a),\n        .b(data_b),\n        .product(mul_result)\n    );\n\n    divider div_module(\n        .a(data_a),\n        .b(data_b),\n        .quotient(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n            valid <= 1;\n        end\n    end\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] quotient,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            quotient = 0;\n            valid = 0;\n        end else begin\n            quotient = a / b;\n            valid = 1;\n        end\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle) begin\n            pwm_out <= 1'b1;\n            counter <= counter + 1;\n        end else begin\n            pwm_out <= 1'b0;\n            counter <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out16;  // 16-bit borrow-out\n    wire [15:0] Diff16;   // 16-bit difference\n\n    // Instantiate 16-bit subtractor for A[15:0] and B[15:0]\n    sub_16bit S16(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff16),\n        .B_out(B_out16)\n    );\n\n    // Instantiate 16-bit subtractor for A[31:16] and B[31:16]\n    sub_16bit S17(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[15:0]),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from 16-bit subtractor\n    assign B_out = B_out16;\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out8;    // 8-bit borrow-out\n    wire [7:0] Diff8;     // 8-bit difference\n\n    // Instantiate 8-bit subtractor for A[7:0] and B[7:0]\n    sub_8bit S8(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff8),\n        .B_out(B_out8)\n    );\n\n    // Instantiate 8-bit subtractor for A[15:8] and B[15:8]\n    sub_8bit S9(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[7:0]),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from 8-bit subtractor\n    assign B_out = B_out8;\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;         // 8-bit input A\n    input [7:0] B;         // 8-bit input B\n    output [7:0] Diff;     // 8-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [3:0] B_out4;     // 4-bit borrow-out\n    wire [3:0] Diff4;      // 4-bit difference\n\n    // Instantiate 4-bit subtractor for A[3:0] and B[3:0]\n    sub_4bit S4(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff4),\n        .B_out(B_out4)\n    );\n\n    // Instantiate 4-bit subtractor for A[7:4] and B[7:4]\n    sub_4bit S5(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[3:0]),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from 4-bit subtractor\n    assign B_out = B_out4;\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [1:0] B_out2;     // 2-bit borrow-out\n    wire [1:0] Diff2;      // 2-bit difference\n\n    // Instantiate 2-bit subtractor for A[1:0] and B[1:0]\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff2),\n        .B_out(B_out2)\n    );\n\n    // Instantiate 2-bit subtractor for A[3:2] and B[3:2]\n    sub_2bit S3(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff[1:0]),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from 2-bit subtractor\n    assign B_out = B_out2;\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire B_out1;           // 1-bit borrow-out\n    wire Diff1;            // 1-bit difference\n\n    // Instantiate 1-bit subtractor for A[0] and B[0]\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff1),\n        .B_out(B_out1)\n    );\n\n    // Instantiate 1-bit subtractor for A[1] and B[1]\n    sub_1bit S2(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Assign borrow-out from 1-bit subtractor\n    assign B_out = B_out1;\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    output Diff;           // 1-bit output Diff\n    output B_out;          // Borrow-out output\n\n    assign Diff = A ^ B;   // XOR\n    assign B_out = A & B;  // AND\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .result(add_result),\n    .valid(valid)\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result),\n    .valid(valid)\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result),\n    .valid(valid)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a + b;\n    assign valid = 1;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a - b;\n    assign valid = 1;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a * b;\n    assign valid = 1;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign result = a / b;\n    assign valid = (b != 0);\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate the arithmetic operation modules\n    adder add_module(\n        .a(data_a),\n        .b(data_b),\n        .result(add_result),\n        .valid(valid)\n    );\n\n    subtractor sub_module(\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result),\n        .valid(valid)\n    );\n\n    multiplier mul_module(\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result),\n        .valid(valid)\n    );\n\n    divider div_module(\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select the operation based on the opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                `ADD_OP: begin\n                    result <= add_result;\n                    valid <= 1;\n                end\n                `SUB_OP: begin\n                    result <= sub_result;\n                    valid <= 1;\n                end\n                `MUL_OP: begin\n                    result <= mul_result;\n                    valid <= 1;\n                end\n                `DIV_OP: begin\n                    result <= div_result;\n                    valid <= 1;\n                end\n                default: begin\n                    result <= 0;\n                    valid <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(*) begin\n        result = a + b;\n        valid = 1;\n    end\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(*) begin\n        result = a - b;\n        valid = 1;\n    end\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(*) begin\n        result = a * b;\n        valid = 1;\n    end\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(*) begin\n        if (b == 0) begin\n            result = 0;\n            valid = 0;\n        end else begin\n            result = a / b;\n            valid = 1;\n        end\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of duty cycle controller module\n    duty_ctrl dut_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of pulse generator module\n    pulse_gen pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    reg [7:0] duty_cycle_reg;\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle_reg) begin\n            pwm_out <= 1'b1;\n        end else begin\n            pwm_out <= 1'b0;\n        end\n\n        if (counter < 255) begin\n            counter <= counter + 1;\n        end else begin\n            counter <= 0;\n        end\n    end\n\n    always @(posedge clk) begin\n        duty_cycle_reg <= duty_cycle;\n    end\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_low, a_high, b_low, b_high;\n    wire [7:0] equal_low, equal_high;\n\n    // Split inputs into 8-bit sections\n    assign a_low = a[7:0];\n    assign a_high = a[15:8];\n    assign b_low = b[7:0];\n    assign b_high = b[15:8];\n\n    // Instantiate 8-bit comparators\n    comparator_8bit comp8_inst1 (\n        .a(a_low),\n        .b(b_low),\n        .equal(equal_low)\n    );\n    comparator_8bit comp8_inst2 (\n        .a(a_high),\n        .b(b_high),\n        .equal(equal_high)\n    );\n    comparator_8bit comp8_inst3 (\n        .a(a_low),\n        .b(b_high),\n        .equal(equal_low)\n    );\n    comparator_8bit comp8_inst4 (\n        .a(a_high),\n        .b(b_low),\n        .equal(equal_high)\n    );\n\n    // Combine results\n    assign equal = equal_low & equal_high;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate the arithmetic operations\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                `ADD_OP: begin\n                    result <= add_result;\n                    valid <= 1;\n                end\n                `SUB_OP: begin\n                    result <= sub_result;\n                    valid <= 1;\n                end\n                `MUL_OP: begin\n                    result <= mul_result;\n                    valid <= 1;\n                end\n                `DIV_OP: begin\n                    result <= div_result;\n                    valid <= valid;\n                end\n                default: begin\n                    result <= 0;\n                    valid <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each section of the inputs\n    comp8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_hi)\n    );\n\n    // Combine the results of each 8-bit comparator\n    assign equal = equal_lo & equal_hi;\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .result(add_result)\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result)\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each section of the inputs\n    comp8 comp8_inst1 (\n        .a(a_lo),\n        .b(b_lo),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a_hi),\n        .b(b_hi),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst4 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_hi)\n    );\n\n    // Combine the results of the 8-bit comparators\n    assign equal = (equal_lo & equal_hi);\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] a_lo_eq, a_hi_eq, b_lo_eq, b_hi_eq;\n\n    // Split inputs into 8-bit sections\n    assign a_lo = a[7:0];\n    assign a_hi = a[15:8];\n    assign b_lo = b[7:0];\n    assign b_hi = b[15:8];\n\n    // Compare 8-bit sections\n    comparator_8 comp8_inst1 (\n        .a(a_lo),\n        .b(b_lo),\n        .equal(a_lo_eq)\n    );\n    comparator_8 comp8_inst2 (\n        .a(a_hi),\n        .b(b_hi),\n        .equal(a_hi_eq)\n    );\n    comparator_8 comp8_inst3 (\n        .a(a_lo),\n        .b(b_hi),\n        .equal(b_lo_eq)\n    );\n    comparator_8 comp8_inst4 (\n        .a(a_hi),\n        .b(b_lo),\n        .equal(b_hi_eq)\n    );\n\n    // Combine results\n    assign equal = a_lo_eq & a_hi_eq & b_lo_eq & b_hi_eq;\nendmodule\n\nmodule comparator_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate arithmetic operation modules\n    adder add_module(\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module(\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module(\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module(\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select operation based on opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case(opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            valid = 0;\n            result = 0;\n        end else begin\n            valid = 1;\n            result = a / b;\n        end\n    end\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Submodules\n    add addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .zero(add_zero));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .zero(add_zero));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .zero(sub_zero));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .zero(sub_zero));\n    and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero));\n    or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .zero(sllv_zero));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .zero(srlv_zero));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero));\n    lui lui_inst(.a(a), .r(lui_result), .carry(lui_carry), .zero(lui_zero));\n\n    // Outputs\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               lui_result;\n\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? add_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? sub_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   lui_carry;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? add_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? sub_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  lui_zero;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? add_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? sub_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      lui_overflow;\n\n    assign negative = r[31];\n\n    // Flag for SLT and SLTU\n    assign slt_flag = (slt_result[31] && !slt_result[30]) ? 1'b1 : 1'b0;\n    assign sltu_flag = (sltu_result[31] && !sltu_result[30]) ? 1'b1 : 1'b0;\n    assign flag = (aluc == 6'b101010) ? slt_flag : (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output zero\n);\n    assign {carry, r} = a + b;\n    assign overflow = (a[31] == b[31]) && (r[31] != a[31]);\n    assign zero = r == 32'b0;\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output zero\n);\n    assign {carry, r} = a + b;\n    assign overflow = (a[31] == b[31]) && (r[31] != a[31]);\n    assign zero = r == 32'b0;\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output zero\n);\n    assign {carry, r} = a - b;\n    assign overflow = (a[31] == b[31]) && (r[31] != a[31]);\n    assign zero = r == 32'b0;\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output zero\n);\n    assign {carry, r} = a - b;\n    assign overflow = (a[31] == b[31]) && (r[31] != a[31]);\n    assign zero = r == 32'b0;\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a & b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a | b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a ^ b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = r == 32'b0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a << b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a >> b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a << b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = a >> b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = r == 32'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    output [31:0] r,\n    output carry,\n    output zero\n);\n    assign {carry, r} = {a[31:12], 12'b0};\n    assign zero = r == 32'b0;\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_low, a_high, b_low, b_high;\n    wire [7:0] a_low_equal, a_high_equal, b_low_equal, b_high_equal;\n\n    // Split 32-bit inputs into 8-bit sections\n    assign a_low = a[7:0];\n    assign a_high = a[15:8];\n    assign b_low = b[7:0];\n    assign b_high = b[15:8];\n\n    // Compare each 8-bit section\n    comparator8 comp8_inst1 (\n        .a(a_low),\n        .b(b_low),\n        .equal(a_low_equal)\n    );\n    comparator8 comp8_inst2 (\n        .a(a_high),\n        .b(b_high),\n        .equal(a_high_equal)\n    );\n    comparator8 comp8_inst3 (\n        .a(a_low),\n        .b(b_high),\n        .equal(b_low_equal)\n    );\n    comparator8 comp8_inst4 (\n        .a(a_high),\n        .b(b_low),\n        .equal(b_high_equal)\n    );\n\n    // Combine results\n    assign equal = a_low_equal & a_high_equal & b_low_equal & b_high_equal;\n\nendmodule\n\nmodule comparator8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate arithmetic modules\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            valid = 0;\n            result = 0;\n        end else begin\n            valid = 1;\n            result = a / b;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_low, a_high, b_low, b_high;\n    wire [7:0] a_low_equal, a_high_equal, b_low_equal, b_high_equal;\n\n    // Split the inputs into 8-bit sections\n    assign a_low = a[7:0];\n    assign a_high = a[15:8];\n    assign b_low = b[7:0];\n    assign b_high = b[15:8];\n\n    // Compare the 8-bit sections\n    comparator8 comp8_inst1 (.a(a_low), .b(b_low), .equal(a_low_equal));\n    comparator8 comp8_inst2 (.a(a_high), .b(b_high), .equal(a_high_equal));\n    comparator8 comp8_inst3 (.a(a_low), .b(b_high), .equal(b_low_equal));\n    comparator8 comp8_inst4 (.a(a_high), .b(b_low), .equal(b_high_equal));\n\n    // Combine the results\n    assign equal = a_low_equal & a_high_equal & b_low_equal & b_high_equal;\n\nendmodule\n\nmodule comparator8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n\n    wire [7:0] a_low, a_high, b_low, b_high;\n    wire [7:0] equal_low, equal_high;\n\n    // Instantiate 8-bit comparators for each section of the inputs\n    comp8 comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_low)\n    );\n\n    comp8 comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_high)\n    );\n\n    comp8 comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_low)\n    );\n\n    comp8 comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_high)\n    );\n\n    // Combine results from each section\n    assign equal = equal_low & equal_high;\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n\n    assign equal = (a == b);\n\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .sum(add_result),\n    .carry()\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .difference(sub_result),\n    .carry()\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .product(mul_result)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .quotient(div_result),\n    .remainder()\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= (data_b != 0);\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] sum,\n    output carry\n);\n    assign sum = a + b;\n    assign carry = (a[7] & b[7]) | (a[7] & sum[15]) | (b[7] & sum[15]);\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] difference,\n    output carry\n);\n    assign difference = a - b;\n    assign carry = (a[7] & ~b[7]) | (~a[7] & b[7] & ~difference[15]);\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] quotient,\n    output [7:0] remainder\n);\n    assign {remainder, quotient} = a / b;\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] comp1, comp2, comp3, comp4;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(comp1)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(comp2)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(comp3)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(comp4)\n    );\n\n    assign equal = comp1 & comp2 & comp3 & comp4;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // 16-bit output from subtraction block 1\n    wire [15:0] S2_out;   // 16-bit output from subtraction block 2\n    wire [15:0] B_out_int; // Internal borrow-out\n\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output difference\n    output B_out;        // Borrow-out output\n\n    wire [14:0] S1_out;   // 15-bit output from subtraction block 1\n    wire [14:0] S2_out;   // 15-bit output from subtraction block 2\n    wire [15:0] B_out_int; // Internal borrow-out\n\n    sub_15bit S1(\n        .A(A[14:0]),\n        .B(B[14:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_15bit S2(\n        .A(A[15]),\n        .B(B[15]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_15bit(A, B, Diff, B_out);\n    input A;              // 15-bit input A\n    input B;              // 15-bit input B\n    output Diff;          // 15-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [14:0] S1_out;   // 14-bit output from subtraction block 1\n    wire [14:0] S2_out;   // 14-bit output from subtraction block 2\n    wire [15:0] B_out_int; // Internal borrow-out\n\n    sub_14bit S1(\n        .A(A[13:0]),\n        .B(B[13:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_14bit S2(\n        .A(A[14]),\n        .B(B[14]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_14bit(A, B, Diff, B_out);\n    input A;              // 14-bit input A\n    input B;              // 14-bit input B\n    output Diff;          // 14-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [13:0] S1_out;   // 13-bit output from subtraction block 1\n    wire [13:0] S2_out;   // 13-bit output from subtraction block 2\n    wire [14:0] B_out_int; // Internal borrow-out\n\n    sub_13bit S1(\n        .A(A[12:0]),\n        .B(B[12:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_13bit S2(\n        .A(A[13]),\n        .B(B[13]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_13bit(A, B, Diff, B_out);\n    input A;              // 13-bit input A\n    input B;              // 13-bit input B\n    output Diff;          // 13-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [12:0] S1_out;   // 12-bit output from subtraction block 1\n    wire [12:0] S2_out;   // 12-bit output from subtraction block 2\n    wire [13:0] B_out_int; // Internal borrow-out\n\n    sub_12bit S1(\n        .A(A[11:0]),\n        .B(B[11:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_12bit S2(\n        .A(A[12]),\n        .B(B[12]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_12bit(A, B, Diff, B_out);\n    input A;              // 12-bit input A\n    input B;              // 12-bit input B\n    output Diff;          // 12-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [11:0] S1_out;   // 11-bit output from subtraction block 1\n    wire [11:0] S2_out;   // 11-bit output from subtraction block 2\n    wire [12:0] B_out_int; // Internal borrow-out\n\n    sub_11bit S1(\n        .A(A[10:0]),\n        .B(B[10:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_11bit S2(\n        .A(A[11]),\n        .B(B[11]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_11bit(A, B, Diff, B_out);\n    input A;              // 11-bit input A\n    input B;              // 11-bit input B\n    output Diff;          // 11-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [10:0] S1_out;   // 10-bit output from subtraction block 1\n    wire [10:0] S2_out;   // 10-bit output from subtraction block 2\n    wire [11:0] B_out_int; // Internal borrow-out\n\n    sub_10bit S1(\n        .A(A[9:0]),\n        .B(B[9:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_10bit S2(\n        .A(A[10]),\n        .B(B[10]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_10bit(A, B, Diff, B_out);\n    input A;              // 10-bit input A\n    input B;              // 10-bit input B\n    output Diff;          // 10-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [9:0] S1_out;    // 9-bit output from subtraction block 1\n    wire [9:0] S2_out;    // 9-bit output from subtraction block 2\n    wire [10:0] B_out_int; // Internal borrow-out\n\n    sub_9bit S1(\n        .A(A[8:0]),\n        .B(B[8:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_9bit S2(\n        .A(A[9]),\n        .B(B[9]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_9bit(A, B, Diff, B_out);\n    input A;              // 9-bit input A\n    input B;              // 9-bit input B\n    output Diff;          // 9-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [8:0] S1_out;    // 8-bit output from subtraction block 1\n    wire [8:0] S2_out;    // 8-bit output from subtraction block 2\n    wire [9:0] B_out_int; // Internal borrow-out\n\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_8bit S2(\n        .A(A[8]),\n        .B(B[8]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input A;              // 8-bit input A\n    input B;              // 8-bit input B\n    output Diff;          // 8-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [7:0] S1_out;    // 7-bit output from subtraction block 1\n    wire [7:0] S2_out;    // 7-bit output from subtraction block 2\n    wire [8:0] B_out_int; // Internal borrow-out\n\n    sub_7bit S1(\n        .A(A[6:0]),\n        .B(B[6:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_7bit S2(\n        .A(A[7]),\n        .B(B[7]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_7bit(A, B, Diff, B_out);\n    input A;              // 7-bit input A\n    input B;              // 7-bit input B\n    output Diff;          // 7-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [6:0] S1_out;    // 6-bit output from subtraction block 1\n    wire [6:0] S2_out;    // 6-bit output from subtraction block 2\n    wire [7:0] B_out_int; // Internal borrow-out\n\n    sub_6bit S1(\n        .A(A[5:0]),\n        .B(B[5:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_6bit S2(\n        .A(A[6]),\n        .B(B[6]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_6bit(A, B, Diff, B_out);\n    input A;              // 6-bit input A\n    input B;              // 6-bit input B\n    output Diff;          // 6-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [5:0] S1_out;    // 5-bit output from subtraction block 1\n    wire [5:0] S2_out;    // 5-bit output from subtraction block 2\n    wire [6:0] B_out_int; // Internal borrow-out\n\n    sub_5bit S1(\n        .A(A[4:0]),\n        .B(B[4:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_5bit S2(\n        .A(A[5]),\n        .B(B[5]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_5bit(A, B, Diff, B_out);\n    input A;              // 5-bit input A\n    input B;              // 5-bit input B\n    output Diff;          // 5-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [4:0] S1_out;    // 4-bit output from subtraction block 1\n    wire [4:0] S2_out;    // 4-bit output from subtraction block 2\n    wire [5:0] B_out_int; // Internal borrow-out\n\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_4bit S2(\n        .A(A[4]),\n        .B(B[4]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input A;              // 4-bit input A\n    input B;              // 4-bit input B\n    output Diff;          // 4-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [3:0] S1_out;    // 3-bit output from subtraction block 1\n    wire [3:0] S2_out;    // 3-bit output from subtraction block 2\n    wire [4:0] B_out_int; // Internal borrow-out\n\n    sub_3bit S1(\n        .A(A[2:0]),\n        .B(B[2:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_3bit S2(\n        .A(A[3]),\n        .B(B[3]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_3bit(A, B, Diff, B_out);\n    input A;              // 3-bit input A\n    input B;              // 3-bit input B\n    output Diff;          // 3-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [2:0] S1_out;    // 2-bit output from subtraction block 1\n    wire [2:0] S2_out;    // 2-bit output from subtraction block 2\n    wire [3:0] B_out_int; // Internal borrow-out\n\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_2bit S2(\n        .A(A[2]),\n        .B(B[2]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input A;              // 2-bit input A\n    input B;              // 2-bit input B\n    output Diff;          // 2-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [1:0] S1_out;    // 1-bit output from subtraction block 1\n    wire [1:0] S2_out;    // 1-bit output from subtraction block 2\n    wire [2:0] B_out_int; // Internal borrow-out\n\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S1_out),\n        .B_out(B_out_int)\n    );\n\n    sub_1bit S2(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output Diff;          // 1-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [0:0] S1_out;    // 1-bit output from subtraction block 1\n    wire [0:0] S2_out;    // 1-bit output from subtraction block 2\n    wire [1:0] B_out_int; // Internal borrow-out\n\n    assign S1_out = A ^ B;\n    assign S2_out = S1_out[0];\n    assign B_out = B_out_int[0];\n\n    assign Diff = {S2_out, S1_out};\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] comp0, comp1, comp2, comp3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(comp0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(comp1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(comp2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(comp3)\n    );\n\n    assign equal = comp0 & comp1 & comp2 & comp3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate the arithmetic operation stages\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end\n        else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            valid = 0;\n            result = 0;\n        end\n        else begin\n            valid = 1;\n            result = a / b;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal_8;\n\n    // Instantiate 8-bit comparators\n    comparator_8 comp8_inst1 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_8[0])\n    );\n\n    comparator_8 comp8_inst2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_8[1])\n    );\n\n    comparator_8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_8[2])\n    );\n\n    comparator_8 comp8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_8[3])\n    );\n\n    // Combine 8-bit comparator outputs\n    assign equal = |equal_8;\nendmodule\n\nmodule comparator_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [3:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparator submodules\n    comp8 comp8_inst1 (\n        .a(a_lo),\n        .b(b_lo),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a_lo),\n        .b(b_hi),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst3 (\n        .a(a_hi),\n        .b(b_lo),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst4 (\n        .a(a_hi),\n        .b(b_hi),\n        .equal(equal_hi)\n    );\n\n    // Combine results from each 8-bit comparator\n    assign equal = (equal_lo[3] & equal_lo[2] & equal_lo[1] & equal_lo[0]) |\n                   (equal_hi[3] & equal_hi[2] & equal_hi[1] & equal_hi[0]);\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [7:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each 8-bit section\n    comp8 comp8_inst1 (\n        .a(a_lo),\n        .b(b_lo),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a_hi),\n        .b(b_hi),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst4 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_hi)\n    );\n\n    // Combine the results of each 8-bit comparator\n    assign equal = equal_lo & equal_hi;\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n    wire add_valid, sub_valid, mul_valid, div_valid;\n\n    // Instantiate the arithmetic operation modules\n    adder add_module(\n        .clk(clk),\n        .rst(rst),\n        .data_a(data_a),\n        .data_b(data_b),\n        .result(add_result),\n        .valid(add_valid)\n    );\n\n    subtractor sub_module(\n        .clk(clk),\n        .rst(rst),\n        .data_a(data_a),\n        .data_b(data_b),\n        .result(sub_result),\n        .valid(sub_valid)\n    );\n\n    multiplier mul_module(\n        .clk(clk),\n        .rst(rst),\n        .data_a(data_a),\n        .data_b(data_b),\n        .result(mul_result),\n        .valid(mul_valid)\n    );\n\n    divider div_module(\n        .clk(clk),\n        .rst(rst),\n        .data_a(data_a),\n        .data_b(data_b),\n        .result(div_result),\n        .valid(div_valid)\n    );\n\n    // Select the operation based on the opcode input\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case(opcode)\n                2'b00: begin // Addition\n                    result <= add_result;\n                    valid <= add_valid;\n                end\n                2'b01: begin // Subtraction\n                    result <= sub_result;\n                    valid <= sub_valid;\n                end\n                2'b10: begin // Multiplication\n                    result <= mul_result;\n                    valid <= mul_valid;\n                end\n                2'b11: begin // Division\n                    result <= div_result;\n                    valid <= div_valid;\n                end\n                default: begin\n                    result <= 0;\n                    valid <= 0;\n                end\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input clk,\n    input rst,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= data_a + data_b;\n            valid <= 1;\n        end\n    end\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input clk,\n    input rst,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= data_a - data_b;\n            valid <= 1;\n        end\n    end\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= data_a * data_b;\n            valid <= 1;\n        end\n    end\nendmodule\n\n// Divider module\nmodule divider(\n    input clk,\n    input rst,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else if (data_b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= data_a / data_b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;  // 16-bit difference from first subtractor\n\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .B_out(B_out_16),\n        .Diff(Diff_16)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    assign Diff = {Diff_16, B_out_16}; // Combine differences and borrow-outs\nendmodule\n\nmodule sub_16bit(A, B, B_out, Diff);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output B_out;         // Borrow-out output\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out from first subtractor\n    wire [7:0] Diff_8;    // 8-bit difference from first subtractor\n\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .B_out(B_out_8),\n        .Diff(Diff_8)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    assign Diff = {Diff_8, B_out_8}; // Combine differences and borrow-outs\nendmodule\n\nmodule sub_8bit(A, B, B_out, Diff);\n    input [7:0] A;       // 8-bit input operand A\n    input [7:0] B;       // 8-bit input operand B\n    output B_out;        // Borrow-out output\n    output [7:0] Diff;   // 8-bit output representing the difference of A and B\n\n    wire [3:0] B_out_4;  // 4-bit borrow-out from first subtractor\n    wire [3:0] Diff_4;   // 4-bit difference from first subtractor\n\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .B_out(B_out_4),\n        .Diff(Diff_4)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    assign Diff = {Diff_4, B_out_4}; // Combine differences and borrow-outs\nendmodule\n\nmodule sub_4bit(A, B, B_out, Diff);\n    input [3:0] A;       // 4-bit input operand A\n    input [3:0] B;       // 4-bit input operand B\n    output B_out;        // Borrow-out output\n    output [3:0] Diff;   // 4-bit output representing the difference of A and B\n\n    wire [1:0] B_out_2;  // 2-bit borrow-out from first subtractor\n    wire [1:0] Diff_2;   // 2-bit difference from first subtractor\n\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .B_out(B_out_2),\n        .Diff(Diff_2)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    assign Diff = {Diff_2, B_out_2}; // Combine differences and borrow-outs\nendmodule\n\nmodule sub_2bit(A, B, B_out, Diff);\n    input [1:0] A;       // 2-bit input operand A\n    input [1:0] B;       // 2-bit input operand B\n    output B_out;        // Borrow-out output\n    output [1:0] Diff;   // 2-bit output representing the difference of A and B\n\n    wire B_out_1;        // 1-bit borrow-out from first subtractor\n    wire Diff_1;         // 1-bit difference from first subtractor\n\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .B_out(B_out_1),\n        .Diff(Diff_1)\n    );\n\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .B_out(B_out),\n        .Diff(Diff)\n    );\n\n    assign Diff = {Diff_1, B_out_1}; // Combine differences and borrow-outs\nendmodule\n\nmodule sub_1bit(A, B, B_out, Diff);\n    input A;             // 1-bit input operand A\n    input B;             // 1-bit input operand B\n    output B_out;        // Borrow-out output\n    output Diff;         // 1-bit output representing the difference of A and B\n\n    assign B_out = ~(A ^ B); // Borrow-out logic\n    assign Diff = A ^ B;     // Difference logic\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] a_lo, a_hi, b_lo, b_hi;\n    wire [3:0] equal_lo, equal_hi;\n\n    // Instantiate 8-bit comparators for each 8-bit section\n    comp8 comp8_inst1 (\n        .a(a_lo),\n        .b(b_lo),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst2 (\n        .a(a_lo),\n        .b(b_hi),\n        .equal(equal_lo)\n    );\n    comp8 comp8_inst3 (\n        .a(a_hi),\n        .b(b_lo),\n        .equal(equal_hi)\n    );\n    comp8 comp8_inst4 (\n        .a(a_hi),\n        .b(b_hi),\n        .equal(equal_hi)\n    );\n\n    // Combine results from each 8-bit comparator\n    assign equal = (equal_lo[0] & equal_lo[1] & equal_lo[2] & equal_lo[3])\n                  | (equal_lo[0] & equal_lo[1] & equal_lo[2] & equal_lo[3])\n                  | (equal_hi[0] & equal_hi[1] & equal_hi[2] & equal_hi[3]);\n\nendmodule\n\nmodule comp8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] comp0, comp1, comp2, comp3;\n\n    // Instantiate 8-bit comparators\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(comp0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(comp1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(comp2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(comp3)\n    );\n\n    // Combine results\n    assign equal = comp0 & comp1 & comp2 & comp3;\nendmodule\n\nmodule comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result, sub_result, mul_result, div_result;\n\n    // Instantiate arithmetic modules\n    adder add_module (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select operation based on opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result = 0;\n            valid = 0;\n        end else begin\n            result = a / b;\n            valid = 1;\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire [7:0] equal_8;\n\n    // Instantiate 8-bit comparators\n    comparator_8 comp8_inst1 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_8[0])\n    );\n\n    comparator_8 comp8_inst2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_8[1])\n    );\n\n    comparator_8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_8[2])\n    );\n\n    comparator_8 comp8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_8[3])\n    );\n\n    // Combine 8-bit comparator results\n    assign equal = |equal_8;\nendmodule\n\nmodule comparator_8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate arithmetic modules\n    adder add_module(.a(data_a), .b(data_b), .result(add_result));\n    subtractor sub_module(.a(data_a), .b(data_b), .result(sub_result));\n    multiplier mul_module(.a(data_a), .b(data_b), .result(mul_result));\n    divider div_module(.a(data_a), .b(data_b), .result(div_result), .valid(valid));\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            valid = 0;\n            result = 0;\n        end else begin\n            valid = 1;\n            result = a / b;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`timescale 1ns/1ps\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n\n    // Instantiate the arithmetic operation modules\n    adder add_module(\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    subtractor sub_module(\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    multiplier mul_module(\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    divider div_module(\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(valid)\n    );\n\n    // Select the operation based on opcode\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            case (opcode)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= mul_result;\n                2'b11: result <= div_result;\n                default: result <= 0;\n            endcase\n        end\n    end\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Divider module\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    assign result = a / b;\n    assign valid = (b != 0);\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // 16-bit subtraction output from S1\n    wire [15:0] S2_out;   // 16-bit subtraction output from S2\n    wire B1_out;          // 16-bit borrow-out from S1\n    wire B2_out;          // 16-bit borrow-out from S2\n\n    // Instantiate 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [7:0] S1_out;    // 8-bit subtraction output from S1\n    wire [7:0] S2_out;    // 8-bit subtraction output from S2\n    wire B1_out;          // 8-bit borrow-out from S1\n    wire B2_out;          // 8-bit borrow-out from S2\n\n    // Instantiate 8-bit subtractor blocks\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input A\n    input [7:0] B;        // 8-bit input B\n    output [7:0] Diff;    // 8-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:0] S1_out;    // 4-bit subtraction output from S1\n    wire [3:0] S2_out;    // 4-bit subtraction output from S2\n    wire B1_out;          // 4-bit borrow-out from S1\n    wire B2_out;          // 4-bit borrow-out from S2\n\n    // Instantiate 4-bit subtractor blocks\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;        // 4-bit input A\n    input [3:0] B;        // 4-bit input B\n    output [3:0] Diff;    // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [1:0] S1_out;    // 2-bit subtraction output from S1\n    wire [1:0] S2_out;    // 2-bit subtraction output from S2\n    wire B1_out;          // 2-bit borrow-out from S1\n    wire B2_out;          // 2-bit borrow-out from S2\n\n    // Instantiate 2-bit subtractor blocks\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;        // 2-bit input A\n    input [1:0] B;        // 2-bit input B\n    output [1:0] Diff;    // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [0:0] S1_out;    // 1-bit subtraction output from S1\n    wire [0:0] S2_out;    // 1-bit subtraction output from S2\n    wire B1_out;          // 1-bit borrow-out from S1\n    wire B2_out;          // 1-bit borrow-out from S2\n\n    // Instantiate 1-bit subtractor blocks\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(S1_out),\n        .B_out(B1_out)\n    );\n\n    sub_1bit S2(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(S2_out),\n        .B_out(B2_out)\n    );\n\n    // Combine outputs\n    assign Diff = {S2_out, S1_out};\n    assign B_out = B1_out | B2_out;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output Diff;          // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    assign Diff = A - B;\n    assign B_out = (A < B);\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, lui_result;\n    wire [31:0] sllv_result, srlv_result, srav_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, lui_carry;\n    wire [31:0] sllv_carry, srlv_carry, srav_carry;\n    wire [31:0] add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, lui_zero;\n    wire [31:0] sllv_zero, srlv_zero, srav_zero;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, lui_negative;\n    wire [31:0] sllv_negative, srlv_negative, srav_negative;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, lui_overflow;\n    wire [31:0] sllv_overflow, srlv_overflow, srav_overflow;\n    wire [31:0] add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, lui_flag;\n    wire [31:0] sllv_flag, srlv_flag, srav_flag;\n\n    // Instantiate submodules\n    add_sub add(.a(a), .b(b), .r(add_result), .carry(add_carry), .zero(add_zero), .negative(add_negative), .overflow(add_overflow));\n    add_sub addu(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .zero(sub_zero), .negative(sub_negative), .overflow(sub_overflow));\n    logic_logic and1(.a(a), .b(b), .r(and_result), .carry(and_carry), .zero(and_zero), .negative(and_negative), .overflow(and_overflow));\n    logic_logic or1(.a(a), .b(b), .r(or_result), .carry(or_carry), .zero(or_zero), .negative(or_negative), .overflow(or_overflow));\n    logic_logic xor1(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .zero(xor_zero), .negative(xor_negative), .overflow(xor_overflow));\n    logic_logic nor1(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .zero(nor_zero), .negative(nor_negative), .overflow(nor_overflow));\n    slt_sltu slt(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .zero(slt_zero), .negative(slt_negative), .overflow(slt_overflow));\n    slt_sltu sltu(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .zero(sltu_zero), .negative(sltu_negative), .overflow(sltu_overflow));\n    shift_shift sll(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .zero(sll_zero), .negative(sll_negative), .overflow(sll_overflow));\n    shift_shift srl(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .zero(srl_zero), .negative(srl_negative), .overflow(srl_overflow));\n    shift_shift sra(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .zero(sra_zero), .negative(sra_negative), .overflow(sra_overflow));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .zero(lui_zero), .negative(lui_negative), .overflow(lui_overflow));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .zero(sllv_zero), .negative(sllv_negative), .overflow(sllv_overflow));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .zero(srlv_zero), .negative(srlv_negative), .overflow(srlv_overflow));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .zero(srav_zero), .negative(srav_negative), .overflow(srav_overflow));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? addu_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? subu_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 1'b0;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? addu_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? subu_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  (aluc == 6'b001111) ? lui_zero : 1'b0;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? addu_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? subu_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      (aluc == 6'b001111) ? lui_negative : 1'b0;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? addu_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? subu_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? slt_flag :\n                  (aluc == 6'b101011) ? sltu_flag :\n                  1'b0;\n\nendmodule\n\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = ((a[31] == 1'b1) && (b[31] == 1'b0) && (r[31] == 1'b0)) || ((a[31] == 1'b0) && (b[31] == 1'b1) && (r[31] == 1'b1));\nendmodule\n\nmodule logic_logic(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule shift_shift(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule slt_sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 32'b1 : 32'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {12'b0, b};\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output zero,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\n\nadder add_module(\n    .a(data_a),\n    .b(data_b),\n    .result(add_result)\n);\n\nsubtractor sub_module(\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result)\n);\n\nmultiplier mul_module(\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result)\n);\n\ndivider div_module(\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(valid)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        valid <= 0;\n    end else begin\n        case (opcode)\n            `ADD_OP: begin\n                result <= add_result;\n                valid <= 1;\n            end\n            `SUB_OP: begin\n                result <= sub_result;\n                valid <= 1;\n            end\n            `MUL_OP: begin\n                result <= mul_result;\n                valid <= 1;\n            end\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 0;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule multiplier(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule divider(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] result,\n    output reg valid\n);\n    always @* begin\n        if (b == 0) begin\n            result <= 0;\n            valid <= 0;\n        end else begin\n            result <= a / b;\n            valid <= 1;\n        end\n    end\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff_16;   // 16-bit difference from first subtractor\n\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    assign B_out = B_out_16;\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out from first subtractor\n    wire [7:0] Diff_8;    // 8-bit difference from first subtractor\n\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;       // 8-bit input A\n    input [7:0] B;       // 8-bit input B\n    output [7:0] Diff;   // 8-bit output Diff\n    output B_out;        // Borrow-out output\n\n    wire [3:0] B_out_4;  // 4-bit borrow-out from first subtractor\n    wire [3:0] Diff_4;   // 4-bit difference from first subtractor\n\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff_4),\n        .B_out(B_out_4)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    assign B_out = B_out_4;\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;       // 4-bit input A\n    input [3:0] B;       // 4-bit input B\n    output [3:0] Diff;   // 4-bit output Diff\n    output B_out;        // Borrow-out output\n\n    wire [1:0] B_out_2;  // 2-bit borrow-out from first subtractor\n    wire [1:0] Diff_2;   // 2-bit difference from first subtractor\n\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff_2),\n        .B_out(B_out_2)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    assign B_out = B_out_2;\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;       // 2-bit input A\n    input [1:0] B;       // 2-bit input B\n    output [1:0] Diff;   // 2-bit output Diff\n    output B_out;        // Borrow-out output\n\n    wire [0] B_out_1;    // 1-bit borrow-out from first subtractor\n    wire [0] Diff_1;     // 1-bit difference from first subtractor\n\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff_1),\n        .B_out(B_out_1)\n    );\n\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    assign B_out = B_out_1;\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;       // 1-bit input A\n    input B;       // 1-bit input B\n    output Diff;   // 1-bit output Diff\n    output B_out;  // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out16;  // 16-bit borrow-out from first subtractor\n    wire [15:0] Diff16;   // 16-bit difference from first subtractor\n\n    // Instantiate two 16-bit subtractors\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff16),\n        .B_out(B_out16)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[31:16]),\n        .B_out(B_out)\n    );\n\n    // Combine the 16-bit differences to get the final 32-bit difference\n    assign Diff = {Diff16, B_out16};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output Diff\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out8;    // 8-bit borrow-out from first subtractor\n    wire [7:0] Diff8;     // 8-bit difference from first subtractor\n\n    // Instantiate two 8-bit subtractors\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff8),\n        .B_out(B_out8)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[15:8]),\n        .B_out(B_out)\n    );\n\n    // Combine the 8-bit differences to get the final 16-bit difference\n    assign Diff = {Diff8, B_out8};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;         // 8-bit input A\n    input [7:0] B;         // 8-bit input B\n    output [7:0] Diff;     // 8-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [3:0] B_out4;     // 4-bit borrow-out from first subtractor\n    wire [3:0] Diff4;      // 4-bit difference from first subtractor\n\n    // Instantiate two 4-bit subtractors\n    sub_4bit S1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff4),\n        .B_out(B_out4)\n    );\n\n    sub_4bit S2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[7:4]),\n        .B_out(B_out)\n    );\n\n    // Combine the 4-bit differences to get the final 8-bit difference\n    assign Diff = {Diff4, B_out4};\n\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;         // 4-bit input A\n    input [3:0] B;         // 4-bit input B\n    output [3:0] Diff;     // 4-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire [1:0] B_out2;     // 2-bit borrow-out from first subtractor\n    wire [1:0] Diff2;      // 2-bit difference from first subtractor\n\n    // Instantiate two 2-bit subtractors\n    sub_2bit S1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff2),\n        .B_out(B_out2)\n    );\n\n    sub_2bit S2(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff[3:2]),\n        .B_out(B_out)\n    );\n\n    // Combine the 2-bit differences to get the final 4-bit difference\n    assign Diff = {Diff2, B_out2};\n\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;         // 2-bit input A\n    input [1:0] B;         // 2-bit input B\n    output [1:0] Diff;     // 2-bit output Diff\n    output B_out;          // Borrow-out output\n\n    wire B_out1;           // 1-bit borrow-out from first subtractor\n    wire Diff1;            // 1-bit difference from first subtractor\n\n    // Instantiate two 1-bit subtractors\n    sub_1bit S1(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff1),\n        .B_out(B_out1)\n    );\n\n    sub_1bit S2(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff),\n        .B_out(B_out)\n    );\n\n    // Combine the 1-bit differences to get the final 2-bit difference\n    assign Diff = {Diff1, B_out1};\n\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    output Diff;           // 1-bit output Diff\n    output B_out;          // Borrow-out output\n\n    assign Diff = A ^ B;   // XOR operation\n    assign B_out = ~(A & B); // Borrow-out logic\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input A\n    input [31:0] B;       // 32-bit input B\n    output [31:0] Diff;   // 32-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_16; // 16-bit borrow-out\n    wire [15:0] Diff_16;   // 16-bit difference\n\n    // Instantiate 16-bit subtractor blocks\n    sub_16bit S1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(Diff_16),\n        .B_out(B_out_16)\n    );\n\n    sub_16bit S2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(Diff[31:16]),\n        .B_out(B_out)\n    );\n\n    // Assign difference\n    assign Diff = {Diff_16, B_out_16};\n\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input A\n    input [15:0] B;       // 16-bit input B\n    output [15:0] Diff;   // 16-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out_8;   // 8-bit borrow-out\n    wire [7:0] Diff_8;    // 8-bit difference\n\n    // Instantiate 8-bit subtractor blocks\n    sub_8bit S1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff_8),\n        .B_out(B_out_8)\n    );\n\n    sub_8bit S2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[15:8]),\n        .B_out(B_out)\n    );\n\n    // Assign difference\n    assign Diff = {Diff_8, B_out_8};\n\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input A\n    input [7:0] B;        // 8-bit input B\n    output [7:0] Diff;    // 8-bit output difference\n    output B_out;         // Borrow-out output\n\n    // Subtract A and B\n    assign {B_out, Diff} = A - B;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;       // 32-bit input operand A\n    input [31:0] B;       // 32-bit input operand B\n    output [31:0] Diff;   // 32-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] S1_out;   // Output from the 16-bit subtractor for the high 16 bits\n    wire [15:0] S2_out;   // Output from the 16-bit subtractor for the low 16 bits\n    wire [15:0] B_out_s;   // Output from the 16-bit subtractor for the borrow\n\n    sub_16bit S1(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .Diff(S1_out),\n        .B_out(B_out_s)\n    );\n\n    sub_16bit S2(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .Diff(S2_out),\n        .B_out(B_out)\n    );\n\n    assign Diff = {S2_out, S1_out};\nendmodule\n\nmodule sub_16bit(A, B, Diff, B_out);\n    input [15:0] A;       // 16-bit input operand A\n    input [15:0] B;       // 16-bit input operand B\n    output [15:0] Diff;   // 16-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [15:0] B_out_s;  // Output from the 8-bit subtractor for the high 8 bits\n\n    sub_8bit S1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Diff(Diff[15:8]),\n        .B_out(B_out_s)\n    );\n\n    sub_8bit S2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Diff(Diff[7:0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_8bit(A, B, Diff, B_out);\n    input [7:0] A;        // 8-bit input operand A\n    input [7:0] B;        // 8-bit input operand B\n    output [7:0] Diff;    // 8-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [7:0] B_out_s;   // Output from the 4-bit subtractor for the high 4 bits\n\n    sub_4bit S1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Diff(Diff[7:4]),\n        .B_out(B_out_s)\n    );\n\n    sub_4bit S2(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Diff(Diff[3:0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_4bit(A, B, Diff, B_out);\n    input [3:0] A;        // 4-bit input operand A\n    input [3:0] B;        // 4-bit input operand B\n    output [3:0] Diff;    // 4-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire [3:0] B_out_s;   // Output from the 2-bit subtractor for the high 2 bits\n\n    sub_2bit S1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .Diff(Diff[3:2]),\n        .B_out(B_out_s)\n    );\n\n    sub_2bit S2(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .Diff(Diff[1:0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_2bit(A, B, Diff, B_out);\n    input [1:0] A;        // 2-bit input operand A\n    input [1:0] B;        // 2-bit input operand B\n    output [1:0] Diff;    // 2-bit output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    wire B_out_s;         // Output from the 1-bit subtractor for the high bit\n\n    sub_1bit S1(\n        .A(A[1]),\n        .B(B[1]),\n        .Diff(Diff[1]),\n        .B_out(B_out_s)\n    );\n\n    sub_1bit S2(\n        .A(A[0]),\n        .B(B[0]),\n        .Diff(Diff[0]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub_1bit(A, B, Diff, B_out);\n    input A;              // Input operand A\n    input B;              // Input operand B\n    output Diff;          // Output representing the difference of A and B\n    output B_out;         // Borrow-out output\n\n    assign Diff = A ^ B;\n    assign B_out = A & B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8;\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(B_out_32), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8;\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A, B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A, B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_8};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A, B;\n    output B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire [31:0] add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire [31:0] add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire [31:0] add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .negative(add_negative), .zero(add_zero));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .carry(add_carry), .overflow(add_overflow), .negative(add_negative), .zero(add_zero));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .negative(sub_negative), .zero(sub_zero));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .carry(sub_carry), .overflow(sub_overflow), .negative(sub_negative), .zero(sub_zero));\n    and and_inst(.a(a), .b(b), .r(and_result), .carry(and_carry), .overflow(and_overflow), .negative(and_negative), .zero(and_zero));\n    or or_inst(.a(a), .b(b), .r(or_result), .carry(or_carry), .overflow(or_overflow), .negative(or_negative), .zero(or_zero));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .carry(xor_carry), .overflow(xor_overflow), .negative(xor_negative), .zero(xor_zero));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .carry(nor_carry), .overflow(nor_overflow), .negative(nor_negative), .zero(nor_zero));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .carry(slt_carry), .overflow(slt_overflow), .negative(slt_negative), .zero(slt_zero));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .carry(sltu_carry), .overflow(sltu_overflow), .negative(sltu_negative), .zero(sltu_zero));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .carry(sll_carry), .overflow(sll_overflow), .negative(sll_negative), .zero(sll_zero));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .carry(srl_carry), .overflow(srl_overflow), .negative(srl_negative), .zero(srl_zero));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .carry(sra_carry), .overflow(sra_overflow), .negative(sra_negative), .zero(sra_zero));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .carry(sllv_carry), .overflow(sllv_overflow), .negative(sllv_negative), .zero(sllv_zero));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .carry(srlv_carry), .overflow(srlv_overflow), .negative(srlv_negative), .zero(srlv_zero));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .carry(srav_carry), .overflow(srav_overflow), .negative(srav_negative), .zero(srav_zero));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .carry(lui_carry), .overflow(lui_overflow), .negative(lui_negative), .zero(lui_zero));\n\n    // Select result based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign carry = (aluc == 6'b100000) ? add_carry :\n                   (aluc == 6'b100001) ? add_carry :\n                   (aluc == 6'b100010) ? sub_carry :\n                   (aluc == 6'b100011) ? sub_carry :\n                   (aluc == 6'b100100) ? and_carry :\n                   (aluc == 6'b100101) ? or_carry :\n                   (aluc == 6'b100110) ? xor_carry :\n                   (aluc == 6'b100111) ? nor_carry :\n                   (aluc == 6'b101010) ? slt_carry :\n                   (aluc == 6'b101011) ? sltu_carry :\n                   (aluc == 6'b000000) ? sll_carry :\n                   (aluc == 6'b000010) ? srl_carry :\n                   (aluc == 6'b000011) ? sra_carry :\n                   (aluc == 6'b000100) ? sllv_carry :\n                   (aluc == 6'b000110) ? srlv_carry :\n                   (aluc == 6'b000111) ? srav_carry :\n                   (aluc == 6'b001111) ? lui_carry : 1'b0;\n\n    assign zero = (aluc == 6'b100000) ? add_zero :\n                  (aluc == 6'b100001) ? add_zero :\n                  (aluc == 6'b100010) ? sub_zero :\n                  (aluc == 6'b100011) ? sub_zero :\n                  (aluc == 6'b100100) ? and_zero :\n                  (aluc == 6'b100101) ? or_zero :\n                  (aluc == 6'b100110) ? xor_zero :\n                  (aluc == 6'b100111) ? nor_zero :\n                  (aluc == 6'b101010) ? slt_zero :\n                  (aluc == 6'b101011) ? sltu_zero :\n                  (aluc == 6'b000000) ? sll_zero :\n                  (aluc == 6'b000010) ? srl_zero :\n                  (aluc == 6'b000011) ? sra_zero :\n                  (aluc == 6'b000100) ? sllv_zero :\n                  (aluc == 6'b000110) ? srlv_zero :\n                  (aluc == 6'b000111) ? srav_zero :\n                  (aluc == 6'b001111) ? lui_zero : 1'b0;\n\n    assign negative = (aluc == 6'b100000) ? add_negative :\n                      (aluc == 6'b100001) ? add_negative :\n                      (aluc == 6'b100010) ? sub_negative :\n                      (aluc == 6'b100011) ? sub_negative :\n                      (aluc == 6'b100100) ? and_negative :\n                      (aluc == 6'b100101) ? or_negative :\n                      (aluc == 6'b100110) ? xor_negative :\n                      (aluc == 6'b100111) ? nor_negative :\n                      (aluc == 6'b101010) ? slt_negative :\n                      (aluc == 6'b101011) ? sltu_negative :\n                      (aluc == 6'b000000) ? sll_negative :\n                      (aluc == 6'b000010) ? srl_negative :\n                      (aluc == 6'b000011) ? sra_negative :\n                      (aluc == 6'b000100) ? sllv_negative :\n                      (aluc == 6'b000110) ? srlv_negative :\n                      (aluc == 6'b000111) ? srav_negative :\n                      (aluc == 6'b001111) ? lui_negative : 1'b0;\n\n    assign overflow = (aluc == 6'b100000) ? add_overflow :\n                      (aluc == 6'b100001) ? add_overflow :\n                      (aluc == 6'b100010) ? sub_overflow :\n                      (aluc == 6'b100011) ? sub_overflow :\n                      (aluc == 6'b100100) ? and_overflow :\n                      (aluc == 6'b100101) ? or_overflow :\n                      (aluc == 6'b100110) ? xor_overflow :\n                      (aluc == 6'b100111) ? nor_overflow :\n                      (aluc == 6'b101010) ? slt_overflow :\n                      (aluc == 6'b101011) ? sltu_overflow :\n                      (aluc == 6'b000000) ? sll_overflow :\n                      (aluc == 6'b000010) ? srl_overflow :\n                      (aluc == 6'b000011) ? sra_overflow :\n                      (aluc == 6'b000100) ? sllv_overflow :\n                      (aluc == 6'b000110) ? srlv_overflow :\n                      (aluc == 6'b000111) ? srav_overflow :\n                      (aluc == 6'b001111) ? lui_overflow : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = (((a[31] == 1'b1) && (b[31] == 1'b0) && (r[31] == 1'b0)) ||\n                       ((a[31] == 1'b0) && (b[31] == 1'b1) && (r[31] == 1'b1)));\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = (((a[31] == 1'b1) && (b[31] == 1'b0) && (r[31] == 1'b0)) ||\n                       ((a[31] == 1'b0) && (b[31] == 1'b1) && (r[31] == 1'b1)));\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = (((a[31] == 1'b1) && (b[31] == 1'b0) && (r[31] == 1'b0)) ||\n                       ((a[31] == 1'b0) && (b[31] == 1'b1) && (r[31] == 1'b1)));\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = (((a[31] == 1'b1) && (b[31] == 1'b0) && (r[31] == 1'b0)) ||\n                       ((a[31] == 1'b0) && (b[31] == 1'b1) && (r[31] == 1'b1)));\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output carry,\n    output overflow,\n    output negative,\n    output zero\n);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1'b1);\n    assign overflow = 1'b0;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] A_high, B_high, D_high;\n    wire [15:0] A_low, B_low, D_low;\n    wire [7:0] A_high_low, B_high_low, D_high_low;\n    wire [7:0] A_high_high, B_high_high, D_high_high;\n\n    sub32 sub0(\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D_high),\n        .B_out(B_high)\n    );\n\n    sub32 sub1(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub16 sub2(\n        .A(A_high),\n        .B(B_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub16 sub3(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub4(\n        .A(A_high_high),\n        .B(B_high_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub8 sub5(\n        .A(A_high_low),\n        .B(B_high_low),\n        .D(D_high_low),\n        .B_out(B_high_low)\n    );\n\n    sub8 sub6(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub7(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] A_high, B_high, D_high;\n    wire [7:0] A_low, B_low, D_low;\n    wire [7:0] A_high_low, B_high_low, D_high_low;\n    wire [7:0] A_high_high, B_high_high, D_high_high;\n\n    sub16 sub0(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D_high),\n        .B_out(B_high)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub2(\n        .A(A_high),\n        .B(B_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub8 sub3(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub4(\n        .A(A_high_high),\n        .B(B_high_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub8 sub5(\n        .A(A_high_low),\n        .B(B_high_low),\n        .D(D_high_low),\n        .B_out(B_high_low)\n    );\n\n    sub8 sub6(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub7(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] A_high, B_high, D_high;\n    wire [7:0] A_low, B_low, D_low;\n    wire [7:0] A_high_low, B_high_low, D_high_low;\n    wire [7:0] A_high_high, B_high_high, D_high_high;\n\n    sub8 sub0(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D_high),\n        .B_out(B_high)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub2(\n        .A(A_high),\n        .B(B_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub8 sub3(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub4(\n        .A(A_high_high),\n        .B(B_high_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub8 sub5(\n        .A(A_high_low),\n        .B(B_high_low),\n        .D(D_high_low),\n        .B_out(B_high_low)\n    );\n\n    sub8 sub6(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub8 sub7(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [3:0] A_high, B_high, D_high;\n    wire [1:0] A_low, B_low, D_low;\n    wire [1:0] A_high_low, B_high_low, D_high_low;\n    wire [1:0] A_high_high, B_high_high, D_high_high;\n\n    sub2 sub0(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D_high),\n        .B_out(B_high)\n    );\n\n    sub2 sub1(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub2 sub2(\n        .A(A_high),\n        .B(B_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub2 sub3(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub2 sub4(\n        .A(A_high_high),\n        .B(B_high_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub2 sub5(\n        .A(A_high_low),\n        .B(B_high_low),\n        .D(D_high_low),\n        .B_out(B_high_low)\n    );\n\n    sub2 sub6(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub2 sub7(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [3:0] A;\n    input [3:0] B;\n    output [3:0] D;\n    output B_out;\n\n    wire [1:0] A_high, B_high, D_high;\n    wire [1:0] A_low, B_low, D_low;\n    wire [1:0] A_high_low, B_high_low, D_high_low;\n    wire [1:0] A_high_high, B_high_high, D_high_high;\n\n    sub2 sub0(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D_high),\n        .B_out(B_high)\n    );\n\n    sub2 sub1(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub2 sub2(\n        .A(A_high),\n        .B(B_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub2 sub3(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub2 sub4(\n        .A(A_high_high),\n        .B(B_high_high),\n        .D(D_high_high),\n        .B_out(B_high_high)\n    );\n\n    sub2 sub5(\n        .A(A_high_low),\n        .B(B_high_low),\n        .D(D_high_low),\n        .B_out(B_high_low)\n    );\n\n    sub2 sub6(\n        .A(A_low),\n        .B(B_low),\n        .D(D_low),\n        .B_out(B_low)\n    );\n\n    sub2 sub7(\n        .A(A[1:0]),\n        .B(B[1:0]),\n        .D(D[1:0]),\n        .B_out(B_out)\n    );\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add_sub add(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow));\n    add_sub addu(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow));\n    and_or_xor and(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow));\n    and_or_xor or(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow));\n    and_or_xor xor(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow));\n    and_or_xor nor(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow));\n    slt_sltu slt(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow));\n    slt_sltu sltu(.a(a), .b(b), .r(sltu_result), .zero(sltu_zero), .carry(sltu_carry), .negative(sltu_negative), .overflow(sltu_overflow));\n    shift_left_right sll(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow));\n    shift_left_right srl(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow));\n    shift_left_right sra(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow));\n    shift_left_right sllv(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow));\n    shift_left_right srlv(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow));\n    shift_left_right srav(.a(a), .b(b), .r(srav_result), .zero(srav_zero), .carry(srav_carry), .negative(srav_negative), .overflow(srav_overflow));\n    lui lui(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select result based on opcode\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || addu_carry || slt_carry || sltu_carry || sllv_carry || srlv_carry || srav_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow || sub_overflow || slt_overflow || sltu_overflow || sllv_overflow || srlv_overflow || srav_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] :\n                  0;\n\nendmodule\n\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) || ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\nendmodule\n\nmodule and_or_xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt_sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule shift_left_right(\n    input [31:0] a,\n    input [5:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b == 0) ? a : (b[5] == 1) ? {a[31:0], {b[4:0] +: 6'b0}} : {a[31:b], {b[5:0] +: 6'b0}};\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [5:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[5:0], 6'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8[0];\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A, B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A, B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B[7:0]};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A, B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub_32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub_16 sub1_1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub_16 sub1_2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_16)\n    );\n\n    sub_8 sub2_1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_2(\n        .A(A[31:8]),\n        .B(B[31:8]),\n        .D(D[31:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_3(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2_4(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_32, B_out_16, B_out_8};\nendmodule\n\nmodule sub_32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub_16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub_16 sub2(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_16)\n    );\n\n    sub_8 sub3_1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub3_2(\n        .A(A[31:8]),\n        .B(B[31:8]),\n        .D(D[31:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub3_3(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub3_4(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_16, B_out_8};\nendmodule\n\nmodule sub_16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub_8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub2(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .B_out(B_out_8)\n    );\n\n    sub_8 sub3(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub_8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(B_out_32), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8[7];\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A, B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A, B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_8};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A, B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    and and_inst(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow), .flag(and_flag));\n    or or_inst(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow), .flag(or_flag));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow), .flag(xor_flag));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow), .flag(nor_flag));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow), .flag(slt_flag));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .zero(sltu_zero), .carry(sltu_carry), .negative(sltu_negative), .overflow(sltu_overflow), .flag(sltu_flag));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow), .flag(sll_flag));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow), .flag(srl_flag));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow), .flag(sra_flag));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow), .flag(sllv_flag));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow), .flag(srlv_flag));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .zero(srav_zero), .carry(srav_carry), .negative(srav_negative), .overflow(srav_overflow), .flag(srav_flag));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow), .flag(lui_flag));\n\n    // Select result based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry | sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow | sub_overflow);\n    assign flag = (slt_flag | sltu_flag);\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) || ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\n    assign flag = 1'b0;\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 1) && (b[31] == 0) && (r[31] == 1)) || ((a[31] == 0) && (b[31] == 1) && (r[31] == 0)));\n    assign flag = 1'b0;\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 0) && (b[31] == 1) && (r[31] == 0)) || ((a[31] == 1) && (b[31] == 0) && (r[31] == 1)));\n    assign flag = 1'b0;\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (((a[31] == 0) && (b[31] == 1) && (r[31] == 0)) || ((a[31] == 1) && (b[31] == 0) && (r[31] == 1)));\n    assign flag = 1'b0;\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = (a < b) ? 1'b1 : 1'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\n    assign flag = 1'b0;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(B_out_32), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8[0];\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A, B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(B_out_16), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A, B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B[7:0]};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A, B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16, B_out_32};\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = {B_out_8};\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub32 sub1(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n\n    sub16 sub2(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub16 sub3(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n\n    sub8 sub4(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n    sub8 sub5(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub2(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub16 sub3(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n\n    sub8 sub4(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n    sub8 sub5(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub6(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n    sub8 sub7(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .D(D[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_16[15] | B_out_8[7];\n\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .D(D[7:0]), .B_out(B_out_8));\n\n    assign B_out = B_out_8[7];\n\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A, B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out_32)\n    );\n\n    sub16 sub1(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub2(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = B_out_32[31] | B_out_16[15] | B_out_8[7];\nendmodule\n\nmodule sub32(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .B_out(B_out_16)\n    );\n\n    sub8 sub1(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = B_out_16[15] | B_out_8[7];\nendmodule\n\nmodule sub16(A, B, D, B_out);\n    input [15:0] A, B;\n    output [15:0] D;\n    output B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_8)\n    );\n\n    assign B_out = B_out_8[7];\nendmodule\n\nmodule sub8(A, B, D, B_out);\n    input [7:0] A, B;\n    output [7:0] D;\n    output B_out;\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;\n    input [63:0] B;\n    output [63:0] D;\n    output B_out;\n\n    wire [31:0] B_out_32;\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub32 sub0(.A(A[31:0]), .B(B[31:0]), .B_out(B_out_32));\n    sub16 sub1(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub2(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign D = {B_out_8, B_out_16, B_out_32};\n    assign B_out = B_out_8[0];\nendmodule\n\nmodule sub32(A, B, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] B_out;\n\n    wire [15:0] B_out_16;\n    wire [7:0] B_out_8;\n\n    sub16 sub0(.A(A[15:0]), .B(B[15:0]), .B_out(B_out_16));\n    sub8 sub1(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_16};\nendmodule\n\nmodule sub16(A, B, B_out);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] B_out;\n\n    wire [7:0] B_out_8;\n\n    sub8 sub0(.A(A[7:0]), .B(B[7:0]), .B_out(B_out_8));\n\n    assign B_out = {B_out_8, B_out_8};\nendmodule\n\nmodule sub8(A, B, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] B_out;\n\n    assign B_out = A - B;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    addu addu_inst(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow), .flag(add_flag));\n    sub sub_inst(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    subu subu_inst(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow), .flag(sub_flag));\n    and and_inst(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow), .flag(and_flag));\n    or or_inst(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow), .flag(or_flag));\n    xor xor_inst(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow), .flag(xor_flag));\n    nor nor_inst(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow), .flag(nor_flag));\n    slt slt_inst(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow), .flag(slt_flag));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result), .zero(sltu_zero), .carry(sltu_carry), .negative(sltu_negative), .overflow(sltu_overflow), .flag(sltu_flag));\n    sll sll_inst(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow), .flag(sll_flag));\n    srl srl_inst(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow), .flag(srl_flag));\n    sra sra_inst(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow), .flag(sra_flag));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow), .flag(sllv_flag));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow), .flag(srlv_flag));\n    srav srav_inst(.a(a), .b(b), .r(srav_result), .zero(srav_zero), .carry(srav_carry), .negative(srav_negative), .overflow(srav_overflow), .flag(srav_flag));\n    lui lui_inst(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow), .flag(lui_flag));\n\n    // Select operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? addu_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? subu_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               lui_result;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || sub_carry);\n    assign negative = (r[31]);\n    assign overflow = (add_overflow || sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_flag : (aluc == 6'b101011) ? sltu_flag : 1'b0;\n\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule addu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] != b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule subu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (a[31] != b[31] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule\n\nmodule or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule\n\nmodule xor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule\n\nmodule nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = (a < b) ? 32'b1 : 32'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = (a < b) ? 32'b1 : 32'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule\n\nmodule sll(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (b[4] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule srl(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (b[4] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule sra(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (b[4] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule sllv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (b[4] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule srlv(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (b[4] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule srav(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = (b[4] && r[31] != a[31]);\n    assign flag = 1'b0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    assign {carry, r} = {b[4:0], 27'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31]);\n    assign overflow = 1'b0;\n    assign flag = 1'b0;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(16'b0),\n        .D(D[16:1]),\n        .B_out(b_out[3:0])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out[3:0]),\n        .D(D[12:1]),\n        .B_out(b_out[2:0])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out[2:0]),\n        .D(D[8:1]),\n        .B_out(b_out[1:0])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[1:0]),\n        .D(D[4:1]),\n        .B_out(b_out[0])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[3];\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input [2:0] C_in;     // 3-bit carry-in\n    output [4:1] D;       // 4-bit output D\n    output B_out;         // 1-bit borrow-out\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(C_in[2:0]),\n        .D(D[4:1]),\n        .B_out(b_out[3:0])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(b_out[3:0]),\n        .D(D[2:1]),\n        .B_out(b_out[2:0])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[1];\n\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input [1:0] C_in;     // 2-bit carry-in\n    output [2:1] D;       // 2-bit output D\n    output B_out;         // 1-bit borrow-out\n\n    wire [1:0] b_out;     // 2-bit borrow-out\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in[1:0]),\n        .D(D[2:1]),\n        .B_out(b_out[1:0])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[0];\n\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    input [0:0] C_in;     // 1-bit carry-in\n    output [1:1] D;       // 1-bit output D\n    output B_out;         // 1-bit borrow-out\n\n    // Instantiate 1-bit subtractor\n    assign {B_out, D[1:1]} = A[1:1] - B[1:1] - C_in[0:0];\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] B_out_4;   // 4-bit borrow-out outputs\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .D(D[16:1]),\n        .B_out(B_out_4[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(B_out_4[1:1]),\n        .D(D[12:1]),\n        .B_out(B_out_4[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(B_out_4[2:2]),\n        .D(D[8:1]),\n        .B_out(B_out_4[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(B_out_4[3:3]),\n        .D(D[4:1]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [5:1] temp;      // Temporary sum\n\n    // Perform subtraction\n    assign temp[1:1] = A[1:1] - B[1:1] - C_in;\n    assign temp[2:2] = A[2:2] - B[2:2] - temp[1:1];\n    assign temp[3:3] = A[3:3] - B[3:3] - temp[2:2];\n    assign temp[4:4] = A[4:4] - B[4:4] - temp[3:3];\n    assign temp[5:5] = A[5:5] - B[5:5] - temp[4:4];\n\n    // Assign outputs\n    assign D = temp[4:1];\n    assign B_out = temp[5:5];\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] B_out_sub; // 4-bit borrow-out from each submodule\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .D(D[16:1]),\n        .B_out(B_out_sub[1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(B_out_sub[1]),\n        .D(D[12:1]),\n        .B_out(B_out_sub[2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(B_out_sub[2]),\n        .D(D[8:1]),\n        .B_out(B_out_sub[3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(B_out_sub[3]),\n        .D(D[4:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [5:1] temp;      // Temporary sum\n    wire C_out;           // Carry-out\n\n    // Perform subtraction\n    assign {C_out, temp} = A - B + C_in;\n\n    // Assign outputs\n    assign D = temp[4:1];\n    assign B_out = temp[5];\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result;\n    wire [31:0] sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(add_result));\n    addu addu_inst(.a(a), .b(b), .r(sub_result));\n    sub sub_inst(.a(a), .b(b), .r(sub_result));\n    and and_inst(.a(a), .b(b), .r(and_result));\n    or or_inst(.a(a), .b(b), .r(or_result));\n    xor xor_inst(.a(a), .b(b), .r(xor_result));\n    nor nor_inst(.a(a), .b(b), .r(nor_result));\n    slt slt_inst(.a(a), .b(b), .r(slt_result));\n    sltu sltu_inst(.a(a), .b(b), .r(sltu_result));\n    sll sll_inst(.a(a), .b(b), .r(sll_result));\n    srl srl_inst(.a(a), .b(b), .r(srl_result));\n    sra sra_inst(.a(a), .b(b), .r(sra_result));\n    sllv sllv_inst(.a(a), .b(b), .r(sllv_result));\n    srlv srlv_inst(.a(a), .b(b), .r(srlv_result));\n    srav srav_inst(.a(a), .b(b), .r(srav_result));\n    lui lui_inst(.a(a), .r(lui_result));\n\n    // Select result based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? sub_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               lui_result;\n\n    // Compute flags\n    assign zero = r == 32'b0;\n    assign carry = (add_result[31] == 1) || (sub_result[31] == 1);\n    assign negative = r[31];\n    assign overflow = (add_result[31] == sub_result[31]) && (add_result[31] != r[31]);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a & b;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a | b;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a ^ b;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = ~(a | b);\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 32'b1 : 32'b0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 32'b1 : 32'b0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule sllv(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srlv(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule srav(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule lui(input [31:0] a, output [31:0] r);\n    assign r = {12'b0, a[15:0]};\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit submodules\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .C_in(b_out[3:3]),\n        .D(D[12:8]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .C_in(b_out[2:2]),\n        .D(D[8:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[1:1]),\n        .D(D[4:1]),\n        .B_out(b_out[0:0])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[3:0];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:1] D;       // 4-bit output D\n    output B_out;         // Borrow-out\n\n    wire [2:1] b_out;     // 3-bit borrow-out\n\n    // Instantiate 2-bit submodules\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[2:2])\n    );\n\n    sub2 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[2:2]),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[2:1];\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] D;       // 2-bit output D\n    output B_out;         // Borrow-out\n\n    wire [1:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 1-bit submodules\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[1:1];\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in\n    output D;             // 1-bit output D\n    output B_out;         // Borrow-out\n\n    assign {B_out, D} = A - B - C_in;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] borrow;    // Borrow output from each sub-block\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .D(D[16:4]),\n        .B_out(borrow[1])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .D(D[12:8]),\n        .B_out(borrow[2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .D(D[8:4]),\n        .B_out(borrow[3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(borrow[4])\n    );\n\n    // Combine borrows to get final borrow-out\n    assign B_out = borrow[1] | borrow[2] | borrow[3] | borrow[4];\nendmodule\n\nmodule sub4(A, B, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    output [3:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] borrow;    // Borrow output from each sub-block\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .D(D[3:2]),\n        .B_out(borrow[1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(borrow[2])\n    );\n\n    // Combine borrows to get final borrow-out\n    assign B_out = borrow[1] | borrow[2];\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire borrow;          // Borrow output from each sub-block\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(borrow)\n    );\n\n    // Combine borrows to get final borrow-out\n    assign B_out = borrow;\nendmodule\n\nmodule sub1(A, B, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    output D;             // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] b_out_sub1;\n    wire [4:1] b_out_sub2;\n    wire [4:1] b_out_sub3;\n    wire [4:1] b_out_sub4;\n\n    // Instantiate 4-bit submodules for each nibble\n    sub4_bit sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .D(D[16:1]),\n        .B_out(b_out_sub1)\n    );\n\n    sub4_bit sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out_sub1[4:1]),\n        .D(D[12:1]),\n        .B_out(b_out_sub2)\n    );\n\n    sub4_bit sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out_sub2[4:1]),\n        .D(D[8:1]),\n        .B_out(b_out_sub3)\n    );\n\n    sub4_bit sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out_sub3[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out_sub4)\n    );\n\n    // Output borrow-out\n    assign B_out = b_out_sub4[4];\nendmodule\n\nmodule sub4_bit(A, B, C_in, D, B_out);\n    input [4:1] A;         // 4-bit input A\n    input [4:1] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [4:1] D;        // 4-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [4:1] b_out;      // Internal borrow-out\n\n    // Instantiate 2-bit submodules for each nibble\n    sub2_bit sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(C_in),\n        .D(D[4:1]),\n        .B_out(b_out[4:1])\n    );\n\n    sub2_bit sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(b_out[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out[2:1])\n    );\n\n    sub2_bit sub3(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1];\nendmodule\n\nmodule sub2_bit(A, B, C_in, D, B_out);\n    input [2:1] A;         // 2-bit input A\n    input [2:1] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [2:1] D;        // 2-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire [2:1] b_out;      // Internal borrow-out\n\n    // Instantiate 1-bit submodule for each nibble\n    sub1_bit sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .D(D[2:1]),\n        .B_out(b_out[2:1])\n    );\n\n    sub1_bit sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1];\nendmodule\n\nmodule sub1_bit(A, B, C_in, D, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output D;              // 1-bit difference output\n    output B_out;          // Borrow-out output\n\n    wire b_out;            // Internal borrow-out\n\n    // Subtract A and B with carry-in\n    assign {B_out, D} = A - B - C_in;\nendmodule"}
{"task_id": "alu", "response": "wire [31:0] result;\n    wire [31:0] result_slt, result_sltu;\n    wire [31:0] result_sll, result_srl, result_sra;\n    wire [31:0] result_sllv, result_srlv, result_srav;\n    wire [31:0] result_lui;\n    wire [31:0] result_and, result_or, result_xor, result_nor;\n    wire [31:0] result_add, result_addu, result_sub, result_subu;\n    wire [31:0] result_slt_flag, result_sltu_flag;\n\n    // Instantiate submodules\n    add add_inst(.a(a), .b(b), .r(result_add));\n    addu addu_inst(.a(a), .b(b), .r(result_addu));\n    sub sub_inst(.a(a), .b(b), .r(result_sub));\n    subu subu_inst(.a(a), .b(b), .r(result_subu));\n    and and_inst(.a(a), .b(b), .r(result_and));\n    or or_inst(.a(a), .b(b), .r(result_or));\n    xor xor_inst(.a(a), .b(b), .r(result_xor));\n    nor nor_inst(.a(a), .b(b), .r(result_nor));\n    slt slt_inst(.a(a), .b(b), .r(result_slt));\n    sltu sltu_inst(.a(a), .b(b), .r(result_sltu));\n    sll sll_inst(.a(a), .b(b), .r(result_sll));\n    srl srl_inst(.a(a), .b(b), .r(result_srl));\n    sra sra_inst(.a(a), .b(b), .r(result_sra));\n    sllv sllv_inst(.a(a), .b(b), .r(result_sllv));\n    srlv srlv_inst(.a(a), .b(b), .r(result_srlv));\n    srav srav_inst(.a(a), .b(b), .r(result_srav));\n    lui lui_inst(.a(a), .r(result_lui));\n\n    // Select result based on aluc\n    assign r = (aluc == 6'b100000) ? result_add :\n               (aluc == 6'b100001) ? result_addu :\n               (aluc == 6'b100010) ? result_sub :\n               (aluc == 6'b100011) ? result_subu :\n               (aluc == 6'b100100) ? result_and :\n               (aluc == 6'b100101) ? result_or :\n               (aluc == 6'b100110) ? result_xor :\n               (aluc == 6'b100111) ? result_nor :\n               (aluc == 6'b101010) ? result_slt_flag :\n               (aluc == 6'b101011) ? result_sltu_flag :\n               (aluc == 6'b000000) ? result_sll :\n               (aluc == 6'b000010) ? result_srl :\n               (aluc == 6'b000011) ? result_sra :\n               (aluc == 6'b000100) ? result_sllv :\n               (aluc == 6'b000110) ? result_srlv :\n               (aluc == 6'b000111) ? result_srav :\n               (aluc == 6'b001111) ? result_lui : 32'b0;\n\n    // Compute flags\n    assign zero = r == 32'b0;\n    assign carry = (aluc == 6'b100000) ? (result_add[31] ^ result_add[30]) :\n                   (aluc == 6'b100001) ? (result_addu[31] ^ result_addu[30]) :\n                   (aluc == 6'b100010) ? (result_sub[31] ^ result_sub[30]) :\n                   (aluc == 6'b100011) ? (result_subu[31] ^ result_subu[30]) :\n                   (aluc == 6'b100100) ? (result_and == 32'b0) :\n                   (aluc == 6'b100101) ? (result_or == 32'b0) :\n                   (aluc == 6'b100110) ? (result_xor == 32'b0) :\n                   (aluc == 6'b100111) ? (result_nor == 32'b0) :\n                   (aluc == 6'b101010) ? (result_slt_flag == 32'b0) :\n                   (aluc == 6'b101011) ? (result_sltu_flag == 32'b0) :\n                   (aluc == 6'b000000) ? (result_sll == 32'b0) :\n                   (aluc == 6'b000010) ? (result_srl == 32'b0) :\n                   (aluc == 6'b000011) ? (result_sra == 32'b0) :\n                   (aluc == 6'b000100) ? (result_sllv == 32'b0) :\n                   (aluc == 6'b000110) ? (result_srlv == 32'b0) :\n                   (aluc == 6'b000111) ? (result_srav == 32'b0) :\n                   (aluc == 6'b001111) ? (result_lui == 32'b0) : 1'b0;\n\n    assign negative = r[31];\n    assign overflow = (aluc == 6'b100000) ? (result_add[31] ^ result_add[30]) :\n                      (aluc == 6'b100001) ? (result_addu[31] ^ result_addu[30]) :\n                      (aluc == 6'b100010) ? (result_sub[31] ^ result_sub[30]) :\n                      (aluc == 6'b100011) ? (result_subu[31] ^ result_subu[30]) :\n                      (aluc == 6'b100100) ? (result_and[31] ^ result_and[30]) :\n                      (aluc == 6'b100101) ? (result_or[31] ^ result_or[30]) :\n                      (aluc == 6'b100110) ? (result_xor[31] ^ result_xor[30]) :\n                      (aluc == 6'b100111) ? (result_nor[31] ^ result_nor[30]) :\n                      (aluc == 6'b101010) ? (result_slt_flag[31] ^ result_slt_flag[30]) :\n                      (aluc == 6'b101011) ? (result_sltu_flag[31] ^ result_sltu_flag[30]) :\n                      (aluc == 6'b000000) ? (result_sll[31] ^ result_sll[30]) :\n                      (aluc == 6'b000010) ? (result_srl[31] ^ result_srl[30]) :\n                      (aluc == 6'b000011) ? (result_sra[31] ^ result_sra[30]) :\n                      (aluc == 6'b000100) ? (result_sllv[31] ^ result_sllv[30]) :\n                      (aluc == 6'b000110) ? (result_srlv[31] ^ result_srlv[30]) :\n                      (aluc == 6'b000111) ? (result_srav[31] ^ result_srav[30]) :\n                      (aluc == 6'b001111) ? (result_lui[31] ^ result_lui[30]) : 1'b0;\n\n    assign flag = (aluc == 6'b101010) ? result_slt_flag :\n                   (aluc == 6'b101011) ? result_sltu_flag : 1'b0;\n\nendmodule\n\nmodule add(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule addu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a + b;\nendmodule\n\nmodule sub(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule subu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a - b;\nendmodule\n\nmodule and(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a & b;\nendmodule\n\nmodule or(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a | b;\nendmodule\n\nmodule xor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a ^ b;\nendmodule\n\nmodule nor(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = ~(a | b);\nendmodule\n\nmodule slt(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 32'b1 : 32'b0;\nendmodule\n\nmodule sltu(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = (a < b) ? 32'b1 : 32'b0;\nendmodule\n\nmodule sll(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srl(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule sra(input [31:0] a, input [4:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule sllv(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a << b;\nendmodule\n\nmodule srlv(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = a >> b;\nendmodule\n\nmodule srav(input [31:0] a, input [31:0] b, output [31:0] r);\n    assign r = $signed(a) >>> b;\nendmodule\n\nmodule lui(input [31:0] a, output [31:0] r);\n    assign r = {a[31:0], 1'b0};\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .D(D[16:1]),\n        .B_out(b_out)\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .D(D[12:1]),\n        .B_out(b_out[3:0])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .D(D[8:1]),\n        .B_out(b_out[7:4])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out[11:8])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[15];\nendmodule\n\nmodule sub4(A, B, D, B_out);\n    input [4:1] A;       // 4-bit input A\n    input [4:1] B;       // 4-bit input B\n    output [4:1] D;      // 4-bit difference output\n    output B_out;        // Borrow-out output\n\n    wire [2:0] b_out;    // 3-bit borrow-out\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out)\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out[2:0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[2];\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [2:1] A;       // 2-bit input A\n    input [2:1] B;       // 2-bit input B\n    output [2:1] D;      // 2-bit difference output\n    output B_out;        // Borrow-out output\n\n    wire [1:0] b_out;    // 2-bit borrow-out\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out)\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1];\nendmodule\n\nmodule sub1(A, B, D, B_out);\n    input [1:1] A;       // 1-bit input A\n    input [1:1] B;       // 1-bit input B\n    output [1:1] D;      // 1-bit difference output\n    output B_out;        // Borrow-out output\n\n    // Subtract and output borrow-out\n    assign {B_out, D} = A - B;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] B_out_sub; // 4-bit borrow-out from each submodule\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .D(D[16:1]),\n        .B_out(B_out_sub[1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(B_out_sub[1]),\n        .D(D[12:1]),\n        .B_out(B_out_sub[2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(B_out_sub[2]),\n        .D(D[8:1]),\n        .B_out(B_out_sub[3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(B_out_sub[3]),\n        .D(D[4:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire C;               // Carry output\n\n    // Instantiate full subtractor\n    full_subtractor full_sub(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .D(D),\n        .C_out(C),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule full_subtractor(A, B, C_in, D, C_out, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] D;       // 4-bit difference output\n    output C_out;         // Carry-out output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] sum;       // 4-bit sum\n    wire [4:1] diff;      // 4-bit difference\n    wire [4:1] carry;     // 4-bit carry\n\n    // Calculate sum and carry\n    assign sum = A + B;\n    assign carry = (A[4] & B[4]) | (A[4] & C_in) | (B[4] & C_in);\n\n    // Calculate difference and borrow\n    assign diff = sum - C_in;\n    assign B_out = (A[4] & ~B[4]) | (A[4] & ~C_in) | (B[4] & ~C_in);\n\n    // Assign outputs\n    assign D = diff;\n    assign C_out = carry;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:8]),\n        .B(B[12:8]),\n        .C_in(b_out[1:1]),\n        .D(D[12:8]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:4]),\n        .B(B[8:4]),\n        .C_in(b_out[2:2]),\n        .D(D[8:4]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[3:3]),\n        .D(D[4:1]),\n        .B_out(b_out[4:4])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[4:4];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;         // 4-bit input A\n    input [3:1] B;         // 4-bit input B\n    input C_in;            // Carry-in\n    output [3:1] D;        // 4-bit output D\n    output B_out;          // Borrow-out\n\n    wire [3:1] b_out;      // 4-bit borrow-out\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(b_out[1:1]),\n        .D(D[2:1]),\n        .B_out(b_out[2:2])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[2:2];\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;         // 2-bit input A\n    input [2:1] B;         // 2-bit input B\n    input C_in;            // Carry-in\n    output [2:1] D;        // 2-bit output D\n    output B_out;          // Borrow-out\n\n    wire [2:1] b_out;      // 2-bit borrow-out\n\n    // Instantiate 1-bit full subtractors\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .D(D[1:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out[1:1];\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;               // 1-bit input A\n    input B;               // 1-bit input B\n    input C_in;            // Carry-in\n    output D;              // 1-bit output D\n    output B_out;          // Borrow-out\n\n    assign {B_out, D} = A - B - C_in;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit submodules\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(16'b0),\n        .D(D[16:1]),\n        .B_out(b_out[3:0])\n    );\n\n    sub4 sub2(\n        .A(A[12:4]),\n        .B(B[12:4]),\n        .C_in(b_out[3:0]),\n        .D(D[12:4]),\n        .B_out(b_out[2:0])\n    );\n\n    sub4 sub3(\n        .A(A[8:8]),\n        .B(B[8:8]),\n        .C_in(b_out[2:0]),\n        .D(D[8:8]),\n        .B_out(b_out[1:0])\n    );\n\n    sub4 sub4(\n        .A(A[4:4]),\n        .B(B[4:4]),\n        .C_in(b_out[1:0]),\n        .D(D[4:4]),\n        .B_out(b_out[0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[3];\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input [1:0] C_in;     // 2-bit carry-in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:0] b_out;     // 3-bit borrow-out\n\n    // Instantiate 2-bit submodules\n    sub2 sub1(\n        .A(A[4:2]),\n        .B(B[4:2]),\n        .C_in(C_in[1:0]),\n        .D(D[4:2]),\n        .B_out(b_out[2:0])\n    );\n\n    sub2 sub2(\n        .A(A[2:2]),\n        .B(B[2:2]),\n        .C_in(b_out[2:0]),\n        .D(D[2:2]),\n        .B_out(b_out[1:0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1];\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input [1:0] C_in;     // 2-bit carry-in\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [1:0] b_out;     // 2-bit borrow-out\n\n    // Instantiate 1-bit submodules\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in[1:0]),\n        .D(D[2:1]),\n        .B_out(b_out[1:0])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[0];\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    input [1:0] C_in;     // 2-bit carry-in\n    output [1:1] D;       // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    // Instantiate 1-bit submodule\n    sub1_final sub1_final(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in[1:0]),\n        .D(D[1:1]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule sub1_final(A, B, C_in, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input [1:0] C_in;     // 2-bit carry-in\n    output D;             // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    // Subtract A and B with carry-in\n    assign {B_out, D} = A - B - C_in;\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, add_carry, add_negative, add_overflow;\n    wire sub_zero, sub_carry, sub_negative, sub_overflow;\n    wire and_zero, and_carry, and_negative, and_overflow;\n    wire or_zero, or_carry, or_negative, or_overflow;\n    wire xor_zero, xor_carry, xor_negative, xor_overflow;\n    wire nor_zero, nor_carry, nor_negative, nor_overflow;\n    wire slt_zero, slt_carry, slt_negative, slt_overflow;\n    wire sltu_zero, sltu_carry, sltu_negative, sltu_overflow;\n    wire sll_zero, sll_carry, sll_negative, sll_overflow;\n    wire srl_zero, srl_carry, srl_negative, srl_overflow;\n    wire sra_zero, sra_carry, sra_negative, sra_overflow;\n    wire sllv_zero, sllv_carry, sllv_negative, sllv_overflow;\n    wire srlv_zero, srlv_carry, srlv_negative, srlv_overflow;\n    wire srav_zero, srav_carry, srav_negative, srav_overflow;\n    wire lui_zero, lui_carry, lui_negative, lui_overflow;\n\n    // Instantiate submodules\n    add_submodule add(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow));\n    addu_submodule addu(.a(a), .b(b), .r(add_result), .zero(add_zero), .carry(add_carry), .negative(add_negative), .overflow(add_overflow));\n    sub_submodule sub(.a(a), .b(b), .r(sub_result), .zero(sub_zero), .carry(sub_carry), .negative(sub_negative), .overflow(sub_overflow));\n    and_submodule and1(.a(a), .b(b), .r(and_result), .zero(and_zero), .carry(and_carry), .negative(and_negative), .overflow(and_overflow));\n    or_submodule or1(.a(a), .b(b), .r(or_result), .zero(or_zero), .carry(or_carry), .negative(or_negative), .overflow(or_overflow));\n    xor_submodule xor1(.a(a), .b(b), .r(xor_result), .zero(xor_zero), .carry(xor_carry), .negative(xor_negative), .overflow(xor_overflow));\n    nor_submodule nor1(.a(a), .b(b), .r(nor_result), .zero(nor_zero), .carry(nor_carry), .negative(nor_negative), .overflow(nor_overflow));\n    slt_submodule slt(.a(a), .b(b), .r(slt_result), .zero(slt_zero), .carry(slt_carry), .negative(slt_negative), .overflow(slt_overflow));\n    sltu_submodule sltu(.a(a), .b(b), .r(sltu_result), .zero(sltu_zero), .carry(sltu_carry), .negative(sltu_negative), .overflow(sltu_overflow));\n    sll_submodule sll(.a(a), .b(b), .r(sll_result), .zero(sll_zero), .carry(sll_carry), .negative(sll_negative), .overflow(sll_overflow));\n    srl_submodule srl(.a(a), .b(b), .r(srl_result), .zero(srl_zero), .carry(srl_carry), .negative(srl_negative), .overflow(srl_overflow));\n    sra_submodule sra(.a(a), .b(b), .r(sra_result), .zero(sra_zero), .carry(sra_carry), .negative(sra_negative), .overflow(sra_overflow));\n    sllv_submodule sllv(.a(a), .b(b), .r(sllv_result), .zero(sllv_zero), .carry(sllv_carry), .negative(sllv_negative), .overflow(sllv_overflow));\n    srlv_submodule srlv(.a(a), .b(b), .r(srlv_result), .zero(srlv_zero), .carry(srlv_carry), .negative(srlv_negative), .overflow(srlv_overflow));\n    srav_submodule srav(.a(a), .b(b), .r(srav_result), .zero(srav_zero), .carry(srav_carry), .negative(srav_negative), .overflow(srav_overflow));\n    lui_submodule lui(.a(a), .b(b), .r(lui_result), .zero(lui_zero), .carry(lui_carry), .negative(lui_negative), .overflow(lui_overflow));\n\n    // Select operation based on control signal\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry || sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow || sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] : (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule addu_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule sub_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a - b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == 1 && b[31] == 0 && r[31] == 0);\nendmodule\n\nmodule and_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule or_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a | b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule xor_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule nor_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = ~(a | b);\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sltu_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 1 : 0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a << b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[4] == 1 && r[31] == a[31]);\nendmodule\n\nmodule srl_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a >> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[4] == 1 && r[31] == a[31]);\nendmodule\n\nmodule sra_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[4] == 1 && r[31] == a[31]);\nendmodule\n\nmodule sllv_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a << b[4:0];\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[5] == 1 && r[31] == a[31]);\nendmodule\n\nmodule srlv_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a >> b[4:0];\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[5] == 1 && r[31] == a[31]);\nendmodule\n\nmodule srav_submodule(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = $signed(a) >>> b[4:0];\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[5] == 1 && r[31] == a[31]);\nendmodule\n\nmodule lui_submodule(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[4:0], 26'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (b[4] == 1 && r[31] == a[31]);\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [4:1] B_out_4;   // 4-bit borrow-out from each submodule\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(1'b0),\n        .D(D[16:1]),\n        .B_out(B_out_4[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(B_out_4[1:1]),\n        .D(D[12:1]),\n        .B_out(B_out_4[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(B_out_4[2:2]),\n        .D(D[8:1]),\n        .B_out(B_out_4[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(B_out_4[3:3]),\n        .D(D[4:1]),\n        .B_out(B_out_4[4:4])\n    );\n\n    // Combine borrow-out outputs\n    assign B_out = B_out_4[4:1] | B_out_4[3:1] | B_out_4[2:1] | B_out_4[1:1];\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:1] B_out_3;   // 3-bit borrow-out from each submodule\n\n    // Instantiate 3-bit full subtractors\n    sub3 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(C_in),\n        .D(D[4:1]),\n        .B_out(B_out_3[1:1])\n    );\n\n    sub3 sub2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(B_out_3[1:1]),\n        .D(D[8:5]),\n        .B_out(B_out_3[2:2])\n    );\n\n    sub3 sub3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(B_out_3[2:2]),\n        .D(D[12:9]),\n        .B_out(B_out_3[3:3])\n    );\n\n    // Combine borrow-out outputs\n    assign B_out = B_out_3[3:1] | B_out_3[2:1] | B_out_3[1:1];\n\nendmodule\n\nmodule sub3(A, B, C_in, D, B_out);\n    input [3:1] A;        // 3-bit input A\n    input [3:1] B;        // 3-bit input B\n    input C_in;           // Carry-in\n    output [3:1] D;       // 3-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] B_out_2;   // 2-bit borrow-out from each submodule\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .C_in(C_in),\n        .D(D[3:1]),\n        .B_out(B_out_2[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[6:4]),\n        .B(B[6:4]),\n        .C_in(B_out_2[1:1]),\n        .D(D[6:4]),\n        .B_out(B_out_2[2:2])\n    );\n\n    sub2 sub3(\n        .A(A[9:7]),\n        .B(B[9:7]),\n        .C_in(B_out_2[2:2]),\n        .D(D[9:7]),\n        .B_out(B_out_2[3:3])\n    );\n\n    // Combine borrow-out outputs\n    assign B_out = B_out_2[3:1] | B_out_2[2:1] | B_out_2[1:1];\n\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [1:1] B_out_1;   // 1-bit borrow-out from each submodule\n\n    // Instantiate 1-bit full subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .D(D[2:1]),\n        .B_out(B_out_1[1:1])\n    );\n\n    sub1 sub2(\n        .A(A[4:3]),\n        .B(B[4:3]),\n        .C_in(B_out_1[1:1]),\n        .D(D[4:3]),\n        .B_out(B_out_1[2:2])\n    );\n\n    // Combine borrow-out outputs\n    assign B_out = B_out_1[2:1] | B_out_1[1:1];\n\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    input C_in;           // Carry-in\n    output [1:1] D;       // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    // Instantiate 1-bit full subtractor\n    full_subtractor sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .D(D[1:1]),\n        .B_out(B_out)\n    );\n\nendmodule\n\nmodule full_subtractor(A, B, C_in, D, B_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry-in\n    output D;             // Difference output\n    output B_out;         // Borrow-out output\n\n    assign {B_out, D} = A - B - C_in;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out;     // 4-bit borrow-out from each sub-block\n\n    // Instantiate 4-bit sub-blocks\n    sub4 sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .D(D[16:1]),\n        .B_out(b_out[3])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .D(D[12:1]),\n        .B_out(b_out[2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .D(D[8:1]),\n        .B_out(b_out[1])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out[0])\n    );\n\n    // Combine borrow-outs to get final borrow-out\n    assign B_out = b_out[3] | b_out[2] | b_out[1] | b_out[0];\n\nendmodule\n\nmodule sub4(A, B, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out from each sub-block\n\n    // Instantiate 2-bit sub-blocks\n    sub2 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .D(D[4:1]),\n        .B_out(b_out[1])\n    );\n\n    sub2 sub2(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out[0])\n    );\n\n    // Combine borrow-outs to get final borrow-out\n    assign B_out = b_out[1] | b_out[0];\n\nendmodule\n\nmodule sub2(A, B, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    output [2:1] D;       // 2-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out from each sub-block\n\n    // Instantiate 1-bit sub-blocks\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .D(D[2:1]),\n        .B_out(b_out)\n    );\n\n    // Combine borrow-outs to get final borrow-out\n    assign B_out = b_out;\n\nendmodule\n\nmodule sub1(A, B, D, B_out);\n    input [1:1] A;        // 1-bit input A\n    input [1:1] B;        // 1-bit input B\n    output [1:1] D;       // 1-bit difference output\n    output B_out;         // Borrow-out output\n\n    wire b_out;           // 1-bit borrow-out from each sub-block\n\n    // Instantiate 1-bit sub-blocks\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out)\n    );\n\n    // Combine borrow-outs to get final borrow-out\n    assign B_out = b_out;\n\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[1:1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out[1:1]),\n        .D(D[12:1]),\n        .B_out(b_out[2:2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out[2:2]),\n        .D(D[8:1]),\n        .B_out(b_out[3:3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[3:3]),\n        .D(D[4:1]),\n        .B_out(b_out[4:4])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[4:4];\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;        // 4-bit input A\n    input [3:1] B;        // 4-bit input B\n    input C_in;           // Carry-in\n    output [3:1] D;       // 4-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [2:1] b_out;     // 2-bit borrow-out\n\n    // Instantiate 2-bit full subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[1:1])\n    );\n\n    sub2 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1:1]),\n        .D(D[1:1]),\n        .B_out(b_out[2:2])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[2:2];\n\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;        // 2-bit input A\n    input [2:1] B;        // 2-bit input B\n    input C_in;           // Carry-in\n    output [2:1] D;       // 2-bit output difference\n    output B_out;         // Borrow-out output\n\n    wire [1:1] b_out;     // 1-bit borrow-out\n\n    // Instantiate 1-bit full subtractors\n    sub1 sub1(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .C_in(C_in),\n        .D(D[2:1]),\n        .B_out(b_out[1:1])\n    );\n\n    // Output borrow-out\n    assign B_out = b_out[1:1];\n\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;              // 1-bit input A\n    input B;              // 1-bit input B\n    input C_in;           // Carry-in\n    output D;             // 1-bit output difference\n    output B_out;         // Borrow-out output\n\n    assign {B_out, D} = A - B - C_in;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_zero, add_carry, add_negative, add_overflow;\n    wire sub_zero, sub_carry, sub_negative, sub_overflow;\n    wire and_zero, and_carry, and_negative, and_overflow;\n    wire or_zero, or_carry, or_negative, or_overflow;\n    wire xor_zero, xor_carry, xor_negative, xor_overflow;\n    wire nor_zero, nor_carry, nor_negative, nor_overflow;\n    wire slt_zero, slt_carry, slt_negative, slt_overflow;\n    wire sltu_zero, sltu_carry, sltu_negative, sltu_overflow;\n    wire sll_zero, sll_carry, sll_negative, sll_overflow;\n    wire srl_zero, srl_carry, srl_negative, srl_overflow;\n    wire sra_zero, sra_carry, sra_negative, sra_overflow;\n    wire sllv_zero, sllv_carry, sllv_negative, sllv_overflow;\n    wire srlv_zero, srlv_carry, srlv_negative, srlv_overflow;\n    wire srav_zero, srav_carry, srav_negative, srav_overflow;\n    wire lui_zero, lui_carry, lui_negative, lui_overflow;\n\n    // Instantiate submodules\n    add_sub addu(\n        .a(a),\n        .b(b),\n        .r(add_result),\n        .zero(add_zero),\n        .carry(add_carry),\n        .negative(add_negative),\n        .overflow(add_overflow)\n    );\n\n    add_sub sub(\n        .a(a),\n        .b(b),\n        .r(sub_result),\n        .zero(sub_zero),\n        .carry(sub_carry),\n        .negative(sub_negative),\n        .overflow(sub_overflow)\n    );\n\n    and_or and1(\n        .a(a),\n        .b(b),\n        .r(and_result),\n        .zero(and_zero),\n        .carry(and_carry),\n        .negative(and_negative),\n        .overflow(and_overflow)\n    );\n\n    and_or or1(\n        .a(a),\n        .b(b),\n        .r(or_result),\n        .zero(or_zero),\n        .carry(or_carry),\n        .negative(or_negative),\n        .overflow(or_overflow)\n    );\n\n    xor_nor xor1(\n        .a(a),\n        .b(b),\n        .r(xor_result),\n        .zero(xor_zero),\n        .carry(xor_carry),\n        .negative(xor_negative),\n        .overflow(xor_overflow)\n    );\n\n    xor_nor nor1(\n        .a(a),\n        .b(b),\n        .r(nor_result),\n        .zero(nor_zero),\n        .carry(nor_carry),\n        .negative(nor_negative),\n        .overflow(nor_overflow)\n    );\n\n    slt_sltu slt(\n        .a(a),\n        .b(b),\n        .r(slt_result),\n        .zero(slt_zero),\n        .carry(slt_carry),\n        .negative(slt_negative),\n        .overflow(slt_overflow)\n    );\n\n    slt_sltu sltu(\n        .a(a),\n        .b(b),\n        .r(sltu_result),\n        .zero(sltu_zero),\n        .carry(sltu_carry),\n        .negative(sltu_negative),\n        .overflow(sltu_overflow)\n    );\n\n    sll_srl_sra sll(\n        .a(a),\n        .b(b),\n        .r(sll_result),\n        .zero(sll_zero),\n        .carry(sll_carry),\n        .negative(sll_negative),\n        .overflow(sll_overflow)\n    );\n\n    sll_srl_sra srl(\n        .a(a),\n        .b(b),\n        .r(srl_result),\n        .zero(srl_zero),\n        .carry(srl_carry),\n        .negative(srl_negative),\n        .overflow(srl_overflow)\n    );\n\n    sll_srl_sra sra(\n        .a(a),\n        .b(b),\n        .r(sra_result),\n        .zero(sra_zero),\n        .carry(sra_carry),\n        .negative(sra_negative),\n        .overflow(sra_overflow)\n    );\n\n    lui lui_inst(\n        .a(a),\n        .b(b),\n        .r(lui_result),\n        .zero(lui_zero),\n        .carry(lui_carry),\n        .negative(lui_negative),\n        .overflow(lui_overflow)\n    );\n\n    // Select the operation based on aluc\n    assign r = (aluc == 6'b100000) ? add_result :\n               (aluc == 6'b100001) ? add_result :\n               (aluc == 6'b100010) ? sub_result :\n               (aluc == 6'b100011) ? sub_result :\n               (aluc == 6'b100100) ? and_result :\n               (aluc == 6'b100101) ? or_result :\n               (aluc == 6'b100110) ? xor_result :\n               (aluc == 6'b100111) ? nor_result :\n               (aluc == 6'b101010) ? slt_result :\n               (aluc == 6'b101011) ? sltu_result :\n               (aluc == 6'b000000) ? sll_result :\n               (aluc == 6'b000010) ? srl_result :\n               (aluc == 6'b000011) ? sra_result :\n               (aluc == 6'b000100) ? sllv_result :\n               (aluc == 6'b000110) ? srlv_result :\n               (aluc == 6'b000111) ? srav_result :\n               (aluc == 6'b001111) ? lui_result : 32'b0;\n\n    // Compute flags\n    assign zero = (r == 32'b0);\n    assign carry = (add_carry | sub_carry);\n    assign negative = (r[31] == 1);\n    assign overflow = (add_overflow | sub_overflow);\n    assign flag = (aluc == 6'b101010) ? slt_result[31] :\n                  (aluc == 6'b101011) ? sltu_result[31] : 1'b0;\n\nendmodule\n\nmodule add_sub(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a + b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = (a[31] == b[31] && r[31] != a[31]);\nendmodule\n\nmodule and_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a & b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule xor_nor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = a ^ b;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule slt_sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (a < b) ? 32'b1 : 32'b0;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule sll_srl_sra(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = (b == 0) ? a : (b[4:0] == 0) ? a : (b[4:0] == 1) ? {a[31], a[31:1]} : (b[4:0] == 2) ? {a[31:2], 2'b00} : (b[4:0] == 3) ? {a[31:3], 3'b000} : (b[4:0] == 4) ? {a[31:4], 4'b0000} : (b[4:0] == 5) ? {a[31:5], 5'b00000} : (b[4:0] == 6) ? {a[31:6], 6'b000000} : (b[4:0] == 7) ? {a[31:7], 7'b0000000} : (b[4:0] == 8) ? {a[31:8], 8'b00000000} : (b[4:0] == 9) ? {a[31:9], 9'b000000000} : (b[4:0] == 10) ? {a[31:10], 10'b0000000000} : (b[4:0] == 11) ? {a[31:11], 11'b00000000000} : (b[4:0] == 12) ? {a[31:12], 12'b000000000000} : (b[4:0] == 13) ? {a[31:13], 13'b0000000000000} : (b[4:0] == 14) ? {a[31:14], 14'b00000000000000} : (b[4:0] == 15) ? {a[31:15], 15'b000000000000000} : (b[4:0] == 16) ? {a[31:16], 16'b0000000000000000} : (b[4:0] == 17) ? {a[31:17], 17'b00000000000000000} : (b[4:0] == 18) ? {a[31:18], 18'b000000000000000000} : (b[4:0] == 19) ? {a[31:19], 19'b0000000000000000000} : (b[4:0] == 20) ? {a[31:20], 20'b00000000000000000000} : (b[4:0] == 21) ? {a[31:21], 21'b000000000000000000000} : (b[4:0] == 22) ? {a[31:22], 22'b0000000000000000000000} : (b[4:0] == 23) ? {a[31:23], 23'b00000000000000000000000} : (b[4:0] == 24) ? {a[31:24], 24'b000000000000000000000000} : (b[4:0] == 25) ? {a[31:25], 25'b0000000000000000000000000} : (b[4:0] == 26) ? {a[31:26], 26'b00000000000000000000000000} : (b[4:0] == 27) ? {a[31:27], 27'b000000000000000000000000000} : (b[4:0] == 28) ? {a[31:28], 28'b0000000000000000000000000000} : (b[4:0] == 29) ? {a[31:29], 29'b00000000000000000000000000000} : (b[4:0] == 30) ? {a[31:30], 30'b000000000000000000000000000000} : (b[4:0] == 31) ? {a[31:31], 31'b0000000000000000000000000000000} : 32'b0;\n    assign zero = (r == 32'b0);\n    assign carry = 0;\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule\n\nmodule lui(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow\n);\n    assign {carry, r} = {b[30:20], 12'b0} | a;\n    assign zero = (r == 32'b0);\n    assign negative = (r[31] == 1);\n    assign overflow = 0;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit output D\n    output B_out;         // Borrow-out output\n\n    wire [3:0] b_out_0;   // 4-bit borrow-out from submodule 0\n    wire [3:0] b_out_1;   // 4-bit borrow-out from submodule 1\n    wire [3:0] b_out_2;   // 4-bit borrow-out from submodule 2\n    wire [3:0] b_out_3;   // 4-bit borrow-out from submodule 3\n\n    // Instantiate 4-bit submodules\n    sub4_bit sub1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .C_in(4'b0000),\n        .D(D[16:1]),\n        .B_out(b_out_0)\n    );\n\n    sub4_bit sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out_0),\n        .D(D[12:1]),\n        .B_out(b_out_1)\n    );\n\n    sub4_bit sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out_1),\n        .D(D[8:1]),\n        .B_out(b_out_2)\n    );\n\n    sub4_bit sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out_2),\n        .D(D[4:1]),\n        .B_out(b_out_3)\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out_3;\nendmodule\n\nmodule sub4_bit(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input [3:1] C_in;     // 4-bit carry-in\n    output [4:1] D;       // 4-bit output D\n    output [3:1] B_out;   // 4-bit borrow-out\n\n    wire [3:1] b_out;     // 4-bit borrow-out\n\n    // Instantiate 4-bit full subtractor\n    full_subtractor sub(\n        .A(A),\n        .B(B),\n        .C_in(C_in),\n        .D(D),\n        .B_out(b_out)\n    );\n\n    // Output the borrow-out\n    assign B_out = b_out;\nendmodule\n\nmodule full_subtractor(A, B, C_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input [3:1] C_in;     // 4-bit carry-in\n    output [4:1] D;       // 4-bit output D\n    output [3:1] B_out;   // 4-bit borrow-out\n\n    wire [4:1] diff;     // 4-bit difference\n    wire [3:1] carry;    // 4-bit carry-out\n\n    // Calculate difference and carry\n    assign diff = A - B;\n    assign carry = (diff[4] == 1) ? C_in : 4'b0000;\n    assign D = diff - {carry, 4'b0000};\n    assign B_out = carry;\nendmodule"}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;      // 16-bit input A\n    input [16:1] B;      // 16-bit input B\n    output [16:1] D;     // 16-bit difference output\n    output B_out;        // Borrow-out output\n\n    wire [3:1] b_out;    // 4-bit borrow-out from each sub-block\n\n    // Instantiate 4-bit subtractors\n    sub4 sub1(\n        .A(A[16:4]),\n        .B(B[16:4]),\n        .C_in(1'b0),\n        .D(D[16:4]),\n        .B_out(b_out[1])\n    );\n\n    sub4 sub2(\n        .A(A[12:1]),\n        .B(B[12:1]),\n        .C_in(b_out[1]),\n        .D(D[12:1]),\n        .B_out(b_out[2])\n    );\n\n    sub4 sub3(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .C_in(b_out[2]),\n        .D(D[8:1]),\n        .B_out(b_out[3])\n    );\n\n    sub4 sub4(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(b_out[3]),\n        .D(D[4:1]),\n        .B_out(b_out[4])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[4];\n\nendmodule\n\nmodule sub4(A, B, C_in, D, B_out);\n    input [3:1] A;       // 4-bit input A\n    input [3:1] B;       // 4-bit input B\n    input C_in;          // Carry-in\n    output [3:1] D;      // 4-bit difference output\n    output B_out;        // Borrow-out output\n\n    wire [3:1] b_out;    // 4-bit borrow-out from each sub-block\n\n    // Instantiate 2-bit subtractors\n    sub2 sub1(\n        .A(A[3:2]),\n        .B(B[3:2]),\n        .C_in(C_in),\n        .D(D[3:2]),\n        .B_out(b_out[1])\n    );\n\n    sub2 sub2(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(b_out[1]),\n        .D(D[1:1]),\n        .B_out(b_out[2])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[2];\n\nendmodule\n\nmodule sub2(A, B, C_in, D, B_out);\n    input [2:1] A;       // 2-bit input A\n    input [2:1] B;       // 2-bit input B\n    input C_in;          // Carry-in\n    output [2:1] D;      // 2-bit difference output\n    output B_out;        // Borrow-out output\n\n    wire [2:1] b_out;    // 2-bit borrow-out from each sub-block\n\n    // Instantiate 1-bit subtractors\n    sub1 sub1(\n        .A(A[1:1]),\n        .B(B[1:1]),\n        .C_in(C_in),\n        .D(D[1:1]),\n        .B_out(b_out[1])\n    );\n\n    // Assign borrow-out to output\n    assign B_out = b_out[1];\n\nendmodule\n\nmodule sub1(A, B, C_in, D, B_out);\n    input A;             // 1-bit input A\n    input B;             // 1-bit input B\n    input C_in;          // Carry-in\n    output D;            // 1-bit difference output\n    output B_out;        // Borrow-out output\n\n    assign {B_out, D} = A - B - C_in;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction module instance\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Carry generation\n    assign A_greater = (diff != 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0);\n    assign A_less = (diff == 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 0 && !borrow);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff == 0 && borrow);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the output values\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0) && (borrow == 0);\n    assign A_less = (diff == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff, // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Perform subtraction\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0) && (borrow == 1'b0);\n    assign A_less = (diff == 32'b0) && (borrow == 1'b1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the result\n    assign A_greater = (sub_result != 0) && !borrow;\n    assign A_equal = (sub_result == 0) && !borrow;\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output borrow       // Carry output\n);\n\n    // Perform subtraction\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "alu", "response": "module alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result, nor_result, slt_result, sltu_result, sll_result, srl_result, sra_result, sllv_result, srlv_result, srav_result, lui_result;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry, nor_carry, slt_carry, sltu_carry, sll_carry, srl_carry, sra_carry, sllv_carry, srlv_carry, srav_carry, lui_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero, nor_zero, slt_zero, sltu_zero, sll_zero, srl_zero, sra_zero, sllv_zero, srlv_zero, srav_zero, lui_zero;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative, nor_negative, slt_negative, sltu_negative, sll_negative, srl_negative, sra_negative, sllv_negative, srlv_negative, srav_negative, lui_negative;\n    wire add_overflow, sub_overflow, and_overflow, or_overflow, xor_overflow, nor_overflow, slt_overflow, sltu_overflow, sll_overflow, srl_overflow, sra_overflow, sllv_overflow, srlv_overflow, srav_overflow, lui_overflow;\n    wire add_flag, sub_flag, and_flag, or_flag, xor_flag, nor_flag, slt_flag, sltu_flag, sll_flag, srl_flag, sra_flag, sllv_flag, srlv_flag, srav_flag, lui_flag;\n\n    // Instantiate submodules\n    adder add(.a(a), .b(b), .carry_out(add_carry), .result(add_result), .overflow(add_overflow));\n    adder_u addu(.a(a), .b(b), .carry_out(sub_carry), .result(sub_result), .overflow(sub_overflow));\n    and_gate and1(.a(a), .b(b), .result(and_result), .carry_out(and_carry));\n    or_gate or1(.a(a), .b(b), .result(or_result), .carry_out(or_carry));\n    xor_gate xor1(.a(a), .b(b), .result(xor_result), .carry_out(xor_carry));\n    nor_gate nor1(.a(a), .b(b), .result(nor_result), .carry_out(nor_carry));\n    slt_gate slt(.a(a), .b(b), .result(slt_result), .carry_out(slt_carry));\n    slt_u_gate sltu(.a(a), .b(b), .result(sltu_result), .carry_out(sltu_carry));\n    sll_gate sll(.a(a), .b(b), .result(sll_result), .carry_out(sll_carry));\n    srl_gate srl(.a(a), .b(b), .result(srl_result), .carry_out(srl_carry));\n    sra_gate sra(.a(a), .b(b), .result(sra_result), .carry_out(sra_carry));\n    sllv_gate sllv(.a(a), .b(b), .result(sllv_result), .carry_out(sllv_carry));\n    srlv_gate srlv(.a(a), .b(b), .result(srlv_result), .carry_out(srlv_carry));\n    srav_gate srav(.a(a), .b(b), .result(srav_result), .carry_out(srav_carry));\n    lui_gate lui(.a(a), .result(lui_result), .carry_out(lui_carry));\n\n    // Select operation based on control signal\n    assign {r, carry, zero, negative, overflow, flag} = (aluc == 6'b100000) ? {add_result, add_carry, add_zero, add_negative, add_overflow, add_flag} :\n                                                          (aluc == 6'b100001) ? {addu_result, addu_carry, addu_zero, addu_negative, addu_overflow, addu_flag} :\n                                                          (aluc == 6'b100010) ? {sub_result, sub_carry, sub_zero, sub_negative, sub_overflow, sub_flag} :\n                                                          (aluc == 6'b100011) ? {subu_result, subu_carry, subu_zero, subu_negative, subu_overflow, subu_flag} :\n                                                          (aluc == 6'b100100) ? {and_result, and_carry, and_zero, and_negative, and_overflow, and_flag} :\n                                                          (aluc == 6'b100101) ? {or_result, or_carry, or_zero, or_negative, or_overflow, or_flag} :\n                                                          (aluc == 6'b100110) ? {xor_result, xor_carry, xor_zero, xor_negative, xor_overflow, xor_flag} :\n                                                          (aluc == 6'b100111) ? {nor_result, nor_carry, nor_zero, nor_negative, nor_overflow, nor_flag} :\n                                                          (aluc == 6'b101010) ? {slt_result, slt_carry, slt_zero, slt_negative, slt_overflow, slt_flag} :\n                                                          (aluc == 6'b101011) ? {sltu_result, sltu_carry, sltu_zero, sltu_negative, sltu_overflow, sltu_flag} :\n                                                          (aluc == 6'b000000) ? {sll_result, sll_carry, sll_zero, sll_negative, sll_overflow, sll_flag} :\n                                                          (aluc == 6'b000010) ? {srl_result, srl_carry, srl_zero, srl_negative, srl_overflow, srl_flag} :\n                                                          (aluc == 6'b000011) ? {sra_result, sra_carry, sra_zero, sra_negative, sra_overflow, sra_flag} :\n                                                          (aluc == 6'b000100) ? {sllv_result, sllv_carry, sllv_zero, sllv_negative, sllv_overflow, sllv_flag} :\n                                                          (aluc == 6'b000110) ? {srlv_result, srlv_carry, srlv_zero, srlv_negative, srlv_overflow, srlv_flag} :\n                                                          (aluc == 6'b000111) ? {srav_result, srav_carry, srav_zero, srav_negative, srav_overflow, srav_flag} :\n                                                          (aluc == 6'b001111) ? {lui_result, lui_carry, lui_zero, lui_negative, lui_overflow, lui_flag} : 32'b0;\n\nendmodule\n\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule adder_u(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a + b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a | b;\nendmodule\n\nmodule xor_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a ^ b;\nendmodule\n\nmodule nor_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = ~(a | b);\nendmodule\n\nmodule slt_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = (a < b) ? 1 : 0;\nendmodule\n\nmodule slt_u_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = (a < b) ? 1 : 0;\nendmodule\n\nmodule sll_gate(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a << b;\nendmodule\n\nmodule srl_gate(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a >> b;\nendmodule\n\nmodule sra_gate(\n    input [31:0] a,\n    input [4:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = $signed(a) >>> b;\nendmodule\n\nmodule sllv_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a << b;\nendmodule\n\nmodule srlv_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = a >> b;\nendmodule\n\nmodule srav_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = $signed(a) >>> b;\nendmodule\n\nmodule lui_gate(\n    input [31:0] a,\n    output [31:0] result,\n    output carry_out\n);\n    assign {carry_out, result} = {16'b0, a[31:12]};\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtractor module instance\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Subtraction operation\n    assign diff = A - B;\n    assign borrow = (diff[31] == 1);\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Carry generation\n    assign A_greater = (diff != 0) && (borrow == 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction module instance\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff == 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0) && (borrow == 1'b1);\n    assign A_less = (diff != 32'b0) && (borrow == 1'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,\n    output borrow\n);\n\n    // Subtraction operation\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the comparison results\n    assign A_greater = (diff == 32'b0) && (borrow == 1'b0);\n    assign A_equal = (diff == 32'b0) && (borrow == 1'b1);\n    assign A_less = (diff != 32'b0) && (borrow == 1'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow     // Borrow output\n);\n\n    // Perform subtraction\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (sub_result == 32'b0) && (borrow == 1'b0);\n    assign A_equal = (sub_result == 32'b0) && (borrow == 1'b1);\n    assign A_less = (sub_result != 32'b0) && (borrow == 1'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output borrow      // Carry out\n);\n\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the output based on the borrow and diff\n    assign A_greater = (diff != 0) && (borrow == 0);\n    assign A_equal = (diff == 0);\n    assign A_less = (diff == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Perform subtraction\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] sub_result;\n    wire borrow;\n\n    // Instantiate the subtraction module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .sub_result(sub_result),\n        .borrow(borrow)\n    );\n\n    // Determine the comparison results\n    assign A_greater = ~borrow & (sub_result != 0);\n    assign A_equal = ~borrow & (sub_result == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] sub_result,  // Result of subtraction\n    output borrow       // Borrow output\n);\n\n    // Perform subtraction\n    assign {borrow, sub_result} = A - B;\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction operation\n    subtractor sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Determine the result\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0) && (borrow == 0);\n    assign A_less = (diff == 0) && (borrow == 1);\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign {borrow, diff} = A - B;\nendmodule"}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;\n    wire borrow;\n\n    // Subtraction module instance\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    // Comparison logic\n    assign A_greater = (diff != 0);\n    assign A_equal = (diff == 0);\n    assign A_less = borrow;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] diff,  // Difference between A and B\n    output borrow      // Borrow output\n);\n\n    // Subtraction operation\n    assign {borrow, diff} = A - B;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA1 CLA2 (.A(A[16:17]), .B(B[16:17]), .Cin(C16), .S(S[17:1]), .Cout(C16));\n    CLA1 CLA3 (.A(A[16:18]), .B(B[16:18]), .Cin(C16), .S(S[18:1]), .Cout(C16));\n    CLA1 CLA4 (.A(A[16:19]), .B(B[16:19]), .Cin(C16), .S(S[19:1]), .Cout(C16));\n    CLA1 CLA5 (.A(A[16:20]), .B(B[16:20]), .Cin(C16), .S(S[20:1]), .Cout(C16));\n    CLA1 CLA6 (.A(A[16:21]), .B(B[16:21]), .Cin(C16), .S(S[21:1]), .Cout(C16));\n    CLA1 CLA7 (.A(A[16:22]), .B(B[16:22]), .Cin(C16), .S(S[22:1]), .Cout(C16));\n    CLA1 CLA8 (.A(A[16:23]), .B(B[16:23]), .Cin(C16), .S(S[23:1]), .Cout(C16));\n    CLA1 CLA9 (.A(A[16:24]), .B(B[16:24]), .Cin(C16), .S(S[24:1]), .Cout(C16));\n    CLA1 CLA10(.A(A[16:25]), .B(B[16:25]), .Cin(C16), .S(S[25:1]), .Cout(C16));\n    CLA1 CLA11(.A(A[16:26]), .B(B[16:26]), .Cin(C16), .S(S[26:1]), .Cout(C16));\n    CLA1 CLA12(.A(A[16:27]), .B(B[16:27]), .Cin(C16), .S(S[27:1]), .Cout(C16));\n    CLA1 CLA13(.A(A[16:28]), .B(B[16:28]), .Cin(C16), .S(S[28:1]), .Cout(C16));\n    CLA1 CLA14(.A(A[16:29]), .B(B[16:29]), .Cin(C16), .S(S[29:1]), .Cout(C16));\n    CLA1 CLA15(.A(A[16:30]), .B(B[16:30]), .Cin(C16), .S(S[30:1]), .Cout(C16));\n    CLA1 CLA16(.A(A[16:31]), .B(B[16:31]), .Cin(C16), .S(S[31:1]), .Cout(C16));\n\n    assign C32 = C16;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire C16,C8,C4,C2;\n\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA1 CLA2 (.A(A[8:17]), .B(B[8:17]), .Cin(C16), .S(S[8:17]), .Cout(C8));\n    CLA1 CLA3 (.A(A[4:18]), .B(B[4:18]), .Cin(C8), .S(S[4:18]), .Cout(C4));\n    CLA1 CLA4 (.A(A[2:19]), .B(B[2:19]), .Cin(C4), .S(S[2:19]), .Cout(C2));\n    CLA1 CLA5 (.A(A[1:20]), .B(B[1:20]), .Cin(C2), .S(S[1:20]), .Cout(C32));\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n    wire C16,C8,C4,C2;\n\n    CLA CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(1'b0), .S(S[8:1]), .Cout(C8));\n    CLA CLA2 (.A(A[4:9]), .B(B[4:9]), .Cin(C8), .S(S[4:9]), .Cout(C4));\n    CLA CLA3 (.A(A[2:5]), .B(B[2:5]), .Cin(C4), .S(S[2:5]), .Cout(C2));\n    CLA CLA4 (.A(A[1:3]), .B(B[1:3]), .Cin(C2), .S(S[1:3]), .Cout(C16));\n    CLA CLA5 (.A(A[1:2]), .B(B[1:2]), .Cin(C16), .S(S[1:2]), .Cout(Cout));\nendmodule\n\nmodule CLA(A,B,Cin,S,Cout);\n    input [3:1] A,B;\n    input Cin;\n    output [3:1] S;\n    output Cout;\n    wire C2,C4;\n\n    CLA2 CLA2 (.A(A[2:1]), .B(B[2:1]), .Cin(1'b0), .S(S[2:1]), .Cout(C2));\n    CLA2 CLA3 (.A(A[1:2]), .B(B[1:2]), .Cin(C2), .S(S[1:2]), .Cout(C4));\n    CLA2 CLA4 (.A(A[1:1]), .B(B[1:1]), .Cin(C4), .S(S[1:1]), .Cout(Cout));\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n    wire C2;\n\n    CLA3 CLA3 (.A(A[1:1]), .B(B[1:1]), .Cin(1'b0), .S(S[1:1]), .Cout(C2));\n    CLA3 CLA4 (.A(A[1:1]), .B(B[1:1]), .Cin(C2), .S(S[1:1]), .Cout(Cout));\nendmodule\n\nmodule CLA3(A,B,Cin,S,Cout);\n    input [1:1] A,B;\n    input Cin;\n    output [1:1] S;\n    output Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C15;\n    wire C16;\n\n    CLA16 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C15[1]));\n    CLA16 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C15[1]), .S(S[32:17]), .Cout(C15[2]));\n\n    assign C32 = C15[2];\nendmodule\n\nmodule CLA16(A,B,Cin,S,Cout);\n    input [15:1] A,B;\n    input Cin;\n    output [15:1] S;\n    output Cout;\n\n    wire [7:1] C7;\n    wire C8;\n\n    CLA7 CLA7_1 (.A(A[7:1]), .B(B[7:1]), .Cin(1'b0), .S(S[7:1]), .Cout(C7[1]));\n    CLA7 CLA7_2 (.A(A[15:8]), .B(B[15:8]), .Cin(C7[1]), .S(S[15:8]), .Cout(C7[2]));\n\n    assign Cout = C7[2];\nendmodule\n\nmodule CLA7(A,B,Cin,S,Cout);\n    input [7:1] A,B;\n    input Cin;\n    output [7:1] S;\n    output Cout;\n\n    wire [3:1] C3;\n    wire C4;\n\n    CLA3 CLA3_1 (.A(A[3:1]), .B(B[3:1]), .Cin(1'b0), .S(S[3:1]), .Cout(C3[1]));\n    CLA3 CLA3_2 (.A(A[7:4]), .B(B[7:4]), .Cin(C3[1]), .S(S[7:4]), .Cout(C3[2]));\n\n    assign Cout = C3[2];\nendmodule\n\nmodule CLA3(A,B,Cin,S,Cout);\n    input [3:1] A,B;\n    input Cin;\n    output [3:1] S;\n    output Cout;\n\n    wire [1:1] C1;\n    wire C2;\n\n    CLA1 CLA1_1 (.A(A[1:1]), .B(B[1:1]), .Cin(1'b0), .S(S[1:1]), .Cout(C1[1]));\n    CLA1 CLA1_2 (.A(A[3:2]), .B(B[3:2]), .Cin(C1[1]), .S(S[3:2]), .Cout(C1[2]));\n\n    assign Cout = C1[2];\nendmodule\n\nmodule CLA1(A,B,Cin,S,Cout);\n    input A,B;\n    input Cin;\n    output S;\n    output Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire C16;\n    wire C8;\n    wire C4;\n    wire C2;\n\n    // Instantiate 16-bit CLA\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA1 CLA2 (.A(A[8:1]), .B(B[8:1]), .Cin(C16), .S(S[8:1]), .Cout(C8));\n    CLA1 CLA3 (.A(A[4:1]), .B(B[4:1]), .Cin(C8), .S(S[4:1]), .Cout(C4));\n    CLA1 CLA4 (.A(A[2:1]), .B(B[2:1]), .Cin(C4), .S(S[2:1]), .Cout(C2));\n    CLA1 CLA5 (.A(A[1:1]), .B(B[1:1]), .Cin(C2), .S(S[1:1]), .Cout(C32));\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C16[32:1];\n    wire C16_0, C16_1, C16_2, C16_3, C16_4, C16_5, C16_6, C16_7, C16_8, C16_9, C16_10, C16_11, C16_12, C16_13, C16_14, C16_15;\n\n    CLA_16bit CLA1 (.A(A[1]), .B(B[1]), .Cin(C16_0), .Sum(S[1]), .Cout(C16[1]));\n    CLA_16bit CLA2 (.A(A[2]), .B(B[2]), .Cin(C16_1), .Sum(S[2]), .Cout(C16[2]));\n    CLA_16bit CLA3 (.A(A[3]), .B(B[3]), .Cin(C16_2), .Sum(S[3]), .Cout(C16[3]));\n    CLA_16bit CLA4 (.A(A[4]), .B(B[4]), .Cin(C16_3), .Sum(S[4]), .Cout(C16[4]));\n    CLA_16bit CLA5 (.A(A[5]), .B(B[5]), .Cin(C16_4), .Sum(S[5]), .Cout(C16[5]));\n    CLA_16bit CLA6 (.A(A[6]), .B(B[6]), .Cin(C16_5), .Sum(S[6]), .Cout(C16[6]));\n    CLA_16bit CLA7 (.A(A[7]), .B(B[7]), .Cin(C16_6), .Sum(S[7]), .Cout(C16[7]));\n    CLA_16bit CLA8 (.A(A[8]), .B(B[8]), .Cin(C16_7), .Sum(S[8]), .Cout(C16[8]));\n    CLA_16bit CLA9 (.A(A[9]), .B(B[9]), .Cin(C16_8), .Sum(S[9]), .Cout(C16[9]));\n    CLA_16bit CLA10 (.A(A[10]), .B(B[10]), .Cin(C16_9), .Sum(S[10]), .Cout(C16[10]));\n    CLA_16bit CLA11 (.A(A[11]), .B(B[11]), .Cin(C16_10), .Sum(S[11]), .Cout(C16[11]));\n    CLA_16bit CLA12 (.A(A[12]), .B(B[12]), .Cin(C16_11), .Sum(S[12]), .Cout(C16[12]));\n    CLA_16bit CLA13 (.A(A[13]), .B(B[13]), .Cin(C16_12), .Sum(S[13]), .Cout(C16[13]));\n    CLA_16bit CLA14 (.A(A[14]), .B(B[14]), .Cin(C16_13), .Sum(S[14]), .Cout(C16[14]));\n    CLA_16bit CLA15 (.A(A[15]), .B(B[15]), .Cin(C16_14), .Sum(S[15]), .Cout(C16[15]));\n\n    assign C32 = C16[32];\nendmodule\n\nmodule CLA_16bit(A,B,Cin,Sum,Cout);\n    input A,B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    wire [7:1] C7[8:1];\n    wire C7_0, C7_1, C7_2, C7_3, C7_4, C7_5, C7_6, C7_7;\n\n    CLA_8bit CLA1 (.A(A), .B(B), .Cin(C7_0), .Sum(Sum), .Cout(C7[1]));\n    CLA_8bit CLA2 (.A(A), .B(B), .Cin(C7_1), .Sum(Sum), .Cout(C7[2]));\n    CLA_8bit CLA3 (.A(A), .B(B), .Cin(C7_2), .Sum(Sum), .Cout(C7[3]));\n    CLA_8bit CLA4 (.A(A), .B(B), .Cin(C7_3), .Sum(Sum), .Cout(C7[4]));\n    CLA_8bit CLA5 (.A(A), .B(B), .Cin(C7_4), .Sum(Sum), .Cout(C7[5]));\n    CLA_8bit CLA6 (.A(A), .B(B), .Cin(C7_5), .Sum(Sum), .Cout(C7[6]));\n    CLA_8bit CLA7 (.A(A), .B(B), .Cin(C7_6), .Sum(Sum), .Cout(C7[7]));\n    CLA_8bit CLA8 (.A(A), .B(B), .Cin(C7_7), .Sum(Sum), .Cout(C7[8]));\n\n    assign Cout = C7[8];\n    assign C7_0 = Cin;\n    assign C7_1 = C7[1];\n    assign C7_2 = C7[2];\n    assign C7_3 = C7[3];\n    assign C7_4 = C7[4];\n    assign C7_5 = C7[5];\n    assign C7_6 = C7[6];\n    assign C7_7 = C7[7];\nendmodule\n\nmodule CLA_8bit(A,B,Cin,Sum,Cout);\n    input A,B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    wire [3:1] C3[4:1];\n    wire C3_0, C3_1, C3_2, C3_3;\n\n    CLA_4bit CLA1 (.A(A), .B(B), .Cin(C3_0), .Sum(Sum), .Cout(C3[1]));\n    CLA_4bit CLA2 (.A(A), .B(B), .Cin(C3_1), .Sum(Sum), .Cout(C3[2]));\n    CLA_4bit CLA3 (.A(A), .B(B), .Cin(C3_2), .Sum(Sum), .Cout(C3[3]));\n    CLA_4bit CLA4 (.A(A), .B(B), .Cin(C3_3), .Sum(Sum), .Cout(C3[4]));\n\n    assign Cout = C3[4];\n    assign C3_0 = Cin;\n    assign C3_1 = C3[1];\n    assign C3_2 = C3[2];\n    assign C3_3 = C3[3];\nendmodule\n\nmodule CLA_4bit(A,B,Cin,Sum,Cout);\n    input A,B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    wire [1:1] C1[2:1];\n    wire C1_0, C1_1;\n\n    CLA_2bit CLA1 (.A(A), .B(B), .Cin(C1_0), .Sum(Sum), .Cout(C1[1]));\n    CLA_2bit CLA2 (.A(A), .B(B), .Cin(C1_1), .Sum(Sum), .Cout(C1[2]));\n\n    assign Cout = C1[2];\n    assign C1_0 = Cin;\n    assign C1_1 = C1[1];\nendmodule\n\nmodule CLA_2bit(A,B,Cin,Sum,Cout);\n    input A,B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    wire [1:1] C1[2:1];\n    wire C1_0, C1_1;\n\n    assign Cout = C1[2];\n    assign C1_0 = Cin;\n    assign C1_1 = C1[1];\n\n    assign Sum = A ^ B ^ C1_0;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n    wire [16:1] S16;\n    wire [8:1] S8;\n    wire [4:1] S4;\n    wire [2:1] S2;\n\n    // Instantiate 16-bit CLA\n    carry_lookahead CLA1(\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S16),\n        .Cout(C16)\n    );\n\n    // Instantiate 8-bit CLA\n    carry_lookahead CLA2(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Cin(C16),\n        .S(S8),\n        .Cout(C8)\n    );\n\n    // Instantiate 4-bit CLA\n    carry_lookahead CLA3(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .Cin(C8),\n        .S(S4),\n        .Cout(C4)\n    );\n\n    // Instantiate 2-bit CLA\n    carry_lookahead CLA4(\n        .A(A[2:1]),\n        .B(B[2:1]),\n        .Cin(C4),\n        .S(S2),\n        .Cout(C2)\n    );\n\n    // Combine the 16-bit, 8-bit, 4-bit, and 2-bit CLA outputs\n    assign S = {S2,S4,S8,S16};\n    assign C32 = C2;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A;\n    input [32:1] B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n\n    CLA16 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16));\n    CLA16 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16), .S(S[32:17]), .Cout(C32));\nendmodule\n\nmodule CLA16(A,B,Cin,S,Cout);\n    input [16:1] A;\n    input [16:1] B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire C8,C4,C2;\n\n    CLA8 CLA8_1 (.A(A[8:1]), .B(B[8:1]), .Cin(Cin), .S(S[8:1]), .Cout(C8));\n    CLA8 CLA8_2 (.A(A[16:9]), .B(B[16:9]), .Cin(C8), .S(S[16:9]), .Cout(Cout));\nendmodule\n\nmodule CLA8(A,B,Cin,S,Cout);\n    input [8:1] A;\n    input [8:1] B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire C4,C2;\n\n    CLA4 CLA4_1 (.A(A[4:1]), .B(B[4:1]), .Cin(Cin), .S(S[4:1]), .Cout(C4));\n    CLA4 CLA4_2 (.A(A[8:5]), .B(B[8:5]), .Cin(C4), .S(S[8:5]), .Cout(Cout));\nendmodule\n\nmodule CLA4(A,B,Cin,S,Cout);\n    input [4:1] A;\n    input [4:1] B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire C2;\n\n    CLA2 CLA2_1 (.A(A[2:1]), .B(B[2:1]), .Cin(Cin), .S(S[2:1]), .Cout(C2));\n    CLA2 CLA2_2 (.A(A[4:3]), .B(B[4:3]), .Cin(C2), .S(S[4:3]), .Cout(Cout));\nendmodule\n\nmodule CLA2(A,B,Cin,S,Cout);\n    input [2:1] A;\n    input [2:1] B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire C1;\n\n    assign S = A ^ B;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16[15:0];\n    wire C16_0, C16_1, C16_2, C16_3, C16_4, C16_5, C16_6, C16_7, C16_8, C16_9, C16_10, C16_11, C16_12, C16_13, C16_14, C16_15;\n\n    CLA_16bit CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(C16_0), .Sum(S[16:1]), .Cout(C16_1));\n    CLA_16bit CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16_1), .Sum(S[32:17]), .Cout(C16_2));\n\n    assign C32 = C16_2;\n\nendmodule\n\nmodule CLA_16bit(A,B,Cin,Sum,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] Sum;\n    output Cout;\n\n    wire [8:1] C8[7:0];\n    wire C8_0, C8_1, C8_2, C8_3, C8_4, C8_5, C8_6, C8_7;\n\n    CLA_8bit CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(C8_0), .Sum(Sum[8:1]), .Cout(C8_1));\n    CLA_8bit CLA2 (.A(A[16:9]), .B(B[16:9]), .Cin(C8_1), .Sum(Sum[16:9]), .Cout(C8_2));\n\n    assign Cout = C8_2;\n\nendmodule\n\nmodule CLA_8bit(A,B,Cin,Sum,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] Sum;\n    output Cout;\n\n    wire [4:1] C4[3:0];\n    wire C4_0, C4_1, C4_2, C4_3;\n\n    CLA_4bit CLA1 (.A(A[4:1]), .B(B[4:1]), .Cin(C4_0), .Sum(Sum[4:1]), .Cout(C4_1));\n    CLA_4bit CLA2 (.A(A[8:5]), .B(B[8:5]), .Cin(C4_1), .Sum(Sum[8:5]), .Cout(C4_2));\n\n    assign Cout = C4_2;\n\nendmodule\n\nmodule CLA_4bit(A,B,Cin,Sum,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] Sum;\n    output Cout;\n\n    wire [2:1] C2[1:0];\n    wire C2_0, C2_1;\n\n    CLA_2bit CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(C2_0), .Sum(Sum[2:1]), .Cout(C2_1));\n    CLA_2bit CLA2 (.A(A[4:3]), .B(B[4:3]), .Cin(C2_1), .Sum(Sum[4:3]), .Cout(C2_0));\n\n    assign Cout = C2_0;\n\nendmodule\n\nmodule CLA_2bit(A,B,Cin,Sum,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] Sum;\n    output Cout;\n\n    wire [1:1] C1[0:0];\n    wire C1_0;\n\n    CLA_1bit CLA1 (.A(A[1:1]), .B(B[1:1]), .Cin(C1_0), .Sum(Sum[1:1]), .Cout(C1_0));\n\n    assign Cout = C1_0;\n\nendmodule\n\nmodule CLA_1bit(A,B,Cin,Sum,Cout);\n    input A,B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C15;\n    wire C16;\n\n    CLA_16bit CLA1 (.A(A[15:1]), .B(B[15:1]), .C15(C15), .C16(C16));\n    CLA_16bit CLA2 (.A(A[31:16]), .B(B[31:16]), .C15(C15), .C16(C16));\n\n    assign S = {C16, C15, A[15:1] + B[15:1], A[31:16] + B[31:16]};\n    assign C32 = C16;\nendmodule\n\nmodule CLA_16bit(A,B,C15,C16);\n    input [15:1] A,B;\n    output [15:1] C15;\n    output C16;\n\n    wire [8:1] C8;\n    wire C9;\n\n    CLA_8bit CLA1 (.A(A[8:1]), .B(B[8:1]), .C8(C8), .C9(C9));\n    CLA_8bit CLA2 (.A(A[15:9]), .B(B[15:9]), .C8(C8), .C9(C9));\n\n    assign C15 = C8;\n    assign C16 = C9;\nendmodule\n\nmodule CLA_8bit(A,B,C8,C9);\n    input [8:1] A,B;\n    output [8:1] C8;\n    output C9;\n\n    wire [4:1] C4;\n    wire C5;\n\n    CLA_4bit CLA1 (.A(A[4:1]), .B(B[4:1]), .C4(C4), .C5(C5));\n    CLA_4bit CLA2 (.A(A[8:5]), .B(B[8:5]), .C4(C4), .C5(C5));\n\n    assign C8 = C4;\n    assign C9 = C5;\nendmodule\n\nmodule CLA_4bit(A,B,C4,C5);\n    input [4:1] A,B;\n    output [4:1] C4;\n    output C5;\n\n    wire [2:1] C2;\n    wire C3;\n\n    CLA_2bit CLA1 (.A(A[2:1]), .B(B[2:1]), .C2(C2), .C3(C3));\n    CLA_2bit CLA2 (.A(A[4:3]), .B(B[4:3]), .C2(C2), .C3(C3));\n\n    assign C4 = C2;\n    assign C5 = C3;\nendmodule\n\nmodule CLA_2bit(A,B,C2,C3);\n    input [2:1] A,B;\n    output [2:1] C2;\n    output C3;\n\n    wire [1:1] C1;\n    wire C2;\n\n    CLA_1bit CLA1 (.A(A[1:1]), .B(B[1:1]), .C1(C1), .C2(C2));\n    CLA_1bit CLA2 (.A(A[2:2]), .B(B[2:2]), .C1(C1), .C2(C2));\n\n    assign C2 = C1;\nendmodule\n\nmodule CLA_1bit(A,B,C1,C2);\n    input [1:1] A,B;\n    output C1;\n    output C2;\n\n    assign C1 = A[1] ^ B[1];\n    assign C2 = A[1] & B[1];\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire C16,C8,C4,C2,C1;\n\n    CLA1 CLA1(.A(A[16:1]),.B(B[16:1]),.Cin(1'b0),.S(S[16:1]),.Cout(C16));\n    CLA1 CLA2(.A(A[8:1]),.B(B[8:1]),.Cin(C16),.S(S[8:1]),.Cout(C8));\n    CLA1 CLA3(.A(A[4:1]),.B(B[4:1]),.Cin(C8),.S(S[4:1]),.Cout(C4));\n    CLA1 CLA4(.A(A[2:1]),.B(B[2:1]),.Cin(C4),.S(S[2:1]),.Cout(C2));\n    CLA1 CLA5(.A(A[1:1]),.B(B[1:1]),.Cin(C2),.S(S[1:1]),.Cout(C1));\n\n    assign C32 = C1;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n    wire C16;\n\n    CLA1 CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .Sum(S[16:1]), .Cout(C16));\n    CLA2 CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16), .Sum(S[32:17]), .Cout(C32));\nendmodule\n\nmodule CLA1(A,B,Cin,Sum,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] Sum;\n    output Cout;\n    wire [16:1] G,P;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign Sum = P ^ Cin;\n    assign Cout = (G | (P & Cin));\nendmodule\n\nmodule CLA2(A,B,Cin,Sum,Cout);\n    input [32:1] A,B;\n    input Cin;\n    output [32:1] Sum;\n    output Cout;\n    wire [32:1] G,P;\n\n    assign G = A & B;\n    assign P = A ^ B;\n    assign Sum = P ^ Cin;\n    assign Cout = (G | (P & Cin));\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n    wire [16:1] S16;\n    wire [8:1] S8;\n    wire [4:1] S4;\n    wire [2:1] S2;\n\n    // Instantiate 16-bit CLA\n    carry_lookahead CLA1(.A(A[16:1]), .B(B[16:1]), .Cin(C16), .S(S16), .Cout(C8));\n    // Instantiate 8-bit CLA\n    carry_lookahead CLA2(.A(A[8:1]), .B(B[8:1]), .Cin(C8), .S(S8), .Cout(C4));\n    // Instantiate 4-bit CLA\n    carry_lookahead CLA3(.A(A[4:1]), .B(B[4:1]), .Cin(C4), .S(S4), .Cout(C2));\n    // Instantiate 2-bit CLA\n    carry_lookahead CLA4(.A(A[2:1]), .B(B[2:1]), .Cin(C2), .S(S2), .Cout(C32));\n\n    assign S = {S2,S4,S8,S16};\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [16:1] C16;\n    wire C16_out;\n\n    CLA_16bit CLA1 (.A(A[16:1]), .B(B[16:1]), .Cin(1'b0), .S(S[16:1]), .Cout(C16[1]));\n    CLA_16bit CLA2 (.A(A[32:17]), .B(B[32:17]), .Cin(C16[1]), .S(S[32:17]), .Cout(C16[2]));\n\n    assign C32 = C16[2];\nendmodule\n\nmodule CLA_16bit(A,B,Cin,S,Cout);\n    input [16:1] A,B;\n    input Cin;\n    output [16:1] S;\n    output Cout;\n\n    wire [8:1] C8;\n    wire C8_out;\n\n    CLA_8bit CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(1'b0), .S(S[8:1]), .Cout(C8[1]));\n    CLA_8bit CLA2 (.A(A[16:9]), .B(B[16:9]), .Cin(C8[1]), .S(S[16:9]), .Cout(C8[2]));\n\n    assign Cout = C8[2];\nendmodule\n\nmodule CLA_8bit(A,B,Cin,S,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] S;\n    output Cout;\n\n    wire [4:1] C4;\n    wire C4_out;\n\n    CLA_4bit CLA1 (.A(A[4:1]), .B(B[4:1]), .Cin(1'b0), .S(S[4:1]), .Cout(C4[1]));\n    CLA_4bit CLA2 (.A(A[8:5]), .B(B[8:5]), .Cin(C4[1]), .S(S[8:5]), .Cout(C4[2]));\n\n    assign Cout = C4[2];\nendmodule\n\nmodule CLA_4bit(A,B,Cin,S,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] S;\n    output Cout;\n\n    wire [2:1] C2;\n    wire C2_out;\n\n    CLA_2bit CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(1'b0), .S(S[2:1]), .Cout(C2[1]));\n    CLA_2bit CLA2 (.A(A[4:3]), .B(B[4:3]), .Cin(C2[1]), .S(S[4:3]), .Cout(C2[2]));\n\n    assign Cout = C2[2];\nendmodule\n\nmodule CLA_2bit(A,B,Cin,S,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] S;\n    output Cout;\n\n    wire [1:1] C1;\n    wire C1_out;\n\n    CLA_1bit CLA1 (.A(A[1]), .B(B[1]), .Cin(1'b0), .S(S[1]), .Cout(C1[1]));\n    CLA_1bit CLA2 (.A(A[2]), .B(B[2]), .Cin(C1[1]), .S(S[2]), .Cout(C1[2]));\n\n    assign Cout = C1[2];\nendmodule\n\nmodule CLA_1bit(A,B,Cin,S,Cout);\n    input A,B;\n    input Cin;\n    output S;\n    output Cout;\n\n    wire C;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (A & Cin) | (B & Cin);\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire [15:1] C15;\n    wire C16;\n\n    CLA16 CLA1 (.A(A[15:1]), .B(B[15:1]), .Cin(1'b0), .Sum(S[15:1]), .Cout(C15[1]));\n    CLA16 CLA2 (.A(A[31:16]), .B(B[31:16]), .Cin(C15[1]), .Sum(S[31:16]), .Cout(C15[2]));\n    assign C32 = C15[2];\nendmodule\n\nmodule CLA16(A,B,Cin,Sum,Cout);\n    input [15:1] A,B;\n    input Cin;\n    output [15:1] Sum;\n    output Cout;\n\n    wire [14:1] C14;\n    wire C15;\n\n    CLA15 CLA1 (.A(A[14:1]), .B(B[14:1]), .Cin(1'b0), .Sum(Sum[14:1]), .Cout(C14[1]));\n    CLA15 CLA2 (.A(A[15:2]), .B(B[15:2]), .Cin(C14[1]), .Sum(Sum[15:2]), .Cout(C14[2]));\n    assign Cout = C14[2];\nendmodule\n\nmodule CLA15(A,B,Cin,Sum,Cout);\n    input [14:1] A,B;\n    input Cin;\n    output [14:1] Sum;\n    output Cout;\n\n    wire [13:1] C13;\n    wire C14;\n\n    CLA14 CLA1 (.A(A[13:1]), .B(B[13:1]), .Cin(1'b0), .Sum(Sum[13:1]), .Cout(C13[1]));\n    CLA14 CLA2 (.A(A[14:2]), .B(B[14:2]), .Cin(C13[1]), .Sum(Sum[14:2]), .Cout(C13[2]));\n    assign Cout = C13[2];\nendmodule\n\nmodule CLA14(A,B,Cin,Sum,Cout);\n    input [13:1] A,B;\n    input Cin;\n    output [13:1] Sum;\n    output Cout;\n\n    wire [12:1] C12;\n    wire C13;\n\n    CLA13 CLA1 (.A(A[12:1]), .B(B[12:1]), .Cin(1'b0), .Sum(Sum[12:1]), .Cout(C12[1]));\n    CLA13 CLA2 (.A(A[13:2]), .B(B[13:2]), .Cin(C12[1]), .Sum(Sum[13:2]), .Cout(C12[2]));\n    assign Cout = C12[2];\nendmodule\n\nmodule CLA13(A,B,Cin,Sum,Cout);\n    input [12:1] A,B;\n    input Cin;\n    output [12:1] Sum;\n    output Cout;\n\n    wire [11:1] C11;\n    wire C12;\n\n    CLA12 CLA1 (.A(A[11:1]), .B(B[11:1]), .Cin(1'b0), .Sum(Sum[11:1]), .Cout(C11[1]));\n    CLA12 CLA2 (.A(A[12:2]), .B(B[12:2]), .Cin(C11[1]), .Sum(Sum[12:2]), .Cout(C11[2]));\n    assign Cout = C11[2];\nendmodule\n\nmodule CLA12(A,B,Cin,Sum,Cout);\n    input [11:1] A,B;\n    input Cin;\n    output [11:1] Sum;\n    output Cout;\n\n    wire [10:1] C10;\n    wire C11;\n\n    CLA10 CLA1 (.A(A[10:1]), .B(B[10:1]), .Cin(1'b0), .Sum(Sum[10:1]), .Cout(C10[1]));\n    CLA10 CLA2 (.A(A[11:2]), .B(B[11:2]), .Cin(C10[1]), .Sum(Sum[11:2]), .Cout(C10[2]));\n    assign Cout = C10[2];\nendmodule\n\nmodule CLA10(A,B,Cin,Sum,Cout);\n    input [10:1] A,B;\n    input Cin;\n    output [10:1] Sum;\n    output Cout;\n\n    wire [9:1] C9;\n    wire C10;\n\n    CLA9 CLA1 (.A(A[9:1]), .B(B[9:1]), .Cin(1'b0), .Sum(Sum[9:1]), .Cout(C9[1]));\n    CLA9 CLA2 (.A(A[10:2]), .B(B[10:2]), .Cin(C9[1]), .Sum(Sum[10:2]), .Cout(C9[2]));\n    assign Cout = C9[2];\nendmodule\n\nmodule CLA9(A,B,Cin,Sum,Cout);\n    input [9:1] A,B;\n    input Cin;\n    output [9:1] Sum;\n    output Cout;\n\n    wire [8:1] C8;\n    wire C9;\n\n    CLA8 CLA1 (.A(A[8:1]), .B(B[8:1]), .Cin(1'b0), .Sum(Sum[8:1]), .Cout(C8[1]));\n    CLA8 CLA2 (.A(A[9:2]), .B(B[9:2]), .Cin(C8[1]), .Sum(Sum[9:2]), .Cout(C8[2]));\n    assign Cout = C8[2];\nendmodule\n\nmodule CLA8(A,B,Cin,Sum,Cout);\n    input [8:1] A,B;\n    input Cin;\n    output [8:1] Sum;\n    output Cout;\n\n    wire [7:1] C7;\n    wire C8;\n\n    CLA7 CLA1 (.A(A[7:1]), .B(B[7:1]), .Cin(1'b0), .Sum(Sum[7:1]), .Cout(C7[1]));\n    CLA7 CLA2 (.A(A[8:2]), .B(B[8:2]), .Cin(C7[1]), .Sum(Sum[8:2]), .Cout(C7[2]));\n    assign Cout = C7[2];\nendmodule\n\nmodule CLA7(A,B,Cin,Sum,Cout);\n    input [7:1] A,B;\n    input Cin;\n    output [7:1] Sum;\n    output Cout;\n\n    wire [6:1] C6;\n    wire C7;\n\n    CLA6 CLA1 (.A(A[6:1]), .B(B[6:1]), .Cin(1'b0), .Sum(Sum[6:1]), .Cout(C6[1]));\n    CLA6 CLA2 (.A(A[7:2]), .B(B[7:2]), .Cin(C6[1]), .Sum(Sum[7:2]), .Cout(C6[2]));\n    assign Cout = C6[2];\nendmodule\n\nmodule CLA6(A,B,Cin,Sum,Cout);\n    input [6:1] A,B;\n    input Cin;\n    output [6:1] Sum;\n    output Cout;\n\n    wire [5:1] C5;\n    wire C6;\n\n    CLA5 CLA1 (.A(A[5:1]), .B(B[5:1]), .Cin(1'b0), .Sum(Sum[5:1]), .Cout(C5[1]));\n    CLA5 CLA2 (.A(A[6:2]), .B(B[6:2]), .Cin(C5[1]), .Sum(Sum[6:2]), .Cout(C5[2]));\n    assign Cout = C5[2];\nendmodule\n\nmodule CLA5(A,B,Cin,Sum,Cout);\n    input [5:1] A,B;\n    input Cin;\n    output [5:1] Sum;\n    output Cout;\n\n    wire [4:1] C4;\n    wire C5;\n\n    CLA4 CLA1 (.A(A[4:1]), .B(B[4:1]), .Cin(1'b0), .Sum(Sum[4:1]), .Cout(C4[1]));\n    CLA4 CLA2 (.A(A[5:2]), .B(B[5:2]), .Cin(C4[1]), .Sum(Sum[5:2]), .Cout(C4[2]));\n    assign Cout = C4[2];\nendmodule\n\nmodule CLA4(A,B,Cin,Sum,Cout);\n    input [4:1] A,B;\n    input Cin;\n    output [4:1] Sum;\n    output Cout;\n\n    wire [3:1] C3;\n    wire C4;\n\n    CLA3 CLA1 (.A(A[3:1]), .B(B[3:1]), .Cin(1'b0), .Sum(Sum[3:1]), .Cout(C3[1]));\n    CLA3 CLA2 (.A(A[4:2]), .B(B[4:2]), .Cin(C3[1]), .Sum(Sum[4:2]), .Cout(C3[2]));\n    assign Cout = C3[2];\nendmodule\n\nmodule CLA3(A,B,Cin,Sum,Cout);\n    input [3:1] A,B;\n    input Cin;\n    output [3:1] Sum;\n    output Cout;\n\n    wire [2:1] C2;\n    wire C3;\n\n    CLA2 CLA1 (.A(A[2:1]), .B(B[2:1]), .Cin(1'b0), .Sum(Sum[2:1]), .Cout(C2[1]));\n    CLA2 CLA2 (.A(A[3:2]), .B(B[3:2]), .Cin(C2[1]), .Sum(Sum[3:2]), .Cout(C2[2]));\n    assign Cout = C2[2];\nendmodule\n\nmodule CLA2(A,B,Cin,Sum,Cout);\n    input [2:1] A,B;\n    input Cin;\n    output [2:1] Sum;\n    output Cout;\n\n    wire [1:1] C1;\n    wire C2;\n\n    CLA1 CLA1 (.A(A[1:1]), .B(B[1:1]), .Cin(1'b0), .Sum(Sum[1:1]), .Cout(C1[1]));\n    CLA1 CLA2 (.A(A[2:2]), .B(B[2:2]), .Cin(C1[1]), .Sum(Sum[2:2]), .Cout(C1[2]));\n    assign Cout = C1[2];\nendmodule\n\nmodule CLA1(A,B,Cin,Sum,Cout);\n    input [1:1] A,B;\n    input Cin;\n    output [1:1] Sum;\n    output Cout;\n\n    wire [0:1] C0;\n    wire C1;\n\n    CLA0 CLA1 (.A(A[0:1]), .B(B[0:1]), .Cin(1'b0), .Sum(Sum[0:1]), .Cout(C0[1]));\n    CLA0 CLA2 (.A(A[1:2]), .B(B[1:2]), .Cin(C0[1]), .Sum(Sum[1:2]), .Cout(C0[2]));\n    assign Cout = C0[2];\nendmodule\n\nmodule CLA0(A,B,Cin,Sum,Cout);\n    input [0:1] A,B;\n    input Cin;\n    output [0:1] Sum;\n    output Cout;\n\n    assign Sum = A + B;\n    assign Cout = Cin;\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n    input [32:1] A,B;\n    output [32:1] S;\n    output C32;\n\n    wire C16,C8,C4,C2;\n    wire [16:1] S16;\n    wire [8:1] S8;\n    wire [4:1] S4;\n    wire [2:1] S2;\n\n    // Instantiate 16-bit CLA\n    carry_lookahead CLA1(\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(1'b0),\n        .S(S16),\n        .Cout(C16)\n    );\n\n    // Instantiate 8-bit CLA\n    carry_lookahead CLA2(\n        .A(A[16:9]),\n        .B(B[16:9]),\n        .Cin(C16),\n        .S(S8),\n        .Cout(C8)\n    );\n\n    // Instantiate 4-bit CLA\n    carry_lookahead CLA3(\n        .A(A[9:5]),\n        .B(B[9:5]),\n        .Cin(C8),\n        .S(S4),\n        .Cout(C4)\n    );\n\n    // Instantiate 2-bit CLA\n    carry_lookahead CLA4(\n        .A(A[5:3]),\n        .B(B[5:3]),\n        .Cin(C4),\n        .S(S2),\n        .Cout(C2)\n    );\n\n    // Instantiate final 1-bit CLA\n    carry_lookahead CLA5(\n        .A(A[3:1]),\n        .B(B[3:1]),\n        .Cin(C2),\n        .S(S[32:1]),\n        .Cout(C32)\n    );\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n    // Instantiate the first carry select adder slice\n    carry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n    // Instantiate the second carry select adder slice\n    carry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n    // Instantiate the third carry select adder slice\n    carry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(cout));\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [4:0] temp_sum;\n\n    // Perform the addition\n    assign temp_sum = a + b + cin;\n\n    // Assign the sum and carry-out\n    assign sum = temp_sum[3:0];\n    assign cout = temp_sum[4];\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [4:0] temp_sum;\n\n    // Instantiate the first ripple carry adder\n    ripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(temp_sum[3:0]), .cout(temp_sum[4]));\n\n    // Instantiate the multiplexer\n    wire [3:0] mux_out;\n    assign mux_out = (temp_sum[4]) ? b : a;\n    assign sum = mux_out;\n    assign cout = temp_sum[4];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Instantiate the 4-bit ripple carry adder\nripple_carry_adder rca1 (.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n// Instantiate the first 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice1 (.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n// Instantiate the second 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice2 (.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n// Instantiate the third 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice3 (.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n// Output the final carry out\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit ripple carry adder module\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Sum calculation\nassign sum = a ^ b ^ {4{cin}};\n\n// Carry calculation\nassign carry = (a & b) | (a & cin) | (b & cin);\n\n// Output carry\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit carry select adder slice module\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Instantiate the first ripple carry adder\nripple_carry_adder rca1 (.a(a), .b(b), .cin(cin), .sum(sum), .cout(carry[0]));\n\n// Instantiate the second ripple carry adder\nripple_carry_adder rca2 (.a(a), .b(b), .cin(carry[0]), .sum(sum), .cout(carry[1]));\n\n// Output carry\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Instantiate first 4-bit carry select adder slice\ncarry_select_adder_slice cs1(.a(a[3:0]), .b(b[3:0]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Instantiate second 4-bit carry select adder slice\ncarry_select_adder_slice cs2(.a(a[7:4]), .b(b[7:4]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Instantiate third 4-bit carry select adder slice\ncarry_select_adder_slice cs3(.a(a[11:8]), .b(b[11:8]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Instantiate fourth 4-bit carry select adder slice\ncarry_select_adder_slice cs4(.a(a[15:12]), .b(b[15:12]), .cin(carry[3]), .sum(sum), .cout(cout));\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [3:0] temp_carry;\n\nassign temp_sum[0] = a[0] ^ b[0];\nassign temp_sum[1] = a[1] ^ b[1];\nassign temp_sum[2] = a[2] ^ b[2];\nassign temp_sum[3] = a[3] ^ b[3];\nassign temp_sum[4] = cin;\n\nassign sum = {temp_sum[3], temp_sum[2], temp_sum[1], temp_sum[0]};\nassign cout = temp_sum[4];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] sum_slice;\nwire carry_in;\n\n// Instantiate first 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(sum_slice), .cout(carry_in));\n\n// Instantiate second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a), .b(b), .cin(carry_in), .sum(sum_slice), .cout(cout));\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate the 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Instantiate the first carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Instantiate the second carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Instantiate the third carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Assign the sum and carry-out\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Compute the sum and carry-out\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (a & cin) | (b & cin);\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate the first ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Instantiate the second ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Assign the sum and carry-out\nassign sum = {sum_slice[1], sum_slice[0]};\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`define WIDTH 16\n`define BITS 4\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 4-bit ripple carry adder\nwire [3:0] ripple_sum;\nripple_carry rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(ripple_sum), .cout(carry[0]));\n\n// First 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n// Second 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n// Third 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n// Final carry-out\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 4-bit ripple carry adder\nripple_carry rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n\n// Final carry-out\nassign cout = carry[0];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 4-bit ripple carry adder\nripple_carry rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n\n// Final carry-out\nassign cout = carry[0];\n\nendmodule\n\nmodule ripple_carry(a, b, cin, sum, cout);\ninput [1:0] a, b;\ninput cin;\noutput [1:0] sum;\noutput cout;\n\nwire [1:0] carry;\n\n// First 2-bit ripple carry adder\nripple_carry rca1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n\n// Final carry-out\nassign cout = carry[0];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n// First 4-bit carry select adder slice\ncarry_select_adder_slice cs1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n// Second 4-bit carry select adder slice\ncarry_select_adder_slice cs2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n// Third 4-bit carry select adder slice\ncarry_select_adder_slice cs3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n// Final carry-out\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit ripple carry adder\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First adder\nfull_adder fa1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n\n// Second adder\nfull_adder fa2(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n\n// Third adder\nfull_adder fa3(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n\n// Fourth adder\nfull_adder fa4(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\n// 4-bit carry select adder slice\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n// Final carry-out\nassign cout = carry[1];\n\nendmodule\n\n// Full adder module\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nassign sum = a ^ b ^ cin;\nassign cout = (a & b) | (cin & (a ^ b));\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4-bit ripple carry adder\nripple_carry rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// First carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Second carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Third carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Multiplexer to select sum and carry\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First bit\nassign sum[0] = a[0] ^ b[0] ^ cin;\nassign carry[0] = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n// Second bit\nassign sum[1] = a[1] ^ b[1] ^ carry[0];\nassign carry[1] = (a[1] & b[1]) | (a[1] & carry[0]) | (b[1] & carry[0]);\n\n// Third bit\nassign sum[2] = a[2] ^ b[2] ^ carry[1];\nassign carry[2] = (a[2] & b[2]) | (a[2] & carry[1]) | (b[2] & carry[1]);\n\n// Fourth bit\nassign sum[3] = a[3] ^ b[3] ^ carry[2];\nassign cout = (a[3] & b[3]) | (a[3] & carry[2]) | (b[3] & carry[2]);\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First ripple carry adder\nripple_carry rca2(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Second ripple carry adder\nripple_carry rca3(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Multiplexer to select sum and carry\nassign sum = {sum_slice[1], sum_slice[0]};\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] csa_sum1, csa_sum2, csa_sum3;\nwire [3:0] csa_cout1, csa_cout2, csa_cout3;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(csa_sum1), .cout(csa_cout1));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[7:4]), .b(b[7:4]), .cin(csa_cout1[0]), .sum(csa_sum2), .cout(csa_cout2[0]));\n\n// Third 4-bit ripple carry adder\nripple_carry_adder rca3(.a(a[11:8]), .b(b[11:8]), .cin(csa_cout2[0]), .sum(csa_sum3), .cout(csa_cout3[0]));\n\n// Fourth 4-bit ripple carry adder\nripple_carry_adder rca4(.a(a[15:12]), .b(b[15:12]), .cin(csa_cout3[0]), .sum(sum), .cout(cout));\n\n// Carry select adder slices\ncarry_select_adder_slice cs_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(csa_sum1), .cout(csa_cout1));\ncarry_select_adder_slice cs_slice2(.a(a[7:4]), .b(b[7:4]), .cin(csa_cout1[0]), .sum(csa_sum2), .cout(csa_cout2[0]));\ncarry_select_adder_slice cs_slice3(.a(a[11:8]), .b(b[11:8]), .cin(csa_cout2[0]), .sum(csa_sum3), .cout(csa_cout3[0]));\ncarry_select_adder_slice cs_slice4(.a(a[15:12]), .b(b[15:12]), .cin(csa_cout3[0]), .sum(sum), .cout(cout));\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [4:0] temp_cout;\n\n// Temporary sum and carry-out\nassign temp_sum = a + b + cin;\nassign temp_cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\n// Final sum and carry-out\nassign sum = temp_sum[3:0];\nassign cout = temp_cout[3];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [4:0] temp_cout;\n\n// Temporary sum and carry-out\nassign temp_sum = a + b + cin;\nassign temp_cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\n// Final sum and carry-out\nassign sum = temp_sum[3:0];\nassign cout = temp_cout[3];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slices[0]), .cout(carry[0]));\n\n// Second 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slices[1]), .cout(carry[1]));\n\n// Third 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slices[2]), .cout(carry[2]));\n\n// Fourth 4-bit carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slices[3]), .cout(carry[3]));\n\n// Output sum\nassign sum = {sum_slices[3], sum_slices[2], sum_slices[1], sum_slices[0]};\n\n// Output carry\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit ripple carry adder\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\nassign {cout, sum} = a + b + cin;\n\nendmodule\n\n// 4-bit carry select adder slice\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slices;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_slices[0]), .cout(carry[0]));\n\n// Second 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_slices[1]), .cout(carry[1]));\n\n// Output sum\nassign sum = {sum_slices[1], sum_slices[0]};\n\n// Output carry\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry_adder rca1(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    // Instantiate the first 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(carry[1])\n    );\n\n    // Instantiate the second 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(carry[1]),\n        .sum(sum[11:8]),\n        .cout(carry[2])\n    );\n\n    // Instantiate the third 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(carry[2]),\n        .sum(sum[15:12]),\n        .cout(carry[3])\n    );\n\n    // Output the final carry-out\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [4:0] carry;\n\n    // Perform the addition\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [4:0] carry;\n\n    // Instantiate the first ripple carry adder\n    ripple_carry_adder rca1(\n        .a(a),\n        .b(b),\n        .cin(cin),\n        .sum(sum),\n        .cout(carry[0])\n    );\n\n    // Instantiate the second ripple carry adder\n    ripple_carry_adder rca2(\n        .a(a),\n        .b(b),\n        .cin(carry[0]),\n        .sum(sum),\n        .cout(carry[1])\n    );\n\n    // Instantiate the third ripple carry adder\n    ripple_carry_adder rca3(\n        .a(a),\n        .b(b),\n        .cin(carry[1]),\n        .sum(sum),\n        .cout(carry[2])\n    );\n\n    // Instantiate the fourth ripple carry adder\n    ripple_carry_adder rca4(\n        .a(a),\n        .b(b),\n        .cin(carry[2]),\n        .sum(sum),\n        .cout(carry[3])\n    );\n\n    // Instantiate the multiplexer\n    wire [3:0] mux_out;\n    assign mux_out = (cin) ? a : b;\n\n    // Output the final carry-out\n    assign cout = carry[3];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n    wire [3:0] carry;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n    // Instantiate the first 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n    // Instantiate the second 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n    // Instantiate the third 4-bit carry select adder slice\n    carry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n    // Output the final carry-out\n    assign cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n    wire [4:0] temp_sum;\n\n    // Perform the addition\n    assign temp_sum = a + b + cin;\n\n    // Output the sum and carry-out\n    assign sum = temp_sum[3:0];\n    assign cout = temp_sum[4];\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [4:0] temp_sum;\n\n    // Instantiate the first ripple carry adder\n    ripple_carry_adder rca1(.a(a), .b(b), .cin(cin), .sum(temp_sum[3:0]), .cout(temp_sum[4]));\n\n    // Select the sum and carry-out based on the carry-in\n    assign sum = (cin) ? temp_sum[3:0] : temp_sum[2:0];\n    assign cout = temp_sum[4];\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Instantiate 4-bit carry select adder slice 1\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Instantiate 4-bit carry select adder slice 2\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Instantiate 4-bit carry select adder slice 3\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Assemble the sum\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n\n// Assemble the carry-out\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit ripple carry adder\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// Add the two inputs\nassign sum = a + b + cin;\n\n// Determine the carry out\nassign cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\nendmodule\n\n// 4-bit carry select adder slice\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// Instantiate 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// Instantiate 4-bit ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Select the sum and carry based on cin\nassign sum = (cin) ? {sum_slice[1], sum_slice[0]} : {sum_slice[1], sum_slice[0]};\nassign cout = carry[1];\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module carry_select_adder_16bit(a, b, cin, sum, cout);\n    input [15:0] a;\n    input [15:0] b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] ripple_carry_out;\n    wire [3:0] carry_select_out;\n\n    // Instantiate the 4-bit ripple carry adder\n    ripple_carry rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .cout(ripple_carry_out[0]));\n    ripple_carry rca2(.a(a[7:4]), .b(b[7:4]), .cin(ripple_carry_out[1]), .cout(ripple_carry_out[2]));\n    ripple_carry rca3(.a(a[11:8]), .b(b[11:8]), .cin(ripple_carry_out[2]), .cout(ripple_carry_out[3]));\n    ripple_carry rca4(.a(a[15:12]), .b(b[15:12]), .cin(ripple_carry_out[3]), .cout(cout));\n\n    // Instantiate the 4-bit carry select adder slices\n    carry_select_adder_slice cs_slice1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(carry_select_out[0]), .cout(carry_select_out[1]));\n    carry_select_adder_slice cs_slice2(.a(a[7:4]), .b(b[7:4]), .cin(carry_select_out[1]), .sum(carry_select_out[2]), .cout(carry_select_out[3]));\n    carry_select_adder_slice cs_slice3(.a(a[11:8]), .b(b[11:8]), .cin(carry_select_out[2]), .sum(carry_select_out[3]), .cout(carry_select_out[4]));\n\n    // Output the sum and carry-out\n    assign sum = {carry_select_out[0], carry_select_out[1], carry_select_out[2], carry_select_out[3]};\n\nendmodule\n\nmodule ripple_carry(a, b, cin, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output cout;\n\n    wire [4:0] sum;\n\n    // Perform the addition\n    assign sum = a + b + cin;\n\n    // Determine the carry-out\n    assign cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n    input [3:0] a;\n    input [3:0] b;\n    input cin;\n    output [3:0] sum;\n    output cout;\n\n    wire [4:0] ripple_carry_out;\n\n    // Instantiate the 2 ripple carry adders\n    ripple_carry rca1(.a(a), .b(b), .cin(cin), .cout(ripple_carry_out[0]));\n    ripple_carry rca2(.a(a), .b(b), .cin(ripple_carry_out[1]), .cout(ripple_carry_out[2]));\n\n    // Instantiate the multiplexer\n    assign sum = (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1111 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1110 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1101 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1100 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1011 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1010 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1001 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b1000 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0111 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0110 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0101 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0100 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0011 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0010 :\n                 (ripple_carry_out[2] & ripple_carry_out[3]) ? 4'b0001 : 4'b0000;\n\n    // Determine the carry-out\n    assign cout = (ripple_carry_out[2] & ripple_carry_out[3]) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum[3:0]), .cout(carry[0]));\n\n// First carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .cout(carry[1]));\n\n// Second carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .cout(carry[2]));\n\n// Third carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .cout(carry[3]));\n\n// Final carry-out\nassign cout = carry[3];\n\nendmodule\n\n// 4-bit ripple carry adder\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First adder\nripple_adder ra1(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0]));\n\n// Second adder\nripple_adder ra2(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n\n// Third adder\nripple_adder ra3(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n\n// Fourth adder\nripple_adder ra4(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(cout));\n\nendmodule\n\n// Carry select adder slice\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\n// First adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(sum[1:0]), .cout(carry[0]));\n\n// Second adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(carry[0]), .sum(sum[3:2]), .cout(carry[1]));\n\n// Final carry-out\nassign cout = carry[1];\n\nendmodule\n\n// 4-bit ripple adder\nmodule ripple_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nwire c1, c2;\n\n// First adder\nfull_adder fa1(.a(a), .b(b), .cin(cin), .sum(sum), .cout(c1));\n\n// Second adder\nfull_adder fa2(.a(sum), .b(c1), .cin(c1), .sum(sum), .cout(cout));\n\nendmodule\n\n// Full adder\nmodule full_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nwire s1, c1;\n\n// First sum\nassign s1 = a ^ b;\n\n// First carry\nassign c1 = (a & b) | (a & cin) | (b & cin);\n\n// Final sum and carry\nassign sum = s1 ^ cin;\nassign cout = c1;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "`timescale 1ns / 1ps\n\nmodule carry_select_adder_16bit(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [3:0] carry;\nwire [3:0] sum_slice;\n\n// First 4-bit ripple carry adder\nripple_carry_adder rca1(.a(a[3:0]), .b(b[3:0]), .cin(cin), .sum(sum_slice[0]), .cout(carry[0]));\n\n// First carry select adder slice\ncarry_select_adder_slice cs_slice1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum_slice[1]), .cout(carry[1]));\n\n// Second carry select adder slice\ncarry_select_adder_slice cs_slice2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum_slice[2]), .cout(carry[2]));\n\n// Third carry select adder slice\ncarry_select_adder_slice cs_slice3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum_slice[3]), .cout(carry[3]));\n\n// Final sum\nassign sum = {sum_slice[3], sum_slice[2], sum_slice[1], sum_slice[0]};\n\n// Final carry-out\nassign cout = carry[3];\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [3:0] temp_carry;\n\n// Addition\nassign temp_sum = a + b + cin;\n\n// Carry-out\nassign cout = (a[3] & b[3]) | (a[3] & cin) | (b[3] & cin);\n\n// Sum\nassign sum = temp_sum[3:0];\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4:0] temp_sum;\nwire [3:0] temp_carry;\n\n// First ripple carry adder\nripple_carry_adder rca1(.a(a[1:0]), .b(b[1:0]), .cin(cin), .sum(temp_sum[1:0]), .cout(temp_carry[0]));\n\n// Second ripple carry adder\nripple_carry_adder rca2(.a(a[3:2]), .b(b[3:2]), .cin(temp_carry[0]), .sum(temp_sum[3:2]), .cout(temp_carry[1]));\n\n// Select sum and carry based on cin\nassign sum = (cin) ? temp_sum[3:2] : temp_sum[1:0];\nassign cout = temp_carry[1];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // Instantiate 8-bit adders\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8bit;\n    wire [7:0] y_8bit;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8bit),\n        .Co(Co_8bit)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8bit),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\n    // Combine the 8-bit results\n    assign y[7:0] = y_8;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[7:0];\n    assign Co = sum[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for first 4 bits\n    add4 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for last 4 bits\n    add4 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for first 2 bits\n    add2 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for last 2 bits\n    add2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for first bit\n    add1 add1_inst1 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co)\n    );\n\n    // 1-bit adder for last bit\n    add1 add1_inst2 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co),\n        .y(y[1]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n\n    assign y = a ^ b ^ Cin;\n    assign Co = (a & b) | (Cin & (a ^ b));\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    // 4-bit adder for first 4 bits\n    add4 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co)\n    );\n\n    // 4-bit adder for last 4 bits\n    add4 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n\n    // 2-bit adder for first 2 bits\n    add2 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co)\n    );\n\n    // 2-bit adder for last 2 bits\n    add2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n\n    // 1-bit adder for first bit\n    assign {Co, y[0]} = a[0] + b[0] + Cin;\n\n    // 1-bit adder for last bit\n    assign {Co, y[1]} = a[1] + b[1] + Co;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n\n    wire [7:0] Co7;\n    wire [7:0] y7;\n\n    // 8-bit adder for the first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co7)\n    );\n\n    // 8-bit adder for the last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co7),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n\n    wire [8:0] temp;\n\n    assign temp = a + b + Cin;\n    assign y = temp[7:0];\n    assign Co = temp[8];\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [7:0] Co_8;\n    wire [7:0] y_8;\n\n    // 8-bit adder for first 8 bits\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y_8),\n        .Co(Co_8)\n    );\n\n    // 8-bit adder for last 8 bits\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_8),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n\n    // 16-bit sum\n    assign y = {y_8, y[15:8]};\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n\n    // 8-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n\n    // 8-bit adder\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n    wire [15:0] y1, y2, y3, y4, y5, y6, y7, y8;\n\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y1),\n        .Co(c1)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(c1),\n        .y(y2),\n        .Co(c2)\n    );\n\n    assign y = {y2[7:0], y1[7:0]};\n    assign Co = c2;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    add4_inst1 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(c1)\n    );\n\n    add4_inst2 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(c1),\n        .y(y[7:4]),\n        .Co(c2)\n    );\n\n    assign y = {y[7:4], y[3:0]};\n    assign Co = c2;\n\nendmodule\n\nmodule add4_inst1 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire c1, c2, c3;\n\n    add2_inst1 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(c1)\n    );\n\n    add2_inst2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(c1),\n        .y(y[3:2]),\n        .Co(c2)\n    );\n\n    assign y = {y[3:2], y[1:0]};\n    assign Co = c2;\n\nendmodule\n\nmodule add4_inst2 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    wire c1, c2;\n\n    add2_inst1 add2_inst1 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(c1)\n    );\n\n    add2_inst2 add2_inst2 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(c1),\n        .y(y[3:2]),\n        .Co(c2)\n    );\n\n    assign y = {y[3:2], y[1:0]};\n    assign Co = c2;\n\nendmodule\n\nmodule add2_inst1 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\n\nendmodule\n\nmodule add2_inst2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder (\n    input a, b, cin,\n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire c1, c2, c3, c4, c5, c6, c7;\n    \n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n    \n    assign {cout, sum} = a + b + cin;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [8:0] sum_temp;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum_temp[0]), .cout(sum_temp[1]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(sum_temp[1]), .sum(sum_temp[2]), .cout(sum_temp[3]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(sum_temp[3]), .sum(sum_temp[4]), .cout(sum_temp[5]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(sum_temp[5]), .sum(sum_temp[6]), .cout(sum_temp[7]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(sum_temp[7]), .sum(sum_temp[8]), .cout(sum_temp[9]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(sum_temp[9]), .sum(sum_temp[10]), .cout(sum_temp[11]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(sum_temp[11]), .sum(sum_temp[12]), .cout(sum_temp[13]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(sum_temp[13]), .sum(sum_temp[14]), .cout(sum_temp[15]));\n\n    assign sum = sum_temp[7:0];\n    assign cout = sum_temp[8];\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\n\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n\n    wire [8:0] sum_temp;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum_temp[0]), .cout(sum_temp[1]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(sum_temp[1]), .sum(sum_temp[2]), .cout(sum_temp[3]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(sum_temp[3]), .sum(sum_temp[4]), .cout(sum_temp[5]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(sum_temp[5]), .sum(sum_temp[6]), .cout(sum_temp[7]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(sum_temp[7]), .sum(sum_temp[8]), .cout(sum_temp[9]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(sum_temp[9]), .sum(sum_temp[10]), .cout(sum_temp[11]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(sum_temp[11]), .sum(sum_temp[12]), .cout(sum_temp[13]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(sum_temp[13]), .sum(sum_temp[14]), .cout(sum_temp[15]));\n\n    assign sum = sum_temp[7:0];\n    assign cout = sum_temp[8];\nendmodule\n\nmodule full_adder (\n    input a, b, cin, \n    output sum, cout);\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Assign output\n    assign yout = product;\n\nendmodule\n\n// Submodule: Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n\n    reg [4:0] shift_count; // Shift count register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done <= 0;\n        end else if (start) begin\n            shift_count <= 16;\n            done <= 0;\n        end else if (shift_count > 0) begin\n            shift_count <= shift_count - 1;\n            done <= 0;\n        end else begin\n            done <= 1;\n        end\n    end\n\nendmodule\n\n// Submodule: Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift_count, // Shift count register\n    output reg [31:0] product  // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            product <= 0;\n        end else if (start) begin\n            shift_count <= 16;\n            product <= {16'b0, ain};\n        end else if (shift_count > 0) begin\n            shift_count <= shift_count - 1;\n            product <= {product[30:0], bin[shift_count]};\n        end\n    end\n\nendmodule\n\n// Submodule: Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product  // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, bin};\n        end else if (shift_count > 0) begin\n            product <= {product[30:0], bin[shift_count]};\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [31:0] product; // Intermediate product register\n\n    // Control unit\n    wire [4:0] shift_count; // Shift count register\n    wire start_shift;       // Start signal for shift operation\n    wire [15:0] a_reg;      // Register for multiplicand\n    wire [15:0] b_reg;      // Register for multiplier\n    wire [31:0] product_reg; // Register for product\n    wire done_flag;         // Completion flag\n\n    // Register unit\n    reg [15:0] a_reg_r;\n    reg [15:0] b_reg_r;\n    reg [31:0] product_reg_r;\n\n    // Multiplier unit\n    reg [31:0] product_r;\n    reg [15:0] b_shifted;\n\n    // Assign outputs\n    assign yout = product_r;\n    assign done = done_flag;\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .start_shift(start_shift),\n        .a_reg(a_reg),\n        .b_reg(b_reg)\n    );\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg_r <= 16'b0;\n            b_reg_r <= 16'b0;\n            product_reg_r <= 32'b0;\n        end else begin\n            a_reg_r <= ain;\n            b_reg_r <= bin;\n            product_reg_r <= product;\n        end\n    end\n\n    // Register unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 16'b0;\n            b_reg <= 16'b0;\n            product_reg <= 32'b0;\n        end else begin\n            a_reg <= a_reg_r;\n            b_reg <= b_reg_r;\n            product_reg <= product_reg_r;\n        end\n    end\n\n    // Multiplier unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_r <= 32'b0;\n            b_shifted <= 16'b0;\n        end else begin\n            if (start_shift) begin\n                b_shifted <= b_reg << shift_count;\n                product_r <= product_reg + b_shifted;\n            end else begin\n                product_r <= product_reg;\n            end\n        end\n    end\n\n    // Completion flag\n    assign done_flag = (shift_count == 16);\n\nendmodule\n\n// Submodule for control unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count, // Shift count register\n    output reg start_shift,       // Start signal for shift operation\n    output reg [15:0] a_reg,      // Register for multiplicand\n    output reg [15:0] b_reg       // Register for multiplier\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 5'b0;\n            start_shift <= 1'b0;\n            a_reg <= 16'b0;\n            b_reg <= 16'b0;\n        end else begin\n            if (start) begin\n                shift_count <= 5'b0;\n                start_shift <= 1'b1;\n            end else begin\n                if (shift_count == 16) begin\n                    shift_count <= 5'b0;\n                    start_shift <= 1'b0;\n                end else begin\n                    shift_count <= shift_count + 1;\n                    start_shift <= 1'b1;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for register unit\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a_reg,      // Register for multiplicand\n    output reg [15:0] b_reg       // Register for multiplier\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 16'b0;\n            b_reg <= 16'b0;\n        end else begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\n\nendmodule\n\n// Submodule for multiplier unit\nmodule mul_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] b_reg, // Register for multiplier\n    input start_shift,  // Start signal for shift operation\n    input [4:0] shift_count, // Shift count register\n    output reg [31:0] product_r, // Register for product\n    output reg [15:0] b_shifted // Register for shifted multiplier\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_r <= 32'b0;\n            b_shifted <= 16'b0;\n        end else begin\n            if (start_shift) begin\n                b_shifted <= b_reg << shift_count;\n                product_r <= product_r + b_shifted;\n            end else begin\n                product_r <= product_r;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift_count;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift_count(shift_count)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(yout)\n    );\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    reg [4:0] shift_count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done <= 0;\n        end else if (start) begin\n            shift_count <= 1;\n            done <= 0;\n        end else if (shift_count < 16) begin\n            shift_count <= shift_count + 1;\n            done <= 0;\n        end else begin\n            shift_count <= 0;\n            done <= 1;\n        end\n    end\nendmodule\n\n// Register Unit\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift_count,\n    output reg [15:0] a_reg,\n    output reg [15:0] b_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            a_reg <= 0;\n            b_reg <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n            a_reg <= ain;\n            b_reg <= bin;\n        end else if (shift_count < 16) begin\n            shift_count <= shift_count + 1;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count,\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product\n);\n    reg [15:0] a_reg;\n    reg [15:0] b_reg;\n    reg [4:0] shift_count_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n            a_reg <= 0;\n            b_reg <= 0;\n            shift_count_reg <= 0;\n        end else if (start) begin\n            product <= 0;\n            a_reg <= 0;\n            b_reg <= 0;\n            shift_count_reg <= 0;\n        end else if (shift_count_reg < shift_count) begin\n            a_reg <= a_reg << 1;\n            b_reg <= b_reg << 1;\n            shift_count_reg <= shift_count_reg + 1;\n        end else if (shift_count_reg == shift_count) begin\n            product <= a_reg * b_reg;\n            shift_count_reg <= 0;\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [15:0] m_reg;      // Multiplicand register\n    wire [15:0] m_shift;    // Shifted multiplier\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .m_reg(m_reg),\n        .m_shift(m_shift)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .m_shift(m_shift),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start & !rst_n; // Done signal\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            shift_count <= 0;\n        else if (start)\n            shift_count <= 5; // Shift count for 16-bit multiplication\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] m_reg,      // Multiplicand register\n    output reg [15:0] m_shift     // Shifted multiplier\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m_reg <= 0;\n            m_shift <= 0;\n        end\n        else if (start) begin\n            m_reg <= ain;\n            m_shift <= bin << shift_count;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] m_shift,    // Shifted multiplier\n    output reg [31:0] product // Product register\n);\n\n    reg [31:0] acc; // Accumulator\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            acc <= 0;\n            product <= 0;\n        end\n        else if (start) begin\n            acc <= 0;\n            product <= 0;\n        end\n        else begin\n            if (m_shift[shift_count])\n                acc <= acc + m_shift;\n            product <= acc;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n    wire [15:0] b;          // Multiplier register\n    wire [31:0] p;          // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(a),\n        .b(b)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .a(a),\n        .b(b),\n        .p(p)\n    );\n\n    // Assign outputs\n    assign yout = p;\n    assign m = bin;\n    assign a = ain;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output done         // Chip output flag signal.\n);\n\n    reg [4:0] shift_count; // Shift count register\n    reg done_flag;         // Done flag\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done_flag <= 0;\n        end else begin\n            if (start) begin\n                shift_count <= 0;\n                done_flag <= 0;\n            end else begin\n                if (shift_count < 16) begin\n                    shift_count <= shift_count + 1;\n                end else begin\n                    shift_count <= 0;\n                    done_flag <= 1;\n                end\n            end\n        end\n    end\n\n    assign done = done_flag;\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Multiplicand input.\n    input [15:0] b      // Multiplier input.\n);\n\n    reg [15:0] a_reg;    // Multiplicand register\n    reg [15:0] b_reg;    // Multiplier register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end else begin\n            if (start) begin\n                a_reg <= a;\n                b_reg <= b;\n            end\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] a,     // Multiplicand input.\n    input [15:0] b,     // Multiplier input.\n    output [31:0] p     // Product output.\n);\n\n    reg [15:0] a_reg;    // Multiplicand register\n    reg [15:0] b_reg;    // Multiplier register\n    reg [31:0] p_reg;     // Product register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n            p_reg <= 0;\n        end else begin\n            if (start) begin\n                a_reg <= a;\n                b_reg <= b;\n                p_reg <= 0;\n            end else begin\n                if (a_reg[0]) begin\n                    p_reg <= p_reg + (b_reg << 0);\n                end\n                if (a_reg[1]) begin\n                    p_reg <= p_reg + (b_reg << 1);\n                end\n                if (a_reg[2]) begin\n                    p_reg <= p_reg + (b_reg << 2);\n                end\n                if (a_reg[3]) begin\n                    p_reg <= p_reg + (b_reg << 3);\n                end\n                if (a_reg[4]) begin\n                    p_reg <= p_reg + (b_reg << 4);\n                end\n                if (a_reg[5]) begin\n                    p_reg <= p_reg + (b_reg << 5);\n                end\n                if (a_reg[6]) begin\n                    p_reg <= p_reg + (b_reg << 6);\n                end\n                if (a_reg[7]) begin\n                    p_reg <= p_reg + (b_reg << 7);\n                end\n                if (a_reg[8]) begin\n                    p_reg <= p_reg + (b_reg << 8);\n                end\n                if (a_reg[9]) begin\n                    p_reg <= p_reg + (b_reg << 9);\n                end\n                if (a_reg[10]) begin\n                    p_reg <= p_reg + (b_reg << 10);\n                end\n                if (a_reg[11]) begin\n                    p_reg <= p_reg + (b_reg << 11);\n                end\n                if (a_reg[12]) begin\n                    p_reg <= p_reg + (b_reg << 12);\n                end\n                if (a_reg[13]) begin\n                    p_reg <= p_reg + (b_reg << 13);\n                end\n                if (a_reg[14]) begin\n                    p_reg <= p_reg + (b_reg << 14);\n                end\n                if (a_reg[15]) begin\n                    p_reg <= p_reg + (b_reg << 15);\n                end\n            end\n        end\n    end\n\n    assign p = p_reg;\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n    wire [15:0] m;          // Multiplier register\n    wire [15:0] a;          // Multiplicand register\n    wire [31:0] temp;       // Temporary product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a_in(ain),\n        .m_in(bin),\n        .a_out(a),\n        .m_out(m)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .m(m),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = (shift_count == 16);\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            shift_count <= 0;\n        else if (start)\n            shift_count <= 0;\n        else if (shift_count < 16)\n            shift_count <= shift_count + 1;\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a_in,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m_in,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a, // Multiplicand register\n    output reg [15:0] m  // Multiplier register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a <= 0;\n            m <= 0;\n        end else begin\n            a <= a_in;\n            m <= m_in;\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] a,     // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] m,     // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count register\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            product <= 0;\n        else begin\n            if (shift_count == 0)\n                product <= {16'b0, a} * m;\n            else\n                product <= product + (product[31] ? m : 0);\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    reg_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .ain(ain),\n        .bin(bin),\n        .shift_count(shift_count),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule reg_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count register\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (shift_count == 0) begin\n            product <= {16'b0, ain};\n        end else begin\n            product <= {product[30:0], bin[shift_count - 1]};\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (shift_count == 0) begin\n            product <= {16'b0, bin};\n        end else begin\n            product <= product + (bin << (shift_count - 1));\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign done = start & ~rst_n;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count - 1;\n        end\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, ain};\n        end else if (shift_count > 0) begin\n            product <= {product[30:0], bin[shift_count - 1]};\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (shift_count > 0) begin\n            product <= product + (bin[shift_count - 1] << (shift_count - 1));\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    wire [31:0] product;    // Product register\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .shift_count(shift_count),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output assignment\n    assign yout = product;\n    assign done = start;\n\nendmodule\n\n// Control unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg [4:0] shift_count // Shift count register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 5;\n        end else begin\n            shift_count <= shift_count + 1;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, ain};\n        end else if (shift_count == 5) begin\n            product <= {16'b0, bin};\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    input [31:0] product // Product register\n);\n\n    reg [31:0] shifted_bin;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shifted_bin <= 0;\n        end else begin\n            shifted_bin <= {16'b0, bin} << shift_count;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            product <= product + shifted_bin;\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift;   // Shift count register\n    wire [31:0] product; // Product register\n\n    // Control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift(shift),\n        .product(product)\n    );\n\n    // Multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Assign product output\n    assign yout = product;\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done      // Chip output flag signal.\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            done <= 0;\n        end else if (start) begin\n            done <= 1;\n        end else begin\n            done <= done;\n        end\n    end\n\nendmodule\n\n// Register unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift, // Shift count register\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n            product <= 0;\n        end else if (start) begin\n            shift <= 0;\n            product <= {16'b0, ain};\n        end else begin\n            if (shift < 16) begin\n                shift <= shift + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift, // Shift count register\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= {16'b0, bin};\n        end else begin\n            if (shift < 16) begin\n                product <= product + (product << 1);\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift;\n    wire [31:0] product;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .shift(shift)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .bin(bin),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            done <= 0;\n        end else if (start) begin\n            done <= 1;\n        end else begin\n            done <= 0;\n        end\n    end\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [4:0] shift // Shift count register.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift <= 0;\n        end else if (start) begin\n            shift <= 0;\n        end else begin\n            shift <= shift + 1;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift,  // Shift count register.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [31:0] product // Product register.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else if (start) begin\n            product <= 0;\n        end else begin\n            if (shift[0]) begin\n                product <= product + (bin << 0);\n            end\n            if (shift[1)) begin\n                product <= product + (bin << 1);\n            end\n            if (shift[2)) begin\n                product <= product + (bin << 2);\n            end\n            if (shift[3)) begin\n                product <= product + (bin << 3);\n            end\n            if (shift[4)) begin\n                product <= product + (bin << 4);\n            end\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    wire [4:0] shift_count; // Shift count register\n    reg [31:0] product;     // Product register\n    reg [15:0] reg_a;       // Register for multiplicand\n    reg [15:0] reg_b;       // Register for multiplier\n    reg [1:0] state;        // State variable for control unit\n\n    // Instantiate control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count)\n    );\n\n    // Instantiate register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .ain(ain),\n        .reg_a(reg_a),\n        .reg_b(reg_b)\n    );\n\n    // Instantiate multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift_count(shift_count),\n        .reg_a(reg_a),\n        .reg_b(reg_b),\n        .product(product)\n    );\n\n    // Assign product output\n    assign yout = product;\n\n    // Assign done output\n    assign done = state[1];\n\nendmodule\n\n// Control unit\nmodule control_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output [4:0] shift_count // Shift count register\n);\n\n    reg [4:0] shift_count_reg; // Shift count register\n    reg [1:0] state;           // State variable\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count_reg <= 0;\n            state <= 0;\n        end else if (start) begin\n            shift_count_reg <= 5;\n            state <= 2;\n        end else if (shift_count_reg > 0) begin\n            shift_count_reg <= shift_count_reg - 1;\n            state <= 2;\n        end else begin\n            state <= 1;\n        end\n    end\n\n    assign shift_count = shift_count_reg;\n\nendmodule\n\n// Register unit\nmodule register_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    output reg [15:0] reg_a, // Register for multiplicand\n    output reg [15:0] reg_b  // Register for multiplier\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            reg_a <= 0;\n            reg_b <= 0;\n        end else if (start) begin\n            reg_a <= ain;\n            reg_b <= 0;\n        end else if (shift_count > 0) begin\n            reg_a <= {reg_a[14:0], 1'b0};\n            reg_b <= {reg_b[14:0], 1'b0};\n        end\n    end\n\nendmodule\n\n// Multiplier unit\nmodule multiplier_unit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count register\n    input [15:0] reg_a,   // Register for multiplicand\n    input [15:0] reg_b,   // Register for multiplier\n    output reg [31:0] product // Product register\n);\n\n    reg [31:0] product_reg; // Product register\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_reg <= 0;\n        end else if (start) begin\n            product_reg <= {16'b0, reg_b};\n        end else if (shift_count > 0) begin\n            product_reg <= product_reg + (reg_a[0] ? product_reg : 0);\n            product_reg <= {product_reg[30:0], 1'b0};\n        end\n    end\n\n    assign product = product_reg;\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(input clk, rst_n, start, ain, bin, yout, done);\n    reg [31:0] product; // Product register\n    reg [4:0] shift_count; // Shift count register\n    reg [15:0] a_reg, b_reg; // Registers for a and b\n    reg done_reg; // Done flag register\n\n    // Control Unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n            done_reg <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n            done_reg <= 0;\n        end else begin\n            if (shift_count < 16) begin\n                shift_count <= shift_count + 1;\n            end else begin\n                done_reg <= 1;\n            end\n        end\n    end\n\n    // Register Unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end else if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\n\n    // Multiplier Unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            if (shift_count == 0) begin\n                product <= b_reg;\n            end else begin\n                if (a_reg[shift_count - 1]) begin\n                    product <= product + b_reg;\n                end\n                product <= product << 1;\n            end\n        end\n    end\n\n    // Output Assignment\n    assign yout = product;\n    assign done = done_reg;\nendmodule\n\n// Submodule for Control Unit\nmodule ctrl_unit(\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] shift_count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 0;\n        end else if (start) begin\n            shift_count <= 0;\n        end else begin\n            if (shift_count < 16) begin\n                shift_count <= shift_count + 1;\n            end\n        end\n    end\nendmodule\n\n// Submodule for Register Unit\nmodule reg_unit(\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    output reg [15:0] a_reg,\n    output reg [15:0] b_reg\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end else if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nendmodule\n\n// Submodule for Multiplier Unit\nmodule mul_unit(\n    input clk,\n    input rst_n,\n    input [15:0] a_reg,\n    input [15:0] b_reg,\n    output reg [31:0] product\n);\n    reg [31:0] temp_product;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            temp_product <= 0;\n        end else begin\n            if (a_reg[0]) begin\n                temp_product <= b_reg;\n            end else begin\n                temp_product <= temp_product + b_reg;\n            end\n            temp_product <= temp_product << 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product <= 0;\n        end else begin\n            product <= temp_product;\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift_count;\n\n    // Control Unit\n    wire [4:0] shift_count_reg;\n    wire [4:0] shift_count_next;\n    wire start_reg;\n    wire start_next;\n    wire done_reg;\n    wire done_next;\n\n    // Register Unit\n    reg [15:0] a_reg;\n    reg [15:0] b_reg;\n\n    // Multiplier Unit\n    reg [31:0] product_reg;\n    reg [31:0] product_next;\n    reg [15:0] multiplicand;\n    reg [15:0] multiplier;\n    reg [4:0] shift_count_m;\n    reg [31:0] product_m;\n\n    // Assign outputs\n    assign yout = product_reg;\n    assign done = done_reg;\n\n    // Control Unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count_reg <= 0;\n            start_reg <= 0;\n            done_reg <= 0;\n        end else begin\n            shift_count_reg <= shift_count_next;\n            start_reg <= start_next;\n            done_reg <= done_next;\n        end\n    end\n\n    always @* begin\n        shift_count_next = shift_count_reg;\n        start_next = start_reg;\n        done_next = done_reg;\n\n        if (start_reg) begin\n            shift_count_next = 0;\n            start_next = 0;\n            done_next = 1;\n        end else if (shift_count_reg < 16) begin\n            shift_count_next = shift_count_reg + 1;\n            start_next = 0;\n            done_next = 0;\n        end else begin\n            start_next = 0;\n            done_next = 1;\n        end\n    end\n\n    // Register Unit\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end else if (start_reg) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\n\n    // Multiplier Unit\n    always @* begin\n        multiplicand = a_reg;\n        multiplier = b_reg;\n        shift_count_m = shift_count_reg;\n        product_m = 0;\n\n        if (shift_count_m < 16) begin\n            product_m = product_m + (multiplier << shift_count_m);\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_reg <= 0;\n        end else if (start_reg) begin\n            product_reg <= product_m;\n        end\n    end\n\nendmodule\n\n// Submodule for control unit\nmodule ctrl_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift_count, // Shift count for the multiplier.\n    output reg [4:0] shift_count_reg, // Register to hold the shift count.\n    output reg start_reg, // Register to hold the start signal.\n    output reg done_reg   // Register to hold the done signal.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count_reg <= 0;\n            start_reg <= 0;\n            done_reg <= 0;\n        end else begin\n            shift_count_reg <= shift_count;\n            start_reg <= start;\n            done_reg <= 0;\n        end\n    end\nendmodule\n\n// Submodule for register unit\nmodule reg_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] a_reg, // Register to hold the multiplicand.\n    output reg [15:0] b_reg  // Register to hold the multiplier.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 0;\n            b_reg <= 0;\n        end else begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nendmodule\n\n// Submodule for multiplier unit\nmodule mul_unit(\n    input clk,          // Chip clock signal.\n    input [15:0] multiplicand, // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] multiplier, // Input b (multiplier) with a data width of 16 bits.\n    input [4:0] shift_count, // Shift count for the multiplier.\n    output reg [31:0] product_reg, // Register to hold the product.\n    output reg [31:0] product_next // Register to hold the next product.\n);\n    always @* begin\n        product_next = product_reg;\n\n        if (shift_count < 16) begin\n            product_next = product_reg + (multiplier << shift_count);\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_reg <= 0;\n        end else begin\n            product_reg <= product_next;\n        end\n    end\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n    wire [4:0] shift;\n    wire [31:0] product;\n    wire [15:0] m_reg;\n    wire [15:0] a_reg;\n    wire [31:0] m_shifted;\n    wire [31:0] product_reg;\n\n    // Control Unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .done(done)\n    );\n\n    // Register Unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .m_reg(m_reg),\n        .a_reg(a_reg)\n    );\n\n    // Multiplier Unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .shift(shift),\n        .m_reg(m_reg),\n        .a_reg(a_reg),\n        .m_shifted(m_shifted),\n        .product(product)\n    );\n\n    // Output Assignment\n    assign yout = product;\n    assign product_reg = product;\n\nendmodule\n\n// Control Unit\nmodule control_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    output reg done     // Chip output flag signal.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            done <= 0;\n        else if (start)\n            done <= 1;\n        else\n            done <= 0;\n    end\nendmodule\n\n// Register Unit\nmodule register_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output reg [15:0] m_reg, // Register for multiplier.\n    output reg [15:0] a_reg  // Register for multiplicand.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m_reg <= 0;\n            a_reg <= 0;\n        end else if (start) begin\n            m_reg <= bin;\n            a_reg <= ain;\n        end\n    end\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit(\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [4:0] shift,  // Shift count.\n    input [15:0] m_reg, // Register for multiplier.\n    input [15:0] a_reg, // Register for multiplicand.\n    output reg [31:0] m_shifted, // Shifted multiplier.\n    output reg [31:0] product   // Product output.\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            m_shifted <= 0;\n            product <= 0;\n        end else if (start) begin\n            m_shifted <= {m_reg[15], m_reg[15:0]};\n            product <= {a_reg[15], a_reg[15:0]};\n        end else begin\n            m_shifted <= {m_reg[15], m_reg[15:0] << shift};\n            product <= product + (m_shifted & {32'b1 << (16 - shift), 16'b0});\n        end\n    end\nendmodule"}
