{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Submodules for registering instructions\n    ins_reg_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    ins_reg_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    // Outputs\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : ad12;\n    assign ad2 = (fetch == 2'b01) ? ad21 : ad22;\n\nendmodule\n\n// Submodule for registering instructions from RAM/ROM\nmodule ins_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n\n// Submodule for registering instructions from register\nmodule ins_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    instr_reg_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    instr_reg_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule instr_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n\n// Submodule for RAM/ROM\nmodule instr_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register instructions\n    ins_reg_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM instructions\n    ins_reg_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register instructions\nmodule ins_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule\n\n// Submodule for RAM/ROM instructions\nmodule ins_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    register_fetch ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    register_fetch ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Select instruction based on fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule register_fetch (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] stored_data;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            stored_data <= 8'b0;\n        end else begin\n            stored_data <= data;\n        end\n    end\n\n    assign ins = stored_data[7:5];\n    assign ad1 = stored_data[4:0];\n    assign ad2 = stored_data;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    reg_ins ins_p1_reg;\n    reg_ins ins_p2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 3'b0;\n            ins_p2_reg <= 3'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg <= {data[7:5], data[4:0]};\n            end else if (fetch == 2'b10) begin\n                ins_p2_reg <= {data[7:5], data[4:0]};\n            end\n        end\n    end\n\n    // Submodule for RAM/ROM\n    reg_ins ins_p1_ram;\n    reg_ins ins_p2_ram;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_ram <= 3'b0;\n            ins_p2_ram <= 3'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_ram <= {data[7:5], data[4:0]};\n            end else if (fetch == 2'b10) begin\n                ins_p2_ram <= {data[7:5], data[4:0]};\n            end\n        end\n    end\n\n    // Connect outputs\n    assign ins = fetch == 2'b01 ? ins_p1_reg : ins_p1_ram;\n    assign ad1 = fetch == 2'b01 ? ad1_p1_reg : ad1_p1_ram;\n    assign ad2 = fetch == 2'b01 ? ad2_p1_reg : ad2_p1_ram;\n\nendmodule\n\n// Submodule for register\nmodule reg_ins (\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk) begin\n        ins <= {data[7:5], data[4:0]};\n        ad1 <= data[7:5];\n        ad2 <= data;\n    end\nendmodule\n\n// Submodule for RAM/ROM\nmodule reg_ins (\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk) begin\n        ins <= {data[7:5], data[4:0]};\n        ad1 <= data[7:5];\n        ad2 <= data;\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register fetch\n    reg_fetch ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM fetch\n    reg_fetch ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule reg_fetch (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    reg_inst ins_reg_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    reg_inst ins_reg_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Connect outputs\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule reg_inst (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n            ad2 <= 8'b0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register fetch\n    instruction_reg_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM fetch\n    instruction_reg_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Connect outputs based on fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register fetch\nmodule instruction_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n\n// Submodule for RAM/ROM fetch\nmodule instruction_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    reg_ins ins_p1_reg;\n    reg_ins ins_p2_reg;\n\n    // Submodule for RAM/ROM\n    reg_ins ins_p1_ram;\n    reg_ins ins_p2_ram;\n\n    // Instantiate submodules\n    assign ins_p1 = ins_p1_reg.ins;\n    assign ad1_p1 = ins_p1_reg.ad;\n    assign ad2_p1 = ins_p1_reg.data;\n\n    assign ins_p2 = ins_p2_ram.ins;\n    assign ad1_p2 = ins_p2_ram.ad;\n    assign ad2_p2 = ins_p2_ram.data;\n\n    // Register for storing instructions\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 0;\n            ins_p2_reg <= 0;\n        end else begin\n            case (fetch)\n                2'b01: begin\n                    ins_p1_reg <= reg_ins_p1(data);\n                    ins_p2_reg <= ins_p2_reg;\n                end\n                2'b10: begin\n                    ins_p1_reg <= ins_p1_reg;\n                    ins_p2_reg <= reg_ins_p2(data);\n                end\n                default: begin\n                    ins_p1_reg <= ins_p1_reg;\n                    ins_p2_reg <= ins_p2_reg;\n                end\n            endcase\n        end\n    end\n\n    // Submodule for register\n    reg_ins_p1 reg_ins_p1 (\n        .clk(clk),\n        .data(data),\n        .ins(ins_p1_reg.ins),\n        .ad(ins_p1_reg.ad),\n        .data(ins_p1_reg.data)\n    );\n\n    // Submodule for RAM/ROM\n    reg_ins_p2 reg_ins_p2 (\n        .clk(clk),\n        .data(data),\n        .ins(ins_p2_reg.ins),\n        .ad(ins_p2_reg.ad),\n        .data(ins_p2_reg.data)\n    );\n\nendmodule\n\n// Submodule for register\nmodule reg_ins_p1 (\n    input clk,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        ins <= data[7:5];\n        ad <= data[4:0];\n        data_out <= data;\n    end\n\nendmodule\n\n// Submodule for RAM/ROM\nmodule reg_ins_p2 (\n    input clk,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        ins <= data[7:5];\n        ad <= data[4:0];\n        data_out <= data;\n    end\n\nendmodule\n\n// Function to extract instruction from data\nfunction reg_ins_p1 reg_ins_p1_func (input [7:0] data);\n    reg_ins_p1_func = data[7:5];\nendfunction\n\nfunction reg_ins_p2 reg_ins_p2_"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    instruction_reg_p1 ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    instruction_reg_p2 ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule instruction_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [7:0] stored_data;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            stored_data <= 8'b0;\n        end else begin\n            stored_data <= data;\n        end\n    end\n\n    assign ins = stored_data[7:5];\n    assign ad1 = stored_data[4:0];\n    assign ad2 = stored_data;\nendmodule\n\n// Submodule for RAM/ROM\nmodule instruction_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [7:0] stored_data;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            stored_data <= 8'b0;\n        end else begin\n            stored_data <= data;\n        end\n    end\n\n    assign ins = stored_data[7:5];\n    assign ad1 = stored_data[4:0];\n    assign ad2 = stored_data;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    instr_reg_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    instr_reg_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule instr_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n\n// Submodule for RAM/ROM\nmodule instr_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Instruction register for register source\n    ins_reg_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Instruction register for RAM/ROM source\n    ins_reg_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Connect outputs\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register source\nmodule ins_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule\n\n// Submodule for RAM/ROM source\nmodule ins_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    reg_ins ins_reg1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    reg_ins ins_reg2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output logic\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule reg_ins (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n            ad2 <= 8'b0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    instr_reg_p1 ins_p1_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM\n    instr_reg_p2 ins_p2_inst (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule instr_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule\n\n// Submodule for RAM/ROM\nmodule instr_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register fetch\n    register_fetch ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for RAM/ROM fetch\n    register_fetch ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\nmodule register_fetch (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg <= 3'b0;\n            ad1_reg <= 5'b0;\n            ad2_reg <= 8'b0;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule"}
