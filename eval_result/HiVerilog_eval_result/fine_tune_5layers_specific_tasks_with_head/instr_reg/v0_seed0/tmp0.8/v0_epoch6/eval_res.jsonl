{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins_p1, ins_p2;\n\n    assign ins = {data, ins_p2};\n    assign ad1 = data[4:0];\n    assign ad2 = data;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 0;\n            ins_p2 <= 0;\n        end else begin\n            case (fetch)\n                2'b01: ins_p1 <= data;\n                2'b10: ins_p2 <= data;\n                default: ; // no change\n            endcase\n        end\n    end\n\nendmodule\n\nmodule ins_reg_p1 (\n    input [7:0] data,\n    output reg [2:0] ins\n);\n\n    always @* begin\n        ins = data[7:5]; // extract opcode\n    end\n\nendmodule\n\nmodule ins_reg_p2 (\n    input [7:0] data,\n    output reg [7:0] ins\n);\n\n    always @* begin\n        ins = data; // accept full 8-bit data\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for register instructions\n    wire [7:0] ins_from_reg;\n    wire [4:0] ad1_from_reg;\n\n    // Submodule for RAM/ROM instructions\n    wire [7:0] ins_from_RAM_ROM;\n    wire [4:0] ad1_from_RAM_ROM;\n\n    // Registers to hold instructions\n    reg [7:0] ins_reg1, ins_reg2;\n    reg [4:0] ad1_reg1, ad1_reg2;\n\n    // Assign values from registers or inputs based on fetch signal\n    assign ins_from_reg = (fetch == 2'b01) ? ins_reg1 : 8'b0;\n    assign ad1_from_reg = (fetch == 2'b01) ? ad1_reg1 : 5'b0;\n    assign ins_from_RAM_ROM = (fetch == 2'b10) ? data : 8'b0;\n    assign ad1_from_RAM_ROM = (fetch == 2'b10) ? 5'b0 : 5'b0;\n\n    // Update register instructions and ad1 based on fetch signal and reset\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'b0;\n            ad1_reg1 <= 5'b0;\n            ins_reg2 <= 8'b0;\n            ad1_reg2 <= 5'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= data;\n                ad1_reg1 <= ad1_from_reg;\n            end else if (fetch == 2'b10) begin\n                ins_reg2 <= data;\n                ad1_reg2 <= ad1_from_RAM_ROM;\n            end\n        end\n    end\n\n    // Assign outputs from either register or RAM/ROM\n    assign ins = (fetch == 2'b10) ? ins_from_RAM_ROM : ins_from_reg;\n    assign ad1 = (fetch == 2'b10) ? ad1_from_RAM_ROM : ad1_from_reg;\n    assign ad2 = (fetch == 2'b10) ? data : 8'b0;\n\nendmodule\n\n// Submodule for register instructions\nmodule ins_reg_submodule (\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1\n);\n\n    assign {ins, ad1} = data;\n\nendmodule\n\n// Submodule for RAM/ROM instructions\nmodule ins_ram_rom_submodule (\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1\n);\n\n    assign {ins, ad1} = data;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    reg [2:0] ins_p1_reg;\n    reg [2:0] ins_p2_reg;\n\n    assign ins_p1 = ins_p1_reg;\n    assign ins_p2 = ins_p2_reg;\n\n    // Submodule for register source\n    ins_reg_sub ins_p1_sub (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1_reg)\n    );\n\n    // Submodule for RAM/ROM source\n    ins_reg_sub ins_p2_sub (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2_reg)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1_reg <= 3'b0;\n            ins_p2_reg <= 3'b0;\n        end else begin\n            if (fetch == 2'b01) // Fetch from register\n                ins_p1_reg <= data;\n            else if (fetch == 2'b10) // Fetch from RAM/ROM\n                ins_p2_reg <= data;\n        end\n    end\n\n    assign ins = ins_p1;\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2;\n\nendmodule\n\nmodule ins_reg_sub (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            ins <= 3'b0;\n        else\n            ins <= data[7:5];\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for storing instructions from register file\n    instruction_register_P1 ins_p1_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Submodule for storing instructions from RAM/ROM\n    instruction_register_P2 ins_p2_reg (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    // Output routing based on fetch signal\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_p1_reg.rst;\n            ins_p2_reg.rst;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1_reg.data(data);\n            end else if (fetch == 2'b10) begin\n                ins_p2_reg.data(data);\n            end\n        end\n    end\n\n    // Demux instruction outputs based on fetch signal\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for storing instructions from register file\nmodule instruction_register_P1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad1_reg <= data[4:0];\n            ad2_reg <= data;\n        end\n    end\n\n    assign ins = ins_reg;\n    assign ad1 = ad1_reg;\n    assign ad2 = ad2_reg;\n\nendmodule\n\n// Submodule for storing instructions from RAM/ROM\nmodule instruction_register_P2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [2:0] ins_reg;\n    reg [4:0] ad1_reg;\n    reg [7:0] ad2_reg;\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins_reg <= 3'b000;\n            ad1_reg <= 5'b00000;\n            ad2_reg <= 8'b00000000;\n        end else begin\n            ins_reg <= data[7:5];\n            ad"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [7:0] ins1, ins2;\n\n    // Submodule to store instructions from register\n    reg [7:0] ins_reg1, ins_reg2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_reg1 <= 8'b0;\n            ins_reg2 <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_reg1 <= data;\n            end else if (fetch == 2'b10) begin\n                ins_reg2 <= data;\n            end\n        end\n    end\n    assign ins1 = ins_reg1;\n    assign ins2 = ins_reg2;\n\n    // Submodule to store instructions from RAM/ROM\n    instruction ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    instruction ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = {ins_p1.opcode, ins_p1.op1, ins_p1.op2}; // Merge ins1 & ins2\n    assign ad1 = ins_p1.address;\n    assign ad2 = ins_p2.address;\n\nendmodule\n\nmodule instruction (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 8'b0;\n        end else begin\n            ins <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for register\n    reg [7:0] reg_data;\n    always @(posedge clk, negedge rst) begin\n        if (!rst) begin\n            reg_data <= 8'b0;\n        end else if (fetch == 2'b01) begin\n            reg_data <= data;\n        end\n    end\n\n    // Submodule for RAM/ROM\n    reg [7:0] ram_data;\n    always @(posedge clk, negedge rst) begin\n        if (!rst) begin\n            ram_data <= 8'b0;\n        end else if (fetch == 2'b10) begin\n            ram_data <= data;\n        end\n    end\n\n    // Connect the inputs from fetch to the submodules\n    assign ins_p1 = (fetch == 2'b01) ? data[2:0] : 3'b0;\n    assign ad1_p1 = (fetch == 2'b01) ? data[4:0] : 5'b0;\n    assign ad2_p1 = (fetch == 2'b01) ? data : 8'b0;\n    assign ins_p2 = (fetch == 2'b10) ? data[2:0] : 3'b0;\n    assign ad1_p2 = (fetch == 2'b10) ? data[4:0] : 5'b0;\n    assign ad2_p2 = (fetch == 2'b10) ? data : 8'b0;\n\n    // Connect the outputs\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for register\nmodule ins_reg_p1 (\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    assign ins = data[2:0];\n    assign ad1 = data[4:0];\n    assign ad2 = data;\nendmodule\n\n// Submodule for RAM/ROM\nmodule ins_reg_p2 (\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    assign ins = data[2:0];\n    assign ad1 = data[4:0];\n    assign ad2 = data;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    reg [7:0] ins1;\n    reg [7:0] ins2;\n\n    assign ins = {ins1[5:3], ins2[5:3]};\n    assign ad1 = {ins1[1:0], ins2[4:0]};\n    assign ad2 = {ins1[7:6], ins2[7:6]};\n\n    submodule ins_p1 (\n        input clk,\n        input rst,\n        input [7:0] data,\n        output reg [7:0] registered\n    );\n\n    submodule ins_p2 (\n        input clk,\n        input rst,\n        input [7:0] data,\n        output reg [7:0] registered\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins1 <= 8'b0;\n            ins2 <= 8'b0;\n        end else begin\n            case (fetch)\n                2'b01: ins_p1.register(data);\n                2'b10: ins_p2.register(data);\n                default: ; // Do nothing\n            endcase\n        end\n    end\n\nendmodule\n\nmodule submodule (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] registered\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            registered <= 8'b0;\n        end else begin\n            registered <= data;\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    // Submodule for register-fetched instructions\n    reg [7:0] reg_data; // Register to store fetched data\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    // Submodule for RAM/ROM-fetched instructions\n    wire [7:0] data_p2;\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Decoders for register-fetched and RAM/ROM-fetched instructions\n    decoder_reg_fetch ins_decoder_r (\n        .clk(clk),\n        .data_in(data),\n        .fetch(fetch[0]),\n        .data_out(data_p2),\n        .ins(ins_p2),\n        .ad1(ad1_p2),\n        .ad2(ad2_p2)\n    );\n\n    decoder_reg_fetch ins_decoder_ram (\n        .clk(clk),\n        .data_in(data_p2),\n        .fetch(fetch[1]),\n        .data_out(reg_data),\n        .ins(ins_p1),\n        .ad1(ad1_p1),\n        .ad2(ad2_p1)\n    );\n\n    // Output assignment\n    assign ins = fetch[0] ? ins_p1 : ins_p2;\n    assign ad1 = fetch[0] ? ad1_p1 : ad1_p2;\n    assign ad2 = fetch[0] ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for decoding instructions from RAM/ROM\nmodule decoder_reg_fetch (\n    input clk,\n    input [7:0] data_in,\n    input fetch,\n    output reg [7:0] data_out,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n            ad2 <= 0;\n        end else if (fetch) begin\n            ins <= data_in[7:5];\n            ad1 <= data_in[4:0];\n            ad2 <= data_in;\n        end\n        data_out <= data_in; // Always assign the input data regardless of the fetch signal\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [5:0] ins1;\n    wire [5:0] ins2;\n\n    ins_reg_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1)\n    );\n\n    ins_reg_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2)\n    );\n\n    assign ins = {ins_p1.ins, ins_p2.ins};\n    assign ad1 = ins_p1.ad1;\n    assign ad2 = ins_p2.ad2;\n\nendmodule\n\nmodule ins_reg_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [5:0] ins,\n    output reg [4:0] ad1\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins <= data[7:5];\n                ad1 <= data[4:0];\n            end\n        end\n    end\n\nendmodule\n\nmodule ins_reg_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] ins,\n    output reg [4:0] ad1\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 0;\n            ad1 <= 0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins <= data;\n                ad1 <= data[7:4];\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n\n    wire [2:0] ins2;\n    wire [7:0] ad22;\n\n    // Submodule 1 for storing instructions from RAM\n    instr_store ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .fetch(fetch[0]),\n        .ins(ins1),\n        .ad(ad11)\n    );\n\n    // Submodule 2 for storing instructions from ROM\n    instr_store ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .fetch(fetch[1]),\n        .ins(ins2),\n        .ad(ad22)\n    );\n\n    // Output connection of the submodules\n    assign ins = (fetch == 2'b01) ? ins1 : ins2;\n    assign ad1 = (fetch == 2'b01) ? ad11 : 5'b0;\n    assign ad2 = (fetch == 2'b10) ? ad22 : 8'b0;\n\nendmodule\n\n// Submodule for storing instructions from source\nmodule instr_store (\n    input clk,\n    input rst,\n    input [7:0] data,\n    input fetch,\n    output reg [2:0] ins,\n    output reg [4:0] ad\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad <= 5'b0;\n        end else if (fetch) begin\n            ins <= data[7:5];\n            ad <= data[4:0];\n        end\n    end\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\nreg [2:0] ins1, ins2;\nreg [4:0] ad11, ad12;\nreg [7:0] ad21, ad22;\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        ins1 <= 3'b0;\n        ad11 <= 5'b0;\n        ad21 <= 8'b0;\n        ins2 <= 3'b0;\n        ad12 <= 5'b0;\n        ad22 <= 8'b0;\n    end else begin\n        case (fetch)\n            2'b01: begin\n                ins1 <= data[7:5];\n                ad11 <= data[4:0];\n                ad21 <= data;\n            end\n            2'b10: begin\n                ins2 <= data[7:5];\n                ad12 <= data[4:0];\n                ad22 <= data;\n            end\n            default: begin\n                ins1 <= ins1;\n                ad11 <= ad11;\n                ad21 <= ad21;\n                ins2 <= ins2;\n                ad12 <= ad12;\n                ad22 <= ad22;\n            end\n        endcase\n    end\nend\n\n// Submodule definitions\n\nwire [2:0] opcode;\n\nassign opcode = fetch == 2'b01 ? ins1 : ins2;\nassign ins = opcode;\nassign ad1 = ad11;\nassign ad2 = ad21;\n\n// Simple Instruction Register Implementation using submodules\nsubmodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] opcode\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        opcode <= 3'b0;\n    end else begin\n        opcode <= data[7:5];\n    end\nend\n\nsubmodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [4:0] adr1,\n    output reg [7:0] adr2\n);\n\nalways @(posedge clk or negedge rst) begin\n    if (!rst) begin\n        adr1 <= 5'b0;\n        adr2 <= 8'b0;\n    end else begin\n        adr1 <= data[4:0];\n        adr2 <= data;\n    end\nend\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins_p1;\n    wire [4:0] ad1_p1;\n    wire [7:0] ad2_p1;\n\n    wire [2:0] ins_p2;\n    wire [4:0] ad1_p2;\n    wire [7:0] ad2_p2;\n\n    // Submodule for storing instructions from register\n    instruction_register_p1 ins_p1_sub (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .inst(ins_p1)\n    );\n\n    // Submodule for storing instructions from RAM/ROM\n    instruction_register_p2 ins_p2_sub (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .inst(ins_p2)\n    );\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ad1_p1 : ad1_p2;\n    assign ad2 = (fetch == 2'b01) ? ad2_p1 : ad2_p2;\n\nendmodule\n\n// Submodule for storing instructions from register\nmodule instruction_register_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] inst\n);\n\n    reg [2:0] current;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            current <= 0;\n        end else begin\n            current <= data[7:5];\n        end\n    end\n\n    assign inst = current;\n\nendmodule\n\n// Submodule for storing instructions from RAM/ROM\nmodule instruction_register_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] inst\n);\n\n    reg [7:0] current;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            current <= 0;\n        end else begin\n            current <= data;\n        end\n    end\n\n    assign inst = current[7:5];\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1, ins2;\n    wire [4:0] ad11, ad12;\n    wire [7:0] ad21, ad22;\n\n    // Submodule for reading instructions from register\n    register_instruction_p1 ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11)\n    );\n\n    // Submodule for reading instructions from RAM/ROM\n    register_instruction_p2 ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    assign ins = fetch[1] ? ins2 : ins1;\n    assign ad1 = fetch[1] ? ad12 : ad11;\n    assign ad2 = fetch[1] ? ad22 : data;\n\nendmodule\n\n// Submodule for reading instructions from register\nmodule register_instruction_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n        end else begin\n            ins <= data[2:0];\n            ad1 <= data[7:3];\n        end\n    end\nendmodule\n\n// Submodule for reading instructions from RAM/ROM\nmodule register_instruction_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n            ad2 <= 8'b0;\n        end else begin\n            ins <= data[2:0];\n            ad1 <= data[7:3];\n            ad2 <= data;\n        end\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "`timescale 11036503113\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n// Submodule for fetching instructions from RAM/ROM\nreg [7:0] ins_p1, ins_p2;\n\n// Submodule for fetching instructions from register file\nreg [7:0] ins_r1, ins_r2;\n\n// Output assignments\nassign ins = {ins_p1[7], ins_p2[7], ins_r1[7], ins_r2[7]};\nassign ad1 = {ins_p1[6:0], ins_p2[6:0], ins_r1[5:0], ins_r2[5:0]};\nassign ad2 = {ins_p1[7:1], ins_p2[7:1], ins_r1[7:1], ins_r2[7:1]};\n\n// FSM for selecting one of the two submodules for instruction fetch\nalways @(posedge clk, negedge rst) begin\n    if(!rst) begin\n        ins_p1 <= 8'b0;\n        ins_p2 <= 8'b0;\n        ins_r1 <= 8'b0;\n        ins_r2 <= 8'b0;\n    end else begin\n        case(fetch)\n            2'b01: ins_p1 <= data;\n            2'b10: ins_p2 <= data;\n            2'b00:; // No change\n        endcase\n    end\nend\n\n// Submodules for fetching instructions from RAM/ROM and register file\n\n// Instruction fetching from RAM/ROM\nalways @(posedge clk) begin\n    if(fetch == 2'b01)\n        ins_r1 <= data;\nend\n\n// Instruction fetching from register file\nalways @(posedge clk) begin\n    if(fetch == 2'b10)\n        ins_r2 <= data;\nend\n\nendmodule\n\n// Submodule for storing instructions in RAM/ROM\nmodule ins_pump (\n    input clk,\n    input [7:0] data,\n    output reg [7:0] ins\n);\nalways @(posedge clk) begin\n    ins <= data;\nend\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    wire [2:0] ins1;\n    wire [4:0] ad11;\n    wire [7:0] ad21;\n\n    wire [2:0] ins2;\n    wire [4:0] ad12;\n    wire [7:0] ad22;\n\n    reg [2:0] ins_r;\n    reg [4:0] ad1_r;\n    reg [7:0] ad2_r;\n\n    ins_register ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins1),\n        .ad1(ad11),\n        .ad2(ad21)\n    );\n\n    ins_register ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ins(ins2),\n        .ad1(ad12),\n        .ad2(ad22)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_r <= 3'b0;\n            ad1_r <= 5'b0;\n            ad2_r <= 8'b0;\n        end else begin\n            ins_r <= fetch[1] ? ins1 : ins_r;\n            ad1_r <= fetch[1] ? ad11 : ad1_r;\n            ad2_r <= fetch[1] ? ad21 : ad2_r;\n        end\n    end\n\n    assign ins = ins_r;\n    assign ad1 = ad1_r;\n    assign ad2 = ad2_r;\n\nendmodule\n\nmodule ins_register (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n            ad2 <= 8'b0;\n        end else begin\n            ins <= data[7:5];\n            ad1 <= data[4:0];\n            ad2 <= data;\n        end\n    end\n\nendmodule"}
