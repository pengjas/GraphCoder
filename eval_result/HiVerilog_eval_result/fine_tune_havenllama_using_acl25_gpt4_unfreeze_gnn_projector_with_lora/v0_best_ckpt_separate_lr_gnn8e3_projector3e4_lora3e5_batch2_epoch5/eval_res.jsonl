{"task_id": "sub_8bit", "response": "module sub_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n\nassign D = A - B;\nassign B_out = (A < B);\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module sub_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n\nassign D = A - B;\nassign B_out = (A < B);\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output reg [31:0] Diff,\n    output reg [31:0] B_out\n);\n\n    wire [31:0] A_neg;\n    wire [31:0] B_neg;\n\n    assign A_neg = ~A;\n    assign B_neg = ~B;\n\n    assign Diff = A_neg ^ B_neg;\n    assign B_out = A ^ B_neg;\n\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] Diff,\n    output [31:0] B_out\n);\n\n    wire [31:0] A_out;\n    wire [31:0] B_out;\n\n    assign A_out = A - B;\n    assign B_out = B;\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(\n    input [63:0] A,\n    input [63:0] B,\n    input [63:0] D,\n    output reg [63:0] B_out\n);\n\n    wire [63:0] A_out;\n    wire [63:0] B_out_out;\n    wire [63:0] D_out;\n\n    sub_32bit sub_32bit_inst1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .B_out(B_out_out)\n    );\n\n    sub_32bit sub_32bit_inst2 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .B_out(B_out)\n    );\n\n    sub_8bit sub_8bit_inst1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst2 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .D(D[3:0]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst3 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .D(D[7:4]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst4 (\n        .A(A[111:8]),\n        .B(B[11:8]),\n        .D(D[11:8]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst5 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .D(D[15:12]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst6 (\n        .A(A[19:16]),\n        .B(B[19:16]),\n        .D(D[19:16]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst7 (\n        .A(A[23:20]),\n        .B(B[23:20]),\n        .D(D[23:20]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst8 (\n        .A(A[27:24]),\n        .B(B[27:24]),\n        .D(D[27:24]),\n        .B_out(B_out_out)\n    );\n\n    sub_8bit sub_8bit_inst9 (\n        .A(A[31:28]),\n        .B(B[31:28]),\n        .D(D[31:28]),\n        .B_out(B_out_out)\n    );\n\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(\n    input [63:0] A,\n    input [63:0] B,\n    input [63:0] D,\n    output reg [63:0] B_out\n);\n\n    wire [63:0] A_out;\n    wire [63:0] B_out_out;\n    wire [63:0] D_out;\n\n    sub_32bit sub0(.A(A[63:32]), .B(B[63:32]), .D(D[63:32]), .B_out(B_out_out));\n    sub_32bit sub1(.A(A[31:0]), .B(B[31:0]), .D(D[31:0]), .B_out(B_out));\n    sub_32bit sub2(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(B_out));\n    sub_32bit sub3(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(B_out));\n\nendmodule\n\nmodule sub_32bit(\n    input [7:0] A,\n    input [7:0] B,\n    input [7:0] D,\n    output reg [7:0] B_out\n);\n\nwire [7:0] A_out;\nwire [7:0] B_out_out;\nwire [7:0] D_out;\n\nsub_8bit sub0(.A(A[7:4]), .B(B[7:4]), .D(D[7:4]), .B_out(B_out_out));\nsub_8bit sub1(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(B_out));\nsub_8bit sub2(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(B_out));\nsub_8bit sub3(.A(A[3:0]), .B(B[3:0]), .D(D[3:0]), .B_out(B_out));\n\nendmodule\n\nmodule sub_8bit(\n    input [3:0] A,\n    input [3:0] B,\n    input [3:0] D,\n    output reg [3:0] B_out\n);\n\nwire [3:0] A_out;\nwire [3:0] B_out_out;\nwire [3:0] D_out;\n\nsub_4bit sub0(.A(A[3:2]), .B(B[3:2]), .D(D[3:2]), .B_out(B_out_out));\nsub_4bit sub1(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(B_out));\nsub_4bit sub2(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(B_out));\nsub_4bit sub3(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(B_out));\n\nendmodule\n\nmodule sub_4bit(\n    input [1:0] A,\n    input [1:0] B,\n    input [1:0] D,\n    output reg [1:0] B_out\n);\n\nwire [1:0] A_out;\nwire [1:0] B_out_out;\nwire [1:0] D_out;\n\nsub_2bit sub0(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(B_out_out));\nsub_2bit sub1(.A(A[1:0]), .B(B[1:0]), .D(D[1:0]), .B_out(B_out));\nsub_2bit sub2(.A(A[1:0]), .B("}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n\n    wire [16:1] B_in;\n    wire [16:1] D_in;\n    wire [16:1] B_out_in;\n\n    assign B_in = B;\n    assign D_in = A;\n    assign B_out_in = 16'b0;\n\n    sub4bit_subtractor sub16_1 (\n        .A(D_in[16:1]),\n        .B(B_in[16:1]),\n        .D(D_in[15:0]),\n        .B_out(B_out_in[15:0])\n    );\n\n    sub4bit_subtractor sub16_2 (\n        .A(D_in[15:0]),\n        .B(B_in[15:0]),\n        .D(D_in[14:0]),\n        .B_out(B_out_in[14:0])\n    );\n\n    sub4bit_subtractor sub16_3 (\n        .A(D_in[14:0]),\n        .B(B_in[14:0]),\n        .D(D_in[13:0]),\n        .B_out(B_out_in[13:0])\n    );\n\n    sub4bit_subtractor sub16_4 (\n        .A(D_in[13:0]),\n        .B(B_in[13:0]),\n        .D(D_in[12:0]),\n        .B_out(B_out_in[12:0])\n    );\n\n    sub4bit_subtractor sub16_5 (\n        .A(D_in[12:0]),\n        .B(B_in[12:0]),\n        .D(D_in[11:0]),\n        .B_out(B_out_in[11:0])\n    );\n\n    sub4bit_subtractor sub16_6 (\n        .A(D_in[11:0]),\n        .B(B_in[11:0]),\n        .D(D_in[10:0]),\n        .B_out(B_out_in[10:0])\n    );\n\n    sub4bit_subtractor sub16_7 (\n        .A(D_in[10:0]),\n        .B(B_in[10:0]),\n        .D(D_in[9:0]),\n        .B_out(B_out_in[9:0])\n    );\n\n    sub4bit_subtractor sub16_8 (\n        .A(D_in[9:0]),\n        .B(B_in[9:0]),\n        .D(D_in[8:0]),\n        .B_out(B_out_in[8:0])\n    );\n\n    sub4bit_subtractor sub16_9 (\n        .A(D_in[8:0]),\n        .B(B_in[8:0]),\n        .D(D_in[7:0]),\n        .B_out(B_out_in[7:0])\n    );\n\n    sub4bit_subtractor sub16_10 (\n        .A(D_in[7:0]),\n        .B(B_in[7:0]),\n        .D(D_in[6:0]),\n        .B_out(B_out_in[6:0])\n    );\n\n    sub4bit_subtractor sub16_11 (\n        .A(D_in[6:0]),\n        .B(B_in[6:0]),\n        .D(D_in[5:0]),\n        .B_out(B_out_in[5:0])\n    );\n\n    sub4bit_subtractor sub16_12 (\n        .A(D_in[5:0]),\n        .B(B_in[5:0]),\n        ."}
{"task_id": "sub_16bit", "response": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A, B;\n    output [16:1] D;\n    output B_out;\n    wire [16:1] B_out_temp;\n    wire [3:1] A_temp, B_temp;\n    wire [4:1] D_temp;\n    wire [4:1] B_out_temp_temp;\n\n    assign A_temp = A[16:13];\n    assign B_temp = B[16:13];\n    assign D_temp = A_temp - B_temp;\n    assign B_out_temp_temp = B[12:9];\n    assign B_out_temp = B_out_temp_temp - B[8:5];\n    assign D = {D_temp, A[12:0] - B[8:5]};\n    assign B_out = B_out_temp[0];\nendmodule"}
{"task_id": "comparator_32bit", "response": "module subtraction_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] subtraction_result,  // 32-bit subtraction result\n);\n\nendmodule"}
{"task_id": "comparator_32bit", "response": "module subtraction_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output [31:0] subtraction_result,  // 32-bit subtraction result\n);\n\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  // pe0\n  wire [31:0] pe0_c0;\n  wire [31:0] pe0_c1;\n  pe pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(pe0_c0),\n    .c1(pe0_c1)\n  );\n\n  // pe1\n  wire [31:0] pe1_c0;\n  wire [31:0] pe1_c1;\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(pe1_c0),\n    .c1(pe1_c1)\n  );\n\n  assign c0 = pe0_c0;\n  assign c1 = pe1_c1;\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] S;\n    output C32;\n\n    wire [31:0] C1;\n    wire [31:0] C2;\n    wire C32;\n\n    // CLA1\n    wire [15:0] A1;\n    wire [15:0] B1;\n    wire [15:0] S1;\n    wire C16;\n\n    assign A1 = A[31:16];\n    assign B1 = B[31:16];\n    assign {C16, S1} = A1 + B1;\n\n    // CLA2\n    wire [7:0] A2;\n    wire [7:0] B2;\n    wire [7:0] S2;\n    wire C8;\n\n    assign A2 = A[15:8];\n    assign B2 = B[15:8];\n    assign {C8, S2} = A2 + B2;\n\n    // CLA3\n    wire [3:0] A3;\n    wire [3:0] B3;\n    wire [3:0] S3;\n    wire C4;\n\n    assign A3 = A[3:0];\n    assign B3 = B[3:0];\n    assign {C4, S3} = A3 + B3;\n\n    // CLA4\n    wire [1:0] A4;\n    wire [1:0] B4;\n    wire [1:0] S4;\n    wire C2;\n\n    assign A4 = A[2:1];\n    assign B4 = B[2:1];\n    assign {C2, S4} = A4 + B4;\n\n    // CLA5\n    wire [5:0] A5;\n    wire [5:0] B5;\n    wire [5:0] S5;\n    wire C10;\n\n    assign A5 = A[5:0];\n    assign B5 = B[5:0];\n    assign {C10, S5} = A5 + B5;\n\n    // CLA6\n    wire [9:0] A6;\n    wire [9:0] B6;\n    wire [9:0] S6;\n    wire C18;\n\n    assign A6 = A[15:6];\n    assign B6 = B[15:6];\n    assign {C18, S6} = A6 + B6;\n\n    // CLA7\n    wire [13:0] A7;\n    wire [13:0] B7;\n    wire [13:0] S7;\n    wire C22;\n\n    assign A7 = A[31:14];\n    assign B7 = B[31:14];\n    assign {C22, S7} = A7 + B7;\n\n    // CLA8\n    wire [17:0] A8;\n    wire [17:0] B8;\n    wire [17:0] S8;\n    wire C26;\n\n    assign A8 = A[31:18];\n    assign B8 = B[31:18];\n    assign {C26, S8} = A8 + B8;\n\n    // CLA9\n    wire [21:0] A9;\n    wire [21:0] B9;\n    wire [21:0] S9;\n    wire C29;\n\n    assign A9 = A[31:222];\n    assign B9 = B[31:22];\n    assign {C29, S9} = A9 + B9;\n\n    // CLA10\n    wire [25:0] A10;\n    wire [25:0] B10;\n    wire [25:0] S10;\n    wire C30;\n\n    assign A10 = A[31:26];\n    assign B10 = B[31:26];\n    assign {C30, S10"}
{"task_id": "alu", "response": "wire [31:0] a;\n    wire [31:0] b;\n    wire [5:0] aluc;\n    wire [31:0] r;\n    wire zero;\n    wire carry;\n    wire negative;\n    wire overflow;\n    wire flag;\n\n    // Addition\n    assign r = a + b + aluc;\n    assign zero = (a + b) == 0;\n    assign carry = (a + b) > 31;\n\n    // Subtraction\n    assign r = a - b - aluc;\n    assign zero = (a - b) == 0;\n    assign carry = (a - b) < 0;\n\n    // Logical operations\n    assign r = a & b;\n    assign zero = (a & b) == 0;\n    assign carry = (a & b) > 0;\n    assign r = a | b;\n    assign zero = (a | b) == 0;\n    assign carry = (a | b) > 0;\n\n    // Shift Left\n    assign r = a << aluc;\n    assign zero = (a << aluc) == 0;\n    assign carry = (a << aluc) > 0;\n    assign r = a >> aluc;\n    assign zero = (a >> aluc) == 0;\n    assign carry = (a >> aluc) < 0;\n\n    // Shift Right\n    assign r = a >> aluc;\n    assign zero = (a >> aluc) == 0;\n    assign carry = (a >> aluc) < 0;\n    assign r = a << aluc;\n    assign zero = (a << aluc) == 0;\n    assign carry = (a << aluc) > 0;\n\n    // SLT\n    assign r = a + b;\n    assign zero = (a + b) == 0;\n    assign carry = (a + b) > 31;\n    assign flag = 1;\n\n    // SLTU\n    assign r = a + b + aluc;\n    assign zero = (a + b + aluc) == 0;\n    assign carry = (a + b + aluc) > 31;\n    assign flag = 1;\nendmodule"}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 0;\n    end else begin\n      b1 <= b0;\n    end\n  end\n\n  // pe0\n  reg [31:0] pe0_c0;\n  always @(posedge clk) begin\n    pe0_c0 <= a0 * b0;\n  end\n\n  // pe1\n  reg [31:0] pe1_c0;\n  reg [31:0] pe1_c1;\n  always @(posedge clk) begin\n    pe1_c0 <= a1 * b1;\n    pe1_c1 <= pe1_c0 + pe0_c0;\n  end\n\n  assign c0 = pe0_c0;\n  assign c1 = pe1_c1;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] count_logic;\n    wire [15:0] count_register;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count(count_logic)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count(count_register)\n    );\n\n    assign count = count_logic + count_register;\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (up_down) begin\n                count <= count + 1;\n            end else begin\n                count <= count - 1;\n            end\n        end\n    end\nend\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    output reg [15:0] count\n);\n    always @(posedge clk or reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            count <= count;\n        end\n    end\nendmodule"}
{"task_id": "adder_32bit", "response": "module adder_32bit(A,B,S,C32);\n\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] S;\n    output C32;\n\n    wire [31:0] A_in;\n    wire [31:0] B_in;\n    wire [31:0] S_in;\n    wire C32_in;\n\n    assign A_in = A;\n    assign B_in = B;\n\n    CLA16 CLA16_inst1 (\n        .A(A_in[31:16]),\n        .B(B_in[31:16]),\n        .S(S_in[31:16]),\n        .C32(C32_in)\n    );\n\n    CLA16 CLA16_inst2 (\n        .A(A_in[15:0]),\n        .B(B_in[15:0]),\n        .S(S_in[15:0]),\n        .C32(C32_in)\n    );\n\n    assign S = S_in;\n    assign C32 = C32_in;\n\nendmodule\n\nmodule CLA16(A,B,S,C32);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] S;\n    output C32;\n\n    wire [15:0] A_in;\n    wire [15:0] B_in;\n    wire [15:0] S_in;\n    wire C32_in;\n\n    assign A_in = A;\n    assign B_in = B;\n\n    CLA16 CLA16_inst1 (\n        .A(A_in[31:16]),\n        .B(B_in[31:0]),\n        .S(S_in[31:16]),\n        .C32(C32_in)\n    );\n\n    CLA16 CLA16_inst2 (\n        .A(A_in[15:0]),\n        .B(B_in[15:0]),\n        .S(S_in[15:0]),\n        .C32(C32_in)\n    );\n\n    assign S = S_in;\n    assign C32 = C32_in;\n\nendmodule"}
{"task_id": "alu", "response": "wire [31:0] a;\n    wire [31:0] b;\n    wire [5:0] aluc;\n    wire [31:0] r;\n    wire zero;\n    wire carry;\n    wire negative;\n    wire overflow;\n    wire flag;\n\n    // Addition\n    assign r = a + b;\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1);\n    assign overflow = (r[31] == 1 && r[30] == 1);\n\n    // Subtraction\n    assign r = a - b;\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1 && r[30] == 1);\n    assign overflow = (r[31] == 1 && r[30] == 1 && r[29] == 1);\n    // Logical operations\n    assign r = a & b;\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1 && r[30] == 1);\n    assign overflow = (r[31] == 1 && r[30] == 1 && r[29] == 1);\n    // SLT and SLTU\n    assign r = a << b;\n    assign zero = (r == 0);\n    assign carry = (r[31] == 1);\n    assign negative = (r[31] == 1 && r[30] == 1);\n    assign overflow = (r[31] == 1 && r[30] == 1 && r[29] == 1);\n    assign flag = (r[31] == 1 && r[30] == 1 && r[29] == 1 && r[28] == 1);\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] instr;\n  wire [4:0] pc;\n  wire [4:0] next_pc;\n  wire [4:0] rd;\n  wire [4:0] rs1;\n  wire [4:0] rs2;\n  wire [4:0] op;\n  wire [31:0] alu_out;\n\n  reg [31:0] res_reg_file_reg [0:31];\n\n  // Fetch Stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= next_pc;\n    end\n  end\n\n  assign instr = instr_mem[pc];\n  assign next_pc = pc + 1;\n\n  // Decode Stage\n  assign rs1 = instr[31:26];\n  assign rs2 = instr[25:20];\n  assign rd = instr[14:10];\n  assign op = instr[30:26];\n\n  // Execute Stage\n  assign alu_out = (op == 0) ? reg_file[rs1] + reg_file[rs2] : reg_file[rs1] - reg_file[rs2];\n\n  // Memory Stage\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      res_reg_file_reg[rd] <= 0;\n    end else begin\n      res_reg_file_reg[rd] <= alu_out;\n    end\n  end\n\n  // Writeback Stage\n  assign res_reg_file[rd] = res_reg_file_reg[rd];\n\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] current_value;\n    wire [31:0] new_value;\n\n    // Multiplier Submodule\n    assign mult_result = a * b;\n\n    // Accumulator Submodule\n    assign current_value = rst ? 0 : current_value + new_value;\n    assign new_value = mult_result[31:0];\n\n    // Main pe module\n    assign c = current_value;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] count_logic;\n    wire [15:0] count_register;\n\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .count_logic(count_logic)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .count_logic(count_logic),\n        .count_register(count_register)\n    );\n\n    assign count = count_register;\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count_logic\n);\n\n    reg [15:0] count_reg = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            if (up_down) begin\n                count_reg <= count_reg + 1;\n            end else begin\n                count_reg <= count_reg - 1;\n            end\n        end\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] count_logic,\n    output wire [15:0] count_register\n);\n    reg [15:0] count_reg = 0;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 0;\n        end else begin\n            count_reg <= count_logic;\n        end\n    end\n\n    assign count_register = count_reg;\nendmodule"}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] mult_result;\n    wire [31:0] current_value;\n\n    // Multiplier Submodule\n    assign mult_result = a * b;\n\n    // Accumulator Submodule\n    reg [31:0] u_accumulator;\n    always @(posedge clk) begin\n        if (rst) begin\n            u_accumulator <= 0;\n        end else begin\n            u_accumulator <= u_accumulator + mult_result[31:0];\n        end\n    end\n\n    // Pe Module\n    assign current_value = u_accumulator;\n    assign c = current_value;\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    // Initialization\n    always @(posedge reset) begin\n        out <= 8'b00000_0001;\n    end\n\n    // State transition\n    always @(posedge clk) begin\n        if (out[7]) begin\n            out <= 8'b00000_000;\n        end else begin\n            out <= out + 1;\n        end\n    end\n\nendmodule"}
{"task_id": "ring_counter", "response": "reg [7:0] out_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            out_reg <= 8'b0000_0001;\n        end else begin\n            out_reg <= {out_reg[6:0], out_reg[0]};\n        end\n    end\n\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\ninput [15:0] a, b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [15:0] sum0, sum1, sum2, sum3;\nwire cout0, cout1, cout2, cout3;\n\n// 4-bit ripple carry adder\nripple_carry_carry adder ripple_carry_carry adder(a[15:0], b[15:0], cout0, sum0);\n\n// 4-bit carry select adder\ncarry_select_adder cs0(.a(a[15:12]), .b(b[15:12]), .cin(cout0), .sum(sum0), .cout(cout1));\ncarry_select_adder cs1(.a(a[11:8]), .b(b[11:8]), .cin(cout1), .sum(sum1), .cout(cout2));\ncarry_select_adder cs2(.a(a[7:4]), .b(b[7:4]), .cin(cout2), .sum(sum2), .cout(cout3));\ncarry_select_adder cs3(.a(a[3:0]), .b(b[3:0]), .cin(cout3), .sum(sum3), .cout(cout));\n\n// 4-bit ripple carry adder\nripple_carry_adder ripple_carry_adder(a[15:12], b[15:12], cout0, sum0);\nripple_carry_adder ripple_carry_adder1(a[11:8], b[11:8], cout1, sum1);\nripple_carry_adder ripple_carry_adder2(a[7:4], b[7:4], cout2, sum2);\nripple_carry_adder ripple_carry_adder3(a[3:0], b[3:0], cout3, sum3);\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cout, sum);\ninput a, b;\noutput cout;\noutput sum;\n\nwire c1, c2;\n\nassign {c1, sum} = a + b;\nassign cout = c1;\n\nendmodule\n\nmodule carry_select_adder(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nwire c1, c2;\n\nassign {c1, sum} = a + b + cin;\nassign cout = c1;\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nwire c1, c2;\n\nassign {c1, sum} = a + b + cin;\nassign cout = c1;\n\nendmodule\n\nmodule ripple_carry_adder(a, b, cout, sum);\ninput a, b;\noutput cout;\noutput sum;\n\nwire c1, c2;\n\n\nassign {c1, sum} = a + b;\nassign cout = c1;\n\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\ninput a, b, cin;\noutput sum, cout;\n\nwire c1, c2;\n\nassign {c1, sum} = a + b + cin;\nassign cout = c1;\n\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [2:0] ins,\n    output reg [4:0] ad1,\n    output reg [7:0] ad2\n);\n\n    // Instruction register for register source\n    reg [7:0] ins_p1;\n    always @(posedge clk) begin\n        if (rst == 1'b0) begin\n            ins_p1 <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins_p1 <= data;\n            end\n        end\n    end\n\n    // Instruction register for RAM/ROM source\n    reg [7:0] ins_p2;\n    always @(posedge clk) begin\n        if (rst == 1'b0) begin\n            ins_p2 <= 8'b0;\n        end else begin\n            if (fetch == 2'b10) begin\n                ins_p2 <= data;\n            end\n        end\n    end\n\n    // Outputs\n    always @(posedge clk) begin\n        if (rst == 1'b0) begin\n            ins <= 3'b0;\n            ad1 <= 5'b0;\n            ad2 <= 8'b0;\n        end else begin\n            if (fetch == 2'b01) begin\n                ins <= ins_p1[7:5];\n                ad1 <= ins_p1[4:0];\n                ad2 <= 8'b0;\n            end else if (fetch == 2'b10) begin\n                ins <= ins_p2[7:5];\n                ad1 <= ins_p2[4:0];\n                ad2 <= ins_p2;\n            end else begin\n                ins <= ins;\n                ad1 <= ad1;\n                ad2 <= ad2;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5", "response": "module stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n  wire [31:0] alu_out;\n  wire [31:0] next_instr_mem;\n  wire [31:0] next_reg_file;\n  wire [31:0] next_res_reg_file;\n\n  // Fetch stage\n  stage5_fetch fetch_stage (\n    .clk(clk),\n    .rst(rst),\n    .instr_mem(instr_mem),\n    .reg_file(reg_file),\n    .alu_out(alu_out),\n    .next_instr_mem(next_instr_mem),\n    .next_reg_file(next_reg_file)\n  );\n\n  // Decode stage\n  stage5_decode decode_stage (\n    .clk(clk),\n    .rst(rst),\n    .alu_out(alu_out),\n    .next_reg_file(next_reg_file),\n    .next_res_reg_file(next_res_reg_file)\n  );\n\n  // Execute stage\n  stage5_execute execute_stage (\n    .clk(clk),\n    .rst(rst),\n    .next_reg_file(next_reg_file),\n    .next_res_reg_file(next_res_reg_file)\n  );\n\n  // Memory stage\n  stage5_memory memory_stage (\n    .clk(clk),\n    .rst(rst),\n    .next_res_reg_file(next_res_reg_file),\n    .res_reg_file(res_reg_file)\n  );\n\n  // Writeback stage\n  stage5_writeback writeback_stage (\n    .clk(clk),\n    .rst(rst),\n    .res_reg_file(res_reg_file),\n    .next_res_reg_file(next_res_reg_file)\n  );\n\n  // Pipeline register\n  reg [31:0] pc;\n  reg [31:0] next_pc;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      pc <= 0;\n    end else begin\n      pc <= next_pc;\n    end\n  end\n\n  assign next_pc = pc + 1;\n\nendmodule\n\n\nmodule stage5_fetch(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] alu_out,\n  output [31:0] next_instr_mem,\n  output [31:0] next_reg_file\n);\n\n  reg [31:0] next_instr_mem_reg;\n  reg [31:0] next_reg_file_reg;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      next_instr_mem_reg <= 0;\n      next_reg_file_reg <= 0;\n    end else begin\n      next_instr_mem_reg <= instr_mem[pc];\n      next_reg_file_reg <= reg_file[pc];\n    end\n  end\n\n  assign alu_out = next_instr_mem_reg;\n  assign next_instr_mem = next_instr_mem_reg;\n  assign next_reg_file = next_reg_file_reg;\n\nendmodule\n\nmodule stage5_decode(\n  input clk,\n  input rst,\n  input [31:0] alu_out,\n  output [31:0] next_reg_file,\n  output [31:0] next_res_reg_file\n);\n\n  reg [31:0] next_reg_file_reg;\n  reg [31:0] next_res_reg_file_reg;"}
{"task_id": "instr_reg", "response": "module submodule ins_p1 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins\n);\n    reg [7:0] ins_p1;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 0;\n        end else if (fetch == 2'b01) begin\n            ins_p1 <= data;\n        end\n    end\n\n    assign ins = ins_p1;\nendmodule\n\nmodule submodule ins_p2 (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output [2:0] ins\n);\n    reg [7:0] ins_p2;\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p2 <= 0;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data;\n        end\n    end\n\n    assign ins = ins_p2;\nendmodule\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [2:0] ins_p1;\n    wire [2:0] ins_p2;\n    submodule ins_p1 (\n        input clk,\n        input rst,\n        input [7:0] data,\n        output [2:0] ins\n    );\n    submodule ins_p2 (\n        input clk,\n        input rst,\n        input [7:0] data,\n        output [2:0] ins\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_p1 <= 0;\n            ins_p2 <= 0;\n        end else if (fetch == 2'b01) begin\n            ins_p1 <= data;\n        end else if (fetch == 2'b10) begin\n            ins_p2 <= data;\n        end\n    end\n\n    assign ins = (fetch == 2'b01) ? ins_p1 : ins_p2;\n    assign ad1 = (fetch == 2'b01) ? ins_p1[4:0] : ins_p2[4:0];\n    assign ad2 = (fetch == 2'b01) ? ins_p1[7:5] : ins_p2[7:5];\nendmodule"}
{"task_id": "square_wave", "response": "endmodule"}
{"task_id": "counter_12", "response": "reg [3:0] count;\n    reg [3:0] out_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'b1111)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out_reg <= 4'b00000;\n        else if (valid_count)\n            out_reg <= count;\n    end\n\n    assign out = out_reg;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave_generator(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n); ASSISTANT:\n\nendmodule"}
{"task_id": "adder_16bit_csa", "response": "module adder_16bit_csa(a, b, cin, sum, cout);\n    input [15:0] a, b;\n    input cin;\n    output [15:0] sum;\n    output cout;\n\n    wire [3:0] c1, c2, c3, c4;\n\n    // 4-bit ripple carry adder\n    wire [3:0] c1_out;\n    ripple_carry_adder ripple_carry_adder1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .cout(c1_out)\n    );\n\n    // 4-bit carry select adder slice 1\n    wire [3:0] s1;\n    carry_select_adder carry_select_adder1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1_out),\n        .sum(s1),\n        .cout(c2)\n    );\n\n    // 4-bit carry select adder slice 2\n    wire [3:0] s2;\n    carry_select_adder carry_select_adder2 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(s1),\n        .sum(s2),\n        .cout(c3)\n    );\n\n    // 4-bit carry select adder slice 3\n    wire [3:0] s3;\n    carry_select_adder carry_select_adder3 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(s2),\n        .sum(s3),\n        .cout(c4)\n    );\n\n    // 4-bit ripple carry adder\n    wire [3:0] c1_out;\n    ripple_carry_adder ripple_carry_adder1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(c1),\n        .cout(c1_out)\n    );\n\n    // 4-bit ripple carry adder\n    wire [3:0] c2_out;\n    ripple_carry_adder ripple_carry_adder2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c2),\n        .cout(c2_out)\n    );\n\n    // 4-bit ripple carry adder\n    wire [3:0] c3_out;\n    ripple_carry_adder ripple_carry_adder3 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c3),\n        .cout(c3_out)\n    );\n\n    // 4-bit ripple carry adder\n    wire [3:0] c4_out;\n    ripple_carry_adder ripple_carry_adder4 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c4),\n        .cout(c4_out)\n    );\n\n    assign sum = {s3, s2, s1, c1_out};\n    assign cout = c4_out;\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg, b0_reg, b1_reg, b2_reg, b3_reg;\n  reg [31:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  reg [2:0] delay_reg;\n  integer i;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      a0_reg <= 0;\n      a1_reg <= 0;\n      a2_reg <= 0;\n      a3_reg <= 0;\n      b0_reg <= 0;\n      b1_reg <= 0;\n      b2_reg <= 0;\n      b3_reg <= 0;\n      c0_reg <= 0;\n      c1_reg <= 0;\n      c2_reg <= 0;\n      c3_reg <= 0;\n      delay_reg <= 0;\n    end else begin\n      a0_reg <= a0;\n      a1_reg <= a1;\n      a2_reg <= a2;\n      a3_reg <= a3;\n      b0_reg <= b0;\n      b1_reg <= b0_reg;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n      c0_reg <= a0_reg * b0_reg;\n      c1_reg <= a1_reg * b1_reg;\n      c2_reg <= a2_reg * b2_reg;\n      c3_reg <= a3_reg * b3_reg;\n      delay_reg <= delay_reg + 1;\n    end\n  end\n\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    // State register\n    reg [1:0] state;\n\n    // Waveform register\n    reg [4:0] wave_reg;\n\n    // State control\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00: state <= 2'b01;\n                2'b01: state <= 2'b10;\n                2'b10: state <= 2'b00;\n                default: state <= 2'b00;\n            endcase\n        end\n    end\n\n    // Waveform generation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            wave_reg <= 5'b0;\n        end else begin\n            case (state)\n                2'b00: wave_reg <= wave_reg + 5'b00001;\n                2'b01: wave_reg <= wave_reg - 5'b00001;\n                default: wave_reg <= wave_reg;\n            endcase\n        end\n    end\n\n    // Output\n    assign wave = wave_reg;\n\nendmodule"}
{"task_id": "signal_generator", "response": "waveform_generator.v\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2, q3;\n\n    my_dff8 dff0 (.clk(clk), .d(d[0]), .q(q0));\n    my_dff8 dff1 (.clk(clk), .d(d[1]), .q(q1));\n    my_dff8 dff2 (.clk(clk), .d(d[2]), .q(q2));\n    my_dff8 dff3 (.clk(clk), .d(d[3]), .q(q3));\n\n    assign q = sel[0] ? q3 :\n           sel[1] ? q2 :\n           sel[2] ? q1 :\n           sel[3] ? q0 :\n           d;\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [15:0] add_out;\n    wire [15:0] add_out_2;\n\n    add8_inst1 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .Co(Co),\n        .y(add_out)\n    );\n\n    add8_inst2 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(add_out[7]),\n        .Co(add_out_2[7]),\n        .y(add_out_2)\n    );\n\n    assign y = add_out_2;\n\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire Co,\n    output wire [7:0] y\n);\n    wire [8:0] add_out;\n\n    add8 add8_inst (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .Co(Co),\n        .y(add_out)\n    );\n\n    assign y = add_out;\n\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire Co,\n    output wire [7:0] y\n);\n    wire [8:0] add_out;\n\n    add8 add8_inst (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .Co(Co),\n        .y(add_out)\n    );\n\n    assign y = add_out[7:0];\n\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire Co,\n    output wire [7:0] y\n);\n    wire [8:0] add_out;\n\n    add8_inst1 add8_inst1 (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .Co(Co),\n        .y(add_out)\n    );\n\n    assign y = add_out[7:0];\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2, q3;\n    my_dff8 dff0 (.clk(clk), .d(d[0]), .q(q0));\n    my_dff8 dff1 (.clk(clk), .d(d[1]), .q(q1));\n    my_dff8 dff2 (.clk(clk), .d(d[2]), .q(q2));\n    my_dff8 dff3 (.clk(clk), .d(d[3]), .q(q3));\n    assign q = (sel == 2'b00) ? d :\n           (sel == 2'b1) ? q0 :\n           (sel == 2'b2) ? q1 :\n           (sel == 2'b3) ? q2 :\n           (sel == 2'b4) ? q3 :\n           d;\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "reg [2:0] q;\n    always @(posedge clk) begin\n        q <= {q[1:0], d};\n    end\nendmodule"}
{"task_id": "counter_12", "response": "reg [3:0] count;\n    always @(posedge clk) begin\n        if (!rst_n)\n            count <= 4'b00000;\n        else if (valid_count) begin\n            if (count == 4'b1111)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n    end\n    assign out = count;\nendmodule\n\nmodule\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            count <= 4'b000000;\n        else if (valid_count)\n            count <= count + 1;\n    end\nendmodule\n\nmodule\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n    end\nendmodule\n\nmodule\nmodule u_output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n    end\nendmodule\n\nmodule\nmodule u_counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count)\n            count <= count + 1;\n    end\nendmodule\n\nmodule\nmodule u_counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= out + 1;\n    end\nendmodule\n\nmodule\nmodule u_counter_12_1 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= out + 1;\n    end\nendmodule\n\nmodule\nmodule u_counter_12_2 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= out + 1;\n    end\nendmodule\n\nmodule\nmodule u_counter_12_3 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] out\n); ASSISTANT:\n    always @(posedge clk) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= out + 1;\n    end\nendmodule\n\nmodule\nmodule u_counter_12_1 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0]"}
{"task_id": "shift_reg", "response": "// D flip-flop\n    my_dff u0 (.clk(clk), .d(d), .q(q[0]));\n    my_dff u1 (.clk(clk), .d(d), .q(q[1]));\n    my_dff u2 (.clk(clk), .d(d), .q(q[2]));\n\nendmodule"}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b1, b2, b3;\n  reg [15:0] a0_reg, a1_reg, a2_reg, a3_reg;\n  reg [15:0] c0_reg, c1_reg, c2_reg, c3_reg;\n  wire [15:0] b0_reg, b1_reg, b2_reg, b3_reg;\n  wire [15:0] a0_wire, a1_wire, a2_wire, a3_wire;\n  wire [15:0] c0_wire, c1_wire, c2_wire, c3_wire;\n\n  assign b0_reg = b0;\n  assign b1_reg = b1;\n  assign b2_reg = b2;\n  assign b3_reg = b3;\n  assign a0_wire = a0;\n  assign a1_wire = a1;\n  assign a2_wire = a2;\n  assign a3_wire = a3;\n  assign c0_wire = c0;\n  assign c1_wire = c1;\n  assign c2_wire = c2;\n  assign c3_wire = c3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n      a0_reg <= 16'b0;\n      a1_reg <= 16'b0;\n      a2_reg <= 16'b0;\n      a3_reg <= 16'b0;\n      c0_reg <= 32'b0;\n      c1_reg <= 32'b0;\n      c2_reg <= 32'b0;\n      c3_reg <= 32'b0;\n    end else begin\n      b1 <= b0_reg;\n      b2 <= b1_reg;\n      b3 <= b2_reg;\n      a0_reg <= a0_wire;\n      a1_reg <= a1_wire;\n      a2_reg <= a2_wire;\n      a3_reg <= a3_wire;\n      c0_reg <= c0_wire;\n      c1_reg <= c1_wire;\n      c2_reg <= c2_wire;\n      c3_reg <= c3_wire;\n    end\n  end\n\n  assign b1 = b1_reg;\n  assign b2 = b2_reg;\n  assign b3 = b3_reg;\n  assign a0 = a0_reg;\n  assign a1 = a1_reg;\n  assign a2 = a2_reg;\n  assign a3 = a3_reg;\n  assign c0 = c0_reg;\n  assign c1 = c1_reg;\n  assign c2 = c2_reg;\n  assign c3 = c3_reg;\n\n  pe pe pe0(\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe pe1(\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  pe pe pe2(\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  pe pe pe3(\n    .clk("}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input clk,\n    input rst_n,\n    output [63:0] Q\n);\n\n    reg [63:0] Q_reg;\n\n    always @(posedge clk) begin\n        if (rst_n == 0) begin\n            Q_reg <= 64'b00000000000000000000000000000000;\n        end else begin\n            Q_reg <= {Q_reg[62:0], Q_reg[63]};\n        end\n    end\n\n    assign Q = Q_reg;\nendmodule\n\nmodule JC_logic(\n    input [63:0]       reg_inst,\n    output [63:0]       Q\n);\n\n    reg [63:0] Q_reg;\n\n    always @(posedge clk) begin\n        if (rst_n == 0) begin\n            Q_reg <= 4'b0000;\n        end else begin\n            Q_reg <= {Q_reg[2:0], reg_inst[63]};\n        end\n    end\n\n    assign Q = {Q_reg, reg_inst[63:0]};\nendmodule"}
{"task_id": "barrel_shifter", "response": "input [7:0] in;\n    input [2:0] sel;\n    output [7:0] out;\n    input [2:0] ctrl;\n    wire [2:0] shifted;\n    wire [2:0] mux2X1;\n    wire [2:0] mux2X1;\n    wire [2:0] mux2X1;\n    wire [2:0] mux2X1;\n    assign out[7:0] = in[7:0];\n    assign shifted[7:0] = in[7:0];\n    assign shifted[6:0] = in[6:0];\n    assign shifted[4:0] = in[4:0];\n    assign shifted[2:0] = in[2:0];\n    assign shifted[0] = in[0];\n    assign mux2X1[7:0] = {shifted[7:0], shifted[6:0]};\n    assign mux2X1[4:0] = {shifted[4:0], shifted[2:0]};\n    assign mux2X1[0] = {shifted[0], in[0]};\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input clk,\n    input rst_n,\n    output [63:0] Q\n);\n\n    reg [63:0] Q_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q_reg <= 64'b0;\n        else\n            Q_reg <= {Q_reg[62:0], Q_reg[63]};\n    end\n\n    assign Q = Q_reg;\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [15:0] add_out;\n    wire [15:0] add_out_2;\n    wire [15:0] add_out_3;\n\n    add8_inst1 add8_inst1_inst (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(Cin),\n        .y(add_out[7:0]),\n        .co(add_out_2[0])\n    );\n\n    add8_inst2 add8_inst2_inst (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(add_out_2[0]),\n        .y(add_out[15:8]),\n        .co(add_out_3[0])\n    );\n\n    add8_inst3 add8_inst3_inst (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(add_out_3[0]),\n        .y(add_out[15:12]),\n        .co(add_out_3[1])\n    );\n\n    assign y = add_out;\n    assign Co = add_out_3[1];\nendmodule\n\nmodule add8_inst1 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n    wire [8:0] add_out;\n\n\n    add8_inst1_inst add8_inst1_inst (\n        .a(a),\n        .b(b),\n        .cin(Cin),\n        .y(add_out),\n        .co(Co)\n    );\n\n    assign y = add_out;\nendmodule\n\nmodule add8_inst1_inst (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n    wire [8:0] add_out;\n\n    add8_inst2 add8_inst2_inst (\n        .a(a),\n        .b(b),\n        .cin(Cin),\n        .y(add_out),\n        .co(Co)\n    );\n\n    assign y = add_out;\nendmodule\n\nmodule add8_inst2 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n    wire [8:0] add_out;\n\n    add8_inst3 add8_inst3_inst (\n        .a(a),\n        .b(b),\n        .cin(Cin),\n        .y(add_out),\n        .co(Co)\n    );\n\n    assign y = add_out;\nendmodule\n\nmodule add8_inst3 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [8:0] y,\n    output wire Co\n);\n    wire [8:0] add_out;\n\n    assign add_out = a + b + Cin;\n    assign y = add_out;\n    assign Co = add_out[8];\nendmodule"}
{"task_id": "barrel_shifter", "response": "input [7:0] in;\n    input [2:0] sel;\n    output [7:0] out;\n    wire [7:0] mux2X1_out;\n    wire [2:0] mux2X1_sel;\n    wire [1:0] mux2X1_ctrl;\n\n    wire [1:0] mux2X1_ctrl;\n    wire [0:0] mux2X1_ctrl;\n\n    wire [2:0] mux2X1_out;\n    wire [1:0] mux2X1_sel;\n    wire [0:0] mux2X1_ctrl;\n\n    assign mux2X1_out = (in << {sel});\n    assign mux2X1_sel = (in << {ctrl});\n    assign mux2X1_ctrl = (in << {ctrl});\n\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\n    wire [31:0] pc;\n    wire [31:0] instr;\n    wire [31:0] op1;\n    wire [31:0] op2;\n    wire [31:0] out_reg_file;\n\n    reg [31:0] pc_reg;\n    reg [31:0] instr_reg;\n    reg [31:0] op1_reg;\n    reg [31:0] op2_reg;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            pc_reg <= 0;\n            instr_reg <= 0;\n            op1_reg <= 0;\n            op2_reg <= 0;\n        end\n        else begin\n            pc_reg <= pc;\n            instr_reg <= instr;\n            op1_reg <= op1;\n            op2_reg <= op2;\n        end\n    end\n\n    assign pc = pc_reg + 1;\n    assign instr = instr_mem[pc_reg];\n    assign op1 = reg_file[instr_reg];\n    assign op2 = reg_file[instr_reg + 1];\n    assign out_reg_file = op1_reg + op2_reg;\n\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout \n    );wire [7:0] sum; \n    wire [7:0] carry; \n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[0])); \n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1])); \n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2])); \n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3])); \n    full_adder fa4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4])); \n    full_adder fa5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5])); \n    full_adder fa6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6])); \n    full_adder fa7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(carry[7])); \nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout); \nassign {sum, cout} = a + b + cin; \nendmodule"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire CLK_50_int;\n    wire CLK_10_int;\n    wire CLK_1_int;\n\n    clk_div_2 clk_div_50 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_50_int));\n    clk_div_10 clk_div_10_int (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_10_int));\n    clk_div_100 clk_div_100_int (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_1_int));\n\n    assign CLK_50 = CLK_50_int;\n    assign CLK_10 = CLK_10_int;\n    assign CLK_1 = CLK_1_int;\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg CLK_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n        end else begin\n            CLK_out_reg <= ~CLK_out_reg;\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg [3:0] CLK_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n        end else begin\n            CLK_out_reg <= CLK_out_reg + 1;\n        end\n    end\n\n    assign CLK_out = CLK_out_reg[3];\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n    reg [6:0] CLK_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n        end else begin\n            CLK_out_reg <= CLK_out_reg + 1;\n        end\n    end\n\n    assign CLK_out = CLK_out_reg[6];\nendmodule"}
{"task_id": "adder_8bit", "response": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout \n    );\n    wire [7:0] sum1, sum2, sum3, sum4, sum5, sum6, sum7;\n    wire c1, c2, c3, c4, c5, c6, c7;\n    \n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum1), .cout(c1));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum2), .cout(c2));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum3), .cout(c3));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum4), .cout(c4));\n    full_adder fa4(.a(a[4]), .b(b[4]), .cin(c4), .sum(sum5), .cout(c5));\n    full_adder fa5(.a(a[5]), .b(b[5]), .cin(c5), .sum(sum6), .cout(c6));\n    full_adder fa6(.a(a[6]), .b(b[6]), .cin(c6), .sum(sum7), .cout(c7));\n    full_adder fa7(.a(a[7]), .b(b[7]), .cin(c7), .sum(sum), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin, \n    output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}
{"task_id": "stagepipe3", "response": "module stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\n\nwire [31:0] instr_mem_fetched;\nwire [31:0] reg_file_fetched;\nwire [31:0] instr_mem_execute;\nwire [31:0] reg_file_execute;\nwire [31:0] instr_mem_writeback;\nwire [31:0] reg_file_writeback;\n\nreg [31:0] out_reg_file;"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire CLK_div_50_out;\n    wire CLK_div_10_out;\n    wire CLK_div_1_out;\n\n    clk_div_2 clk_div_50 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_div_50_out), .CLK_div_out(CLK_50));\n    clk_div_10 clk_div_10 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_div_10_out), .CLK_div_out(CLK_10));\n    clk_div_1 clk_div_1 (.CLK_in(CLK_in), .RST(RST), .CLK_out(CLK_div_1_out), .CLK_div_out(CLK_1));\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out,\n    output CLK_div_out\n);\n    reg CLK_out_reg;\n    reg [1:0] CLK_div_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n            CLK_div_out_reg <= 0;\n        end else begin\n            CLK_out_reg <= ~CLK_out_reg;\n            CLK_div_out_reg <= CLK_div_out_reg + 1;\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\n    assign CLK_div_out = CLK_div_out_reg[1];\n\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output CLK_out,\n    output CLK_div_out\n);\n    reg CLK_out_reg;\n    reg [3:0] CLK_div_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n            CLK_div_out_reg <= 0;\n        end else begin\n            CLK_out_reg <= ~CLK_out_reg;\n            CLK_div_out_reg <= CLK_div_out_reg + 1;\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\n    assign CLK_div_out = CLK_div_out_reg[3];\n\nendmodule\n\n\nmodule clk_div_1 (\n    input CLK_in,\n    input RST,\n    output CLK_out,\n    output CLK_div_out\n);\n    reg CLK_out_reg;\n    reg [6:0] CLK_div_out_reg;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out_reg <= 0;\n            CLK_div_out_reg <= 0;\n        end else begin\n            CLK_out_reg <= ~CLK_out_reg;\n            CLK_div_out_reg <= CLK_div_out_reg + 1;\n        end\n    end\n\n    assign CLK_out = CLK_out_reg;\n    assign CLK_div_out = CLK_div_out_reg[6];\n\nendmodule"}
{"task_id": "multi_16bit", "response": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    // Control Unit\n    reg [3:0] shift_count;\n    reg done_flag;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            shift_count <= 4'b0000;\n            done_flag <= 1'b0;\n        end else begin\n            if (start) begin\n                shift_count <= 4'b0000;\n                done_flag <= 1'b0;\n            end else begin\n                if (shift_count == 4'b1111) begin\n                    shift_count <= 4'b0000;\n                    done_flag <= 1'b1;\n                end else begin\n                    shift_count <= shift_count + 4'b0001;\n                    done_flag <= 1'b0;\n                end\n            end\n        end\n    end\n\n    // Register Unit\n    reg [15:0] a_reg;\n    reg [15:0] b_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            a_reg <= 16'b0000000000000;\n            b_reg <= 16'b0000000000000;\n        end else begin\n            if (start) begin\n                a_reg <= ain;\n                b_reg <= bin;\n            end\n        end\n    end\n\n    // Multiplier Unit\n    reg [31:0] product_reg;\n    reg [15:0] shift_reg;\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            product_reg <= 32'b00000000000000000000000000000000;\n            shift_reg <= 16'b00000000000000;\n        end else begin\n            if (shift_count == 4'b0000) begin\n                shift_reg <= b_reg;\n            end else begin\n                shift_reg <= shift_reg;\n            end\n            if (shift_count == 4'b0000) begin\n                product_reg <= {shift_reg, 16'b0};\n            end else begin\n                if (shift_reg[0]) begin\n                    product_reg <= product_reg + {shift_reg, b_reg};\n                end\n                product_reg <= product_reg;\n            end\n        end\n    end\n\n    // Output Assignment\n    assign yout = product_reg;\n    assign done = done_flag;\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [3:0]   cnt;\n    reg [9:0]   data_accum;\n    reg              valid_out;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            data_accum <= 0;\n            valid_out <= 0;\n        end else begin\n            if (valid_in) begin\n                cnt <= cnt + 1;\n                data_accum <= data_accum + data_in;\n                if (cnt == 4) begin\n                    valid_out <= 1;\n                    cnt <= 0;\n                end\n            end else begin\n                valid_out <= 0;\n            end\n        end\n    end\n\n    assign data_out = data_accum;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    output reg [3:0]   cnt\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accum (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output reg [9:0]   data_accum\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_accum <= 0;\n        end else begin\n            if (valid_in) begin\n                data_accum <= data_accum + data_in;\n            end\n        end\n    end\n\nendmodule\n\nmodule valid_out (\n    input               clk,\n    input               rst_n,\n    input               valid_in,\n\n    output reg          valid_out\n);\n\n    reg [1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            valid_out <= 0;\n        end else begin\n            if (valid_in) begin\n                cnt <= cnt + 1;\n                if (cnt == 4) begin\n                    valid_out <= 1;\n                    cnt <= 0;\n                end\n            end else begin\n                valid_out <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n\n    reg [2:0] counter;\n    reg [2:0] clk_div;\n\n    reg [1:0] clk_div_2;\n    reg [1:0] clk_div_3;\n\n    wire clk_div_4;\n    wire clk_div_5;\n    wire clk_div_6;\n\n    wire clk_average;\n    wire clk_adjustment;\n\n    assign clk_div = clk_div_4 | clk_div_5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == MUL2_DIV_CLK - 1) begin\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n\n            clk_div <= clk_div_4 | clk_div_5;\n        end\n    end\n\n    assign clk_div_4 = counter == 0;\n    assign clk_div_5 = counter == 1;\n\n    assign clk_average = counter == 0;\n    assign clk_adjustment = counter == 1;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_2 <= 0;\n            clk_div_3 <= 0;\n        end else begin\n            clk_div_2 <= clk_div_4;\n            clk_div_3 <= clk_div_5;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_6 <= 0;\n        end else begin\n            clk_div_6 <= clk_div_2 | clk_div_3;\n        end\n    end\n\nendmodule"}
{"task_id": "accu", "response": "module accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    reg [3:0]   cnt;\n    reg [9:0]   acc_data;\n    reg [0:0]   valid_out;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            cnt <= 0;\n        else if (valid_in)\n            cnt <= cnt + 1;\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            acc_data <= 0;\n        else if (cnt == 4) begin\n            acc_data <= acc_data + data_in;\n            cnt <= 0;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            valid_out <= 0;\n        else if (cnt == 4)\n            valid_out <= 1;\n    end\n\n    assign data_out = acc_data;\n\nendmodule"}
{"task_id": "multi_16bit", "response": "// Control Unit\nreg [4:0] shift_count;\nreg done_flag;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        shift_count <= 0;\n        done_flag <= 0;\n    end else begin\n        if (start) begin\n            shift_count <= 15;\n            done_flag <= 0;\n        end else if (shift_count != 0) begin\n            shift_count <= shift_count - 1;\n            done_flag <= 0;\n        end else begin\n            done_flag <= 1;\n        end\n    end\nend\n\n// Register Unit\nreg [15:0] a_reg;\nreg [15:0] b_reg;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        a_reg <= 0;\n        b_reg <= 0;\n    end else begin\n        if (start) begin\n            a_reg <= ain;\n            b_reg <= bin;\n        end\n    end\nend\n\n// Multiplier Unit\nreg [31:0] product;\nreg [15:0] shifted_b;\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        product <= 0;\n        shifted_b <= 0;\n    end else begin\n        if (shift_count != 0) begin\n            shifted_b <= {b_reg[shift_count], b_reg[15:shift_count]};\n            product <= product + (a_reg & shifted_b);\n        end\n    end\nend\n\n// Output Assignment\nassign yout = product;\nassign done = done_flag;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": "module freq_divbyfrac (\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n\n    parameter MUL2_DIV_CLK = 7;\n\n\n    reg [2:0] clk_div;\n\n    reg [2:0] clk_div_div;\n\n    reg [2:0] clk_div_avg;\n\n    reg [3:0] clk_div_cnt;\n    reg [3:0] clk_div_cnt_avg;\n\n    reg [1:0] clk_div_cnt_adjust;\n    reg [1:0] clk_div_cnt_adjust_avg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_cnt <= 0;\n            clk_div_cnt_avg <= 0;\n        end else begin\n            clk_div_cnt <= clk_div_cnt + 1;\n            clk_div_cnt_avg <= clk_div_cnt_avg + 1;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div_cnt_adjust <= 0;\n            clk_div_cnt_adjust_avg <= 0;\n        end else begin\n            clk_div_cnt_adjust <= clk_div_cnt;\n            clk_div_cnt_adjust_avg <= clk_div_cnt_avg;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 0;\n            clk_div_avg <= 0;\n        end else begin\n            clk_div <= clk_div_cnt_adjust[MUL2_DIV_CLK-1];\n            clk_div_avg <= clk_div_cnt_adjust_avg[MUL2_DIV_CLK-1];\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [NUM_DIV-1:0] pos_edge_counter;\n    reg [NUM_DIV-1:0] neg_edge_counter;\n    reg [NUM_DIV-1:0] clk_div1;\n    reg [NUM_DIV-1:0] clk_div2;\n\n    always @(posedge clk or negedge clk) begin\n        if (rst_n == 1'b0) begin\n            pos_edge_counter <= {NUM_DIV{1'b0}};\n            neg_edge_counter <= {NUM_DIV{1'b0}};\n        end else begin\n            if (clk == 1'b1) begin\n                pos_edge_counter <= pos_edge_counter + 1'b1;\n            end else begin\n                neg_edge_counter <= neg_edge_counter + 1'b1;\n            end\n        end\n    end\n\n    assign clk_div1 = pos_edge_counter[NUM_DIV-1] | neg_edge_counter[NUM_DIV-1];\n    assign clk_div2 = pos_edge_counter[NUM_DIV-2] | neg_edge_counter[NUM_DIV-2];\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [15:0] abs_dividend;\n    wire [15:0] abs_divisor;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    wire [3:0] counter;\n    wire [3:0] shift_reg;\n    wire [15:0] shifted_divisor;\n    wire [15:0] shifted_dividend;\n    wire [15:0] shifted_result;\n    wire [15:0] shifted_remainder;\n    wire [15:0] shifted_quotient;\n    wire [15:0] shifted_abs_divisor;\n    wire [15:0] shifted_abs_dividend;\n    wire [15:0] shifted_abs_divisor_neg;\n    wire [15:0] shifted_abs_dividend_neg;\n    wire [15:0] shifted_abs_dividend_neg_divisor;\n    wire [15:0] shifted_abs_dividend_neg_divisor_neg;\n    wire [15:0] shifted_abs_dividend_neg_divisor_neg_remainder;\n    wire [15:0] shifted_abs_dividend_neg_divisor_neg_remainder_quotient;\n    wire [15:0] shifted_abs_dividend_neg_divisor_neg_remainder_quotient_remainder;\n    wire [15:0] shifted_abs_dividend_neg_divisor_neg_remainder_quotient_remainder_result;\n\n    reg [15:0] abs_dividend_reg;\n    reg [15:0] abs_divisor_reg;\n    reg [15:0] quotient_reg;\n    reg [15:0] remainder_reg;\n    reg [3:0] counter_reg;\n    reg [3:0] shift_reg_reg;\n    reg [15:0] shifted_divisor_reg;\n    reg [15:0] shifted_dividend_reg;\n    reg [15:0] shifted_result_reg;\n    reg [15:0] shifted_remainder_reg;\n    reg [15:0] shifted_quotient_reg;\n    reg [15:0] shifted_abs_divisor_reg;\n    reg [15:0] shifted_abs_dividend_reg;\n    reg [15:0] shifted_abs_divisor_neg_reg;\n    reg [15:0] shifted_abs_dividend_neg_divisor_neg_remainder_reg;\n    reg [15:0] shifted_abs_dividend_neg_divisor_neg_remainder_quotient_reg;\n    reg [15:0] shifted_abs_dividend_neg_divisor_neg_remainder_quotient_remainder_result_reg;\n\n    assign abs_dividend = (sign == 1) ? -dividend : dividend;\n    assign abs_divisor = (sign == 1) ? -divisor : divisor;\n\n    assign quotient = (sign == 1) ? -remainder : remainder;\n    assign remainder = (sign == 1) ? -quotient : quotient;\n\n    assign counter = 0;\n    assign shift_reg = 0;\n    assign shifted_divisor = 0;\n    assign shifted_dividend = 0;\n    assign shifted_result = 0;\n    assign shifted_remainder = 0;\n    assign shifted_quotient"}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    parameter NUM_DIV = 5;\n\n    reg [NUM_DIV - 1:0] pos_edge_counter;\n    reg [NUM_DIV - 1:0] neg_edge_counter;\n    reg [NUM_DIV - 1:0] clk_div1;\n    reg [NUM_DIV - 1:0] clk_div2;\n\n    always @(posedge clk) begin\n        if (rst_n) begin\n            pos_edge_counter <= 0;\n            neg_edge_counter <= 0;\n        end else begin\n            if (clk == 1) begin\n                pos_edge_counter <= pos_edge_counter + 1;\n            end else begin\n                neg_edge_counter <= neg_edge_counter + 1;\n            end\n        end\n    end\n\n    assign clk_div1 = pos_edge_counter[0] | pos_edge_counter[1] | pos_edge_counter[2] | pos_edge_counter[3] | pos_edge_counter[4];\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "parameter NUM_DIV = 2;\n\n    reg [3:0] counter;\n    reg clk_div;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == (NUM_DIV - 1)) begin\n                counter <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                counter <= counter + 1;\n                clk_div <= clk_div;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyeven", "response": "parameter NUM_DIV = 2;\n    reg [3:0] counter = 0;\n    reg clk_div = 0;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            counter <= 0;\n            clk_div <= 0;\n        end else begin\n            if (counter == NUM_DIV - 1) begin\n                counter <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "radix2_div", "response": "module radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [15:0] abs_dividend;\n    wire [15:0] abs_divisor;\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    wire [3:0] counter;\n    wire [15:0] shift_reg;\n\n    reg [15:0] shift_reg_next;\n    reg [15:0] remainder_next;\n    reg [15:0] quotient_next;\n    reg [3:0] counter_next;\n    reg [15:0] abs_dividend_next;\n    reg [15:0] abs_divisor_next;\n\n    // Absolute Value Calculation\n    assign abs_dividend = (sign == 1) ? -dividend : dividend;\n    assign abs_divisor = (sign == 1) ? -divisor : divisor;\n\n    // Negative Divisor Calculation\n    assign neg_divisor = (sign == 1) ? divisor : -divisor;\n\n    // Division Control Logic\n    always @(posedge clk or posedge rst) begin\n        if (rst == 1) begin\n            counter <= 0;\n            shift_reg <= 0;\n            quotient <= 0;\n            remainder <= 0;\n        end else begin\n            if (opn_valid == 1) begin\n                counter <= counter + 1;\n                shift_reg <= shift_reg_next;\n                quotient <= quotient_next;\n                remainder <= remainder_next;\n            end\n        end\n    end\n\n    // Result Management\n    always @(posedge clk) begin\n        if (counter == 16) begin\n            res_valid <= 1;\n        end else begin\n            res_valid <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Prepare dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    assign dividend = {A, 16'b0};\n    assign divisor = {B, 16'b0};\n\n    // Divide operation\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    div_operation div_op(.dividend(dividend), .divisor(divisor), .quotient(quotient), .remainder(remainder));\n\n    // Output\n    assign result = quotient;\n    assign odd = remainder;\nendmodule\n\n// Prepare dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] dividend,\n    output reg [31:0] dividend_32,\n    output reg [15:0] divisor_16\n);\n    always @(*) begin\n        dividend_32 = dividend;\n        divisor_16 = divisor;\n    end\nendmodule\n\n// Divide operation\nmodule div_operation(\n    input wire [31:0] dividend,\n    input wire [15:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    always @(*) begin\n        quotient = dividend / divisor;\n        remainder = dividend % divisor;\n    end\nendmodule"}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n    // Prepare the dividend and divisor\n    wire [31:0] dividend;\n    wire [15:0] divisor;\n    wire [31:0] dividend_prep;\n    wire [31:0] divisor_prep;\n\n    // Prepare the dividend\n    assign dividend_prep = {A[31:16], 16'b0};\n    assign dividend = dividend_prep[31:0];\n\n    // Prepare the divisor\n    assign divisor_prep = {B, 16'b0};\n    assign divisor = divisor_prep[15:0];\n\n    // Perform the division\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    wire [31:0] shifted_dividend;\n    wire [31:0] shifted_divisor;\n    wire [31:0] shifted_dividend_prep;\n    wire [31:0] shifted_divisor_prep;\n    wire [31:0] shifted_dividend;\n    wire [31:0] shifted_divisor;\n    wire [31:0] shifted_dividend_prep_2;\n    wire [31:0] shifted_divisor_prep_2;\n    wire [31:0] shifted_dividend_prep_3;\n    wire [31:0] shifted_divisor_prep_3;\n    wire [31:0] shifted_dividend_prep_4;\n    wire [31:0] shifted_divisor_prep_4;\n    wire [31:0] shifted_dividend_prep_5;\n    wire [31:0] shifted_divisor_prep_5;\n    wire [31:0] shifted_dividend_prep_6;\n    wire [31:0] shifted_divisor_prep_6;\n    wire [31:0] shifted_dividend_prep_7;\n    wire [31:0] shifted_divisor_prep_7;\n    wire [31:0] shifted_dividend_prep_8;\n    wire [31:0] shifted_divisor_prep_8;\n    wire [31:0] shifted_dividend_prep_9;\n    wire [31:0] shifted_divisor_prep_9;\n    wire [31:0] shifted_dividend_prep_10;\n    wire [31:0] shifted_divisor_prep_10;\n    wire [31:0] shifted_dividend_prep_11;\n    wire [31:0] shifted_divisor_prep_11;\n    wire [31:0] shifted_dividend_prep_12;\n    wire [31:0] shifted_divisor_prep_12;\n    wire [31:0] shifted_dividend_prep_13;\n    wire [31:0] shifted_divisor_prep_13;\n    wire [31:0] shifted_dividend_prep_14;\n    wire [31:0] shifted_divisor_prep_14;\n    wire [31:0] shifted_dividend_prep_15;\n    wire [31:0] shifted_divisor_prep_15;\n    wire [31:0] shifted_dividend_prep_16;\n    wire [31:0] shifted_divisor_prep_16;\n    wire [31:0] shifted_dividend_prep_17;\n    wire [31:0] shifted"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    // Control unit\n    reg [15:0] dividend;\n    reg [7:0] divisor;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [15:0] shift_reg;\n    reg [15:0] shift_reg_next;\n    reg [15:0] odd_reg;\n    reg [15:0] odd_reg_next;\n    reg [15:0] result_reg;\n    reg [15:0] result_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] result_reg_next;\n    reg [15:0] result_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [15:0] odd_reg_next;\n    reg [1"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    // 16-bit dividend\n    wire [15:0] dividend = A;\n\n    // 8-bit divisor\n    wire [7:0] divisor = B;\n\n    // 16-bit quotient\n    wire [15:0] quotient = 0;\n\n    // 16-bit remainder\n    wire [15:0] remainder = 0;\n\n    // 16-bit dividend shifted left\n    wire [15:0] shifted_dividend = dividend << 8;\n\n    // 16-bit divisor shifted right\n    wire [15:0] shifted_divisor = divisor >> 1;\n\n    // 16-bit quotient\n    wire [15:0] quotient_temp = shifted_dividend - shifted_divisor;\n\n    // 16-bit remainder\n    wire [15:0] remainder_temp = shifted_dividend - quotient_temp * divisor;\n\n    // 16-bit quotient\n    assign quotient = quotient_temp;\n\n    // 16-bit remainder\n    assign remainder = remainder_temp;\n\nendmodule"}
