{"task_id": 21, "response": "module ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);\n\n    // Submodule for configuration register\n    wire [31:0] config_reg_output;\n    configuration_register config_store (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load(load),\n        .config_data(config_data),\n        .config_reg_output(config_reg_output)\n    );\n\n    // Output assignment\n    assign current_config = config_reg_output;\n\nendmodule\n\n// Submodule for configuration register\nmodule configuration_register (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output reg [31:0] config_reg_output\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            config_reg_output <= 32'b0; // Reset to default value\n        end else if (load) begin\n            config_reg_output <= config_data;\n        end\n    end\n\nendmodule"}
{"task_id": 21, "response": "module ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);\n\n    // Submodule for configuration register\n    wire [31:0] config_reg_value;\n    reg [31:0] reg_value; // Internal register to store configuration\n\n    configuration_store config_store (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load(load),\n        .config_data(config_data),\n        .config_reg_value(config_reg_value)\n    );\n\n    assign current_config = reg_value;\n\nendmodule\n\n// Submodule for configuration register\nmodule configuration_store (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output reg [31:0] config_reg_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            config_reg_value <= 32'b0;\n        end else if (load) begin\n            config_reg_value <= config_data;\n        end\n    end\n\nendmodule"}
{"task_id": 21, "response": "module ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);\n\n    // Submodule for configuration register\n    wire [31:0] config_reg_output;\n    reg [31:0] config_reg;  // 32-bit configuration register\n\n    configuration_store config_store (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load(load),\n        .config_data(config_data),\n        .config_out(config_reg_output)\n    );\n\n    always @ (posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            config_reg <= 32'b0;\n        else if (load)\n            config_reg <= config_data;\n    end\n\n    assign current_config = config_reg_output;\n\nendmodule\n\n// Submodule for configuration register\nmodule configuration_store (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output reg [31:0] config_out\n);\n\n    always @ (posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            config_out <= 32'b0;\n        else if (load)\n            config_out <= config_data;\n    end\n\nendmodule"}
{"task_id": 22, "response": "module subtractor_32bit_css(A, B, Diff);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n\n    wire [7:0] c1, c2, c3, c4;\n    wire [7:0] s1, s2, s3, s4;\n\n    cs_subtractor sub1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(1'b0),\n        .S(s1),\n        .Cout(c1)\n    );\n\n    cs_subtractor sub2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .S(s2),\n        .Cout(c2)\n    );\n\n    cs_subtractor sub3 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .S(s3),\n        .Cout(c3)\n    );\n\n    cs_subtractor sub4 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .S(s4),\n        .Cout(Diff[31:24])\n    );\n\n    assign Diff[23:0] = s1 + s2 + s3 + s4;\n\nendmodule\n\nmodule cs_subtractor(A, B, Cin, S, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    wire [8:0] diff;\n    wire carry;\n\n    assign diff = A + B + {8{Cin}};\n    assign S = diff[7:0];\n    assign Cout = diff[8];\nendmodule"}
{"task_id": 22, "response": "module subtractor_32bit_css(A, B, Diff);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n\n    wire [7:0] c1, c2, c3, c4;\n    wire [7:0] s1, s2, s3, s4;\n\n    cs_subtractor sub1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(1'b0),\n        .S(s1),\n        .Cout(c1)\n    );\n\n    cs_subtractor sub2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .S(s2),\n        .Cout(c2)\n    );\n\n    cs_subtractor sub3 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .S(s3),\n        .Cout(c3)\n    );\n\n    cs_subtractor sub4 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .S(s4),\n        .Cout(Diff[31:24])\n    );\n\n    assign Diff[23:0] = s1 + s2 + s3 + s4;\n\nendmodule\n\nmodule cs_subtractor(A, B, Cin, S, Cout);\n    input [7:0] A, B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    assign {Cout, S} = A - B - Cin;\nendmodule"}
{"task_id": 22, "response": "module subtractor_32bit_css(A, B, Diff);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n\n    wire [7:0] s1, s2, s3, s4;\n    wire [7:0] c1, c2, c3, c4;\n\n    cs_subtractor sub1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .S(s1),\n        .C(c1)\n    );\n\n    cs_subtractor sub2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .S(s2),\n        .C(c2)\n    );\n\n    cs_subtractor sub3 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .S(s3),\n        .C(c3)\n    );\n\n    cs_subtractor sub4 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .S(s4),\n        .C(c4)\n    );\n\n    assign Diff[7:0] = s1 - s2 - c2;\n    assign Diff[15:8] = s3 - s4 - c3;\n    assign Diff[23:16] = s1 + s3 - c1 - c3;\n    assign Diff[31:24] = s2 + s4 - c2 - c4;\n\nendmodule\n\nmodule cs_subtractor(A, B, S, C);\n    input [7:0] A, B;\n    output [7:0] S;\n    output C;\n\n    wire [8:0] diff;\n    assign diff = A - B;\n    assign S = diff[7:0];\n    assign C = diff[8];\nendmodule"}
{"task_id": 23, "response": "module sub_32bit_cascaded(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [6:0] borrow;\n\n    borrow_save_subt bss1(A[31:28], B[31:28], borrow[0]);\n    borrow_save_subt bss2(A[27:24], B[27:24], borrow[1]);\n    borrow_save_subt bss3(A[23:20], B[23:20], borrow[2]);\n    borrow_save_subt bss4(A[19:16], B[19:16], borrow[3]);\n    borrow_save_subt bss5(A[15:12], B[15:12], borrow[4]);\n    borrow_save_subt bss6(A[11:8], B[11:8], borrow[5]);\n    borrow_save_subt bss7(A[7:4], B[7:4], borrow[6]);\n    borrow_save_subt bss8(A[3:0], B[3:0], borrow[7]);\n\n    assign D = A - B - borrow[7];\n    assign B_out = borrow[7];\nendmodule\n\nmodule borrow_save_subt(A, B, borrow_in, D, borrow_out);\n    input [3:0] A;\n    input [3:0] B;\n    input borrow_in;\n    output [3:0] D;\n    output borrow_out;\n\n    wire [4:0] borrow;\n\n    assign borrow[0] = 1;\n    assign D = A - B - borrow[0];\n    assign borrow_out = (A[0] & ~B[0]) | (~A[0] & B[0]) | (A[0] & B[0] & borrow_in);\nendmodule"}
{"task_id": 14, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the BCD increment logic\n    bcd_increment u_bcd_increment (\n        .current_count(count),\n        .next_count(next_count),\n        .enable(enable)\n    );\n\n    // Instantiate the BCD register\n    bcd_register u_bcd_register (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule bcd_increment (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            if (current_count < 9) begin\n                next_count = current_count + 1;\n            end else begin\n                next_count = 0;\n            end\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule bcd_register (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else if (enable) begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 7, "response": "`timescale 1ns / 1ps\n\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);\n\n    reg [15:0] data_a;\n    reg [15:0] data_b;\n    reg [31:0] result;\n    reg op_valid;\n\n    wire [31:0] sum;\n    wire [31:0] product;\n\n    // Instantiate the adder and multiplier submodules\n    adder u_adder (\n        .a(data_a),\n        .b(data_b),\n        .sum(sum)\n    );\n\n    multiplier u_multiplier (\n        .a(data_a),\n        .b(data_b),\n        .product(product)\n    );\n\n    // Control logic to decide addition or multiplication\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_a <= 0;\n            data_b <= 0;\n            op_valid <= 0;\n            result_valid <= 0;\n            result_out <= 0;\n        end else if (op_valid) begin\n            result_valid <= 0;\n            op_valid <= 0;\n        end else if (control) begin\n            data_a <= data_in;\n            data_b <= data_in;\n            op_valid <= 1;\n        end else begin\n            result_out <= result;\n            result_valid <= 1;\n        end\n    end\n\n    // Calculate the result\n    always @(posedge clk) begin\n        if (op_valid) begin\n            if (control) begin\n                result <= sum;\n            end else begin\n                result <= product;\n            end\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n\n    assign product = $signed(a) * $signed(b);\n\nendmodule"}
{"task_id": 23, "response": "module sub_32bit_cascaded(A, B, D, B_out);\n    input [31:0] A, B;\n    output [31:0] D;\n    output B_out;\n\n    wire [7:0] borrow;\n\n    borrow_save_subt bss1 bss2 bss3 bss4 bss5 bss6 bss7 bss8 (.A(A), .B(B), .B_out(borrow[0]), .D(D[0]), .B_in(borrow[7]));\n    borrow_save_subt bss2 bss3 bss4 bss5 bss6 bss7 bss8 (.A(A[3:1]), .B(B[3:1]), .B_out(borrow[1]), .D(D[1]), .B_in(borrow[6]));\n    borrow_save_subt bss3 bss4 bss5 bss6 bss7 bss8 (.A(A[5:2]), .B(B[5:2]), .B_out(borrow[2]), .D(D[2]), .B_in(borrow[5]));\n    borrow_save_subt bss4 bss5 bss6 bss7 bss8 (.A(A[7:4]), .B(B[7:4]), .B_out(borrow[3]), .D(D[3]), .B_in(borrow[4]));\n    borrow_save_subt bss5 bss6 bss7 bss8 (.A(A[11:8]), .B(B[11:8]), .B_out(borrow[4]), .D(D[4]), .B_in(borrow[3]));\n    borrow_save_subt bss6 bss7 bss8 (.A(A[15:12]), .B(B[15:12]), .B_out(borrow[5]), .D(D[5]), .B_in(borrow[2]));\n    borrow_save_subt bss7 bss8 (.A(A[19:16]), .B(B[19:16]), .B_out(borrow[6]), .D(D[6]), .B_in(borrow[1]));\n    borrow_save_subt bss8 (.A(A[31:20]), .B(B[31:20]), .B_out(borrow[7]), .D(D[7]), .B_in(borrow[0]));\n\n    assign B_out = borrow[7];\nendmodule\n\nmodule borrow_save_subt(A, B, B_out, D, B_in);\n    input [3:0] A, B;\n    input B_in;\n    output B_out;\n    output D;\n\n    wire [3:0] B_prime;\n    assign B_prime = ~B + B_in;\n\n    assign D = A - B_prime;\n    assign B_out = (A < B_prime) ? 1 : 0;\nendmodule"}
{"task_id": 14, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the BCD increment logic\n    bcd_increment u_bcd_increment (\n        .current_count(count),\n        .next_count(next_count),\n        .enable(enable)\n    );\n\n    // Instantiate the BCD register\n    bcd_register u_bcd_register (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule bcd_increment (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            if (current_count < 9) begin\n                next_count = current_count + 1;\n            end else begin\n                next_count = 0;\n            end\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule bcd_register (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else if (enable) begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 23, "response": "module sub_32bit_cascaded(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [6:0] borrow;\n\n    borrow_save_subt bss1(A[31:28], B[31:28], D[31:28], borrow[6:0]);\n    borrow_save_subt bss2(A[27:24], B[27:24], D[27:24], borrow[6:5]);\n    borrow_save_subt bss3(A[23:20], B[23:20], D[23:20], borrow[5:4]);\n    borrow_save_subt bss4(A[19:16], B[19:16], D[19:16], borrow[4:3]);\n    borrow_save_subt bss5(A[15:12], B[15:12], D[15:12], borrow[3:2]);\n    borrow_save_subt bss6(A[11:8], B[11:8], D[11:8], borrow[2:1]);\n    borrow_save_subt bss7(A[7:4], B[7:4], D[7:4], borrow[1:0]);\n    borrow_save_subt bss8(A[3:0], B[3:0], D[3:0], borrow[0]);\n\n    assign B_out = borrow[0];\nendmodule\n\nmodule borrow_save_subt(A, B, D, borrow_in);\n    input [3:0] A;\n    input [3:0] B;\n    input borrow_in;\n    output [3:0] D;\n    output borrow_out;\n\n    wire [4:0] borrow;\n\n    assign borrow[0] = 1;\n    assign borrow_out = borrow[4];\n\n    assign D = A - B - borrow_in;\nendmodule"}
{"task_id": 7, "response": "`timescale 1ns/1ps\n\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);\n\n    reg [15:0] data_a;\n    reg [15:0] data_b;\n    reg [31:0] result;\n    reg op_valid;\n\n    wire [31:0] adder_out;\n    wire [31:0] multiplier_out;\n\n    // Instantiate the adder and multiplier modules\n    adder u_adder (\n        .a(data_a),\n        .b(data_b),\n        .sum(adder_out)\n    );\n\n    multiplier u_multiplier (\n        .a(data_a),\n        .b(data_b),\n        .product(multiplier_out)\n    );\n\n    // Control logic to select operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            result_valid <= 1'b0;\n            op_valid <= 1'b0;\n        end else if (op_valid) begin\n            result_valid <= 1'b0;\n            op_valid <= 1'b0;\n        end else if (control) begin\n            result_valid <= 1'b1;\n            result_out <= multiplier_out;\n            op_valid <= 1'b1;\n        end else begin\n            result_valid <= 1'b1;\n            result_out <= adder_out;\n            op_valid <= 1'b1;\n        end\n    end\n\n    // Initialize the inputs\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_a <= 16'd0;\n            data_b <= 16'd0;\n        end else if (op_valid) begin\n            if (control) begin\n                data_a <= data_in;\n                data_b <= data_in;\n            end else begin\n                data_a <= data_in;\n                data_b <= data_in;\n            end\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n    assign product = a * b;\nendmodule"}
{"task_id": 14, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the BCD increment logic\n    bcd_increment u_bcd_increment (\n        .current_count(count),\n        .next_count(next_count),\n        .enable(enable)\n    );\n\n    // Instantiate the BCD register\n    bcd_register u_bcd_register (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule bcd_increment (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            if (current_count < 9) begin\n                next_count = current_count + 1;\n            end else begin\n                next_count = 0;\n            end\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule bcd_register (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else if (enable) begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 24, "response": "module hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);\n\n    wire clk_60_out;\n    wire clk_3_out;\n\n    clk_div_by_2 div_60 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_60_out)\n    );\n\n    clk_div_by_40 div_3 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_3_out)\n    );\n\n    assign clk_60 = clk_60_out;\n    assign clk_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_by_2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\nmodule clk_div_by_40 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] count;\n\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == 19) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": 0, "response": "module multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_15_out;\n    wire clk_3_out;\n\n    clk_div_4 div_15 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    clk_div_20 div_3 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 1) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 9) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 7, "response": "`timescale 1ns/1ps\n\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);\n\n    reg [15:0] data_a;\n    reg [15:0] data_b;\n    reg [31:0] result;\n    reg op_valid;\n\n    wire [31:0] add_out;\n    wire [31:0] mult_out;\n\n    // Instantiate the adder and multiplier modules\n    adder u_adder (\n        .a(data_a),\n        .b(data_b),\n        .sum(add_out)\n    );\n\n    multiplier u_multiplier (\n        .a(data_a),\n        .b(data_b),\n        .product(mult_out)\n    );\n\n    // Control logic to determine operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_a <= 16'd0;\n            data_b <= 16'd0;\n            op_valid <= 1'b0;\n        end else begin\n            if (control) begin\n                data_a <= data_in;\n                data_b <= data_in;\n                op_valid <= 1'b1;\n            end else begin\n                data_a <= data_a;\n                data_b <= data_b;\n                op_valid <= 1'b0;\n            end\n        end\n    end\n\n    // Pipeline the results\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            result <= 32'd0;\n            result_valid <= 1'b0;\n        end else begin\n            if (op_valid) begin\n                if (control) begin\n                    result <= mult_out;\n                    result_valid <= 1'b1;\n                end else begin\n                    result <= add_out;\n                    result_valid <= 1'b1;\n                end\n            end else begin\n                result <= result;\n                result_valid <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n    assign product = a * b;\nendmodule"}
{"task_id": 24, "response": "module hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);\n    wire clk_60_out;\n    wire clk_3_out;\n\n    clk_div_by_2 div_60 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_60_out)\n    );\n\n    clk_div_by_40 div_3 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_3_out)\n    );\n\n    assign clk_60 = clk_60_out;\n    assign clk_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_by_2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\nmodule clk_div_by_40 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] count;\n\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == 19) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": 8, "response": "module power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);\n\n    wire power_two_check;\n\n    // Instantiate the power of two checker submodule\n    is_power_two_16bit power_two_checker (\n        .input_number(A),\n        .is_power_two(power_two_check)\n    );\n\n    // Compare if A is power of two and less than B\n    assign A_is_power_two_less_B = power_two_check & (A < B);\n\nendmodule\n\nmodule is_power_two_16bit(\n    input [15:0] input_number,\n    output is_power_two\n);\n\n    // Check if only one bit is set to 1\n    assign is_power_two = (input_number & (input_number - 16'b1)) == 16'b0;\n\nendmodule"}
{"task_id": 0, "response": "module multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_15_out;\n    wire clk_3_out;\n\n    clk_div_4 div_15 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    clk_div_20 div_3 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 3) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 9) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 15, "response": "module stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);\nwire [31:0] fetch_out;\nwire [31:0] decode_out;\nwire [31:0] execute_out;\nwire [31:0] memory_access_out;\nwire [31:0] writeback_out;\n\nfetch_stage fetch(.clk(clk), .rst(rst), .data_mem(data_mem), .ctrl_unit(ctrl_unit), .data_out(fetch_out));\ndecode_stage decode(.clk(clk), .data_in(fetch_out), .decode_out(decode_out));\nexecute_stage execute(.clk(clk), .data_in(decode_out), .execute_out(execute_out));\nmemory_access_stage memory_access(.clk(clk), .data_in(execute_out), .memory_access_out(memory_access_out));\nwriteback_stage writeback(.clk(clk), .data_in(memory_access_out), .writeback_out(writeback_out));\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result_reg <= 0;\n    end else begin\n        result_reg <= writeback_out;\n    end\nend\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output reg [31:0] data_out\n);\n    always @(posedge clk) begin\n        if (rst) begin\n            data_out <= 0;\n        end else begin\n            data_out <= data_mem[ctrl_unit[0]];\n        end\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input [31:0] data_in,\n    output reg [31:0] decode_out\n);\n    always @(posedge clk) begin\n        decode_out <= data_in;\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [31:0] data_in,\n    output reg [31:0] execute_out\n);\n    always @(posedge clk) begin\n        execute_out <= data_in;\n    end\nendmodule\n\nmodule memory_access_stage(\n    input clk,\n    input [31:0] data_in,\n    output reg [31:0] memory_access_out\n);\n    always @(posedge clk) begin\n        memory_access_out <= data_in;\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] data_in,\n    output reg [31:0] writeback_out\n);\n    always @(posedge clk) begin\n        writeback_out <= data_in;\n    end\nendmodule"}
{"task_id": 8, "response": "module power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);\n\n    wire is_power_two;\n\n    is_power_two_16bit power_two_checker (\n        .input_number(A),\n        .is_power_two(is_power_two)\n    );\n\n    assign A_is_power_two_less_B = is_power_two & (A < B);\n\nendmodule\n\nmodule is_power_two_16bit(\n    input [15:0] input_number,\n    output is_power_two\n);\n\n    assign is_power_two = (input_number & (input_number + 1)) == 0;\n\nendmodule"}
{"task_id": 24, "response": "module hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);\n\n    wire clk_60_out;\n    wire clk_3_out;\n\n    clk_div_by_2 div_60 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_60_out)\n    );\n\n    clk_div_by_40 div_3 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_3_out)\n    );\n\n    assign clk_60 = clk_60_out;\n    assign clk_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_by_2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\nmodule clk_div_by_40 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] count;\n\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n            count <= 0;\n        end else begin\n            if (count == 19) begin\n                clk_out <= ~clk_out;\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": 8, "response": "module power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);\n\n    wire is_power_two;\n\n    // Instantiate the power of two checker submodule\n    is_power_two_16bit power_two_checker (\n        .input_number(A),\n        .is_power_two(is_power_two)\n    );\n\n    // Determine if A is a power of two and less than B\n    assign A_is_power_two_less_B = is_power_two && (A < B);\n\nendmodule\n\nmodule is_power_two_16bit(\n    input [15:0] input_number,\n    output is_power_two\n);\n\n    // Check if only one bit is set to 1\n    assign is_power_two = (input_number & (input_number - 16'b1)) == 16'b0;\n\nendmodule"}
{"task_id": 0, "response": "module multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_15_out;\n    wire clk_3_out;\n\n    clk_div_4 div_15 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    clk_div_20 div_3 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 1) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 9) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 1, "response": "module binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);\n\n    wire equal_out, greater_out;\n\n    equal_comparator_16bit equality (\n        .A(X),\n        .B(Y),\n        .equal(equal_out)\n    );\n\n    magnitude_comparator_16bit magnitude (\n        .A(X),\n        .B(Y),\n        .greater(greater_out)\n    );\n\n    assign X_equal = equal_out;\n    assign X_greater = greater_out;\n    assign X_less = ~equal_out & ~greater_out;\n\nendmodule\n\nmodule equal_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output equal\n);\n    assign equal = (A == B);\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output greater\n);\n    assign greater = (A > B);\nendmodule"}
{"task_id": 1, "response": "module binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);\n\n    wire equal_out, greater_out;\n\n    equal_comparator_16bit equality(\n        .A(X),\n        .B(Y),\n        .equal(equal_out)\n    );\n\n    magnitude_comparator_16bit magnitude(\n        .A(X),\n        .B(Y),\n        .greater(greater_out)\n    );\n\n    assign X_greater = greater_out;\n    assign X_equal = equal_out;\n    assign X_less = ~(equal_out | greater_out);\n\nendmodule\n\nmodule equal_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output equal\n);\n    assign equal = (A == B);\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output greater\n);\n    assign greater = (A > B);\nendmodule"}
{"task_id": 25, "response": "module carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);\n    wire [15:0] lower_sum;\n    wire lower_carry;\n    wire [15:0] upper_sum;\n    wire upper_carry;\n\n    // Instantiate lower 16-bit adder\n    adder_16bit lower_adder (\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .Cin(Cin),\n        .sum(lower_sum),\n        .Cout(lower_carry)\n    );\n\n    // Instantiate upper 16-bit adder with lower carry-in\n    adder_16bit upper_adder0 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(lower_carry),\n        .sum(upper_sum),\n        .Cout(upper_carry)\n    );\n\n    // Instantiate upper 16-bit adder with upper carry-in\n    adder_16bit upper_adder1 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(upper_carry),\n        .sum(upper_sum),\n        .Cout(Cout)\n    );\n\n    assign sum = {upper_sum, lower_sum};\n\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    wire [15:0] temp_sum;\n    wire temp_carry;\n\n    adder_8bit adder0 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .sum(temp_sum[7:0]),\n        .Cout(temp_carry)\n    );\n\n    adder_8bit adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(temp_carry),\n        .sum(temp_sum[15:8]),\n        .Cout(Cout)\n    );\n\n    assign sum = temp_sum;\n\nendmodule\n\nmodule adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] sum,\n    output wire Cout\n);\n    wire [7:0] temp_sum;\n    wire temp_carry;\n\n    adder_4bit adder0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .sum(temp_sum[3:0]),\n        .Cout(temp_carry)\n    );\n\n    adder_4bit adder1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(temp_carry),\n        .sum(temp_sum[7:4]),\n        .Cout(Cout)\n    );\n\n    assign sum = temp_sum;\n\nendmodule\n\nmodule adder_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] sum,\n    output wire Cout\n);\n    wire [3:0] temp_sum;\n    wire temp_carry;\n\n    adder_2bit adder0 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .sum(temp_sum[1:0]),\n        .Cout(temp_carry)\n    );\n\n    adder_2bit adder1 (\n        .a("}
{"task_id": 1, "response": "module binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);\n\n    wire equal_out;\n    wire greater_out;\n\n    // Instantiate the equal comparator\n    equal_comparator_16bit equality (\n        .A(X),\n        .B(Y),\n        .equal(equal_out)\n    );\n\n    // Instantiate the magnitude comparator\n    magnitude_comparator_16bit magnitude (\n        .A(X),\n        .B(Y),\n        .greater(greater_out)\n    );\n\n    // Determine the output signals\n    assign X_greater = greater_out;\n    assign X_equal = equal_out;\n    assign X_less = ~(X_greater | X_equal);\n\nendmodule\n\nmodule equal_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output equal\n);\n\n    assign equal = (A == B);\n\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output greater\n);\n\n    assign greater = (A > B);\n\nendmodule"}
{"task_id": 15, "response": "module stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);\nwire [31:0] fetch_out;\nwire [31:0] decode_out;\nwire [31:0] execute_out;\nwire [31:0] memory_access_out;\nwire [31:0] writeback_out;\n\nfetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .data_mem(data_mem),\n    .ctrl_unit(ctrl_unit),\n    .data_out(fetch_out)\n);\n\ndecode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .data_in(fetch_out),\n    .data_out(decode_out)\n);\n\nexecute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .data_in(decode_out),\n    .data_out(execute_out)\n);\n\nmemory_access_stage memory_access(\n    .clk(clk),\n    .rst(rst),\n    .data_in(execute_out),\n    .data_out(memory_access_out)\n);\n\nwriteback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .data_in(memory_access_out),\n    .data_out(writeback_out)\n);\n\nassign result_reg = writeback_out;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_mem[ctrl_unit];\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else begin\n            case (data_in[7:4])\n                0: data_out <= data_in[31:0] + data_in[31:0];\n                1: data_out <= data_in[31:0] & data_in[31:0];\n                2: data_out <= data_in[31:0] | data_in[31:0];\n                3: data_out <= ~data_in[31:0];\n                4: data_out <= data_in[31:0] << 1;\n                5: data_out <= data_in[31:0] >> 1;\n                6: data_out <= data_in[31:0] + data_in[31:0];\n                7: data_out <= data_in[31:0] - data_in[31:0];\n            endcase\n        end\n    end\nendmodule\n\nmodule memory_access_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;"}
{"task_id": 9, "response": "module carry_lookahead_adder_32bit(a, b, cin, sum, cout);\n    input [31:0] a;\n    input [31:0] b;\n    input cin;\n    output [31:0] sum;\n    output cout;\n\n    wire [3:0] carry;\n\n    carry_lookahead_adder_8bit cla1(\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(cin),\n        .sum(sum[7:0]),\n        .cout(carry[0])\n    );\n\n    carry_lookahead_adder_8bit cla2(\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(carry[0]),\n        .sum(sum[15:8]),\n        .cout(carry[1])\n    );\n\n    carry_lookahead_adder_8bit cla3(\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .cin(carry[1]),\n        .sum(sum[23:16]),\n        .cout(carry[2])\n    );\n\n    carry_lookahead_adder_8bit cla4(\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .cin(carry[2]),\n        .sum(sum[31:24]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a;\n    input [7:0] b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [6:0] carry;\n\n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder fa1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder fa2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder fa3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    full_adder fa4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4])\n    );\n\n    full_adder fa5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5])\n    );\n\n    full_adder fa6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6])\n    );\n\n    full_adder fa7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(carry[7])\n    );\n\n    assign cout = carry[7];\n\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & ("}
{"task_id": 9, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n.a(a[7:0]),\n.b(b[7:0]),\n.cin(cin),\n.sum(sum[7:0]),\n.cout(carry[0])\n);\n\ncarry_lookahead_adder_8bit cla2(\n.a(a[15:8]),\n.b(b[15:8]),\n.cin(carry[0]),\n.sum(sum[15:8]),\n.cout(carry[1])\n);\n\ncarry_lookahead_8bit cla3(\n.a(a[23:16]),\n.b(b[23:16]),\n.cin(carry[1]),\n.sum(sum[23:16]),\n.cout(carry[2])\n);\n\ncarry_lookahead_8bit cla4(\n.a(a[31:24]),\n.b(b[31:24]),\n.cin(carry[2]),\n.sum(sum[31:24]),\n.cout(cout)\n);\nendmodule\n\nmodule carry_lookahead_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] p, g, s;\n\nassign p = a & b;\nassign g = a | b;\nassign s = g | (a & b & cin);\n\nassign sum = s ^ p;\nassign cout = (a & b & cin) | (g & cin);\nendmodule\n\nmodule rya_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] p, g, s;\n\nassign p = a & b;\nassign g = a | b;\nassign s = g | (a & b & cin);\n\nassign sum = s ^ p;\nassign cout = (a & b & cin) | (g & cin);\nendmodule"}
{"task_id": 2, "response": "module magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    wire [3:0] comp0, comp1, comp2, comp3;\n\n    bitwise_comparator_4bit comp0_instance(.X(X[3:0]), .Y(Y[3:0]), .X_greater_Y(comp0[0]), .X_equal_Y(comp0[1]), .X_less_Y(comp0[2]));\n    bitwise_comparator_4bit comp1_instance(.X(X[7:4]), .Y(Y[7:4]), .X_greater_Y(comp1[0]), .X_equal_Y(comp1[1]), .X_less_Y(comp1[2]));\n    bitwise_comparator_4bit comp2_instance(.X(X[11:8]), .Y(Y[11:8]), .X_greater_Y(comp2[0]), .X_equal_Y(comp2[1]), .X_less_Y(comp2[2]));\n    bitwise_comparator_4bit comp3_instance(.X(X[15:12]), .Y(Y[15:12]), .X_greater_Y(comp3[0]), .X_equal_Y(comp3[1]), .X_less_Y(comp3[2]));\n\n    always @(*) begin\n        X_greater_Y = comp0[2] | (comp0[1] & comp1[2]) | (comp0[0] & comp1[1] & comp2[2]) | (comp0[0] & comp1[0] & comp2[1] & comp3[2]);\n        X_equal_Y = comp0[1] & comp1[1] & comp2[1] & comp3[1];\n        X_less_Y = comp0[0] & comp1[0] & comp2[0] & comp3[0];\n    end\n\nendmodule\n\nmodule bitwise_comparator_4bit(\n    input [3:0] X,\n    input [3:0] Y,\n    output X_greater_Y,\n    output X_equal_Y,\n    output X_less_Y\n);\n    assign X_greater_Y = X[3] | (X[2] & Y[3]) | (X[1] & Y[2] & Y[3]) | (X[0] & Y[1] & Y[2] & Y[3]);\n    assign X_equal_Y = X[3] == Y[3] & X[2] == Y[2] & X[1] == Y[1] & X[0] == Y[0];\n    assign X_less_Y = X[3] == Y[3] & X[2] == Y[2] & X[1] == Y[1] & X[0] < Y[0];\nendmodule"}
{"task_id": 25, "response": "module carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);\n    wire [15:0] lower_sum, upper_sum0, upper_sum1;\n    wire lower_carry, upper_carry0, upper_carry1;\n\n    adder_16bit lower_adder (\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .Cin(Cin),\n        .sum(lower_sum),\n        .Cout(lower_carry)\n    );\n\n    adder_16bit upper_adder0 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(lower_carry),\n        .sum(upper_sum0),\n        .Cout(upper_carry0)\n    );\n\n    adder_16bit upper_adder1 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(upper_carry0),\n        .sum(upper_sum1),\n        .Cout(upper_carry1)\n    );\n\n    assign sum = {upper_sum1, upper_sum0} | {upper_sum0, upper_sum1};\n    assign Cout = upper_carry1 | upper_carry0;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    wire [15:0] carry;\n    full_adder FA0 (.a(a[0]), .b(b[0]), .Cin(Cin), .sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .Cin(carry[0]), .sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .Cin(carry[1]), .sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .Cin(carry[2]), .sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .Cin(carry[3]), .sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .Cin(carry[4]), .sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .Cin(carry[5]), .sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .Cin(carry[6]), .sum(sum[7]), .Cout(carry[7]));\n    full_adder FA8 (.a(a[8]), .b(b[8]), .Cin(carry[7]), .sum(sum[8]), .Cout(carry[8]));\n    full_adder FA9 (.a(a[9]), .b(b[9]), .Cin(carry[8]), .sum(sum[9]), .Cout(carry[9]));\n    full_adder FA10 (.a(a[10]), .b(b[10]), .Cin(carry[9]), .sum(sum[10]), .Cout(carry[10]));\n    full_adder FA11 (.a(a[11]), .b(b[11]), .Cin(carry[10]), .sum(sum[11"}
{"task_id": 15, "response": "module stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);\nwire [31:0] fetch_out;\nwire [31:0] decode_out;\nwire [31:0] execute_out;\nwire [31:0] memory_access_out;\nwire [31:0] writeback_out;\n\nfetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .data_mem(data_mem),\n    .ctrl_unit(ctrl_unit),\n    .data_out(fetch_out)\n);\n\ndecode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .data_in(fetch_out),\n    .data_out(decode_out)\n);\n\nexecute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .data_in(decode_out),\n    .data_out(execute_out)\n);\n\nmemory_access_stage memory_access(\n    .clk(clk),\n    .rst(rst),\n    .data_in(execute_out),\n    .data_out(memory_access_out)\n);\n\nwriteback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .data_in(memory_access_out),\n    .data_out(writeback_out)\n);\n\nassign result_reg = writeback_out;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] data_mem[0:31],\n    input [7:0] ctrl_unit[0:7],\n    output reg [31:0] data_out\n);\n    reg [4:0] index;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            index <= 0;\n            data_out <= 0;\n        end else begin\n            data_out <= data_mem[ctrl_unit[index]];\n            index <= index + 1;\n        end\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 0;\n        end else begin\n            data_out <= data_in;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 0;\n        end else begin\n            data_out <= data_in;\n        end\n    end\nendmodule\n\nmodule memory_access_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 0;\n        end else begin\n            data_out <= data_in;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 0;\n        end else begin\n            data_out <= data_in;\n        end\n    end\nendmodule"}
{"task_id": 2, "response": "module magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    wire [3:0] X_greater_Y_4bit, X_equal_Y_4bit, X_less_Y_4bit;\n\n    bitwise_comparator_4bit comp0(X[15:12], Y[15:12], X_greater_Y_4bit[0], X_equal_Y_4bit[0], X_less_Y_4bit[0]);\n    bitwise_comparator_4bit comp1(X[11:8], Y[11:8], X_greater_Y_4bit[1], X_equal_Y_4bit[1], X_less_Y_4bit[1]);\n    bitwise_comparator_4bit comp2(X[7:4], Y[7:4], X_greater_Y_4bit[2], X_equal_Y_4bit[2], X_less_Y_4bit[2]);\n    bitwise_comparator_4bit comp3(X[3:0], Y[3:0], X_greater_Y_4bit[3], X_equal_Y_4bit[3], X_less_Y_4bit[3]);\n\n    always @* begin\n        X_greater_Y = &X_greater_Y_4bit;\n        X_equal_Y = &X_equal_Y_4bit;\n        X_less_Y = &X_less_Y_4bit;\n    end\n\nendmodule\n\nmodule bitwise_comparator_4bit(\n    input [3:0] x,\n    input [3:0] y,\n    output greater,\n    output equal,\n    output less\n);\n    assign greater = (x > y);\n    assign equal = (x == y);\n    assign less = (x < y);\nendmodule"}
{"task_id": 16, "response": "module multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);\n    wire [15:0] P0, P1, P2, P3;\n\n    // Instantiate four 4-bit multiplier submodules\n    multiplier_4bit mul0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Product(P0)\n    );\n    multiplier_4bit mul1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Product(P1)\n    );\n    multiplier_4bit mul2 (\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .Product(P2)\n    );\n    multiplier_4bit mul3 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .Product(P3)\n    );\n\n    // Calculate the final product\n    assign Product = P0 + (P1 << 4) + (P2 << 8) + (P3 << 12);\n\nendmodule\n\nmodule multiplier_4bit(\n    input [3:0] A,   \n    input [3:0] B,   \n    output [7:0] Product\n);\n    assign Product = A * B;  // Simple multiplication logic\nendmodule"}
{"task_id": 9, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n.a(a[7:0]),\n.b(b[7:0]),\n.cin(cin),\n.sum(sum[7:0]),\n.cout(carry[0])\n);\n\ncarry_lookahead_adder_8bit cla2(\n.a(a[15:8]),\n.b(b[15:8]),\n.cin(carry[0]),\n.sum(sum[15:8]),\n.cout(carry[1])\n);\n\ncarry_lookahead_8bit cla3(\n.a(a[23:16]),\n.b(b[23:16]),\n.cin(carry[1]),\n.sum(sum[23:16]),\n.cout(carry[2])\n);\n\ncarry_lookahead_8bit cla4(\n.a(a[31:24]),\n.b(b[31:24]),\n.cin(carry[2]),\n.sum(sum[31:24]),\n.cout(cout)\n);\nendmodule\n\nmodule carry_lookahead_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [8:0] c;\n\nadd_8bit add1(\n.a(a),\n.b(b),\n.cin(cin),\n.sum(sum),\n.cout(c[0])\n);\n\nadd_8bit add2(\n.a(a),\n.b(b),\n.cin(c[0]),\n.sum(sum),\n.cout(c[1])\n);\n\nadd_8bit add3(\n.a(a),\n.b(b),\n.cin(c[1]),\n.sum(sum),\n.cout(c[2])\n);\n\nadd_8bit add4(\n.a(a),\n.b(b),\n.cin(c[2]),\n.sum(sum),\n.cout(c[3])\n);\n\nadd_8bit add5(\n.a(a),\n.b(b),\n.cin(c[3]),\n.sum(sum),\n.cout(c[4])\n);\n\nadd_8bit add6(\n.a(a),\n.b(b),\n.cin(c[4]),\n.sum(sum),\n.cout(c[5])\n);\n\nadd_8bit add7(\n.a(a),\n.b(b),\n.cin(c[5]),\n.sum(sum),\n.cout(c[6])\n);\n\nadd_8bit add8(\n.a(a),\n.b(b),\n.cin(c[6]),\n.sum(sum),\n.cout(c[7])\n);\n\nassign cout = c[7];\nendmodule\n\nmodule add_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [8:0] c;\n\nadd_4bit add1(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(cin),\n.sum(sum[3:0]),\n.cout(c[0])\n);\n\nadd_4bit add2(\n.a(a[7:4]),\n.b(b[7:4]),\n.cin(c[0]),\n.sum(sum[7:4]),\n.cout(c[1])\n);\n\nassign cout = c[1];\nassign sum[7:4] = 0;\nendmodule\n\nmodule add_4bit(a, b, cin, sum, cout);\ninput [3:0] a, b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [4"}
{"task_id": 25, "response": "module carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);\n    wire [15:0] lower_sum, upper_sum0, upper_sum1;\n    wire lower_carry, upper_carry0, upper_carry1;\n\n    // Instantiate two 16-bit adders for lower 16 bits\n    adder_16bit lower_adder (\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .Cin(Cin),\n        .sum(lower_sum),\n        .Cout(lower_carry)\n    );\n\n    // Instantiate two 16-bit adders for upper 16 bits\n    adder_16bit upper_adder0 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(lower_carry),\n        .sum(upper_sum0),\n        .Cout(upper_carry0)\n    );\n\n    adder_16bit upper_adder1 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(1'b0),\n        .sum(upper_sum1),\n        .Cout(upper_carry1)\n    );\n\n    // Combine the results\n    assign sum = {upper_sum1, upper_sum0} | {upper_carry1, upper_carry0, lower_carry} | {upper_sum0, upper_sum1, lower_sum};\n    assign Cout = upper_carry1 | upper_carry0 | lower_carry;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    wire [15:0] temp_sum;\n    wire temp_carry;\n\n    adder_16bit_partial adder_partial (\n        .a(a),\n        .b(b),\n        .Cin(Cin),\n        .sum(temp_sum),\n        .Cout(temp_carry)\n    );\n\n    assign sum = temp_sum;\n    assign Cout = temp_carry;\nendmodule\n\nmodule adder_16bit_partial (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    assign {Cout, sum} = a + b + Cin;\nendmodule"}
{"task_id": 16, "response": "module multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);\n    wire [15:0] partial_product0, partial_product1, partial_product2, partial_product3;\n\n    // Instantiate four 4-bit multipliers for each chunk of A and B\n    multiplier_4bit mul0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .Product(partial_product0)\n    );\n    multiplier_4bit mul1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .Product(partial_product1)\n    );\n    multiplier_4bit mul2 (\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .Product(partial_product2)\n    );\n    multiplier_4bit mul3 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .Product(partial_product3)\n    );\n\n    // Calculate the final product\n    assign Product = partial_product0 << 0 | partial_product1 << 4 | partial_product2 << 8 | partial_product3 << 12;\n\nendmodule\n\nmodule multiplier_4bit(\n    input [3:0] A,   \n    input [3:0] B,   \n    output [7:0] Product\n);\n    // Partial product calculation\n    assign Product = A * B;\nendmodule"}
{"task_id": 2, "response": "module magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    wire [3:0] comp0, comp1, comp2, comp3;\n\n    bitwise_comparator_4bit comp0_instance(.X(X[3:0]), .Y(Y[3:0]), .X_greater_Y(comp0[0]), .X_equal_Y(comp0[1]), .X_less_Y(comp0[2]));\n    bitwise_comparator_4bit comp1_instance(.X(X[7:4]), .Y(Y[7:4]), .X_greater_Y(comp1[0]), .X_equal_Y(comp1[1]), .X_less_Y(comp1[2]));\n    bitwise_comparator_4bit comp2_instance(.X(X[11:8]), .Y(Y[11:8]), .X_greater_Y(comp2[0]), .X_equal_Y(comp2[1]), .X_less_Y(comp2[2]));\n    bitwise_comparator_4bit comp3_instance(.X(X[15:12]), .Y(Y[15:12]), .X_greater_Y(comp3[0]), .X_equal_Y(comp3[1]), .X_less_Y(comp3[2]));\n\n    always @(*) begin\n        X_greater_Y = comp0[2] | (comp0[1] & comp1[2]) | (comp0[0] & comp1[1] & comp2[2]) | (comp0[0] & comp1[0] & comp2[1] & comp3[2]);\n        X_equal_Y = (comp0[1] & comp1[1] & comp2[1] & comp3[1]) | (comp0[0] & comp1[0] & comp2[0] & comp3[0]);\n        X_less_Y = comp0[2] | (comp0[1] & comp1[2]) | (comp0[0] & comp1[1] & comp2[2]) | (comp0[0] & comp1[0] & comp2[1] & comp3[2]);\n    end\nendmodule\n\nmodule bitwise_comparator_4bit(\n    input [3:0] X,\n    input [3:0] Y,\n    output X_greater_Y,\n    output X_equal_Y,\n    output X_less_Y\n);\n    assign X_greater_Y = X > Y;\n    assign X_equal_Y = X == Y;\n    assign X_less_Y = X < Y;\nendmodule"}
{"task_id": 16, "response": "module multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);\n    wire [15:0] partial_product0, partial_product1, partial_product2, partial_product3;\n\n    // Instantiate four 4-bit multiplier submodules for each chunk\n    multiplier_4bit mul0(.a(A[3:0]), .b(B[3:0]), .product(partial_product0));\n    multiplier_4bit mul1(.a(A[7:4]), .b(B[7:4]), .product(partial_product1));\n    multiplier_4bit mul2(.a(A[11:8]), .b(B[11:8]), .product(partial_product2));\n    multiplier_4bit mul3(.a(A[15:12]), .b(B[15:12]), .product(partial_product3));\n\n    // Calculate the final product\n    assign Product = partial_product0 << 0 | partial_product1 << 4 | partial_product2 << 8 | partial_product3 << 12;\nendmodule\n\nmodule multiplier_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] product\n);\n    assign product = a * b;\nendmodule"}
{"task_id": 10, "response": "module combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\nwire [15:0] addition_result;\nwire [15:0] subtraction_result;\nwire [15:0] xor_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(addition_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .difference(subtraction_result)\n);\n\n// Instantiating the XOR module\nxor u_xor (\n    .a(a),\n    .b(b),\n    .xor_result(xor_result)\n);\n\n// Selecting the output based on the sel signal\nalways @(posedge clk) begin\n    case(sel)\n        2'b00: result <= addition_result;\n        2'b01: result <= subtraction_result;\n        2'b10: result <= xor_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\n// XOR module\nmodule xor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": 26, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);\n\nwire [15:0] add_result, sub_result;\n\nadd_stage ADD (.clk(clk), .rst(rst), .a(op1), .b(op2), .result(add_result));\nsub_stage SUB (.clk(clk), .rst(rst), .a(op1), .b(op2), .result(sub_result));\nmult_stage MULT (.clk(clk), .rst(rst), .a(add_result), .b(sub_result), .result(result));\n\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule sub_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a - b;\n    end\nendmodule\n\nmodule mult_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a * b;\n    end\nendmodule"}
{"task_id": 10, "response": "module combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\nwire [15:0] addition_result;\nwire [15:0] subtraction_result;\nwire [15:0] xor_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(addition_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .difference(subtraction_result)\n);\n\nxor_module u_xor (\n    .a(a),\n    .b(b),\n    .xor_result(xor_result)\n);\n\nalways @(posedge clk) begin\n    case(sel)\n        2'b00: result <= addition_result;\n        2'b01: result <= subtraction_result;\n        2'b10: result <= xor_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": 26, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);\n\nwire [15:0] add_result, sub_result;\n\nadd_stage ADD (.clk(clk), .rst(rst), .a(op1), .b(op2), .result(add_result));\nsub_stage SUB (.clk(clk), .a(op1), .b(op2), .result(sub_result));\nmult_stage MULT (.clk(clk), .a(add_result), .b(sub_result), .result(result));\n\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule sub_stage(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        result <= a - b;\n    end\nendmodule\n\nmodule mult_stage(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        result <= a * b;\n    end\nendmodule"}
{"task_id": 3, "response": "module sub_16bit(A, B, Result, Overflow);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Result;\n    output Overflow;\n\n    wire [7:0] lower_result;\n    wire [7:0] higher_result;\n    wire lower_overflow;\n    wire higher_overflow;\n\n    sub_8bit lower_sub(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Result(lower_result),\n        .Overflow(lower_overflow)\n    );\n\n    sub_8bit higher_sub(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Result(higher_result),\n        .Overflow(higher_overflow)\n    );\n\n    assign Result = {higher_result, lower_result};\n    assign Overflow = (lower_overflow ^ higher_overflow);\n\nendmodule\n\nmodule sub_8bit(A, B, Result, Overflow);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Result;\n    output Overflow;\n\n    wire [7:0] difference;\n    wire borrow_out;\n\n    adder_8bit adder(\n        .A(A),\n        .B(B),\n        .Sum(difference),\n        .BorrowOut(borrow_out)\n    );\n\n    assign Result = difference;\n    assign Overflow = borrow_out;\n\nendmodule\n\nmodule adder_8bit(A, B, Sum, BorrowOut);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Sum;\n    output BorrowOut;\n\n    wire [7:0] carry;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(0), .Sum(Sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(Sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(Sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(Sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(Sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(Sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(Sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(Sum[7]), .Cout(BorrowOut));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": 10, "response": "module combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result, sub_result, xor_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nxor_module u_xor (\n    .a(a),\n    .b(b),\n    .result(xor_result)\n);\n\nalways @(posedge clk) begin\n    case (sel)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= xor_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": 17, "response": "module complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);\n\n    wire clk_25_out;\n    wire clk_5_out;\n    wire clk_1_out;\n    wire clk_200_out;\n\n    clk_div_8 div_25MHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_25_out)\n    );\n\n    clk_div_40 div_5MHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_200 div_1MHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_1_out)\n    );\n\n    clk_div_1000 div_200kHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_200_out)\n    );\n\n    assign CLK_25MHz = clk_25_out;\n    assign CLK_5MHz = clk_5_out;\n    assign CLK_1MHz = clk_1_out;\n    assign CLK_200kHz = clk_200_out;\n\nendmodule\n\nmodule clk_div_8 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 3) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_40 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [5:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 19) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_200 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [7:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 99) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_1000 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [9:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 499) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;"}
{"task_id": 26, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);\n\nwire [15:0] add_result, sub_result;\n\nadd_stage ADD (\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .result(add_result)\n);\n\nsub_stage SUB (\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .result(sub_result)\n);\n\nmult_stage MULT (\n    .clk(clk),\n    .rst(rst),\n    .a(add_result),\n    .b(sub_result),\n    .result(result)\n);\n\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule sub_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a - b;\n    end\nendmodule\n\nmodule mult_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a * b;\n    end\nendmodule"}
{"task_id": 3, "response": "module sub_16bit(A, B, Result, Overflow);\n    input [15:0] A, B;\n    output [15:0] Result;\n    output Overflow;\n\n    wire [7:0] lower_result, higher_result;\n    wire lower_overflow, higher_overflow;\n\n    sub_8bit lower_sub(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Result(lower_result),\n        .Overflow(lower_overflow)\n    );\n\n    sub_8bit higher_sub(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Result(higher_result),\n        .Overflow(higher_overflow)\n    );\n\n    assign Result = {higher_result, lower_result};\n    assign Overflow = (lower_overflow ^ higher_overflow);\n\nendmodule\n\nmodule sub_8bit(A, B, Result, Overflow);\n    input [7:0] A, B;\n    output [7:0] Result;\n    output Overflow;\n\n    wire [7:0] difference;\n    wire borrow_out;\n\n    adder_8bit adder(\n        .A(A),\n        .B(~B),\n        .Result(difference),\n        .Carry(borrow_out)\n    );\n\n    assign Result = difference;\n    assign Overflow = borrow_out;\n\nendmodule\n\nmodule adder_8bit(A, B, Result, Carry);\n    input [7:0] A, B;\n    output [7:0] Result;\n    output Carry;\n\n    wire [7:0] sum;\n    wire carry_out;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(0), .Sum(sum[0]), .Cout(carry_out));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry_out), .Sum(sum[1]), .Cout(carry_out));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry_out), .Sum(sum[2]), .Cout(carry_out));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry_out), .Sum(sum[3]), .Cout(carry_out));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry_out), .Sum(sum[4]), .Cout(carry_out));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry_out), .Sum(sum[5]), .Cout(carry_out));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry_out), .Sum(sum[6]), .Cout(carry_out));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry_out), .Sum(sum[7]), .Cout(Carry));\n\n    assign Result = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A, B, Cin;\n    output Sum, Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": 27, "response": "module adder_64bit(A, B, Cin, Sum, Cout);\n    input [63:0] A, B;\n    input Cin;\n    output [63:0] Sum;\n    output Cout;\n\n    wire [7:0] carry;\n\n    adder_8bit adder0(.a(A[7:0]), .b(B[7:0]), .cin(Cin), .sum(Sum[7:0]), .cout(carry[0]));\n    adder_8bit adder1(.a(A[15:8]), .b(B[15:8]), .cin(carry[0]), .sum(Sum[15:8]), .cout(carry[1]));\n    adder_8bit adder2(.a(A[23:16]), .b(B[23:16]), .cin(carry[1]), .sum(Sum[23:16]), .cout(carry[2]));\n    adder_8bit adder3(.a(A[31:24]), .b(B[31:24]), .cin(carry[2]), .sum(Sum[31:24]), .cout(carry[3]));\n    adder_8bit adder4(.a(A[39:32]), .b(B[39:32]), .cin(carry[3]), .sum(Sum[39:32]), .cout(carry[4]));\n    adder_8bit adder5(.a(A[47:40]), .b(B[47:40]), .cin(carry[4]), .sum(Sum[47:40]), .cout(carry[5]));\n    adder_8bit adder6(.a(A[55:48]), .b(B[55:48]), .cin(carry[5]), .sum(Sum[55:48]), .cout(carry[6]));\n    adder_8bit adder7(.a(A[63:56]), .b(B[63:56]), .cin(carry[6]), .sum(Sum[63:56]), .cout(Cout));\nendmodule\n\nmodule adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a, b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [7:0] g, p;\n\n    assign g = a & b;\n    assign p = a ^ b;\n\n    assign sum = p ^ (p + cin);\n    assign cout = (a & b) | (p & cin);\nendmodule"}
{"task_id": 11, "response": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n\n    // Submodules for decoding instruction fields\n    wire [31:0] func_imm;\n    wire [4:0] func_rd;\n    wire [4:0] func_rs1;\n    wire [4:0] func_rs2;\n    wire [2:0] func_func3;\n    wire [6:0] func_func7;\n\n    // Opcode decoder\n    assign opcode = instr[6:0];\n\n    // Functional unit decoder\n    func_unit func_decoder (\n        .instr(instr),\n        .rd(func_rd),\n        .rs1(func_rs1),\n        .rs2(func_rs2),\n        .func3(func_func3),\n        .func7(func_func7),\n        .imm(func_imm)\n    );\n\n    // Register file decoder\n    reg_file registers (\n        .instr(instr),\n        .rd(func_rd),\n        .rs1(func_rs1),\n        .rs2(func_rs2),\n        .func3(func_func3),\n        .func7(func_func7),\n        .imm(func_imm)\n    );\n\n    // Immediate decoder\n    immediate_decoder immediates (\n        .instr(instr),\n        .rd(func_rd),\n        .rs1(func_rs1),\n        .rs2(func_rs2),\n        .func3(func_func3),\n        .func7(func_func7),\n        .imm(func_imm)\n    );\n\nendmodule\n\nmodule func_unit (\n    input [31:0] instr,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign func3 = instr[11:8];\n    assign func7 = instr[31:25];\n    assign imm = {instr[31], instr[7], instr[30:25], instr[24:21], instr[11:8]};\nendmodule\n\nmodule reg_file (\n    input [31:0] instr,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign func3 = instr[11:8];\n    assign func7 = instr[31:25];\n    assign imm = {instr[31], instr[7], instr[30:25], instr[24:21], instr[11:8]};\nendmodule\n\nmodule immediate_decoder (\n    input [31:0] instr,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:2"}
{"task_id": 17, "response": "module complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);\n\n    wire clk_25_out;\n    wire clk_5_out;\n    wire clk_1_out;\n    wire clk_200k_out;\n\n    clk_div_8 div_25MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_25_out)\n    );\n\n    clk_div_40 div_5MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_200 div_1MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_1_out)\n    );\n\n    clk_div_1000 div_200kHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_200k_out)\n    );\n\n    assign CLK_25MHz = clk_25_out;\n    assign CLK_5MHz = clk_5_out;\n    assign CLK_1MHz = clk_1_out;\n    assign CLK_200kHz = clk_200k_out;\n\nendmodule\n\nmodule clk_div_8 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 3) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_40 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 19) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_200 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 99) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10000 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [9:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 499) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": 3, "response": "module sub_16bit(A, B, Result, Overflow);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Result;\n    output Overflow;\n\n    wire [7:0] lower_result;\n    wire [7:0] higher_result;\n    wire lower_overflow;\n    wire higher_overflow;\n\n    sub_8bit lower_sub(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Result(lower_result),\n        .Overflow(lower_overflow)\n    );\n\n    sub_8bit higher_sub(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Result(higher_result),\n        .Overflow(higher_overflow)\n    );\n\n    assign Result = {higher_result, lower_result};\n    assign Overflow = (lower_overflow ^ higher_overflow);\n\nendmodule\n\nmodule sub_8bit(A, B, Result, Overflow);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Result;\n    output Overflow;\n\n    wire [7:0] difference;\n    wire borrow_out;\n\n    adder_8bit adder(\n        .A(A),\n        .B(~B),\n        .Sum(difference),\n        .BorrowOut(borrow_out)\n    );\n\n    assign Result = difference;\n    assign Overflow = borrow_out;\n\nendmodule\n\nmodule adder_8bit(A, B, Sum, BorrowOut);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Sum;\n    output BorrowOut;\n\n    wire [7:0] carry;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(0), .Sum(Sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(Sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(Sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(Sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(Sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(Sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(Sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(Sum[7]), .Cout(BorrowOut));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": 27, "response": "module adder_64bit(A, B, Cin, Sum, Cout);\n    input [63:0] A, B;\n    input Cin;\n    output [63:0] Sum;\n    output Cout;\n\n    wire [7:0] carry;\n\n    adder_8bit adder0(.a(A[7:0]), .b(B[7:0]), .cin(Cin), .sum(Sum[7:0]), .cout(carry[0]));\n    adder_8bit adder1(.a(A[15:8]), .b(B[15:8]), .cin(carry[0]), .sum(Sum[15:8]), .cout(carry[1]));\n    adder_8bit adder2(.a(A[23:16]), .b(B[23:16]), .cin(carry[1]), .sum(Sum[23:16]), .cout(carry[2]));\n    adder_8bit adder3(.a(A[31:24]), .b(B[31:24]), .cin(carry[2]), .sum(Sum[31:24]), .cout(carry[3]));\n    adder_8bit adder4(.a(A[39:32]), .b(B[39:32]), .cin(carry[3]), .sum(Sum[39:32]), .cout(carry[4]));\n    adder_8bit adder5(.a(A[47:40]), .b(B[47:40]), .cin(carry[4]), .sum(Sum[47:40]), .cout(carry[5]));\n    adder_8bit adder6(.a(A[55:48]), .b(B[55:48]), .cin(carry[5]), .sum(Sum[55:48]), .cout(carry[6]));\n    adder_8bit adder7(.a(A[63:56]), .b(B[63:56]), .cin(carry[6]), .sum(Sum[63:56]), .cout(Cout));\nendmodule\n\nmodule adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a, b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [7:0] g, p;\n    assign g = a & b;\n    assign p = a ^ b;\n    assign sum = p ^ (p + g);\n    assign cout = (a & b) | (p & g);\nendmodule"}
{"task_id": 11, "response": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n\n    // Submodules for instruction decoding\n    wire [31:0] func_decoder_out;\n    wire [31:0] register_decoder_out;\n    wire [31:0] immediate_decoder_out;\n\n    // Opcode extraction\n    assign opcode = instr[6:0];\n\n    // Functional decoder\n    func_decoder func_decoder (\n        .instr(instr),\n        .out(func_decoder_out)\n    );\n\n    // Register decoder\n    register_decoder registers (\n        .instr(instr),\n        .out(register_decoder_out)\n    );\n\n    // Immediate decoder\n    immediate_decoder immediates (\n        .instr(instr),\n        .out(immediate_decoder_out)\n    );\n\n    // Output assignments\n    assign rs1 = register_decoder_out[4:0];\n    assign rs2 = register_decoder_out[19:15];\n    assign rd = register_decoder_out[24:20];\n    assign func3 = func_decoder_out[14:12];\n    assign func7 = func_decoder_out[31:25];\n    assign imm = immediate_decoder_out;\n\nendmodule\n\nmodule func_decoder (\n    input [31:0] instr,\n    output [31:0] out\n);\n    assign out = (instr[6:0] == 7'b0110011) ? instr[31:25] : 32'b0; // Example function decoding\nendmodule\n\nmodule register_decoder (\n    input [31:0] instr,\n    output [31:0] out\n);\n    assign out = instr; // Example register decoding\nendmodule\n\nmodule immediate_decoder (\n    input [31:0] instr,\n    output [31:0] out\n);\n    assign out = (instr[6:0] == 7'b0010011) ? {instr[31], instr[7], instr[30:25], instr[11:8], 5'b0, instr[4:0]} : 32'b0; // Example immediate decoding\nendmodule"}
{"task_id": 4, "response": "module mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the next count logic\n    next_count_logic u_next_count_logic (\n        .current_count(count),\n        .enable(enable),\n        .next_count(next_count)\n    );\n\n    // Instantiate the count register\n    count_register u_count_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule next_count_logic (\n    input wire [3:0] current_count,\n    input wire enable,\n    output wire [3:0] next_count\n);\n\n    assign next_count = (current_count == 9 && enable) ? 0 : current_count + 1;\n\nendmodule\n\nmodule count_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 17, "response": "module complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);\n\n    wire clk_25;\n    wire clk_5;\n    wire clk_1;\n    wire clk_200;\n\n    clk_div_8 div_25MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_25)\n    );\n\n    clk_div_40 div_5MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_5)\n    );\n\n    clk_div_200 div_1MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_1)\n    );\n\n    clk_div_1000 div_200kHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_200)\n    );\n\n    assign CLK_25MHz = clk_25;\n    assign CLK_5MHz = clk_5;\n    assign CLK_1MHz = clk_1;\n    assign CLK_200kHz = clk_200;\n\nendmodule\n\nmodule clk_div_8 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 3) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_40 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 19) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_200 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 99) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_1000 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [9:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 499) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": 4, "response": "module mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the next count logic\n    next_count_logic u_next_count_logic (\n        .current_count(count),\n        .enable(enable),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    count_register u_count_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule next_count_logic (\n    input wire [3:0] current_count,\n    input wire enable,\n    output wire [3:0] next_count\n);\n\n    assign next_count = (current_count == 9 && enable) ? 0 : current_count + 1;\n\nendmodule\n\nmodule count_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 4'b0000;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 11, "response": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n\n    // Submodules for decoding instruction fields\n    func_decoder func_decoder (\n        .instr(instr),\n        .opcode(opcode),\n        .func3(func3),\n        .func7(func7)\n    );\n\n    reg_decoder registers (\n        .instr(instr),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2)\n    );\n\n    immediate_decoder immediates (\n        .instr(instr),\n        .imm(imm)\n    );\n\nendmodule\n\nmodule func_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [2:0] func3,\n    output [6:0] func7\n);\n    assign opcode = instr[6:0];\n    assign func3 = instr[14:12];\n    assign func7 = instr[31:25];\nendmodule\n\nmodule reg_decoder (\n    input [31:0] instr,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\nendmodule\n\nmodule immediate_decoder (\n    input [31:0] instr,\n    output [31:0] imm\n);\n    assign imm = instr[31:20];\nendmodule"}
{"task_id": 27, "response": "module adder_64bit(A, B, Cin, Sum, Cout);\n    input [63:0] A, B;\n    input Cin;\n    output [63:0] Sum;\n    output Cout;\n\n    wire [7:0] carry;\n\n    adder_8bit adder0(.a(A[7:0]), .b(B[7:0]), .cin(Cin), .sum(Sum[7:0]), .cout(carry[0]));\n    adder_8bit adder1(.a(A[15:8]), .b(B[15:8]), .cin(carry[0]), .sum(Sum[15:8]), .cout(carry[1]));\n    adder_8bit adder2(.a(A[23:16]), .b(B[23:16]), .cin(carry[1]), .sum(Sum[23:16]), .cout(carry[2]));\n    adder_8bit adder3(.a(A[31:24]), .b(B[31:24]), .cin(carry[2]), .sum(Sum[31:24]), .cout(carry[3]));\n    adder_8bit adder4(.a(A[39:32]), .b(B[39:32]), .cin(carry[3]), .sum(Sum[39:32]), .cout(carry[4]));\n    adder_8bit adder5(.a(A[47:40]), .b(B[47:40]), .cin(carry[4]), .sum(Sum[47:40]), .cout(carry[5]));\n    adder_8bit adder6(.a(A[55:48]), .b(B[55:48]), .cin(carry[5]), .sum(Sum[55:48]), .cout(carry[6]));\n    adder_8bit adder7(.a(A[63:56]), .b(B[63:56]), .cin(carry[6]), .sum(Sum[63:56]), .cout(Cout));\nendmodule\n\nmodule adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a, b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [7:0] g, p;\n    assign g = a & b;\n    assign p = a ^ b;\n    assign sum = p ^ (p + g);\n    assign cout = (a & b) | (p & g);\nendmodule"}
{"task_id": 4, "response": "module mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the next count logic\n    next_count_logic u_next_count_logic (\n        .current_count(count),\n        .enable(enable),\n        .next_count(next_count)\n    );\n\n    // Instantiate the count register\n    count_register u_count_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule next_count_logic (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            next_count = (current_count == 9) ? 0 : current_count + 1;\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule count_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 12, "response": "module dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the shift logic\n    shift_logic u_shift_logic (\n        .current_count(count_out),\n        .shift_dir(shift_dir),\n        .next_count(next_count)\n    );\n\n    // Instantiate the shift register\n    shift_register u_shift_register (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(data_in),\n        .current_count(count_out),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule shift_logic (\n    input wire [3:0] current_count,\n    input wire shift_dir,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (shift_dir) begin\n            next_count = {current_count[2:0], current_count[3]};\n        end else begin\n            next_count = {current_count[0], current_count[3:1]};\n        end\n    end\n\nendmodule\n\nmodule shift_register (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    input wire [3:0] current_count,\n    output reg [3:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 4'b0000;\n        end else if (load) begin\n            next_count <= data_in;\n        end else begin\n            next_count <= current_count;\n        end\n    end\n\nendmodule"}
{"task_id": 28, "response": "module alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nand u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\nassign result = (op_code == 2'b00) ? add_result :\n                (op_code == 2'b01) ? sub_result :\n                (op_code == 2'b10) ? and_result : or_result;\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 5, "response": "module barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);\n    wire [31:0] left_shift, right_shift;\n\n    // Generate left circular shift outputs\n    assign left_shift = (data_in << shift_amt) | (data_in >> (32 - shift_amt));\n\n    // Generate right circular shift outputs\n    assign right_shift = (data_in >> shift_amt) | (data_in << (32 - shift_amt));\n\n    // Mux the shift outputs based on shift direction\n    assign data_out = shift_dir ? right_shift : left_shift;\n\nendmodule"}
{"task_id": 18, "response": "module signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    wire [14:0] mag_A;\n    wire [14:0] mag_B;\n    wire sign_A;\n    wire sign_B;\n\n    // Sign extraction for A and B\n    assign sign_A = A[15];\n    assign sign_B = B[15];\n\n    // Extract magnitude for A and B\n    assign mag_A = A[14:0];\n    assign mag_B = B[14:0];\n\n    // Instantiate the 15-bit unsigned magnitude comparator\n    unsigned_magnitude_comparator_15bit mag_comp (\n        .A(mag_A),\n        .B(mag_B),\n        .A_greater(A_greater),\n        .A_equal(A_equal),\n        .A_less(A_less)\n    );\n\n    // Comparison logic for sign\n    always @(*) begin\n        if (sign_A != sign_B) begin\n            A_greater = sign_A;\n            A_equal = 0;\n            A_less = ~sign_A;\n        end else begin\n            A_greater = 0;\n            A_equal = A_equal | (~sign_A & A_greater);\n            A_less = 0;\n        end\n    end\n\nendmodule\n\nmodule unsigned_magnitude_comparator_15bit(\n    input [14:0] A,   \n    input [14:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\n\nendmodule"}
{"task_id": 5, "response": "module barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);\n    wire [31:0] left_shift, right_shift;\n\n    // Shift left\n    assign left_shift = (data_in << shift_amt) | (data_in >> (32 - shift_amt));\n\n    // Shift right\n    assign right_shift = (data_in >> shift_amt) | (data_in << (32 - shift_amt));\n\n    // Output data based on shift direction\n    assign data_out = shift_dir ? right_shift : left_shift;\n\nendmodule"}
{"task_id": 5, "response": "module barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);\n    wire [31:0] left_shift, right_shift;\n    \n    // Generate left circular shift outputs\n    assign left_shift = (data_in << shift_amt) | (data_in >> (32 - shift_amt));\n    \n    // Generate right circular shift outputs\n    assign right_shift = (data_in >> shift_amt) | (data_in << (32 - shift_amt));\n    \n    // Mux the outputs based on shift direction\n    assign data_out = shift_dir ? right_shift : left_shift;\n\nendmodule"}
{"task_id": 12, "response": "module dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the shift logic\n    shift_logic u_shift_logic (\n        .current_count(count_out),\n        .shift_dir(shift_dir),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count\n    shift_register u_shift_register (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(data_in),\n        .next_count(next_count),\n        .current_count(count_out)\n    );\n\nendmodule\n\nmodule shift_logic (\n    input wire [3:0] current_count,\n    input wire shift_dir,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (shift_dir) begin\n            next_count = {current_count[2:0], current_count[3]};\n        end else begin\n            next_count = {current_count[0], current_count[3:1]};\n        end\n    end\n\nendmodule\n\nmodule shift_register (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 4'b0000;\n        end else if (load) begin\n            current_count <= data_in;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 18, "response": "module signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    wire sign_A = A[15];\n    wire sign_B = B[15];\n\n    // Instantiate the 15-bit magnitude comparator\n    unsigned_magnitude_comparator_15bit mag_comp (\n        .A(A[14:0]),\n        .B(B[14:0]),\n        .A_greater(A_greater),\n        .A_equal(A_equal),\n        .A_less(A_less)\n    );\n\n    // Determine the sign comparison\n    always @(*) begin\n        if (sign_A != sign_B) begin\n            A_greater = sign_A;\n            A_equal = 0;\n            A_less = ~sign_A;\n        end else begin\n            A_greater = 0;\n            A_equal = A_equal | (A_less == 0 & A_greater == 0);\n            A_less = 0;\n        end\n    end\n\nendmodule\n\nmodule unsigned_magnitude_comparator_15bit(\n    input [14:0] A,\n    input [14:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\n\nendmodule"}
{"task_id": 28, "response": "module alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n);\n\n// Instantiating the AND module\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .out(and_result)\n);\n\n// Instantiating the OR module\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .out(or_result)\n);\n\n// Selecting the output based on the op_code\nassign result = (op_code == 2'b00) ? add_result :\n                (op_code == 2'b01) ? sub_result :\n                (op_code == 2'b10) ? and_result :\n                or_result;\n\nendmodule\n\n// Submodule for addition\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Submodule for subtraction\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// Submodule for bitwise AND\nmodule and_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] out\n);\n    assign out = a & b;\nendmodule\n\n// Submodule for bitwise OR\nmodule or_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": 12, "response": "module dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the shift logic\n    shift_logic u_shift_logic (\n        .current_count(count_out),\n        .shift_dir(shift_dir),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    shift_register u_shift_register (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(data_in),\n        .next_count(next_count),\n        .current_count(count_out)\n    );\n\nendmodule\n\nmodule shift_logic (\n    input wire [3:0] current_count,\n    input wire shift_dir,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (shift_dir) begin\n            next_count = {current_count[0], current_count[3:1]};\n        end else begin\n            next_count = {current_count[1:0], current_count[3:2]};\n        end\n    end\n\nendmodule\n\nmodule shift_register (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 4'b0000;\n        end else if (load) begin\n            current_count <= data_in;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 6, "response": "module memory_shifter(data, shift_control, out);\n\n  input [15:0] data;\n  input [3:0] shift_control;\n  output [15:0] out;\n\n  wire [15:0] shifted_left, shifted_right, rotated_right;\n\n  shift_left shift_left_module (\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .result(shifted_left)\n  );\n\n  shift_right shift_right_module (\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .result(shifted_right)\n  );\n\n  rotate_right rotate_right_module (\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .result(rotated_right)\n  );\n\n  output_selector output_selector (\n    .shifted_left(shifted_left),\n    .shifted_right(shifted_right),\n    .rotated_right(rotated_right),\n    .shift_control(shift_control),\n    .out(out)\n  );\n\nendmodule\n\nmodule shift_left(data, shift_amount, result);\n  input [15:0] data;\n  input [1:0] shift_amount;\n  output [15:0] result;\n  assign result = data << shift_amount;\nendmodule\n\nmodule shift_right(data, shift_amount, result);\n  input [15:0] data;\n  input [1:0] shift_amount;\n  output [15:0] result;\n  assign result = data >> shift_amount;\nendmodule\n\nmodule rotate_right(data, shift_amount, result);\n  input [15:0] data;\n  input [1:0] shift_amount;\n  output [15:0] result;\n  assign result = {data[shift_amount-1:0], data[15:shift_amount]};\nendmodule\n\nmodule output_selector(shifted_left, shifted_right, rotated_right, shift_control, out);\n  input [15:0] shifted_left;\n  input [15:0] shifted_right;\n  input [15:0] rotated_right;\n  input [3:0] shift_control;\n  output [15:0] out;\n\n  reg [15:0] selected_data;\n\n  always @(*) begin\n    case(shift_control[3:2])\n      2'b00: selected_data = shifted_left;\n      2'b01: selected_data = shifted_right;\n      2'b10: selected_data = rotated_right;\n      2'b11: selected_data = shifted_left; // This is an example of wrapping around\n    endcase\n  end\n\n  assign out = selected_data;\n\nendmodule"}
{"task_id": 28, "response": "module alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Selective output based on op_code\nassign result = (op_code == 2'b00) ? add_result :\n                (op_code == 2'b01) ? sub_result :\n                (op_code == 2'b10) ? and_result :\n                                      or_result;\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 18, "response": "module signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    wire [14:0] mag_A;\n    wire [14:0] mag_B;\n    wire sign_A;\n    wire sign_B;\n\n    // Extracting the magnitude and sign\n    assign mag_A = A[14:0];\n    assign mag_B = B[14:0];\n    assign sign_A = A[15];\n    assign sign_B = B[15];\n\n    // Instantiating the 15-bit magnitude comparator\n    unsigned_magnitude_comparator_15bit mag_comp (\n        .A(mag_A),\n        .B(mag_B),\n        .A_greater(A_greater),\n        .A_equal(A_equal),\n        .A_less(A_less)\n    );\n\n    // Comparison logic for sign\n    always @(*) begin\n        if (sign_A != sign_B) begin\n            A_greater = sign_A;\n            A_equal = 0;\n            A_less = ~sign_A;\n        end else begin\n            A_greater = 0;\n            A_equal = A_equal | (A_less == 0 && A_greater == 0);\n            A_less = 0;\n        end\n    end\n\nendmodule\n\nmodule unsigned_magnitude_comparator_15bit(\n    input [14:0] A,\n    input [14:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\n\nendmodule"}
{"task_id": 13, "response": "module bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n    wire direction;\n\n    // Submodule for controlling count direction\n    count_direction_controller direction_control (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .direction(direction)\n    );\n\n    // Submodule for counting\n    counter_module count_module (\n        .clk(clk),\n        .reset(reset),\n        .direction(direction),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\n// Submodule for controlling count direction\nmodule count_direction_controller (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg wire direction\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            direction <= 1'b0; // Initialize to down count\n        else\n            direction <= up_down;\n    end\n\nendmodule\n\n// Submodule for counting\nmodule counter_module (\n    input wire clk,\n    input wire reset,\n    input wire direction,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (direction)\n            count <= count + 1;\n        else\n            count <= count - 1;\n    end\n\nendmodule"}
{"task_id": 6, "response": "module memory_shifter(data, shift_control, out);\n\ninput [15:0] data;\ninput [3:0] shift_control;\noutput reg [15:0] out;\n\nwire [15:0] shift_left_out, shift_right_out, rotate_right_out;\n\nshift_left shift_left_module (.data(data), .count(shift_control[1:0]), .out(shift_left_out));\nshift_right shift_right_module (.data(data), .count(shift_control[1:0]), .out(shift_right_out));\nrotate_right rotate_right_module (.data(data), .count(shift_control[3:2]), .out(rotate_right_out));\n\nassign out = (shift_control[3:2] == 2'b00) ? data : (shift_control[3:2] == 2'b01) ? shift_left_out : (shift_control[3:2] == 2'b10) ? shift_right_out : rotate_right_out;\n\nendmodule\n\nmodule shift_left(data, count, out);\ninput [15:0] data;\ninput [1:0] count;\noutput [15:0] out;\n\nassign out = (count == 2'b00) ? data : (count == 2'b01) ? (data << 2) : (data << 4);\n\nendmodule\n\nmodule shift_right(data, count, out);\ninput [15:0] data;\ninput [1:0] count;\noutput [15:0] out;\n\nassign out = (count == 2'b00) ? data : (count == 2'b01) ? (data >> 2) : (data >> 4);\n\nendmodule\n\nmodule rotate_right(data, count, out);\ninput [15:0] data;\ninput [1:0] count;\noutput [15:0] out;\n\nassign out = (count == 2'b00) ? data : (count == 2'b01) ? (data >> 2) : (data >> 4);\n\nendmodule\n\nmodule output_selector(data, out);\ninput [15:0] data;\noutput [15:0] out;\n\nassign out = data;\n\nendmodule"}
{"task_id": 13, "response": "module bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n    wire direction;\n\n    // Submodule for controlling count direction\n    count_direction_controller direction_control (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .direction(direction)\n    );\n\n    // Submodule for counting\n    counter_module count_module (\n        .clk(clk),\n        .reset(reset),\n        .direction(direction),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\n// Submodule for controlling count direction\nmodule count_direction_controller (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg wire direction\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            direction <= 1'b0; // Reset to initial state\n        else\n            direction <= up_down; // Follow the up_down signal\n    end\n\nendmodule\n\n// Submodule for counting\nmodule counter_module (\n    input wire clk,\n    input wire reset,\n    input wire direction,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000; // Reset to initial state\n        else if (direction)\n            count <= count + 1; // Increment\n        else\n            count <= count - 1; // Decrement\n    end\n\nendmodule"}
{"task_id": 19, "response": "module bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);\n\n    wire [11:0] next_value;\n\n    // Instantiate the control unit\n    control_unit u_control_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .next_value(next_value)\n    );\n\n    // Instantiate the increment/decrement logic\n    increment_decrement_logic u_increment_decrement_logic (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Instantiate the register unit\n    register_unit u_register_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_value(next_value),\n        .current_value(value)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (next_value == 12'b111111111111) ? 12'b0 : next_value + 1; // Increment\n            end else begin\n                next_value <= (next_value == 12'b0) ? 12'b111111111111 : next_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule increment_decrement_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (current_value == 12'b111111111111) ? 12'b0 : current_value + 1; // Increment\n            end else begin\n                next_value <= (current_value == 12'b0) ? 12'b111111111111 : current_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [11:0] next_value,\n    output reg [11:0] current_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            current_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            current_value <= next_value;\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns / 1ps\n\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [15:0] add_out, sub_out, and_out, or_out, xor_out, slt_out, not_out;\nwire add_carry, sub_borrow;\n\nadder_16 add_mod(.a(a), .b(b), .sum(add_out), .carry(add_carry));\nsubtractor_16 sub_mod(.a(a), .b(b), .diff(sub_out), .borrow(sub_borrow));\nand_16 and_mod(.a(a), .b(b), .out(and_out));\nor_16 or_mod(.a(a), .b(b), .out(or_out));\nxor_16 xor_mod(.a(a), .b(b), .out(xor_out));\nslt_16 slt_mod(.a(a), .b(b), .out(slt_out));\nnot_16 not_mod(.a(a), .out(not_out));\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_out;\n        4'b0001: result = sub_out;\n        4'b0010: result = and_out;\n        4'b0011: result = or_out;\n        4'b0100: result = xor_out;\n        4'b0101: result = slt_out;\n        4'b0110: result = not_out;\n        default: result = 16'bx;\n    endcase\nend\n\nassign zero = (result == 16'b0);\nassign carry = (op_code == 4'b0000) ? add_carry : (op_code == 4'b0001) ? sub_borrow : 1'b0;\nassign negative = result[15];\n\nendmodule\n\nmodule adder_16(input [15:0] a, input [15:0] b, output [15:0] sum, output carry);\n    assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_16(input [15:0] a, input [15:0] b, output [15:0] diff, output borrow);\n    assign {borrow, diff} = a - b;\nendmodule\n\nmodule and_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\nmodule slt_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = (a < b) ? 16'b1 : 16'b0;\nendmodule\n\nmodule not_16(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}
{"task_id": 13, "response": "module bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n    wire direction;\n\n    // Submodule for counting direction control\n    count_direction_controller direction_control (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .direction(direction)\n    );\n\n    // Submodule for counting\n    counter_module count_module (\n        .clk(clk),\n        .reset(reset),\n        .direction(direction),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\n// Submodule for counting direction control\nmodule count_direction_controller (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output reg wire direction\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            direction <= 0;\n        else\n            direction <= up_down;\n    end\n\nendmodule\n\n// Submodule for counting\nmodule counter_module (\n    input wire clk,\n    input wire reset,\n    input wire direction,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (direction)\n            count <= count + 1;\n        else\n            count <= count - 1;\n    end\n\nendmodule"}
{"task_id": 6, "response": "module memory_shifter(data, shift_control, out);\n\ninput [15:0] data;\ninput [3:0] shift_control;\noutput reg [15:0] out;\n\nwire [15:0] shift_left_out, shift_right_out, rotate_right_out;\n\nshift_left shift_left_module(.data(data), .shift_amount(shift_control[1:0]), .out(shift_left_out));\nshift_right shift_right_module(.data(data), .shift_amount(shift_control[1:0]), .out(shift_right_out));\nrotate_right rotate_right_module(.data(data), .shift_amount(shift_control[1:0]), .out(rotate_right_out));\n\nassign out = (shift_control[3] == 0) ? data : (shift_control[3] == 1) ? shift_left_out : (shift_control[3] == 2) ? shift_right_out : rotate_right_out;\n\nendmodule\n\nmodule shift_left(data, shift_amount, out);\ninput [15:0] data;\ninput [1:0] shift_amount;\noutput [15:0] out;\n\nassign out = data << shift_amount;\n\nendmodule\n\nmodule shift_right(data, shift_amount, out);\ninput [15:0] data;\ninput [1:0] shift_amount;\noutput [15:0] out;\n\nassign out = data >> shift_amount;\n\nendmodule\n\nmodule rotate_right(data, shift_amount, out);\ninput [15:0] data;\ninput [1:0] shift_amount;\noutput [15:0] out;\n\nassign out = {data[shift_amount-1:0], data[15:shift_amount]};\n\nendmodule\n\nmodule output_selector(data, out);\ninput [15:0] data;\noutput reg [15:0] out;\n\nalways @(*) begin\n    case(data)\n        16'h0000: out = 16'h0000;\n        16'h0001: out = 16'h0002;\n        16'h0002: out = 16'h0004;\n        16'h0003: out = 16'h0008;\n        16'h0004: out = 16'h0010;\n        16'h0005: out = 16'h0020;\n        16'h0006: out = 16'h0040;\n        16'h0007: out = 16'h0080;\n        16'h0008: out = 16'h0100;\n        16'h0009: out = 16'h0200;\n        16'h000A: out = 16'h0400;\n        16'h000B: out = 16'h0800;\n        16'h000C: out = 16'h1000;\n        16'h000D: out = 16'h2000;\n        16'h000E: out = 16'h4000;\n        16'h000F: out = 16'h8000;\n        default: out = 16'h0000;\n    endcase\nend\n\nendmodule"}
{"task_id": 19, "response": "module bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);\n\n    wire [11:0] next_value;\n\n    // Instantiate the control unit\n    control_unit u_control_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .next_value(next_value)\n    );\n\n    // Instantiate the increment/decrement logic\n    increment_decrement_logic u_increment_decrement_logic (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Instantiate the register unit\n    register_unit u_register_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_value(next_value),\n        .current_value(value)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (next_value == 12'b111111111111) ? 12'b0 : next_value + 1; // Increment\n            end else begin\n                next_value <= (next_value == 12'b0) ? 12'b111111111111 : next_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule increment_decrement_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (current_value == 12'b111111111111) ? 12'b0 : current_value + 1; // Increment\n            end else begin\n                next_value <= (current_value == 12'b0) ? 12'b111111111111 : current_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [11:0] next_value,\n    output reg [11:0] current_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            current_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            current_value <= next_value;\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns / 1ps\n\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [15:0] add_out, sub_out, and_out, or_out, xor_out, slt_out, not_out;\nwire add_carry, sub_borrow;\n\nadder_16 add_mod(.a(a), .b(b), .sum(add_out), .carry(add_carry));\nsubtractor_16 sub_mod(.a(a), .b(b), .difference(sub_out), .borrow(sub_borrow));\nand_16 and_mod(.a(a), .b(b), .out(and_out));\nor_16 or_mod(.a(a), .b(b), .out(or_out));\nxor_16 xor_mod(.a(a), .b(b), .out(xor_out));\nslt_16 slt_mod(.a(a), .b(b), .out(slt_out));\nnot_16 not_mod(.a(a), .out(not_out));\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_out;\n        4'b0001: result = sub_out;\n        4'b0010: result = and_out;\n        4'b0011: result = or_out;\n        4'b0100: result = xor_out;\n        4'b0101: result = slt_out;\n        4'b0110: result = not_out;\n        default: result = 16'bx;\n    endcase\nend\n\nassign zero = (result == 16'b0);\nassign carry = (op_code == 4'b0000) ? add_carry : sub_borrow;\nassign negative = result[15];\n\nendmodule\n\nmodule adder_16(input [15:0] a, input [15:0] b, output [15:0] sum, output carry);\n    assign sum = a + b;\n    assign carry = (a[15] & b[15]) | (a[15] & ~b[15]) | (~a[15] & ~b[15] & sum[15]);\nendmodule\n\nmodule subtractor_16(input [15:0] a, input [15:0] b, input borrow, output [15:0] difference, output borrow_out);\n    assign difference = a - b - borrow;\n    assign borrow_out = (~a[15] & b[15]) | (a[15] & ~b[15] & ~borrow);\nendmodule\n\nmodule and_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\nmodule slt_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = (a < b) ? 16'b1 : 16'b0;\nendmodule\n\nmodule not_16(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}
{"task_id": 19, "response": "module bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);\n\n    wire [11:0] next_value;\n\n    // Instantiate control unit\n    control_unit u_control_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Instantiate increment/decrement logic\n    increment_decrement_logic u_increment_decrement_logic (\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Instantiate register unit\n    register_unit u_register_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_value(next_value),\n        .current_value(value)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            next_value <= 12'b0;\n        else if (enable) begin\n            if (direction)\n                next_value <= (current_value == 12'hFFF) ? 12'h000 : current_value + 1;\n            else\n                next_value <= (current_value == 12'h000) ? 12'hFFF : current_value - 1;\n        end\n    end\n\nendmodule\n\nmodule increment_decrement_logic (\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @* begin\n        if (current_value == 12'hFFF)\n            next_value = 12'h000;\n        else\n            next_value = current_value + 1;\n    end\n\nendmodule\n\nmodule register_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [11:0] next_value,\n    output reg [11:0] current_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            current_value <= 12'b0;\n        else if (enable)\n            current_value <= next_value;\n    end\n\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns / 1ps\n\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [15:0] add_out, sub_out, and_out, or_out, xor_out, slt_out, not_out;\nwire add_carry, sub_borrow;\n\n// Instantiating adder, subtractor, and other modules\nadder_16 add_mod(.a(a), .b(b), .sum(add_out), .carry(add_carry));\nsubtractor_16 sub_mod(.a(a), .b(b), .diff(sub_out), .borrow(sub_borrow));\nand_16 and_mod(.a(a), .b(b), .out(and_out));\nor_16 or_mod(.a(a), .b(b), .out(or_out));\nxor_16 xor_mod(.a(a), .b(b), .out(xor_out));\nslt_16 slt_mod(.a(a), .b(b), .out(slt_out));\nnot_16 not_mod(.a(a), .out(not_out));\n\n// Control logic\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_out;\n        4'b0001: result = sub_out;\n        4'b0010: result = and_out;\n        4'b0011: result = or_out;\n        4'b0100: result = xor_out;\n        4'b0101: result = slt_out;\n        4'b0110: result = not_out;\n        default: result = 16'bx;\n    endcase\nend\n\n// Flags\nassign zero = (result == 16'b0);\nassign carry = (op_code == 4'b0000) ? add_carry : sub_borrow;\nassign negative = result[15];\n\nendmodule\n\n// Submodules\n\n// Adder\nmodule adder_16(input [15:0] a, input [15:0] b, output [15:0] sum, output carry);\n    assign {carry, sum} = a + b;\nendmodule\n\n// Subtractor\nmodule subtractor_16(input [15:0] a, input [15:0] b, output [15:0] diff, output borrow);\n    assign {borrow, diff} = a - b;\nendmodule\n\n// AND\nmodule and_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\n// OR\nmodule or_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\n// XOR\nmodule xor_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\n// SLT (Set if Less Than)\nmodule slt_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = (a < b) ? 16'b1 : 16'b0;\nendmodule\n\n// NOT\nmodule not_16(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}
{"task_id": 20, "response": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);\n\n    wire [6:0] op_type_out;\n    wire [4:0] dest_reg_out;\n    wire [31:0] immediate_out;\n\n    // Instantiate the operation decoder\n    decode_op op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .op_type(op_type_out)\n    );\n\n    // Instantiate the destination register decoder\n    decode_dest dest_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .dest_reg(dest_reg_out)\n    );\n\n    // Instantiate the immediate value decoder\n    decode_imm imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .immediate(immediate_out)\n    );\n\n    assign op_type = op_type_out;\n    assign dest_reg = dest_reg_out;\n    assign immediate = immediate_out;\n\nendmodule\n\nmodule decode_op (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] op_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            op_type <= 0;\n        end else begin\n            op_type <= instruction[6:0]; // Extract the operation type\n        end\n    end\nendmodule\n\nmodule decode_dest (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [4:0] dest_reg\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            dest_reg <= 0;\n        end else begin\n            dest_reg <= instruction[11:7]; // Extract the destination register\n        end\n    end\nendmodule\n\nmodule decode_imm (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] immediate\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            immediate <= 0;\n        end else begin\n            immediate <= instruction[31:20]; // Extract the immediate value\n        end\n    end\nendmodule"}
{"task_id": 20, "response": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);\n\n    wire [6:0] op_type_out;\n    wire [4:0] dest_reg_out;\n    wire [31:0] immediate_out;\n\n    // Instantiate the operation decoder\n    decode_op op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .op_type(op_type_out)\n    );\n\n    // Instantiate the destination register decoder\n    decode_dest dest_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .dest_reg(dest_reg_out)\n    );\n\n    // Instantiate the immediate value decoder\n    decode_imm imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .immediate(immediate_out)\n    );\n\n    assign op_type = op_type_out;\n    assign dest_reg = dest_reg_out;\n    assign immediate = immediate_out;\n\nendmodule\n\nmodule decode_op (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] op_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            op_type <= 0;\n        end else begin\n            op_type <= instruction[6:0]; // Extract the operation type\n        end\n    end\nendmodule\n\nmodule decode_dest (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [4:0] dest_reg\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            dest_reg <= 0;\n        end else begin\n            dest_reg <= instruction[11:7]; // Extract the destination register\n        end\n    end\nendmodule\n\nmodule decode_imm (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] immediate\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            immediate <= 0;\n        end else begin\n            immediate <= instruction[31:20]; // Extract the immediate value\n        end\n    end\nendmodule"}
{"task_id": 20, "response": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);\n\n    wire [6:0] op_type_out;\n    wire [4:0] dest_reg_out;\n    wire [31:0] immediate_out;\n\n    // Instantiating the operation decoder\n    decode_op op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .op_type(op_type_out)\n    );\n\n    // Instantiating the destination register decoder\n    decode_dest dest_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .dest_reg(dest_reg_out)\n    );\n\n    // Instantiating the immediate value decoder\n    decode_imm imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .immediate(immediate_out)\n    );\n\n    assign op_type = op_type_out;\n    assign dest_reg = dest_reg_out;\n    assign immediate = immediate_out;\n\nendmodule\n\nmodule decode_op (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] op_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            op_type <= 0;\n        end else begin\n            op_type <= instruction[6:0];\n        end\n    end\nendmodule\n\nmodule decode_dest (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [4:0] dest_reg\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            dest_reg <= 0;\n        end else begin\n            dest_reg <= instruction[11:7];\n        end\n    end\nendmodule\n\nmodule decode_imm (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] immediate\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            immediate <= 0;\n        end else begin\n            immediate <= instruction[31:20];\n        end\n    end\nendmodule"}
