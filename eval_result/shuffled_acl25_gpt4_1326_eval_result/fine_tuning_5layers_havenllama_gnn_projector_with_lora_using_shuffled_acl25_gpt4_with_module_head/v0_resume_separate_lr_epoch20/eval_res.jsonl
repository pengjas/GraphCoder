{"task_id": 21, "response": "module ripple_carry_adder_8bit(A, B, Cin, S, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_2bit RCA0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .S(S[0]),\n        .Cout(carry[0])\n    );\n\n    ripple_carry_adder_2bit RCA1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry[0]),\n        .S(S[1]),\n        .Cout(carry[1])\n    );\n\n    ripple_carry_adder_2bit RCA2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry[1]),\n        .S(S[2]),\n        .Cout(carry[2])\n    );\n\n    ripple_carry_adder_2bit RCA3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry[2]),\n        .S(S[3]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder_2bit(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    wire C1;\n\n    full_adder FA0(\n        .A(A),\n        .B(B),\n        .Cin(Cin),\n        .S(S),\n        .Cout(C1)\n    );\n\n    full_adder FA1(\n        .A(A),\n        .B(B),\n        .Cin(C1),\n        .S(S),\n        .Cout(Cout)\n    );\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (B & Cin) | (A & Cin);\nendmodule"}
{"task_id": 21, "response": "module ripple_carry_adder_8bit(A, B, Cin, S, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_2bit RCA0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .S(S[0]),\n        .Cout(carry[0])\n    );\n\n    ripple_carry_adder_2bit RCA1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry[0]),\n        .S(S[1]),\n        .Cout(carry[1])\n    );\n\n    ripple_carry_adder_2bit RCA2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry[1]),\n        .S(S[2]),\n        .Cout(carry[2])\n    );\n\n    ripple_carry_adder_2bit RCA3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry[2]),\n        .S(S[3]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder_2bit(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    wire c1, c2;\n\n    full_adder FA0(A, B, Cin, S, c1);\n    full_adder FA1(A, B, c1, S, c2);\n\n    assign Cout = c2;\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}
{"task_id": 21, "response": "module ripple_carry_adder_8bit(A, B, Cin, S, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    wire [3:0] carry;\n\n    ripple_carry_adder_2bit RCA0(\n        .A(A[0]),\n        .B(B[0]),\n        .Cin(Cin),\n        .S(S[0]),\n        .Cout(carry[0])\n    );\n\n    ripple_carry_adder_2bit RCA1(\n        .A(A[1]),\n        .B(B[1]),\n        .Cin(carry[0]),\n        .S(S[1]),\n        .Cout(carry[1])\n    );\n\n    ripple_carry_adder_2bit RCA2(\n        .A(A[2]),\n        .B(B[2]),\n        .Cin(carry[1]),\n        .S(S[2]),\n        .Cout(carry[2])\n    );\n\n    ripple_carry_adder_2bit RCA3(\n        .A(A[3]),\n        .B(B[3]),\n        .Cin(carry[2]),\n        .S(S[3]),\n        .Cout(carry[3])\n    );\n\n    assign Cout = carry[3];\nendmodule\n\nmodule ripple_carry_adder_2bit(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    wire [1:0] sum, carry;\n\n    full_adder FA0(.A(A), .B(B), .Cin(Cin), .S(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(sum[0]), .B(1'b0), .Cin(carry[0]), .S(sum[1]), .Cout(Cout));\n\n    assign S = sum;\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (B & Cin) | (A & Cin);\nendmodule"}
{"task_id": 22, "response": "module binary_gray_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] gray_count\n);\n\n    wire [7:0] binary_count;\n\n    // Instantiate the binary counter\n    binary_counter u_binary_counter (\n        .clk(clk),\n        .reset(reset),\n        .binary_count(binary_count)\n    );\n\n    // Instantiate the binary to Gray code converter\n    binary_to_gray_converter u_binary_to_gray_converter (\n        .binary_count(binary_count),\n        .gray_count(gray_count)\n    );\n\nendmodule\n\nmodule binary_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] binary_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary_count <= 8'b0;\n        end else begin\n            binary_count <= binary_count + 1;\n        end\n    end\n\nendmodule\n\nmodule binary_to_gray_converter (\n    input wire [7:0] binary_count,\n    output wire [7:0] gray_count\n);\n\n    assign gray_count = binary_count ^ (binary_count >> 1);\n\nendmodule"}
{"task_id": 22, "response": "module binary_gray_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] gray_count\n);\n\n    wire [7:0] binary_count;\n\n    // Instantiate the binary counter\n    binary_counter u_binary_counter (\n        .clk(clk),\n        .reset(reset),\n        .binary_count(binary_count)\n    );\n\n    // Instantiate the binary to Gray code converter\n    binary_to_gray_converter u_binary_to_gray_converter (\n        .binary_count(binary_count),\n        .gray_count(gray_count)\n    );\n\nendmodule\n\nmodule binary_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] binary_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary_count <= 8'b0;\n        end else begin\n            binary_count <= binary_count + 1;\n        end\n    end\n\nendmodule\n\nmodule binary_to_gray_converter (\n    input wire [7:0] binary_count,\n    output wire [7:0] gray_count\n);\n\n    assign gray_count = binary_count ^ (binary_count >> 1);\n\nendmodule"}
{"task_id": 22, "response": "module binary_gray_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] gray_count\n);\n\n    wire [7:0] binary_count;\n\n    // Instantiate the binary counter\n    binary_counter u_binary_counter (\n        .clk(clk),\n        .reset(reset),\n        .binary_count(binary_count)\n    );\n\n    // Instantiate the binary to Gray code converter\n    binary_to_gray_converter u_binary_to_gray_converter (\n        .binary_count(binary_count),\n        .gray_count(gray_count)\n    );\n\nendmodule\n\nmodule binary_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] binary_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary_count <= 8'b0000000;\n        end else begin\n            binary_count <= binary_count + 1;\n        end\n    end\n\nendmodule\n\nmodule binary_to_gray_converter (\n    input wire [7:0] binary_count,\n    output wire [7:0] gray_count\n);\n\n    assign gray_count = binary_count ^ (binary_count >> 1);\n\nendmodule"}
{"task_id": 23, "response": "module data_shifter(data_in, shift_ctrl, data_out);\n    input [15:0] data_in;\n    input [3:0] shift_ctrl;\n    output [15:0] data_out;\n    wire [15:0] shifted_data;\n\n    assign shifted_data = (shift_ctrl[3]) ? (data_in << shift_ctrl[2:0]) : (data_in >> shift_ctrl[2:0]);\n\n    assign data_out = (shift_ctrl[3]) ? shifted_data : data_in;\nendmodule"}
{"task_id": 23, "response": "module data_shifter(data_in, shift_ctrl, data_out);\n    input [15:0] data_in;\n    input [3:0] shift_ctrl;\n    output [15:0] data_out;\n    wire [15:0] shifted_data;\n\n    assign shifted_data = (shift_ctrl[3]) ? (data_in << shift_ctrl[2:0]) : (data_in >> shift_ctrl[2:0]);\n\n    assign data_out = (shift_ctrl[3]) ? (shifted_data | (16'b0 << (16 - shift_ctrl[2:0]))) : (shifted_data | (16'b0 >> (shift_ctrl[2:0] + 1)));\n\nendmodule"}
{"task_id": 23, "response": "module data_shifter(data_in, shift_ctrl, data_out);\n    input [15:0] data_in;\n    input [3:0] shift_ctrl;\n    output [15:0] data_out;\n\n    wire [15:0] shifted_data;\n\n    assign shifted_data = (shift_ctrl[3]) ? (data_in << shift_ctrl[2:0]) : (data_in >> shift_ctrl[2:0]);\n\n    assign data_out = (shift_ctrl[3]) ? (shifted_data | (16'hFFFF << (16 - shift_ctrl[2:0]))) : (shifted_data & (16'hFFFF >> (16 - shift_ctrl[2:0])));\n\nendmodule"}
{"task_id": 7, "response": "module custom_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output reg [15:0] result,\n    output zero\n);\n    always @(*) begin\n        case (op)\n            4'b0000: result = a + b;\n            4'b0001: result = a - b;\n            4'b0010: result = a & b;\n            4'b0011: result = a | b;\n            4'b0100: result = a ^ b;\n            4'b0101: result = a << b;\n            4'b0110: result = a >> b;\n            4'b0111: result = ~a;\n            default: result = 16'h0;\n        endcase\n    end\n\n    assign zero = (result == 16'h0);\nendmodule"}
{"task_id": 0, "response": "module magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n    wire [7:0] A_higher, A_lower;\n    wire [7:0] B_higher, B_lower;\n\n    // Instantiate the 8-bit magnitude comparator for the higher 8-bits\n    magnitude_comparator_8bit higher_cmp(.A(A[15:8]), .B(B[15:8]), .A_greater(A_higher[7]), .A_equal(A_higher[6]), .A_less(A_higher[5]));\n    // Instantiate the 8-bit magnitude comparator for the lower 8-bits\n    magnitude_comparator_8bit lower_cmp(.A(A[7:0]), .B(B[7:0]), .A_greater(A_lower[7]), .A_equal(A_lower[6]), .A_less(A_lower[5]));\n\n    always @(*) begin\n        if (A_higher == B_higher) begin\n            if (A_lower == B_lower) begin\n                A_greater = 0;\n                A_equal = 1;\n                A_less = 0;\n            end else if (A_lower > B_lower) begin\n                A_greater = 0;\n                A_equal = 0;\n                A_less = 1;\n            end else begin\n                A_greater = 1;\n                A_equal = 0;\n                A_less = 0;\n            end\n        end else if (A_higher > B_higher) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end\n    end\nendmodule\n\nmodule magnitude_comparator_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\nendmodule"}
{"task_id": 24, "response": "`timescale 1ns / 1ps\n\nmodule alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\n    wire [15:0] add_result, sub_result, and_result, or_result, xor_result;\n    wire add_carry, sub_carry, and_carry, or_carry, xor_carry;\n    wire add_zero, sub_zero, and_zero, or_zero, xor_zero;\n    wire add_negative, sub_negative, and_negative, or_negative, xor_negative;\n\n    // Addition module\n    add_module add_inst (\n        .a(a),\n        .b(b),\n        .result(add_result),\n        .carry(add_carry),\n        .zero(add_zero),\n        .negative(add_negative)\n    );\n\n    // Subtraction module\n    sub_module sub_inst (\n        .a(a),\n        .b(b),\n        .result(sub_result),\n        .carry(sub_carry),\n        .zero(sub_zero),\n        .negative(sub_negative)\n    );\n\n    // Bitwise AND module\n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .result(and_result),\n        .carry(and_carry),\n        .zero(and_zero),\n        .negative(and_negative)\n    );\n\n    // Bitwise OR module\n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .result(or_result),\n        .carry(or_carry),\n        .zero(or_zero),\n        .negative(or_negative)\n    );\n\n    // Bitwise XOR module\n    xor_module xor_inst (\n        .a(a),\n        .b(b),\n        .result(xor_result),\n        .carry(xor_carry),\n        .zero(xor_zero),\n        .negative(xor_negative)\n    );\n\n    // Branch condition check module\n    branch_module branch_inst (\n        .a(a),\n        .b(b),\n        .opcode(opcode),\n        .result(result),\n        .zero(zero),\n        .carry(carry),\n        .negative(negative)\n    );\n\n    always @(*) begin\n        case (opcode)\n            4'b0000: result = add_result;\n            4'b0001: result = sub_result;\n            4'b0010: result = and_result;\n            4'b0011: result = or_result;\n            4'b0100: result = xor_result;\n            4'b0101: result = b; // BEQ\n            4'b0110: result = a; // BLT\n            default: result = 16'b0;\n        endcase\n    end\n\nendmodule\n\nmodule add_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result,\n    output carry,\n    output zero,\n    output negative\n);\n    assign {carry, result} = a + b;\n    assign zero = (result == 16'b0);\n    assign negative = (result[15] == 1);\nendmodule\n\nmodule sub_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result,\n    output carry,\n    output zero,\n    output negative\n);\n    assign {carry, result} = a - b;\n    assign zero = (result == 16'b0);\n    assign negative = (result[15] == 1);\nendmodule\n\nmodule and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:"}
{"task_id": 14, "response": "module alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result, xor_result, not_result;\n\nadd_module add_module(\n    .a(input1),\n    .b(input2),\n    .sum(add_result)\n);\n\nsub_module sub_module(\n    .a(input1),\n    .b(input2),\n    .diff(sub_result)\n);\n\nand_module and_module(\n    .a(input1),\n    .b(input2),\n    .c(and_result)\n);\n\nor_module or_module(\n    .a(input1),\n    .b(input2),\n    .c(or_result)\n);\n\nxor_module xor_module(\n    .a(input1),\n    .b(input2),\n    .c(xor_result)\n);\n\nnot_module not_module(\n    .a(input1),\n    .b(not_result)\n);\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_result;\n        4'b0001: result = sub_result;\n        4'b0010: result = and_result;\n        4'b0011: result = or_result;\n        4'b0100: result = xor_result;\n        4'b0101: result = not_result;\n        default: result = 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule add_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule sub_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] c\n);\n    assign c = a & b;\nendmodule\n\nmodule or_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] c\n);\n    assign c = a | b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] c\n);\n    assign c = a ^ b;\nendmodule\n\nmodule not_module(\n    input [15:0] a,\n    output [15:0] b\n);\n    assign b = ~a;\nendmodule"}
{"task_id": 7, "response": "`timescale 1ns / 1ps\n\nmodule custom_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output reg [15:0] result,\n    output reg zero\n);\n\nalways @(*) begin\n    case (op)\n        4'b0000: result = a + b;\n        4'b0001: result = a - b;\n        4'b0010: result = a & b;\n        4'b0010: result = a | b;\n        4'b0011: result = a ^ b;\n        4'b0100: result = a << b;\n        4'b0101: result = a >> b;\n        4'b0110: result = ~a;\n        default: result = 16'h0;\n    endcase\n    zero = (result == 0);\nend\n\nendmodule"}
{"task_id": 7, "response": "module custom_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output reg [15:0] result,\n    output zero\n);\n    always @(*) begin\n        case (op)\n            4'b0000: result = a + b; // addition\n            4'b0001: result = a - b; // subtraction\n            4'b0010: result = a & b; // bitwise AND\n            4'b0011: result = a | b; // bitwise OR\n            4'b0100: result = a ^ b; // bitwise XOR\n            4'b0101: result = a << b; // left shift\n            4'b0110: result = a >> b; // right shift\n            4'b0111: result = ~a; // bitwise NOT\n            default: result = 16'b0; // default case\n        endcase\n    end\n\n    assign zero = (result == 16'b0);\nendmodule"}
{"task_id": 0, "response": "module magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n    wire [7:0] A_higher, A_lower, B_higher, B_lower;\n    assign A_higher = A[15:8];\n    assign A_lower = A[7:0];\n    assign B_higher = B[15:8];\n    assign B_lower = B[7:0];\n\n    magnitude_comparator_8bit higher_cmp(.A(A_higher), .B(B_higher), .A_greater(A_greater), .A_equal(A_equal), .A_less(A_less));\n    magnitude_comparator_8bit lower_cmp(.A(A_lower), .B(B_lower), .A_greater(A_greater), .A_equal(A_equal), .A_less(A_less));\n\n    always @(*) begin\n        if (A_greater || A_equal) begin\n            A_less = 0;\n        end else if (A_less) begin\n            A_greater = 0;\n        end\n    end\nendmodule\n\nmodule magnitude_comparator_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\nendmodule"}
{"task_id": 24, "response": "`timescale 1ns / 1ps\n\nmodule alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire and_result;\nwire or_result;\nwire xor_result;\n\nadd_sub_module add_module(.a(a), .b(b), .result(add_result), .carry(carry));\nadd_sub_module sub_module(.a(a), .b(b), .result(sub_result), .carry(carry));\nand_or_xor_module and_module(.a(a), .b(b), .result(and_result));\nand_or_xor_module or_module(.a(a), .b(b), .result(or_result));\nand_or_xor_module xor_module(.a(a), .b(b), .result(xor_result));\n\nassign result = (opcode == 4'b0000) ? add_result :\n              (opcode == 4'b0001) ? sub_result :\n              (opcode == 4'b0010) ? and_result :\n              (opcode == 4'b0011) ? or_result :\n              (opcode == 4'b0100) ? xor_result : 16'b0;\n\nassign zero = (result == 16'b0);\nassign negative = (result[15] == 1);\n\nendmodule\n\nmodule add_sub_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result,\n    output carry\n);\n\nassign {carry, result} = a + b;\n\nendmodule\n\nmodule and_or_xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nassign result = a & b;\n\nendmodule"}
{"task_id": 14, "response": "module alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result, xor_result, not_result;\n\nadd_module add_module (\n    .a(input1),\n    .b(input2),\n    .sum(add_result)\n);\n\nsub_module sub_module (\n    .a(input1),\n    .b(input2),\n    .diff(sub_result)\n);\n\nand_module and_module (\n    .a(input1),\n    .b(input2),\n    .out(and_result)\n);\n\nor_module or_module (\n    .a(input1),\n    .b(input2),\n    .out(or_result)\n);\n\nxor_module xor_module (\n    .a(input1),\n    .b(input2),\n    .out(xor_result)\n);\n\nnot_module not_module (\n    .a(input1),\n    .out(not_result)\n);\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_result;\n        4'b0001: result = sub_result;\n        4'b0010: result = and_result;\n        4'b0011: result = or_result;\n        4'b0100: result = xor_result;\n        4'b0101: result = not_result;\n        default: result = 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule add_module(input [15:0] a, input [15:0] b, output [15:0] sum);\n    assign sum = a + b;\nendmodule\n\nmodule sub_module(input [15:0] a, input [15:0] b, output [15:0] diff);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_module(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_module(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\nmodule not_module(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}
{"task_id": 8, "response": "module systolic2x2(\n    input clk,\n    input rst,\n    input [7:0] a00, a01, a10, a11,\n    input [7:0] b00, b01, b10, b11,\n    output [15:0] c00, c01, c10, c11\n);\n    wire [15:0] p00, p01, p10, p11;\n    PE pe00(.clk(clk), .rst(rst), .a(a00), .b(b00), .c(p00));\n    PE pe01(.clk(clk), .rst(rst), .a(a01), .b(b01), .c(p01));\n    PE pe10(.clk(clk), .rst(rst), .a(a10), .b(b10), .c(p10));\n    PE pe11(.clk(clk), .rst(rst), .a(a11), .b(b11), .c(p11));\n    assign c00 = p00 + p01;\n    assign c01 = p10 + p11;\n    assign c10 = p00 + p10;\n    assign c11 = p01 + p11;\nendmodule\n\nmodule PE(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] c\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            c <= 0;\n        else\n            c <= c + (a * b);\n    end\nendmodule"}
{"task_id": 8, "response": "module systolic2x2(\n    input clk,\n    input rst,\n    input [7:0] a00, a01, a10, a11,\n    input [7:0] b00, b01, b10, b11,\n    output [15:0] c00, c01, c10, c11\n);\n    wire [15:0] p00, p01, p10, p11;\n    PE pe00(.clk(clk), .rst(rst), .a(a00), .b(b00), .c(p00));\n    PE pe01(.clk(clk), .rst(rst), .a(a01), .b(b01), .c(p01));\n    PE pe10(.clk(clk), .rst(rst), .a(a10), .b(b10), .c(p10));\n    PE pe11(.clk(clk), .rst(rst), .a(a11), .b(b11), .c(p11));\n    assign c00 = p00 + p01;\n    assign c01 = p10 + p11;\n    assign c10 = p00 + p10;\n    assign c11 = p01 + p11;\nendmodule\n\nmodule PE(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] c\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            c <= 0;\n        else\n            c <= c + (a * b);\n    end\nendmodule"}
{"task_id": 0, "response": "module magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    wire [7:0] A_higher, A_lower, B_higher, B_lower;\n    wire A_higher_greater, A_higher_equal, A_higher_less;\n    wire A_lower_greater, A_lower_equal, A_lower_less;\n\n    // Instantiate the 8-bit magnitude comparator for higher significance\n    magnitude_comparator_8bit higher_cmp(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .A_greater(A_higher_greater),\n        .A_equal(A_higher_equal),\n        .A_less(A_higher_less)\n    );\n\n    // Instantiate the 8-bit magnitude comparator for lower significance\n    magnitude_comparator_8bit lower_cmp(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .A_greater(A_lower_greater),\n        .A_equal(A_lower_equal),\n        .A_less(A_lower_less)\n    );\n\n    // Combine the results from the 8-bit comparators\n    always @(*) begin\n        if (A_higher_greater) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A_higher_equal) begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end else begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end\n\n        if (A_lower_greater) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A_lower_equal) begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end else begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end\n    end\n\nendmodule\n\nmodule magnitude_comparator_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A == B) begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end else begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end\n    end\n\nendmodule"}
{"task_id": 24, "response": "`timescale 1ns / 1ps\n\nmodule alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\n    wire [15:0] add_result, sub_result, and_result, or_result, xor_result;\n    wire add_carry, sub_carry;\n\n    // Instantiate the addition module\n    add_sub_module add_module(.a(a), .b(b), .result(add_result), .carry(add_carry));\n\n    // Instantiate the subtraction module\n    add_sub_module sub_module(.a(a), .b(b), .result(sub_result), .carry(sub_carry));\n\n    // Instantiate the bitwise AND module\n    and_module and_module(.a(a), .b(b), .result(and_result));\n\n    // Instantiate the bitwise OR module\n    or_module or_module(.a(a), .b(b), .result(or_result));\n\n    // Instantiate the bitwise XOR module\n    xor_module xor_module(.a(a), .b(b), .result(xor_result));\n\n    // Multiplexer for selecting the operation\n    always @(*) begin\n        case(opcode)\n            4'b0000: result = add_result;\n            4'b0001: result = sub_result;\n            4'b0010: result = and_result;\n            4'b0011: result = or_result;\n            4'b0100: result = xor_result;\n            default: result = 16'b0;\n        endcase\n    end\n\n    // Flags\n    assign zero = (result == 16'b0);\n    assign carry = (opcode == 4'b0000) ? add_carry : (opcode == 4'b0001) ? sub_carry : 1'b0;\n    assign negative = (result[15] == 1);\n\nendmodule\n\nmodule add_sub_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result,\n    output carry\n);\n    assign {carry, result} = a + b;\nendmodule\n\nmodule and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": 14, "response": "module alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] and_result;\nwire [15:0] or_result;\nwire [15:0] xor_result;\nwire [15:0] not_result;\n\nadd_module add_module(\n    .a(input1),\n    .b(input2),\n    .sum(add_result)\n);\n\nsub_module sub_module(\n    .a(input1),\n    .b(input2),\n    .diff(sub_result)\n);\n\nand_module and_module(\n    .a(input1),\n    .b(input2),\n    .and_result(and_result)\n);\n\nor_module or_module(\n    .a(input1),\n    .b(input2),\n    .or_result(or_result)\n);\n\nxor_module xor_module(\n    .a(input1),\n    .b(input2),\n    .xor_result(xor_result)\n);\n\nnot_module not_module(\n    .a(input1),\n    .not_result(not_result)\n);\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_result;\n        4'b0001: result = sub_result;\n        4'b0010: result = and_result;\n        4'b0011: result = or_result;\n        4'b0100: result = xor_result;\n        4'b0101: result = not_result;\n        default: result = 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule add_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule sub_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule\n\nmodule not_module(\n    input [15:0] a,\n    output [15:0] not_result\n);\n    assign not_result = ~a;\nendmodule"}
{"task_id": 8, "response": "module systolic2x2(\n    input clk,\n    input rst,\n    input [7:0] a00, a01, a10, a11,\n    input [7:0] b00, b01, b10, b11,\n    output [15:0] c00, c01, c10, c11\n);\n    wire [15:0] p00, p01, p10, p11;\n    PE pe00(.clk(clk), .rst(rst), .a(a00), .b(b00), .p(p00));\n    PE pe01(.clk(clk), .rst(rst), .a(a01), .b(b01), .p(p01));\n    PE pe10(.clk(clk), .rst(rst), .a(a10), .b(b10), .p(p10));\n    PE pe11(.clk(clk), .rst(rst), .a(a11), .b(b11), .p(p11));\n    assign c00 = p00 + p01;\n    assign c01 = p10 + p11;\n    assign c10 = p00 + p10;\n    assign c11 = p01 + p11;\nendmodule\n\nmodule PE(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= p + (a * b);\n    end\nendmodule"}
{"task_id": 15, "response": "module comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [3:0] greater, equal, less;\n\n    comparator_4bit comp0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .greater(greater[0]),\n        .equal(equal[0]),\n        .less(less[0])\n    );\n\n    comparator_4bit comp1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .greater(greater[1]),\n        .equal(equal[1]),\n        .less(less[1])\n    );\n\n    comparator_4bit comp2 (\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .greater(greater[2]),\n        .equal(equal[2]),\n        .less(less[2])\n    );\n\n    comparator_4bit comp3 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .greater(greater[3]),\n        .equal(equal[3]),\n        .less(less[3])\n    );\n\n    assign A_greater = |greater;\n    assign A_equal = &equal;\n    assign A_less = &less;\n\nendmodule\n\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output greater,\n    output equal,\n    output less\n);\n\n    assign greater = (A > B);\n    assign equal = (A == B);\n    assign less = (A < B);\n\nendmodule"}
{"task_id": 25, "response": "module pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);\nwire [15:0] opA, opB, result;\n\nfetch_stage fetch(.clk(clk), .rst(rst), .opcode(opcode), .inputA(inputA), .inputB(inputB), .opA(opA), .opB(opB));\ndecode_stage decode(.clk(clk), .opA(opA), .opB(opB), .result(result));\nexecute_stage execute(.clk(clk), .opcode(opcode), .opA(opA), .opB(opB), .result(result));\nmemory_stage memory(.clk(clk), .result(result));\nwriteback_stage writeback(.clk(clk), .result(result), .outputResult(outputResult));\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output reg [15:0] opA,\n    output reg [15:0] opB\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            opA <= 0;\n            opB <= 0;\n        end else begin\n            opA <= inputA;\n            opB <= inputB;\n        end\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input [15:0] opA,\n    input [15:0] opB,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: result <= opA + opB;\n            2'b01: result <= opA - opB;\n            2'b10: result <= opA & opB;\n            2'b11: result <= opA | opB;\n            default: result <= 0;\n        endcase\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [1:0] opcode,\n    input [15:0] opA,\n    input [15:0] opB,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: result <= opA + opB;\n            2'b01: result <= opA - opB;\n            2'b10: result <= opA & opB;\n            2'b11: result <= opA | opB;\n            default: result <= 0;\n        endcase\n    end\nendmodule\n\nmodule memory_stage(\n    input clk,\n    input [15:0] result\n);\n    always @(posedge clk) begin\n        // Memory access logic\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [15:0] result,\n    output reg [15:0] outputResult\n);\n    always @(posedge clk) begin\n        outputResult <= result;\n    end\nendmodule"}
{"task_id": 9, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] corrected_count;\n\n    // Submodule for counter logic\n    counter_logic logic_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .up_down(up_down),\n        .count(count)\n    );\n\n    // Submodule for BCD correction\n    bcd_correction correction_unit (\n        .count(count),\n        .corrected_count(corrected_count)\n    );\n\n    // Output the corrected count\n    assign count = corrected_count;\n\nendmodule\n\n// Submodule for counter logic\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            if (up_down) begin\n                if (count == 4'b1001) begin\n                    count <= 4'b0000;\n                end else begin\n                    count <= count + 1;\n                end\n            end else begin\n                if (count == 4'b0000) begin\n                    count <= 4'b1001;\n                end else begin\n                    count <= count - 1;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for BCD correction\nmodule bcd_correction (\n    input wire [3:0] count,\n    output reg [3:0] corrected_count\n);\n\n    always @(*) begin\n        if (count >= 4'b1000) begin\n            corrected_count = count - 4'b1000;\n        end else if (count <= 4'b0000) begin\n            corrected_count = count + 4'b0001;\n        end else begin\n            corrected_count = count;\n        end\n    end\n\nendmodule"}
{"task_id": 1, "response": "module adder_16bit_csla(\n    input [15:0] a, b,\n    output [15:0] sum\n);\n    wire [3:0] carry;\n\n    // Instantiate 4-bit ripple carry adders\n    ripple_carry_adder adder0_0(.a(a[3:0]), .b(b[3:0]), .cin(1'b0), .sum(sum[3:0]), .carry(carry[0]));\n    ripple_carry_adder adder0_1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .carry(carry[1]));\n    ripple_carry_adder adder1_0(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .carry(carry[2]));\n    ripple_carry_adder adder1_1(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .carry(carry[3]));\n\n    // Instantiate 4-bit ripple carry adders for the second block\n    ripple_carry_adder adder2_0(.a(a[3:0]), .b(b[3:0]), .cin(1'b0), .sum(sum[3:0]), .carry(carry[0]));\n    ripple_carry_adder adder2_1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .carry(carry[1]));\n    ripple_carry_adder adder2_2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .carry(carry[2]));\n    ripple_carry_adder adder2_3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .carry(carry[3]));\n\n    // Instantiate 4-bit ripple carry adders for the third block\n    ripple_carry_adder adder3_0(.a(a[3:0]), .b(b[3:0]), .cin(1'b0), .sum(sum[3:0]), .carry(carry[0]));\n    ripple_carry_adder adder3_1(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .carry(carry[1]));\n    ripple_carry_adder adder3_2(.a(a[11:8]), .b(b[11:8]), .cin(carry[1]), .sum(sum[11:8]), .carry(carry[2]));\n    ripple_carry_adder adder3_3(.a(a[15:12]), .b(b[15:12]), .cin(carry[2]), .sum(sum[15:12]), .carry(carry[3]));\n\n    // Multiplexer for selecting the correct sum based on carry-in\n    wire [3:0] mux_out;\n    assign mux_out = (carry[3]) ? adder2_3.sum : adder2_2.sum;\n    assign sum = (carry[2]) ? adder2_1.sum : mux_out;\n    assign mux_out = (carry[1]) ? adder2_0.sum : mux_out;\n    assign sum = (carry[0]) ? adder1_1.sum : mux_out;\n    assign mux_out = (carry[3]) ? adder1_1."}
{"task_id": 15, "response": "module comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [3:0] greater, equal, less;\n\n    comparator_4bit comp0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .greater(greater[0]),\n        .equal(equal[0]),\n        .less(less[0])\n    );\n\n    comparator_4bit comp1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .greater(greater[1]),\n        .equal(equal[1]),\n        .less(less[1])\n    );\n\n    comparator_4bit comp2 (\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .greater(greater[2]),\n        .equal(equal[2]),\n        .less(less[2])\n    );\n\n    comparator_4bit comp3 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .greater(greater[3]),\n        .equal(equal[3]),\n        .less(less[3])\n    );\n\n    assign A_greater = greater[3] || (equal[3] && greater[2]) || (equal[3] && equal[2] && greater[1]) || (equal[3] && equal[2] && equal[1] && greater[0]);\n    assign A_equal = equal[3] && equal[2] && equal[1] && equal[0];\n    assign A_less = less[3] || (less[3] && equal[2]) || (less[3] && equal[2] && less[1]) || (less[3] && equal[2] && equal[1] && less[0]);\n\nendmodule\n\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output greater,\n    output equal,\n    output less\n);\n\n    assign greater = (A > B);\n    assign equal = (A == B);\n    assign less = (A < B);\n\nendmodule"}
{"task_id": 9, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] corrected_count;\n\n    // Submodule for counter logic\n    counter_logic logic_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .up_down(up_down),\n        .count(count)\n    );\n\n    // Submodule for BCD correction\n    bcd_correction correction_unit (\n        .count(count),\n        .corrected_count(corrected_count)\n    );\n\n    // Output the corrected count\n    assign count = corrected_count;\n\nendmodule\n\n// Submodule for counter logic\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            if (up_down) begin\n                if (count == 4'b1001) begin\n                    count <= 4'b0000;\n                end else begin\n                    count <= count + 1;\n                end\n            end else begin\n                if (count == 4'b0000) begin\n                    count <= 4'b1001;\n                end else begin\n                    count <= count - 1;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for BCD correction\nmodule bcd_correction (\n    input wire [3:0] count,\n    output reg [3:0] corrected_count\n);\n\n    always @(*) begin\n        corrected_count = count;\n        if (count > 4'b1001) begin\n            corrected_count = corrected_count + 4'b0006;\n        end else if (count < 4'b0000) begin\n            corrected_count = corrected_count - 4'b0006;\n        end\n    end\n\nendmodule"}
{"task_id": 15, "response": "module comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [3:0] greater_0, greater_1, greater_2, greater_3;\n    wire [3:0] equal_0, equal_1, equal_2, equal_3;\n    wire [3:0] less_0, less_1, less_2, less_3;\n\n    comparator_4bit comp0(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .A_greater(greater_0),\n        .A_equal(equal_0),\n        .A_less(less_0)\n    );\n\n    comparator_4bit comp1(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .A_greater(greater_1),\n        .A_equal(equal_1),\n        .A_less(less_1)\n    );\n\n    comparator_4bit comp2(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .A_greater(greater_2),\n        .A_equal(equal_2),\n        .A_less(less_2)\n    );\n\n    comparator_4bit comp3(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .A_greater(greater_3),\n        .A_equal(equal_3),\n        .A_less(less_3)\n    );\n\n    assign A_greater = (greater_3 | (equal_3 & greater_2) | (equal_2 & greater_1) | (equal_1 & greater_0));\n    assign A_equal = (equal_3 & equal_2 & equal_1 & equal_0);\n    assign A_less = (less_3 | (equal_3 & less_2) | (equal_2 & less_1) | (equal_1 & less_0));\n\nendmodule\n\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\n\nendmodule"}
{"task_id": 1, "response": "module adder_16bit_csla(\n    input [15:0] a, b,\n    output [15:0] sum\n);\n    wire [3:0] carry;\n\n    // Instantiate 4-bit ripple carry adders\n    adder_4bit_rca adder0_0(.a(a[3:0]), .b(b[3:0]), .cin(1'b0), .sum(sum[3:0]), .carry(carry[0]));\n    adder_4bit_rca adder0_1(.a(a[3:0]), .b(b[3:0]), .cin(1'b1), .sum(sum[3:0]), .carry(carry[1]));\n    adder_4bit_rca adder1_0(.a(a[7:4]), .b(b[7:4]), .cin(carry[0]), .sum(sum[7:4]), .carry(carry[2]));\n    adder_4bit_rca adder1_1(.a(a[7:4]), .b(b[7:4]), .cin(carry[1]), .sum(sum[7:4]), .carry(carry[3]));\n    adder_4bit_rca adder2_0(.a(a[11:8]), .b(b[11:8]), .cin(carry[2]), .sum(sum[11:8]), .carry(carry[4]));\n    adder_4bit_rca adder2_1(.a(a[11:8]), .b(b[11:8]), .cin(carry[3]), .sum(sum[11:8]), .carry(carry[5]));\n    adder_4bit_rca adder3_0(.a(a[15:12]), .b(b[15:12]), .cin(carry[4]), .sum(sum[15:12]), .carry(carry[6]));\n    adder_4bit_rca adder3_1(.a(a[15:12]), .b(b[15:12]), .cin(carry[5]), .sum(sum[15:12]), .carry(carry[7]));\n\n    // Select the correct carry out based on the carry-in\n    wire [3:0] carry_select;\n    assign carry_select[0] = carry[0];\n    assign carry_select[1] = carry[1] & ~carry[0];\n    assign carry_select[2] = carry[2];\n    assign carry_select[3] = carry[3] & ~carry[2];\n\n    // Select the correct sum based on the carry-in\n    assign sum[15:0] = (carry_select[0] ? sum[15:0] : sum[15:0] + a[15:0]) + (carry_select[1] ? sum[15:0] : sum[15:0] + b[15:0]);\n\nendmodule\n\nmodule adder_4bit_rca(\n    input [3:0] a, b,\n    input cin,\n    output [3:0] sum,\n    output carry\n);\n    wire [4:0] temp;\n    assign temp = a + b + cin;\n    assign sum = temp[3:0];\n    assign carry = temp[4];\nendmodule"}
{"task_id": 25, "response": "module pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);\nwire [15:0] fetched_inputA, fetched_inputB, fetched_opcode;\nwire [1:0] fetched_opcode_decoded;\nwire [15:0] executed_result;\nwire [15:0] memory_result;\n\nfetch_stage fetch (\n    .clk(clk),\n    .rst(rst),\n    .opcode(opcode),\n    .inputA(inputA),\n    .inputB(inputB),\n    .fetched_opcode(fetched_opcode),\n    .fetched_inputA(fetched_inputA),\n    .fetched_inputB(fetched_inputB)\n);\n\ndecode_stage decode (\n    .clk(clk),\n    .opcode(fetched_opcode),\n    .fetched_inputA(fetched_inputA),\n    .fetched_inputB(fetched_inputB),\n    .fetched_opcode_decoded(fetched_opcode_decoded)\n);\n\nexecute_stage execute (\n    .clk(clk),\n    .opcode(fetched_opcode_decoded),\n    .fetched_inputA(fetched_inputA),\n    .fetched_inputB(fetched_inputB),\n    .executed_result(executed_result)\n);\n\nmemory_stage memory (\n    .clk(clk),\n    .result(executed_result),\n    .memory_result(memory_result)\n);\n\nwriteback_stage writeback (\n    .clk(clk),\n    .memory_result(memory_result),\n    .outputResult(outputResult)\n);\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output reg [15:0] fetched_inputA,\n    output reg [15:0] fetched_inputB,\n    output reg [1:0] fetched_opcode\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            fetched_inputA <= 0;\n            fetched_inputB <= 0;\n            fetched_opcode <= 0;\n        end else begin\n            fetched_inputA <= inputA;\n            fetched_inputB <= inputB;\n            fetched_opcode <= opcode;\n        end\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input [1:0] opcode,\n    input [15:0] fetched_inputA,\n    input [15:0] fetched_inputB,\n    output reg [1:0] fetched_opcode_decoded\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: fetched_opcode_decoded <= 2'b00; // Add\n            2'b01: fetched_opcode_decoded <= 2'b01; // Subtract\n            2'b10: fetched_opcode_decoded <= 2'b10; // AND\n            2'b11: fetched_opcode_decoded <= 2'b11; // OR\n            default: fetched_opcode_decoded <= 2'b00; // Default to Add\n        endcase\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [1:0] opcode,\n    input [15:0] fetched_inputA,\n    input [15:0] fetched_inputB,\n    output reg [15:0] executed_result\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: executed_result <= fetched_inputA + fetched_inputB; // Add\n            2'b01: executed_result <= fetch"}
{"task_id": 9, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] corrected_count;\n\n    // Submodule for counter logic\n    counter_logic logic_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .up_down(up_down),\n        .count(count)\n    );\n\n    // Submodule for BCD correction\n    bcd_correction correction_unit (\n        .count(count),\n        .corrected_count(corrected_count)\n    );\n\n    assign count = corrected_count;\n\nendmodule\n\n// Submodule for counter logic\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (enable) begin\n            if (up_down) begin\n                if (count == 4'b1001) begin\n                    count <= 4'b0000;\n                end else begin\n                    count <= count + 1;\n                end\n            end else begin\n                if (count == 4'b0000) begin\n                    count <= 4'b1001;\n                end else begin\n                    count <= count - 1;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for BCD correction\nmodule bcd_correction (\n    input wire [3:0] count,\n    output reg [3:0] corrected_count\n);\n\n    always @(*) begin\n        if (count > 4'b0100) begin\n            corrected_count = count - 4'b0100;\n        end else if (count < 4'b0001) begin\n            corrected_count = count + 4'b0100;\n        end else begin\n            corrected_count = count;\n        end\n    end\n\nendmodule"}
{"task_id": 16, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .cin(cin),\n    .sum(sum[7:0]),\n    .cout(carry[0])\n);\ncarry_lookahead_adder_8bit cla2(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .cin(carry[0]),\n    .sum(sum[15:8]),\n    .cout(carry[1])\n);\ncarry_lookahead_adder_8bit cla3(\n    .a(a[23:16]),\n    .b(b[23:16]),\n    .cin(carry[1]),\n    .sum(sum[23:16]),\n    .cout(carry[2])\n);\ncarry_lookahead_adder_8bit cla4(\n    .a(a[31:24]),\n    .b(b[31:24]),\n    .cin(carry[2]),\n    .sum(sum[31:24]),\n    .cout(carry[3])\n);\n\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] g, p, c;\n\nassign g = a & b;\nassign p = a ^ b;\nassign c[0] = cin;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : g_loop\n        assign c[i+1] = g[i] | (p[i] & c[i]);\n    end\nendgenerate\n\nassign sum = p ^ c;\nassign cout = c[7];\n\nendmodule"}
{"task_id": 10, "response": "module carry_lookahead_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire cin,\n    output wire [31:0] sum,\n    output wire cout\n);\n    wire [3:0] carry;\n\n    // Instantiate the 8-bit carry-lookahead adder\n    carry_lookahead_8bit cla1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(cin),\n        .sum(sum[7:0]),\n        .cout(carry[0])\n    );\n\n    carry_lookahead_8bit cla2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(carry[0]),\n        .sum(sum[15:8]),\n        .cout(carry[1])\n    );\n\n    carry_lookahead_8bit cla3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .cin(carry[1]),\n        .sum(sum[23:16]),\n        .cout(carry[2])\n    );\n\n    carry_lookahead_8bit cla4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .cin(carry[2]),\n        .sum(sum[31:24]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule carry_lookahead_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire cin,\n    output wire [7:0] sum,\n    output wire cout\n);\n    wire [7:0] g, p, c;\n\n    // Generate the carry-in and carry-out\n    assign g = a & b;\n    assign p = a ^ b;\n    assign c[0] = cin;\n    assign c[1:7] = g | (p & c[0:6]);\n\n    // Sum the bits\n    assign sum = p ^ c[0:7];\n    assign cout = c[7];\nendmodule"}
{"task_id": 25, "response": "module pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);\nwire [15:0] opA, opB, result;\n\nfetch_stage fetch(.clk(clk), .rst(rst), .opcode(opcode), .inputA(inputA), .inputB(inputB), .result(opA), .opB(opB));\ndecode_stage decode(.clk(clk), .opA(opA), .opB(opB), .result(result));\nexecute_stage execute(.clk(clk), .opcode(opcode), .opA(opA), .opB(opB), .result(result));\nmemory_stage memory(.clk(clk), .result(result));\nwriteback_stage writeback(.clk(clk), .result(result), .outputResult(outputResult));\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output reg [15:0] result,\n    output reg [15:0] opB\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n            opB <= 0;\n        end else begin\n            result <= inputA;\n            opB <= inputB;\n        end\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input [15:0] opA,\n    input [15:0] opB,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: result <= opA + opB;\n            2'b01: result <= opA - opB;\n            2'b10: result <= opA & opB;\n            2'b11: result <= opA | opB;\n            default: result <= 0;\n        endcase\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [1:0] opcode,\n    input [15:0] opA,\n    input [15:0] opB,\n    output reg [15:0] result\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: result <= opA + opB;\n            2'b01: result <= opA - opB;\n            2'b10: result <= opA & opB;\n            2'b11: result <= opA | opB;\n            default: result <= 0;\n        endcase\n    end\nendmodule\n\nmodule memory_stage(\n    input clk,\n    input [15:0] result\n);\n    always @(posedge clk) begin\n        // Do nothing\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [15:0] result,\n    output reg [15:0] outputResult\n);\n    always @(posedge clk) begin\n        outputResult <= result;\n    end\nendmodule"}
{"task_id": 16, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [7:0] c1, c2, c3, c4;\n\ncarry_lookahead_adder_8bit cla1(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .cin(cin),\n    .sum(sum[7:0]),\n    .cout(c1)\n);\n\ncarry_lookahead_adder_8bit cla2(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .cin(c1),\n    .sum(sum[15:8]),\n    .cout(c2)\n);\n\ncarry_lookahead_adder_8bit cla3(\n    .a(a[23:16]),\n    .b(b[23:16]),\n    .cin(c2),\n    .sum(sum[23:16]),\n    .cout(c3)\n);\n\ncarry_lookahead_adder_8bit cla4(\n    .a(a[31:24]),\n    .b(b[31:24]),\n    .cin(c3),\n    .sum(sum[31:24]),\n    .cout(c4)\n);\n\nassign cout = c4;\n\nendmodule\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] g, p, c;\n\nassign g = a & b;\nassign p = a ^ b;\nassign c = cin & (a | b);\n\nassign sum = p ^ g;\nassign cout = c | (p & g);\n\nendmodule"}
{"task_id": 1, "response": "module adder_16bit_csla(\n    input [15:0] a, b,\n    output [15:0] sum\n);\n    wire [3:0] carry;\n\n    // Instantiate 4-bit ripple carry adders\n    ripple_carry_adder adder0_0(.a(a[3:0]), .b(b[3:0]), .ci(1'b0), .sum(sum[3:0]), .co(carry[0]));\n    ripple_carry_adder adder0_1(.a(a[3:0]), .b(b[3:0]), .ci(1'b1), .sum(sum[3:0]), .co(carry[1]));\n    ripple_carry_adder adder1_0(.a(a[7:4]), .b(b[7:4]), .ci(1'b0), .sum(sum[7:4]), .co(carry[2]));\n    ripple_carry_adder adder1_1(.a(a[7:4]), .b(b[7:4]), .ci(1'b1), .sum(sum[7:4]), .co(carry[3]));\n    ripple_carry_adder adder2_0(.a(a[11:8]), .b(b[11:8]), .ci(1'b0), .sum(sum[11:8]), .co(carry[4]));\n    ripple_carry_adder adder2_1(.a(a[11:8]), .b(b[11:8]), .ci(1'b1), .sum(sum[11:8]), .co(carry[5]));\n    ripple_carry_adder adder3_0(.a(a[15:12]), .b(b[15:12]), .ci(1'b0), .sum(sum[15:12]), .co(carry[6]));\n    ripple_carry_adder adder3_1(.a(a[15:12]), .b(b[15:12]), .ci(1'b1), .sum(sum[15:12]), .co(carry[7]));\n\n    // Select the correct carry out based on the carry-in\n    wire [3:0] carry_sel;\n    assign carry_sel[0] = ~carry[0] & ~carry[1];\n    assign carry_sel[1] = ~carry[0] & carry[1];\n    assign carry_sel[2] = carry[0] & ~carry[1];\n    assign carry_sel[3] = carry[0] & carry[1];\n\n    // Select the correct sum based on the carry-in\n    assign sum[15:12] = (carry_sel[0] & a[15:12]) | (carry_sel[1] & b[15:12]) | (carry_sel[2] & {15{1'b0}});\n    assign sum[11:8] = (carry_sel[0] & a[11:8]) | (carry_sel[1] & b[11:8]) | (carry_sel[2] & {14{1'b0}});\n    assign sum[7:4] = (carry_sel[0] & a[7:4]) | (carry_sel[1] & b[7:4]) | (carry_sel[2] & {10{1'b0}});\n    assign sum[3:0] = (carry_sel[0] & a[3:0]) | (carry_sel[1] & b[3:0]) | (carry_sel[2] & {12{1'b0}});\n\nendmodule\n\nmodule ripple_carry_adder(\n    input [3:0] a, b,\n    input ci,\n    output [3:0] sum,\n    output co\n);\n    wire [4:0] c;\n    assign {co, c[0]} = a[3] + b[3] + ci;"}
{"task_id": 10, "response": "module carry_lookahead_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire cin,\n    output wire [31:0] sum,\n    output wire cout\n);\n    wire [3:0] carry;\n\n    carry_lookahead_8bit cla1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(cin),\n        .sum(sum[7:0]),\n        .cout(carry[0])\n    );\n\n    carry_lookahead_8bit cla2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(carry[0]),\n        .sum(sum[15:8]),\n        .cout(carry[1])\n    );\n\n    carry_lookahead_8bit cla3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .cin(carry[1]),\n        .sum(sum[23:16]),\n        .cout(carry[2])\n    );\n\n    carry_lookahead_8bit cla4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .cin(carry[2]),\n        .sum(sum[31:24]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule carry_lookahead_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire cin,\n    output wire [7:0] sum,\n    output wire cout\n);\n    wire [7:0] g, p, c;\n\n    assign g = a & b;\n    assign p = a ^ b;\n    assign c[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : gen_cla\n            assign c[i+1] = g[i] | (p[i] & c[i]);\n            assign sum[i] = p[i] ^ c[i];\n        end\n    endgenerate\n\n    assign cout = c[7];\n\nendmodule"}
{"task_id": 26, "response": "module signed_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [31:0] A_ext, B_ext;\n    wire A_greater_int, A_equal_int, A_less_int;\n\n    extend_sign_16bit extend_A(\n        .input(A),\n        .output(A_ext)\n    );\n\n    extend_sign_16bit extend_B(\n        .input(B),\n        .output(B_ext)\n    );\n\n    comparator_32bit compare_inst(\n        .A(A_ext),\n        .B(B_ext),\n        .A_greater(A_greater_int),\n        .A_equal(A_equal_int),\n        .A_less(A_less_int)\n    );\n\n    assign A_greater = A_greater_int;\n    assign A_equal = A_equal_int;\n    assign A_less = A_less_int;\n\nendmodule\n\nmodule extend_sign_16bit(\n    input [15:0] input,\n    output reg [31:0] output\n);\n    always @(*) begin\n        output = {input[15], input};\n    end\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\nendmodule"}
{"task_id": 16, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n    .a(a[7:0]),\n    .b(b[7:0]),\n    .cin(cin),\n    .sum(sum[7:0]),\n    .cout(carry[0])\n);\ncarry_lookahead_adder_8bit cla2(\n    .a(a[15:8]),\n    .b(b[15:8]),\n    .cin(carry[0]),\n    .sum(sum[15:8]),\n    .cout(carry[1])\n);\ncarry_lookahead_adder_8bit cla3(\n    .a(a[23:16]),\n    .b(b[23:16]),\n    .cin(carry[1]),\n    .sum(sum[23:16]),\n    .cout(carry[2])\n);\ncarry_lookahead_adder_8bit cla4(\n    .a(a[31:24]),\n    .b(b[31:24]),\n    .cin(carry[2]),\n    .sum(sum[31:24]),\n    .cout(carry[3])\n);\n\nassign cout = carry[3];\n\nendmodule\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] g, p, c;\n\nassign g = a & b;\nassign p = a ^ b;\nassign c[0] = cin;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin : g_loop\n        assign c[i+1] = g[i] | (p[i] & c[i]);\n    end\nendgenerate\n\nassign sum = p ^ c;\nassign cout = c[7];\n\nendmodule"}
{"task_id": 10, "response": "module carry_lookahead_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire cin,\n    output wire [31:0] sum,\n    output wire cout\n);\n    wire [3:0] carry;\n\n    carry_lookahead_8bit cla1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(cin),\n        .sum(sum[7:0]),\n        .cout(carry[0])\n    );\n\n    carry_lookahead_8bit cla2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(carry[0]),\n        .sum(sum[15:8]),\n        .cout(carry[1])\n    );\n\n    carry_lookahead_8bit cla3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .cin(carry[1]),\n        .sum(sum[23:16]),\n        .cout(carry[2])\n    );\n\n    carry_lookahead_8bit cla4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .cin(carry[2]),\n        .sum(sum[31:24]),\n        .cout(carry[3])\n    );\n\n    assign cout = carry[3];\n\nendmodule\n\nmodule carry_lookahead_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire cin,\n    output wire [7:0] sum,\n    output wire cout\n);\n    wire [7:0] g, p, c;\n\n    assign g = a & b;\n    assign p = a ^ b;\n    assign c[0] = cin;\n\n    genvar i;\n    generate\n        for (i = 0; i < 7; i = i + 1) begin : gen_cla\n            assign c[i+1] = g[i] | (p[i] & c[i]);\n        end\n    endgenerate\n\n    assign sum = p ^ c;\n    assign cout = g[7] | (p[7] & c[7]);\n\nendmodule"}
{"task_id": 26, "response": "module signed_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [31:0] A_ext, B_ext;\n    wire A_greater_int, A_equal_int, A_less_int;\n\n    extend_sign_16bit extend_A(\n        .input(A),\n        .output(A_ext)\n    );\n\n    extend_sign_16bit extend_B(\n        .input(B),\n        .output(B_ext)\n    );\n\n    comparator_32bit compare_inst(\n        .A(A_ext),\n        .B(B_ext),\n        .A_greater(A_greater_int),\n        .A_equal(A_equal_int),\n        .A_less(A_less_int)\n    );\n\n    assign A_greater = A_greater_int;\n    assign A_equal = A_equal_int;\n    assign A_less = A_less_int;\n\nendmodule\n\nmodule extend_sign_16bit(\n    input [15:0] input,\n    output reg [31:0] output\n);\n    always @(*) begin\n        output = {1'b0, input};\n    end\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1'b1;\n            A_equal = 1'b0;\n            A_less = 1'b0;\n        end else if (A == B) begin\n            A_greater = 1'b0;\n            A_equal = 1'b1;\n            A_less = 1'b0;\n        end else begin\n            A_greater = 1'b0;\n            A_equal = 1'b0;\n            A_less = 1'b1;\n        end\n    end\nendmodule"}
{"task_id": 2, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_60,\n    output CLK_30,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_60_out;\n    wire clk_30_out;\n    wire clk_15_out;\n    wire clk_3_out;\n\n    div_by_2 u_div_by_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_60_out)\n    );\n\n    div_by_4 u_div_by_4 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_30_out)\n    );\n\n    div_by_8 u_div_by_8 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    div_by_40 u_div_by_40 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_60 = clk_60_out;\n    assign CLK_30 = clk_30_out;\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule div_by_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule div_by_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 1) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule div_by_8 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 3) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule div_by_40 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 19) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 17, "response": "module dual_phase_square_wave(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    output wave1_out,\n    output wave2_out\n);\n\n    wire wave_out1, wave_out2;\n\n    // Instantiate the basic wave generators\n    basic_wave_gen wave_gen1 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave_out1)\n    );\n\n    basic_wave_gen wave_gen2 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave_out2)\n    );\n\n    // Instantiate the phase controller\n    phase_ctrl p_ctrl (\n        .clk(clk),\n        .reset(reset),\n        .phase_shift(phase_shift),\n        .wave_in(wave_out2),\n        .wave_out(wave2_out)\n    );\n\n    // Connect the outputs\n    assign wave1_out = wave_out1;\n\nendmodule\n\nmodule basic_wave_gen(\n    input clk,\n    input reset,\n    output reg wave_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            wave_out <= 0;\n        else\n            wave_out <= ~wave_out;\n    end\n\nendmodule\n\nmodule phase_ctrl(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    input wave_in,\n    output reg wave_out\n);\n\n    reg [3:0] delay_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            delay_count <= 0;\n            wave_out <= 0;\n        end else begin\n            if (delay_count == phase_shift) begin\n                wave_out <= wave_in;\n                delay_count <= 0;\n            end else begin\n                delay_count <= delay_count + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 11, "response": "module hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);\n    wire [15:0] carry;\n\n    // Instantiate the carry look-ahead adder for the higher bits\n    carry_lookahead_adder cla_adder (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(carry[15]),\n        .y(y[31:16]),\n        .Co(carry[15])\n    );\n\n    // Instantiate the two 8-bit ripple carry adders for the lower bits\n    ripple_carry_adder rc_adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry[14]),\n        .y(y[15:8]),\n        .Co(carry[14])\n    );\n\n    ripple_carry_adder rc_adder2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(carry[7]),\n        .y(y[7:0]),\n        .Co(carry[7])\n    );\n\n    assign Co = carry[15];\n\nendmodule\n\nmodule carry_lookahead_adder (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [16:0] sum;\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule ripple_carry_adder (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n    assign {Co, y} = a + b + Cin;\nendmodule"}
{"task_id": 26, "response": "module signed_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [31:0] A_extended, B_extended;\n    wire A_greater_int, A_equal_int, A_less_int;\n\n    extend_sign_16bit extend_A(\n        .input_A(A),\n        .output_A(A_extended)\n    );\n\n    extend_sign_16bit extend_B(\n        .input_A(B),\n        .output_A(B_extended)\n    );\n\n    comparator_32bit compare_inst(\n        .A(A_extended),\n        .B(B_extended),\n        .A_greater(A_greater_int),\n        .A_equal(A_equal_int),\n        .A_less(A_less_int)\n    );\n\n    assign A_greater = A_greater_int;\n    assign A_equal = A_equal_int;\n    assign A_less = A_less_int;\n\nendmodule\n\nmodule extend_sign_16bit(\n    input [15:0] input_A,\n    output reg [31:0] output_A\n);\n\n    always @(*) begin\n        if (input_A[15] == 1) begin\n            output_A = {1'b1, input_A[15:0]};\n        end else begin\n            output_A = {1'b0, input_A[15:0]};\n        end\n    end\n\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\n\nendmodule"}
{"task_id": 17, "response": "module dual_phase_square_wave(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    output wave1_out,\n    output wave2_out\n);\n\n    wire wave_out1, wave_out2;\n\n    // Instantiate the basic wave generators\n    basic_wave_gen wave_gen1 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave_out1)\n    );\n\n    basic_wave_gen wave_gen2 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave_out2)\n    );\n\n    // Instantiate the phase controller\n    phase_ctrl p_ctrl (\n        .clk(clk),\n        .reset(reset),\n        .phase_shift(phase_shift),\n        .wave_in(wave_out2),\n        .wave_out(wave2_out)\n    );\n\n    // Connect the outputs\n    assign wave1_out = wave_out1;\n\nendmodule\n\nmodule basic_wave_gen(\n    input clk,\n    input reset,\n    output reg wave_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            wave_out <= 0;\n        else\n            wave_out <= ~wave_out;\n    end\n\nendmodule\n\nmodule phase_ctrl(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    input wave_in,\n    output reg wave_out\n);\n\n    reg [3:0] delay_count;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            delay_count <= 0;\n            wave_out <= 0;\n        end else begin\n            if (delay_count == phase_shift) begin\n                wave_out <= wave_in;\n                delay_count <= 0;\n            end else begin\n                delay_count <= delay_count + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 11, "response": "module hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);\n    wire [15:0] c1, c2;\n\n    // Instantiate the carry look-ahead adder for the higher bits\n    carry_lookahead_adder cla_adder (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .cin(Cin),\n        .y(y[31:16]),\n        .co(c1)\n    );\n\n    // Instantiate the two 8-bit ripple carry adders for the lower bits\n    ripple_carry_adder rc_adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(c1),\n        .y(y[15:8]),\n        .co(c2)\n    );\n\n    ripple_carry_adder rc_adder1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(c2),\n        .y(y[7:0]),\n        .co(Co)\n    );\nendmodule\n\nmodule carry_lookahead_adder (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [16:0] sum;\n\n    assign sum = a + b + Cin;\n    assign y = sum[15:0];\n    assign Co = sum[16];\nendmodule\n\nmodule ripple_carry_adder (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire cin,\n    output wire [7:0] y,\n    output wire co\n);\n    wire [8:0] sum;\n\n    assign sum = a + b + cin;\n    assign y = sum[7:0];\n    assign co = sum[8];\nendmodule"}
{"task_id": 27, "response": "module tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [31:0] mul_result;\n\n// Instantiating the adder, subtractor and multiplier modules\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mul_result)\n);\n\n// Mode decoder\nalways @(posedge clk) begin\n    case(mode)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= mul_result[15:0];\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] result\n);\n    assign result = a * b;\nendmodule"}
{"task_id": 2, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_60,\n    output CLK_30,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_60_int;\n    wire clk_30_int;\n    wire clk_15_int;\n    wire clk_3_int;\n\n    div_by_2 u_div_by_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_60_int)\n    );\n\n    div_by_4 u_div_by_4 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_30_int)\n    );\n\n    div_by_8 u_div_by_8 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_int)\n    );\n\n    div_by_40 u_div_by_40 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_int)\n    );\n\n    assign CLK_60 = clk_60_int;\n    assign CLK_30 = clk_30_int;\n    assign CLK_15 = clk_15_int;\n    assign CLK_3 = clk_3_int;\n\nendmodule\n\nmodule div_by_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule div_by_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] counter;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 1) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule div_by_8 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] counter;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 3) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule div_by_40 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] counter;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (counter == 19) begin\n                CLK_out <= ~CLK_out;\n                counter <= 0;\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": 17, "response": "module dual_phase_square_wave(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    output wave1_out,\n    output wave2_out\n);\n\n    wire wave_out1, wave_out2;\n\n    // Instantiate the basic wave generators\n    basic_wave_gen wave_gen1 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave_out1)\n    );\n\n    basic_wave_gen wave_gen2 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave_out2)\n    );\n\n    // Instantiate the phase controller\n    phase_ctrl p_ctrl (\n        .clk(clk),\n        .reset(reset),\n        .phase_shift(phase_shift),\n        .wave_in(wave_out2),\n        .wave_out(wave2_out)\n    );\n\n    // Connect the outputs\n    assign wave1_out = wave_out1;\n\nendmodule\n\nmodule basic_wave_gen(\n    input clk,\n    input reset,\n    output reg wave_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            wave_out <= 0;\n        else\n            wave_out <= ~wave_out;\n    end\n\nendmodule\n\nmodule phase_ctrl(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    input wave_in,\n    output reg wave_out\n);\n\n    reg [3:0] delay_counter;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            delay_counter <= 0;\n            wave_out <= 0;\n        end else begin\n            if (delay_counter == phase_shift) begin\n                wave_out <= wave_in;\n                delay_counter <= 0;\n            end else begin\n                delay_counter <= delay_counter + 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 27, "response": "module tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result, sub_result, mul_result;\n\n// Instantiating the adder submodule\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\n// Instantiating the subtractor submodule\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n);\n\n// Instantiating the multiplier submodule\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .product(mul_result)\n);\n\n// Mode decoder\nalways @(posedge clk) begin\n    case(mode)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= mul_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n    assign product = a * b;\nendmodule"}
{"task_id": 11, "response": "module hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);\n    wire [15:0] carry_out;\n\n    // Instantiate the carry look-ahead adder for the higher 16 bits\n    carry_lookahead_adder cla_adder (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(Cin),\n        .y(y[31:16]),\n        .Co(carry_out[0])\n    );\n\n    // Instantiate the two 8-bit ripple carry adders for the lower 8 bits\n    ripple_carry_adder rc_adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry_out[0]),\n        .y(y[15:8]),\n        .Co(carry_out[1])\n    );\n\n    ripple_carry_adder rc_adder2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(carry_out[1]),\n        .y(y[7:0]),\n        .Co(Co)\n    );\nendmodule\n\nmodule carry_lookahead_adder (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire [16:0] sum;\n    wire [16:0] carry;\n\n    assign sum = a + b + Cin;\n    assign y = sum[15:0];\n    assign Co = sum[16];\nendmodule\n\nmodule ripple_carry_adder (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [8:0] sum;\n    wire [8:0] carry;\n\n    assign sum = {Cin, a} + b;\n    assign y = sum[7:0];\n    assign Co = sum[8];\nendmodule"}
{"task_id": 18, "response": "module simple_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op_code,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] and_result;\nwire [15:0] or_result;\n\nadd_mod add_mod(\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsub_mod sub_mod(\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nand_mod and_mod(\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor_mod or_mod(\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\nalways @(*) begin\n    case(op_code)\n        2'b00: result = add_result;\n        2'b01: result = sub_result;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule add_mod(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule sub_mod(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and_mod(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_mod(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 27, "response": "module tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result, sub_result, mul_result;\n\n// Instantiating the adder, subtractor and multiplier modules\nadder u_adder(\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor(\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nmultiplier u_multiplier(\n    .a(a),\n    .b(b),\n    .result(mul_result)\n);\n\n// Mode decoder\nalways @(posedge clk) begin\n    case(mode)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= mul_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule multiplier(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule"}
{"task_id": 12, "response": "module systolic1x4 (\n    input clk,\n    input rst,\n    input [7:0] a[3:0],\n    input [7:0] b[3:0],\n    output [7:0] sum[3:0]\n);\n    wire [7:0] pe_sum0, pe_sum1, pe_sum2, pe_sum3;\n\n    // Instantiate the Processing Elements\n    PE pe0 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[0]),\n        .b(b[0]),\n        .sum(pe_sum0)\n    );\n    PE pe1 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[1]),\n        .b(b[1]),\n        .sum(pe_sum1)\n    );\n    PE pe2 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[2]),\n        .b(b[2]),\n        .sum(pe_sum2)\n    );\n    PE pe3 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[3]),\n        .b(b[3]),\n        .sum(pe_sum3)\n    );\n\n    // Connect outputs\n    assign sum[0] = pe_sum0;\n    assign sum[1] = pe_sum1;\n    assign sum[2] = pe_sum2;\n    assign sum[3] = pe_sum3;\n\nendmodule\n\nmodule PE (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            sum <= 8'b0;\n        else\n            sum <= a + b;\n    end\nendmodule"}
{"task_id": 2, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_60,\n    output CLK_30,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_60_out;\n    wire clk_30_out;\n    wire clk_15_out;\n    wire clk_3_out;\n\n    div_by_2 u_div_by_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_60_out)\n    );\n\n    div_by_4 u_div_by_4 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_30_out)\n    );\n\n    div_by_8 u_div_by_8 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    div_by_40 u_div_by_40 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_60 = clk_60_out;\n    assign CLK_30 = clk_30_out;\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule div_by_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule div_by_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 2) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule div_by_8 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 3) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule div_by_40 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else begin\n            if (count == 19) begin\n                count <= 0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": 28, "response": "module branch_control (\n    input clk,\n    input rst_n,\n    input [1:0] branch_type,\n    input [2:0] condition_flags,\n    output reg take_branch\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            take_branch <= 0;\n        end else begin\n            case (branch_type)\n                2'b00: take_branch <= condition_flags[0] & condition_flags[1] & condition_flags[2];\n                2'b01: take_branch <= condition_flags[0] & ~condition_flags[1] & condition_flags[2];\n                2'b10: take_branch <= ~condition_flags[0] & condition_flags[1] & condition_flags[2];\n                2'b11: take_branch <= ~condition_flags[0] & ~condition_flags[1] & condition_flags[2];\n                default: take_branch <= 0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 18, "response": "module simple_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op_code,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result;\n\naddition_module add_mod(\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtraction_module sub_mod(\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nbitwise_and_module and_mod(\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nbitwise_or_module or_mod(\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\nalways @(*) begin\n    case(op_code)\n        2'b00: result = add_result;\n        2'b01: result = sub_result;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule addition_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtraction_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 28, "response": "module branch_control (\n    input clk,\n    input rst_n,\n    input [1:0] branch_type,\n    input [2:0] condition_flags,\n    output reg take_branch\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            take_branch <= 0;\n        end else begin\n            case (branch_type)\n                2'b00: take_branch <= 0; // BEQ\n                2'b01: take_branch <= condition_flags[0] == 0; // BNE\n                2'b10: take_branch <= condition_flags[2] == 0; // BLT\n                2'b11: take_branch <= condition_flags[2] == 1; // BGE\n                default: take_branch <= 0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 12, "response": "module systolic1x4 (\n    input clk,\n    input rst,\n    input [7:0] a[3:0],\n    input [7:0] b[3:0],\n    output [7:0] sum[3:0]\n);\n    wire [7:0] pe_sum[3:0];\n\n    // Instantiate the four PEs\n    processing_element pe0 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[0]),\n        .b(b[0]),\n        .sum(pe_sum[0])\n    );\n    processing_element pe1 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[1]),\n        .b(b[1]),\n        .sum(pe_sum[1])\n    );\n    processing_element pe2 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[2]),\n        .b(b[2]),\n        .sum(pe_sum[2])\n    );\n    processing_element pe3 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[3]),\n        .b(b[3]),\n        .sum(pe_sum[3])\n    );\n\n    // Connect outputs\n    assign sum[0] = pe_sum[0];\n    assign sum[1] = pe_sum[1];\n    assign sum[2] = pe_sum[2];\n    assign sum[3] = pe_sum[3];\n\nendmodule\n\nmodule processing_element (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            sum <= 0;\n        else\n            sum <= a + b;\n    end\nendmodule"}
{"task_id": 28, "response": "module branch_control (\n    input clk,\n    input rst_n,\n    input [1:0] branch_type,\n    input [2:0] condition_flags,\n    output reg take_branch\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            take_branch <= 0;\n        end else begin\n            case (branch_type)\n                2'b00: take_branch <= condition_flags[0] && condition_flags[1] && condition_flags[2];\n                2'b01: take_branch <= condition_flags[0] && !condition_flags[1] && condition_flags[2];\n                2'b10: take_branch <= !condition_flags[0] && condition_flags[1] && condition_flags[2];\n                2'b11: take_branch <= !condition_flags[0] && !condition_flags[1] && !condition_flags[2];\n                default: take_branch <= 0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 18, "response": "module simple_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op_code,\n    output reg [15:0] result\n);\n\nwire [15:0] add_out, sub_out, and_out, or_out;\n\nadd_sub_module add_mod (\n    .a(a),\n    .b(b),\n    .result(add_out)\n);\n\nadd_sub_module sub_mod (\n    .a(a),\n    .b(b),\n    .result(sub_out)\n);\n\nbitwise_and_module and_mod (\n    .a(a),\n    .b(b),\n    .result(and_out)\n);\n\nbitwise_or_module or_mod (\n    .a(a),\n    .b(b),\n    .result(or_out)\n);\n\nalways @(*) begin\n    case(op_code)\n        2'b00: result = add_out;\n        2'b01: result = sub_out;\n        2'b10: result = and_out;\n        2'b11: result = or_out;\n        default: result = 16'hxxxx;\n    endcase\nend\n\nendmodule\n\nmodule add_sub_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule bitwise_and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 12, "response": "module systolic1x4 (\n    input clk,\n    input rst,\n    input [7:0] a[3:0],\n    input [7:0] b[3:0],\n    output [7:0] sum[3:0]\n);\n    wire [7:0] pe_sum0, pe_sum1, pe_sum2, pe_sum3;\n\n    // Instantiate the Processing Elements\n    PE pe0 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[0]),\n        .b(b[0]),\n        .sum(pe_sum0)\n    );\n    PE pe1 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[1]),\n        .b(b[1]),\n        .sum(pe_sum1)\n    );\n    PE pe2 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[2]),\n        .b(b[2]),\n        .sum(pe_sum2)\n    );\n    PE pe3 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[3]),\n        .b(b[3]),\n        .sum(pe_sum3)\n    );\n\n    // Connect outputs\n    assign sum[0] = pe_sum0;\n    assign sum[1] = pe_sum1;\n    assign sum[2] = pe_sum2;\n    assign sum[3] = pe_sum3;\n\nendmodule\n\nmodule PE (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            sum <= 8'b0;\n        else\n            sum <= a + b;\n    end\nendmodule"}
{"task_id": 3, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);\n\n    wire clk_33_out;\n    wire clk_20_out;\n    wire clk_5_out;\n    wire clk_2_out;\n\n    clk_div_3 div_33 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_33_out)\n    );\n\n    clk_div_5 div_20 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_20_out)\n    );\n\n    clk_div_5 div_5 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_2 div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_2_out)\n    );\n\n    assign CLK_33 = clk_33_out;\n    assign CLK_20 = clk_20_out;\n    assign CLK_5 = clk_5_out;\n    assign CLK_2 = clk_2_out;\n\nendmodule\n\nmodule clk_div_3 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 2) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_5 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 4) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 9) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 9) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 13, "response": "module dual_mode_subtractor(A, B, mode, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    input mode;\n    output [31:0] Result;\n    output Overflow;\n\n    wire [31:0] sub_result_unsigned;\n    wire [31:0] sub_result_twoscomp;\n\n    // Unsigned subtractor\n    subtractor_32bit us (\n        .A(A),\n        .B(B),\n        .Result(sub_result_unsigned)\n    );\n\n    // Two's complement subtractor\n    subtractor_32bit_twoscomp tcs (\n        .A(A),\n        .B(B),\n        .Result(sub_result_twoscomp)\n    );\n\n    // Multiplexer to select output based on mode\n    assign Result = (mode) ? sub_result_twoscomp : sub_result_unsigned;\n    assign Overflow = (mode) ? 1'b0 : 1'b0; // Placeholder for two's complement overflow\n\nendmodule\n\nmodule subtractor_32bit(A, B, Result);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Result;\n    assign Result = A - B;\nendmodule\n\nmodule subtractor_32bit_twoscomp(A, B, Result);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Result;\n    assign Result = ~(~A + B) + 1;\nendmodule"}
{"task_id": 19, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);\nwire [15:0] op_a, op_b;\nwire [15:0] op_result;\nwire [1:0] op_code;\n\nstage1 s1(.clk(clk), .rst(rst), .data_a(data_a), .data_b(data_b), .opcode(opcode), .op_a(op_a), .op_b(op_b), .op_code(op_code));\nstage2 s2(.clk(clk), .op_a(op_a), .op_b(op_b), .op_code(op_code), .op_result(op_result));\nstage3 s3(.clk(clk), .op_result(op_result), .result(result));\n\nendmodule\n\nmodule stage1(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output reg [15:0] op_a,\n    output reg [15:0] op_b,\n    output reg [1:0] op_code\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op_a <= 0;\n            op_b <= 0;\n            op_code <= 0;\n        end else begin\n            op_a <= data_a;\n            op_b <= data_b;\n            op_code <= opcode;\n        end\n    end\nendmodule\n\nmodule stage2(\n    input clk,\n    input [15:0] op_a,\n    input [15:0] op_b,\n    input [1:0] op_code,\n    output reg [15:0] op_result\n);\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: op_result <= op_a + op_b;\n            2'b01: op_result <= op_a - op_b;\n            2'b10: op_result <= op_a * op_b;\n            default: op_result <= 0;\n        endcase\n    end\nendmodule\n\nmodule stage3(\n    input clk,\n    input [15:0] op_result,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        result <= {op_result, 16'b0};\n    end\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns/1ps\n\nmodule weighted_accu (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   data_in,\n    input               enable,\n    output              ready,\n    output      [9:0]   data_out\n);\n\n    wire [9:0] weighted_data;\n    wire [3:0] accumulated_data;\n    wire [3:0] accumulated_data_out;\n    wire [3:0] accumulated_count;\n    wire [3:0] accumulated_count_out;\n    wire [3:0] enable_out;\n\n    input_weighting u_input_weighting (\n        .data_in(data_in),\n        .weighted_data(weighted_data)\n    );\n\n    accumulation_control u_accumulation_control (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(enable),\n        .enable_out(enable_out),\n        .accumulated_data(accumulated_data)\n    );\n\n    output_module u_output_module (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(enable_out),\n        .accumulated_data(accumulated_data),\n        .accumulated_data_out(accumulated_data_out),\n        .ready(ready),\n        .data_out(data_out)\n    );\n\nendmodule\n\nmodule input_weighting (\n    input       [3:0]   data_in,\n    output reg [9:0]   weighted_data\n);\n\n    always @(*) begin\n        weighted_data = data_in * 2;\n    end\n\nendmodule\n\nmodule accumulation_control (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    output reg [3:0]   enable_out,\n    input       [3:0]   accumulated_data,\n    output reg [3:0]   accumulated_data_out\n);\n\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            enable_out <= 0;\n            accumulated_data_out <= 0;\n        end else if (enable) begin\n            if (count < 3) begin\n                count <= count + 1;\n                enable_out <= 1;\n                accumulated_data_out <= accumulated_data;\n            end else begin\n                enable_out <= 0;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_module (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    input       [3:0]   accumulated_data,\n    output reg [3:0]   accumulated_data_out,\n    output reg          ready,\n    output reg  [9:0]  data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            ready <= 0;\n            data_out <= 0;\n            accumulated_data_out <= 0;\n        end else if (enable) begin\n            ready <= 1;\n            data_out <= accumulated_data_out;\n        end\n    end\n\nendmodule"}
{"task_id": 13, "response": "module dual_mode_subtractor(A, B, mode, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    input mode;\n    output [31:0] Result;\n    output Overflow;\n\n    wire [31:0] sub_result_unsigned;\n    wire [31:0] sub_result_twoscomp;\n    wire overflow_unsigned;\n    wire overflow_twoscomp;\n\n    subtractor_unsigned us (\n        .A(A),\n        .B(B),\n        .Result(sub_result_unsigned),\n        .Overflow(overflow_unsigned)\n    );\n\n    subtractor_twoscomp tcs (\n        .A(A),\n        .B(B),\n        .Result(sub_result_twoscomp),\n        .Overflow(overflow_twoscomp)\n    );\n\n    assign Result = (mode) ? sub_result_twoscomp : sub_result_unsigned;\n    assign Overflow = (mode) ? overflow_twoscomp : overflow_unsigned;\n\nendmodule\n\nmodule subtractor_unsigned (A, B, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Result;\n    output Overflow;\n    assign {Overflow, Result} = A - B;\nendmodule\n\nmodule subtractor_twoscomp (A, B, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Result;\n    output Overflow;\n    wire [31:0] twoscomp_B;\n    assign twoscomp_B = ~B + 1;\n    assign {Overflow, Result} = A - twoscomp_B;\nendmodule"}
{"task_id": 3, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);\n\n    wire clk_33_out;\n    wire clk_20_out;\n    wire clk_5_out;\n    wire clk_2_out;\n\n    clk_div_3 div_33 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_33_out)\n    );\n\n    clk_div_5 div_20 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_20_out)\n    );\n\n    clk_div_5 div_5 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_2 div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_2_out)\n    );\n\n    assign CLK_33 = clk_33_out;\n    assign CLK_20 = clk_20_out;\n    assign CLK_5 = clk_5_out;\n    assign CLK_2 = clk_2_out;\n\nendmodule\n\nmodule clk_div_3 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 2) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_5 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 4) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 9) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 9) begin\n            count <= 0;\n            CLK_out <= ~CLK_out;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 19, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);\nwire [15:0] op_a, op_b;\nwire [31:0] op_result;\n\nstage1 s1(.clk(clk), .rst(rst), .data_a(data_a), .data_b(data_b), .opcode(opcode), .op_a(op_a), .op_b(op_b));\nstage2 s2(.clk(clk), .op_a(op_a), .op_b(op_b), .opcode(opcode), .op_result(op_result));\nstage3 s3(.clk(clk), .op_result(op_result), .result(result));\n\nendmodule\n\nmodule stage1(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output reg [15:0] op_a,\n    output reg [15:0] op_b\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            op_a <= 0;\n            op_b <= 0;\n        end else begin\n            op_a <= data_a;\n            op_b <= data_b;\n        end\n    end\nendmodule\n\nmodule stage2(\n    input clk,\n    input [15:0] op_a,\n    input [15:0] op_b,\n    input [1:0] opcode,\n    output reg [31:0] op_result\n);\n    always @(posedge clk) begin\n        case (opcode)\n            2'b00: op_result <= op_a + op_b;\n            2'b01: op_result <= op_a - op_b;\n            2'b10: op_result <= op_a * op_b;\n            default: op_result <= 0;\n        endcase\n    end\nendmodule\n\nmodule stage3(\n    input clk,\n    input [31:0] op_result,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        result <= op_result;\n    end\nendmodule"}
{"task_id": 13, "response": "module dual_mode_subtractor(A, B, mode, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    input mode;\n    output [31:0] Result;\n    output Overflow;\n\n    wire [31:0] sub_result_unsigned;\n    wire [31:0] sub_result_twoscomp;\n    wire overflow_unsigned;\n    wire overflow_twoscomp;\n\n    subtractor_unsigned us (\n        .A(A),\n        .B(B),\n        .Result(sub_result_unsigned),\n        .Overflow(overflow_unsigned)\n    );\n\n    subtractor_twoscomp tcs (\n        .A(A),\n        .B(B),\n        .Result(sub_result_twoscomp),\n        .Overflow(overflow_twoscomp)\n    );\n\n    assign Result = mode ? sub_result_twoscomp : sub_result_unsigned;\n    assign Overflow = mode ? overflow_twoscomp : overflow_unsigned;\n\nendmodule\n\nmodule subtractor_unsigned(A, B, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Result;\n    output Overflow;\n    assign {Overflow, Result} = A - B;\nendmodule\n\nmodule subtractor_twoscomp(A, B, Result, Overflow);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Result;\n    output Overflow;\n    assign {Overflow, Result} = A - B;\nendmodule"}
{"task_id": 29, "response": "module weighted_accu (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   data_in,\n    input               enable,\n    output              ready,\n    output      [9:0]   data_out\n);\n\n    wire [9:0] weighted_data;\n    wire [3:0] accumulated_data;\n    wire [3:0] accumulated_data_out;\n    wire [3:0] accumulated_data_out;\n    wire [3:0] enable_reg;\n    wire [3:0] enable_next;\n    wire [3:0] enable_next_next;\n    wire [3:0] enable_next_next_next;\n    wire [3:0] enable_next_next_next_next;\n    wire [3:0] enable_next_next_next_next_next;\n    wire [3:0] enable_next_next_next_next_next_next;\n\n    // Instantiate the input weighting module\n    input_weighting u_input_weighting (\n        .data_in(data_in),\n        .weighted_data(weighted_data)\n    );\n\n    // Instantiate the accumulation control module\n    accumulation_control u_accumulation_control (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(enable),\n        .enable_next(enable_reg),\n        .enable_next_next(enable_next),\n        .enable_next_next_next(enable_next_next),\n        .enable_next_next_next_next(enable_next_next_next),\n        .enable_next_next_next_next_next(enable_next_next_next_next),\n        .enable_next_next_next_next_next_next(enable_next_next_next_next_next)\n    );\n\n    // Instantiate the output module\n    output_module u_output_module (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(enable),\n        .enable_next(enable_next),\n        .enable_next_next(enable_next_next),\n        .enable_next_next_next(enable_next_next_next),\n        .enable_next_next_next_next(enable_next_next_next_next),\n        .enable_next_next_next_next_next(enable_next_next_next_next_next),\n        .enable_next_next_next_next_next_next(enable_next_next_next_next_next_next),\n        .weighted_data(weighted_data),\n        .accumulated_data(accumulated_data),\n        .accumulated_data_out(accumulated_data_out),\n        .data_out(data_out),\n        .ready(ready)\n    );\n\nendmodule\n\nmodule input_weighting (\n    input       [3:0]   data_in,\n    output reg  [9:0]   weighted_data\n);\n\n    always @(*) begin\n        weighted_data = data_in * 2;\n    end\n\nendmodule\n\nmodule accumulation_control (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    output reg          [3:0]   enable_next,\n    output reg          [3:0]   enable_next_next,\n    output reg          [3:0]   enable_next_next_next,\n    output reg          [3:0]   enable_next_next_next_next,\n    output reg          [3:0]   enable_next_next_next_next_next,\n    output reg          [3:0]   enable_next_next_next_next_next_next\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            enable_next <= 4'b0;\n            enable_next_next <= 4'b0;\n            enable_next_next_next <= 4'b0;\n            enable_next_next_next_next <= 4'b0;\n            enable_next_next_next_next_"}
{"task_id": 19, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);\n\nwire [15:0] a, b;\nwire [31:0] c;\nwire [1:0] op;\n\nstage1 s1(.clk(clk), .rst(rst), .data_a(data_a), .data_b(data_b), .opcode(opcode), .a(a), .b(b), .op(op));\nstage2 s2(.clk(clk), .rst(rst), .a(a), .b(b), .op(op), .c(c));\nstage3 s3(.clk(clk), .rst(rst), .c(c), .result(result));\n\nendmodule\n\nmodule stage1(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output reg [15:0] a,\n    output reg [15:0] b,\n    output reg [1:0] op\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            a <= 0;\n            b <= 0;\n            op <= 0;\n        end else begin\n            a <= data_a;\n            b <= data_b;\n            op <= opcode;\n        end\n    end\nendmodule\n\nmodule stage2(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op,\n    output reg [31:0] c\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            c <= 0;\n        end else begin\n            case (op)\n                2'b00: c <= a + b;\n                2'b01: c <= a - b;\n                2'b10: c <= a * b;\n                default: c <= 0;\n            endcase\n        end\n    end\nendmodule\n\nmodule stage3(\n    input clk,\n    input rst,\n    input [31:0] c,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= c;\n        end\n    end\nendmodule"}
{"task_id": 3, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);\n\n    wire clk_33_out;\n    wire clk_20_out;\n    wire clk_5_out;\n    wire clk_2_out;\n\n    clk_div_3 div_33 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_33_out)\n    );\n\n    clk_div_5 div_20 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_20_out)\n    );\n\n    clk_div_5 div_5 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_2 div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_2_out)\n    );\n\n    assign CLK_33 = clk_33_out;\n    assign CLK_20 = clk_20_out;\n    assign CLK_5 = clk_5_out;\n    assign CLK_2 = clk_2_out;\n\nendmodule\n\nmodule clk_div_3 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 3) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_5 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 5) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 20) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 0;\n            CLK_out <= 0;\n        end else if (count == 50) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 20, "response": "module csr_reg (\n    input clk,\n    input rst,\n    input write_en,\n    input read_en,\n    input [31:0] data_in,\n    output [31:0] data_out,\n    output interrupt_en\n);\n\n    // Register to hold the configuration settings\n    reg [31:0] csr_reg;\n\n    // Assign the default value to the register on reset\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            csr_reg <= 32'h000000000;\n        end else begin\n            if (write_en) begin\n                csr_reg <= data_in;\n            end\n        end\n    end\n\n    // Assign data_out based on read_en\n    always @(*) begin\n        if (read_en) begin\n            data_out <= csr_reg;\n        end\n    end\n\n    // Assign interrupt_en based on the interrupt enable bit\n    assign interrupt_en = csr_reg[0];\n\nendmodule"}
{"task_id": 4, "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire ctrl,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n\n    // Instantiate the up counter submodule\n    up_counter inc (\n        .clk(clk),\n        .reset(reset),\n        .count(current_count)\n    );\n\n    // Instantiate the down counter submodule\n    down_counter dec (\n        .clk(clk),\n        .reset(reset),\n        .count(current_count)\n    );\n\n    // Assign the output based on the control signal\n    assign count = ctrl ? current_count : ~current_count + 1;\n\nendmodule\n\nmodule up_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule down_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count - 1;\n    end\n\nendmodule"}
{"task_id": 20, "response": "module csr_reg (\n    input clk,\n    input rst,\n    input write_en,\n    input read_en,\n    input [31:0] data_in,\n    output [31:0] data_out,\n    output interrupt_en\n);\n\n    // Register to hold the configuration settings\n    reg [31:0] reg_data;\n\n    // Submodule to manage read and write operations\n    csr_reg_submodule csr_submodule (\n        .clk(clk),\n        .rst(rst),\n        .write_en(write_en),\n        .read_en(read_en),\n        .data_in(data_in),\n        .data_out(reg_data)\n    );\n\n    // Assign output ports\n    assign data_out = reg_data;\n    assign interrupt_en = reg_data[0];\n\nendmodule\n\nmodule csr_reg_submodule (\n    input clk,\n    input rst,\n    input write_en,\n    input read_en,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 32'h0;\n        end else if (write_en) begin\n            data_out <= data_in;\n        end else if (read_en) begin\n            data_out <= data_out; // No change\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns/1ps\n\nmodule weighted_accu (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   data_in,\n    input               enable,\n    output              ready,\n    output      [9:0]   data_out\n);\n\n    wire [9:0] weighted_sum;\n    wire [3:0] enable_reg;\n    wire [3:0] ready_reg;\n\n    // Instantiate the input weighting module\n    input_weighting u_input_weighting (\n        .data_in(data_in),\n        .weighted_sum(weighted_sum)\n    );\n\n    // Instantiate the accumulation control module\n    accumulation_control u_accumulation_control (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(enable),\n        .enable_reg(enable_reg),\n        .ready_reg(ready_reg)\n    );\n\n    // Instantiate the output module\n    output_module u_output_module (\n        .weighted_sum(weighted_sum),\n        .ready_reg(ready_reg),\n        .data_out(data_out),\n        .ready(ready)\n    );\n\nendmodule\n\nmodule input_weighting (\n    input       [3:0]   data_in,\n    output reg  [9:0]   weighted_sum\n);\n\n    always @(*) begin\n        weighted_sum = data_in[0] + (data_in[1] << 1) + (data_in[2] << 2) + (data_in[3] << 3);\n    end\n\nendmodule\n\nmodule accumulation_control (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    output reg  [3:0]   enable_reg,\n    output reg  [3:0]   ready_reg\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            enable_reg <= 0;\n            ready_reg <= 0;\n        end else begin\n            if (enable) begin\n                enable_reg <= 1;\n            end else if (enable_reg > 0) begin\n                enable_reg <= enable_reg + 1;\n            end\n            if (enable_reg == 4) begin\n                ready_reg <= 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_module (\n    input       [9:0]   weighted_sum,\n    input       [3:0]   ready_reg,\n    output reg  [9:0]   data_out,\n    output reg          ready\n);\n\n    always @(*) begin\n        if (ready_reg > 0) begin\n            data_out <= weighted_sum;\n            ready <= 1;\n        end else begin\n            ready <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": 20, "response": "module csr_reg (\n    input clk,\n    input rst,\n    input write_en,\n    input read_en,\n    input [31:0] data_in,\n    output [31:0] data_out,\n    output interrupt_en\n);\n\n    // Register to hold the configuration settings\n    reg [31:0] csr_reg;\n\n    // Assigning the default value on reset\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            csr_reg <= 32'h000000000;\n        end else begin\n            if (write_en) begin\n                csr_reg <= data_in;\n            end\n        end\n    end\n\n    // Assigning the output data\n    assign data_out = csr_reg;\n\n    // Assigning the interrupt enable signal\n    assign interrupt_en = csr_reg[0];\n\nendmodule"}
{"task_id": 4, "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire ctrl,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n\n    // Instantiate the up counter submodule\n    up_counter inc (\n        .clk(clk),\n        .reset(reset),\n        .count(current_count)\n    );\n\n    // Instantiate the down counter submodule\n    down_counter dec (\n        .clk(clk),\n        .reset(reset),\n        .count(current_count)\n    );\n\n    // Connect the output to the current count\n    assign count = current_count;\n\nendmodule\n\n// Submodule for counting up\nmodule up_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (ctrl)\n            count <= count + 1;\n    end\n\nendmodule\n\n// Submodule for counting down\nmodule down_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (!ctrl)\n            count <= count - 1;\n    end\n\nendmodule"}
{"task_id": 4, "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire ctrl,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n\n    // Instantiate the up counter submodule\n    up_counter inc (\n        .clk(clk),\n        .reset(reset),\n        .count(current_count)\n    );\n\n    // Instantiate the down counter submodule\n    down_counter dec (\n        .clk(clk),\n        .reset(reset),\n        .count(current_count)\n    );\n\n    // Connect the output to the counter based on the control signal\n    assign count = ctrl ? current_count : ~current_count + 1;\n\nendmodule\n\nmodule up_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count + 1;\n    end\n\nendmodule\n\nmodule down_counter (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else\n            count <= count - 1;\n    end\n\nendmodule"}
{"task_id": 5, "response": "module arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\nwire [15:0] stage1_out;\nwire [15:0] stage2_out;\nwire [15:0] stage3_out;\nwire [15:0] stage4_out;\nwire [15:0] stage5_out;\n\ninput_stage stage1(\n    .clk(clk),\n    .rst(rst),\n    .data_in(data_in),\n    .data_out(stage1_out)\n);\nadd_stage stage2(\n    .clk(clk),\n    .rst(rst),\n    .data_in(stage1_out),\n    .data_out(stage2_out)\n);\nmultiply_stage stage3(\n    .clk(clk),\n    .rst(rst),\n    .data_in(stage2_out),\n    .data_out(stage3_out)\n);\nsubtract_stage stage4(\n    .clk(clk),\n    .rst(rst),\n    .data_in(stage3_out),\n    .data_out(stage4_out)\n);\noutput_stage stage5(\n    .clk(clk),\n    .rst(rst),\n    .data_in(stage4_out),\n    .data_out(stage5_out)\n);\nassign data_out = stage5_out;\n\nendmodule\n\nmodule input_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in + 16'd10;\n    end\nendmodule\n\nmodule multiply_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in * 16'd10;\n    end\nendmodule\n\nmodule subtract_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in - 16'd10;\n    end\nendmodule\n\nmodule output_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule"}
{"task_id": 5, "response": "module arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\nwire [15:0] stage1_out;\nwire [15:0] stage2_out;\nwire [15:0] stage3_out;\nwire [15:0] stage4_out;\nwire [15:0] stage5_out;\n\ninput_stage stage1(\n    .clk(clk),\n    .rst(rst),\n    .data_in(data_in),\n    .data_out(stage1_out)\n);\nadd_stage stage2(\n    .clk(clk),\n    .data_in(stage1_out),\n    .data_out(stage2_out)\n);\nmultiply_stage stage3(\n    .clk(clk),\n    .data_in(stage2_out),\n    .data_out(stage3_out)\n);\nsubtract_stage stage4(\n    .clk(clk),\n    .data_in(stage3_out),\n    .data_out(stage4_out)\n);\noutput_stage stage5(\n    .clk(clk),\n    .data_in(stage4_out),\n    .data_out(stage5_out)\n);\nassign data_out = stage5_out;\n\nendmodule\n\nmodule input_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule add_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in + 16'h1000;\n    end\nendmodule\n\nmodule multiply_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in * 16'h1000;\n    end\nendmodule\n\nmodule subtract_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in - 16'h1000;\n    end\nendmodule\n\nmodule output_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\nendmodule"}
{"task_id": 5, "response": "module arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\nwire [15:0] stage1_out;\nwire [15:0] stage2_out;\nwire [15:0] stage3_out;\nwire [15:0] stage4_out;\nwire [15:0] stage5_out;\n\ninput_stage stage1(\n    .clk(clk),\n    .rst(rst),\n    .data_in(data_in),\n    .data_out(stage1_out)\n);\n\nadd_stage stage2(\n    .clk(clk),\n    .data_in(stage1_out),\n    .data_out(stage2_out)\n);\n\nmultiply_stage stage3(\n    .clk(clk),\n    .data_in(stage2_out),\n    .data_out(stage3_out)\n);\n\nsubtract_stage stage4(\n    .clk(clk),\n    .data_in(stage3_out),\n    .data_out(stage4_out)\n);\n\noutput_stage stage5(\n    .clk(clk),\n    .data_in(stage4_out),\n    .data_out(stage5_out)\n);\n\nassign data_out = stage5_out;\n\nendmodule\n\nmodule input_stage(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule add_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in + 16'd100;\n    end\nendmodule\n\nmodule multiply_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in * 16'd10;\n    end\nendmodule\n\nmodule subtract_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in - 16'd1000;\n    end\nendmodule\n\nmodule output_stage(\n    input clk,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\nendmodule"}
{"task_id": 6, "response": "module byte_circular_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);\n    wire [31:0] bs1_out, bs2_out;\n\n    // Instantiating the three byte shifter submodules\n    byte_shifter bs1 (\n        .data_in(data_in),\n        .shift(shift[0]),\n        .data_out(bs1_out)\n    );\n\n    byte_shifter bs2 (\n        .data_in(data_in),\n        .shift(shift[1]),\n        .data_out(bs2_out)\n    );\n\n    // Multiplexer to select output based on shift value\n    always @(*) begin\n        case(shift)\n            2'b00: data_out = bs1_out;\n            2'b01: data_out = {bs2_out[7:0], bs1_out[31:8]};\n            2'b10: data_out = {bs1_out[15:0], bs2_out[31:16]};\n            2'b11: data_out = {bs2_out[23:0], bs1_out[31:24]};\n            default: data_out = data_in; // Default case\n        endcase\n    end\n\nendmodule\n\nmodule byte_shifter (\n    input [31:0] data_in,\n    input shift,\n    output reg [31:0] data_out\n);\n    always @(*) begin\n        case(shift)\n            1'b0: data_out = data_in;\n            1'b1: data_out = {data_in[30:0], data_in[31]};\n            default: data_out = data_in; // Default case\n        endcase\n    end\nendmodule"}
{"task_id": 6, "response": "module byte_circular_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);\n    wire [31:0] bs1_out, bs2_out;\n\n    // Instantiate the three byte shifter submodules\n    byte_shifter bs1 (\n        .data_in(data_in),\n        .shift(shift[0]),\n        .data_out(bs1_out)\n    );\n\n    byte_shifter bs2 (\n        .data_in(data_in),\n        .shift(shift[1]),\n        .data_out(bs2_out)\n    );\n\n    // Multiplexer to select the output based on the shift value\n    always @(*) begin\n        case(shift)\n            2'b00: data_out = bs1_out;\n            2'b01: data_out = {bs1_out[23:0], bs1_out[31:24], bs2_out[7:0], bs2_out[31:8]};\n            2'b10: data_out = {bs1_out[15:0], bs1_out[31:16], bs2_out[3:0], bs2_out[31:4]};\n            2'b11: data_out = {bs1_out[7:0], bs1_out[31:8], bs2_out[1:0], bs2_out[31:2]};\n            default: data_out = data_in; // Default case\n        endcase\n    end\nendmodule\n\nmodule byte_shifter (\n    input [7:0] data_in,\n    input shift,\n    output reg [7:0] data_out\n);\n    always @(*) begin\n        if (shift)\n            data_out = {data_in[6:0], data_in[7]};\n        else\n            data_out = data_in;\n    end\nendmodule"}
{"task_id": 6, "response": "module byte_circular_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);\n    wire [31:0] bs1_out, bs2_out;\n\n    // Instantiate the three byte shifter submodules\n    byte_shifter bs1 (\n        .data_in(data_in),\n        .shift(shift[0]),\n        .data_out(bs1_out)\n    );\n\n    byte_shifter bs2 (\n        .data_in(data_in),\n        .shift(shift[1]),\n        .data_out(bs2_out)\n    );\n\n    // Multiplexer to select the output based on the shift value\n    always @(*) begin\n        case(shift)\n            2'b00: data_out = bs1_out;\n            2'b01: data_out = bs2_out;\n            2'b10: data_out = {bs2_out[23:0], bs1_out[31:24]};\n            2'b11: data_out = {bs1_out[23:0], bs2_out[31:24]};\n            default: data_out = data_in;\n        endcase\n    end\n\nendmodule\n\nmodule byte_shifter (\n    input [31:0] data_in,\n    input shift,\n    output reg [31:0] data_out\n);\n    always @(*) begin\n        if (shift)\n            data_out = {data_in[23:0], data_in[31:24]};\n        else\n            data_out = data_in;\n    end\nendmodule"}
