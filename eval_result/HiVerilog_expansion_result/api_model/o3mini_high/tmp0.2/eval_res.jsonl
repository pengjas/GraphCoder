{"task_id": "pe_v_0", "response": "module u_adder (\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] sum\n);\n    assign sum = op1 + op2;\nendmodule\n\nmodule u_subtractor (\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] diff\n);\n    assign diff = op1 - op2;\nendmodule\n\nmodule as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_res;\n    wire [31:0] sub_res;\n    \n    u_adder u_adder_inst (\n        .op1(op1),\n        .op2(op2),\n        .sum(add_res)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .op1(op1),\n        .op2(op2),\n        .diff(sub_res)\n    );\n    \n    always @(posedge clk) begin\n        if (rst)\n            result <= 32'b0;\n        else\n            result <= mode ? sub_res : add_res;\n    end\n\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            quotient <= 32'b0;\n        else if (divisor != 0)\n            quotient <= dividend / divisor;\n        else\n            quotient <= 32'b0;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] difference\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            difference <= 32'b0;\n        else\n            difference <= a - b;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_q;\n    wire [31:0] diff_result;\n\n    u_divider divider_inst(\n        .clk(clk),\n        .rst(rst),\n        .dividend(x),\n        .divisor(y),\n        .quotient(div_q)\n    );\n\n    u_subtractor subtractor_inst(\n        .clk(clk),\n        .rst(rst),\n        .a(div_q),\n        .b(z),\n        .difference(diff_result)\n    );\n\n    assign quotient = div_q;\n    assign difference = diff_result;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\nwire [31:0] add_out;\nwire [31:0] sub_out;\nwire [31:0] and_out;\nwire [31:0] or_out;\n\nadder u_adder(\n    .a(a),\n    .b(b),\n    .sum(add_out)\n);\n\nsubtractor u_subtractor(\n    .a(a),\n    .b(b),\n    .diff(sub_out)\n);\n\nand_unit u_and(\n    .a(a),\n    .b(b),\n    .out(and_out)\n);\n\nor_unit u_or(\n    .a(a),\n    .b(b),\n    .out(or_out)\n);\n\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= add_out;\n        2'b01: result <= sub_out;\n        2'b10: result <= and_out;\n        2'b11: result <= or_out;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_unit(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\nassign out = a & b;\nendmodule\n\nmodule or_unit(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\nassign out = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] and_result;\n    \n    u_adder u1 (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    u_bitwise_and u2 (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n    \n    always @(posedge clk) begin\n        if (op_sel)\n            result <= and_result;\n        else\n            result <= add_result;\n    end\nendmodule"}
{"task_id": "pe_v_4", "response": "module u_adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n\n    u_adder u_adder_inst(\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n\n    u_subtractor u_subtractor_inst(\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n\n    always @(posedge clk) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire borrow1, borrow2, borrow3, borrow4, borrow5, borrow6, borrow7;\n\n    full_subtractor FS0 (\n        .a(a[0]), \n        .b(b[0]), \n        .bin(bin), \n        .diff(diff[0]), \n        .bout(borrow1)\n    );\n    full_subtractor FS1 (\n        .a(a[1]), \n        .b(b[1]), \n        .bin(borrow1), \n        .diff(diff[1]), \n        .bout(borrow2)\n    );\n    full_subtractor FS2 (\n        .a(a[2]), \n        .b(b[2]), \n        .bin(borrow2), \n        .diff(diff[2]), \n        .bout(borrow3)\n    );\n    full_subtractor FS3 (\n        .a(a[3]), \n        .b(b[3]), \n        .bin(borrow3), \n        .diff(diff[3]), \n        .bout(borrow4)\n    );\n    full_subtractor FS4 (\n        .a(a[4]), \n        .b(b[4]), \n        .bin(borrow4), \n        .diff(diff[4]), \n        .bout(borrow5)\n    );\n    full_subtractor FS5 (\n        .a(a[5]), \n        .b(b[5]), \n        .bin(borrow5), \n        .diff(diff[5]), \n        .bout(borrow6)\n    );\n    full_subtractor FS6 (\n        .a(a[6]), \n        .b(b[6]), \n        .bin(borrow6), \n        .diff(diff[6]), \n        .bout(borrow7)\n    );\n    full_subtractor FS7 (\n        .a(a[7]), \n        .b(b[7]), \n        .bin(borrow7), \n        .diff(diff[7]), \n        .bout(bout)\n    );\n\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~a | b) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a, \n    input [7:0] b, \n    input bin, \n    output [7:0] diff, \n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6;\n    \n    subtractor_1bit S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b0));\n    subtractor_1bit S1 (.a(a[1]), .b(b[1]), .bin(b0),  .diff(diff[1]), .bout(b1));\n    subtractor_1bit S2 (.a(a[2]), .b(b[2]), .bin(b1),  .diff(diff[2]), .bout(b2));\n    subtractor_1bit S3 (.a(a[3]), .b(b[3]), .bin(b2),  .diff(diff[3]), .bout(b3));\n    subtractor_1bit S4 (.a(a[4]), .b(b[4]), .bin(b3),  .diff(diff[4]), .bout(b4));\n    subtractor_1bit S5 (.a(a[5]), .b(b[5]), .bin(b4),  .diff(diff[5]), .bout(b5));\n    subtractor_1bit S6 (.a(a[6]), .b(b[6]), .bin(b5),  .diff(diff[6]), .bout(b6));\n    subtractor_1bit S7 (.a(a[7]), .b(b[7]), .bin(b6),  .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = ((~a) & b) | ((~(a ^ b)) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6;\n    \n    full_subtractor fs0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(b0)\n    );\n    \n    full_subtractor fs1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(b0),\n        .diff(diff[1]),\n        .bout(b1)\n    );\n    \n    full_subtractor fs2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(b1),\n        .diff(diff[2]),\n        .bout(b2)\n    );\n    \n    full_subtractor fs3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(b2),\n        .diff(diff[3]),\n        .bout(b3)\n    );\n    \n    full_subtractor fs4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(b3),\n        .diff(diff[4]),\n        .bout(b4)\n    );\n    \n    full_subtractor fs5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(b4),\n        .diff(diff[5]),\n        .bout(b5)\n    );\n    \n    full_subtractor"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [7:0] product\n);\n  wire [7:0] pp0, pp1, pp2, pp3;\n\n  assign pp0 = b[0] ? {4'b0, a}       : 8'b0;\n  assign pp1 = b[1] ? {3'b0, a, 1'b0}   : 8'b0;\n  assign pp2 = b[2] ? {2'b0, a, 2'b0}   : 8'b0;\n  assign pp3 = b[3] ? {1'b0, a, 3'b0}   : 8'b0;\n\n  assign product = pp0 + pp1 + pp2 + pp3;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n    wire [31:0] current_count;\n\n    u_toggle_logic u_toggle_logic_inst (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    u_counter_logic u_counter_logic_inst (\n        .toggle(toggle),\n        .current_count(current_count),\n        .next_count(next_count)\n    );\n\n    u_counter_register u_counter_register_inst (\n        .clk(clk),\n        .control_signal(control_signal),\n        .next_count(next_count),\n        .current_count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\nmodule u_toggle_logic (\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule u_counter_logic (\n    input wire toggle,\n    input wire [31:0] current_count,\n    output wire [31:0] next_count\n);\n    assign next_count = (toggle) ? current_count + 32'd1 : 32'd0;\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] current_count\n);\n    always @(posedge clk) begin\n        if (!control_signal)\n            current_count <= 32'd0;\n        else\n            current_count <= next_count;\n    end\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n  wire [31:0] add_out;\n  wire [31:0] sub_out;\n  wire [31:0] and_out;\n  wire [31:0] or_out;\n  \n  u_adder u_adder_inst (\n    .a(a),\n    .b(b),\n    .result(add_out)\n  );\n  \n  u_subtractor u_subtractor_inst (\n    .a(a),\n    .b(b),\n    .result(sub_out)\n  );\n  \n  u_and_logic u_and_logic_inst (\n    .a(a),\n    .b(b),\n    .result(and_out)\n  );\n  \n  u_or_logic u_or_logic_inst (\n    .a(a),\n    .b(b),\n    .result(or_out)\n  );\n  \n  reg [31:0] alu_result;\n  \n  always @(*) begin\n    case(op_code)\n      2'b00: alu_result = add_out;\n      2'b01: alu_result = sub_out;\n      2'b10: alu_result = and_out;\n      2'b11: alu_result = or_out;\n      default: alu_result = 32'b0;\n    endcase\n  end\n  \n  assign result = alu_result;\n  assign zero = (alu_result == 32'b0);\n  \nendmodule\n\nmodule u_adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n  assign result = a + b;\nendmodule\n\nmodule u_subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n  assign result = b - a;\nendmodule\n\nmodule u_and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n  assign result = a & b;\nendmodule\n\nmodule u_or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n  assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    adder u_adder (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(sub_result)\n    );\n\n    and_bit u_and_bit (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(and_result)\n    );\n\n    or_bit u_or_bit (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(xor_result)\n    );\n\n    reg [31:0] alu_result;\n    assign result = alu_result;\n\n    always @(*) begin\n        case (op_code)\n            3'b000: alu_result = add_result;\n            3'b001: alu_result = sub_result;\n            3'b010: alu_result = and_result;\n            3'b011: alu_result = or_result;\n            3'b100: alu_result = xor_result;\n            default: alu_result = 32'b0;\n        endcase\n    end\n\n    assign zero = (alu_result == 32'b0);\nendmodule\n\nmodule adder (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a ^ operand_b;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] bw_result;\n\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n\n    bitwise_operator u_bitwise_operator (\n        .a(operand_a),\n        .b(operand_b),\n        .op(op_code[0]),\n        .result(bw_result)\n    );\n\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result <= add_result;\n            2'b01: result <= sub_result;\n            2'b10,\n            2'b11: result <= bw_result;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire op,\n    output wire [31:0] result\n);\n    assign result = (op == 1'b0) ? (a & b) : (a | b);\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        y_bit,\n    output [15:0] partial_product\n);\n    assign partial_product = y_bit ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n\n    gen_product #(0) GP0 (\n        .X(X),\n        .y_bit(Y[0]),\n        .partial_product(pp0)\n    );\n\n    gen_product #(1) GP1 (\n        .X(X),\n        .y_bit(Y[1]),\n        .partial_product(pp1)\n    );\n\n    gen_product #(2) GP2 (\n        .X(X),\n        .y_bit(Y[2]),\n        .partial_product(pp2)\n    );\n\n    gen_product #(3) GP3 (\n        .X(X),\n        .y_bit(Y[3]),\n        .partial_product(pp3)\n    );\n\n    gen_product #(4) GP4 (\n        .X(X),\n        .y_bit(Y[4]),\n        .partial_product(pp4)\n    );\n\n    gen_product #(5) GP5 (\n        .X(X),\n        .y_bit(Y[5]),\n        .partial_product(pp5)\n    );\n\n    gen_product #(6) GP6 (\n        .X(X),\n        .y_bit(Y[6]),\n        .partial_product(pp6)\n    );\n\n    gen_product #(7) GP7 (\n        .X(X),\n        .y_bit(Y[7]),\n        .partial_product(pp7)\n    );\n\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": ""}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n  wire [3:0] add_result;\n  wire [3:0] sub_result;\n  wire [3:0] and_result;\n  wire [3:0] or_result;\n\n  adder u_adder(\n    .a(operand_a),\n    .b(operand_b),\n    .sum(add_result)\n  );\n\n  subtractor u_subtractor(\n    .a(operand_a),\n    .b(operand_b),\n    .diff(sub_result)\n  );\n\n  and_logical u_and_logical(\n    .a(operand_a),\n    .b(operand_b),\n    .result(and_result)\n  );\n\n  or_logical u_or_logical(\n    .a(operand_a),\n    .b(operand_b),\n    .result(or_result)\n  );\n\n  always @(posedge clk) begin\n    case(op_code)\n      2'b00: result <= add_result;\n      2'b01: result <= sub_result;\n      2'b10: result <= and_result;\n      2'b11: result <= or_result;\n      default: result <= 4'b0000;\n    endcase\n  end\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n  assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n  assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n  assign result = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n  assign result = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] add_result;\nwire [3:0] sub_result;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder u_adder(\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\nsubtractor u_subtractor(\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n);\n\nand_module u_and(\n    .a(a),\n    .b(b),\n    .and_out(and_result)\n);\n\nor_module u_or(\n    .a(a),\n    .b(b),\n    .or_out(or_result)\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = add_result;\n        2'b01: result = sub_result;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\nassign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\nassign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": ""}
{"task_id": "stagepipe3_v_21", "response": "module arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n  wire [15:0] adder_result;\n  wire [15:0] subtract_result;\n  wire [15:0] multiplier_result;\n  wire [15:0] divider_result;\n  wire       div_valid;\n  \n  add_module u_add (\n    .clk(clk),\n    .rst(rst),\n    .a(data_a),\n    .b(data_b),\n    .sum(adder_result)\n  );\n  \n  sub_module u_sub (\n    .clk(clk),\n    .rst(rst),\n    .a(data_a),\n    .b(data_b),\n    .diff(subtract_result)\n  );\n  \n  mul_module u_mul (\n    .clk(clk),\n    .rst(rst),\n    .a(data_a),\n    .b(data_b),\n    .product(multiplier_result)\n  );\n  \n  div_module u_div (\n    .clk(clk),\n    .rst(rst),\n    .a(data_a),\n    .b(data_b),\n    .quotient(divider_result),\n    .valid(div_valid)\n  );\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      result <= 16'd0;\n      valid  <= 1'b0;\n    end\n    else begin\n      case (opcode)\n        2'b00: begin\n          result <= adder_result;\n          valid  <= 1'b1;\n        end\n        2'b01: begin\n          result <= subtract_result;\n          valid  <= 1'b1;\n        end\n        2'b10: begin\n          result <= multiplier_result;\n          valid  <= 1'b1;\n        end\n        2'b11: begin\n          result <= divider_result;\n          valid  <= div_valid;\n        end\n        default: begin\n          result <= 16'd0;\n          valid  <= 1'b0;\n        end\n      endcase\n    end\n  end\nendmodule\n\nmodule add_module(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] sum\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      sum <= 16'd0;\n    else\n      sum <= a + b;\n  end\nendmodule\n\nmodule sub_module(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0"}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare (\n    input  a,\n    input  b,\n    output"}
{"task_id": "barrel_shifter_v_23", "response": "module bitwise_and(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n  assign result = a & b;\nendmodule\n\nmodule bitwise_or(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n  assign result = a | b;\nendmodule\n\nmodule adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result,\n    output       carry_borrow\n);\n  assign {carry_borrow, result} = a + b;\nendmodule\n\nmodule subtractor_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result,\n    output       carry_borrow\n);\n  assign result = a - b;\n  assign carry_borrow = (a < b) ? 1'b1 : 1'b0;\nendmodule\n\nmodule simple_alu(\n    input  [3:0] a,\n    input  [3:0] b,\n    input  [1:0] op,\n    output [3:0] result,\n    output       carry_borrow\n);\n  wire [3:0] and_result;\n  wire [3:0] or_result;\n  wire [3:0] add_result;\n  wire [3:0] sub_result;\n  wire       add_carry;\n  wire       sub_borrow;\n\n  bitwise_and    u_and       ( .a(a), .b(b), .result(and_result) );\n  bitwise_or     u_or        ( .a(a), .b(b), .result(or_result)  );\n  adder_4bit     u_adder     ( .a(a), .b(b), .result(add_result), .carry_borrow(add_carry) );\n  subtractor_4bit u_subtractor( .a(a), .b(b), .result(sub_result), .carry_borrow(sub_borrow) );\n\n  reg [3:0] alu_result;\n  reg       alu_carry_borrow;\n\n  always @(*) begin\n    case(op)\n      2'b00: begin\n        alu_result       = and_result;\n        alu_carry_borrow = 1'b0;\n      end\n      2'b01: begin\n        alu_result       = or_result;\n        alu_carry_borrow = 1'b0;\n      end\n      2'b10: begin\n        alu_result       = add_result;\n        alu_carry_borrow = add_carry;\n      end\n      2'b11: begin\n        alu_result       = sub_result;\n        alu_carry_borrow = sub_borrow;\n      end\n      default: begin\n        alu_result       = 4'b0000;\n        alu_carry_borrow = 1'b0;\n      end\n    endcase\n  end\n\n  assign result = alu_result;\n  assign carry_borrow = alu_carry_borrow;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module comp_temp (\n    input  [7:0] temp_in,\n    output       comp_out\n);\n    parameter [7:0] TEMP_THRESHOLD = 8'd100;\n    assign comp_out = (temp_in > TEMP_THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_gate (\n    input  a,\n    input  b,\n    output y\n);\n    assign y = a | b;\nendmodule\n\nmodule alarm_system (\n    input  [7:0] temp_sensor,\n    input        smoke_sensor,\n    output       alarm_out\n);\n    wire temp_compare;\n\n    comp_temp u_comp_temp (\n        .temp_in(temp_sensor),\n        .comp_out(temp_compare)\n    );\n\n    or_gate u_or_gate (\n        .a(temp_compare),\n        .b(smoke_sensor),\n        .y(alarm_out)\n    );\n\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": "module cla_4bit (\n    input  [3:0] A,\n    input  [3:0] B,\n    input        C_in,\n    output [3:0] S,\n    output       C_out\n);\n  wire [3:0] p, g;\n  wire [4:0] c;\n  \n  assign c[0] = C_in;\n  assign p = A ^ B;\n  assign g = A & B;\n  \n  assign c[1] = g[0] | (p[0] & c[0]);\n  assign c[2] = g[1] | (p[1] & g[0]) | (p[1] & p[0] & c[0]);\n  assign c[3] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & c[0]);\n  assign c[4] = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & c[0]);\n  \n  assign S[0] = p[0] ^ c[0];\n  assign S[1] = p[1] ^ c[1];\n  assign S[2] = p[2] ^ c[2];\n  assign S[3] = p[3] ^ c[3];\n  \n  assign C_out = c[4];\nendmodule\n\nmodule add_16bit (\n    input  [16:1] A,\n    input  [16:1] B,\n    output [16:1] S,\n    output       C_out\n);\n  wire c1, c2, c3;\n  \n  cla_4bit cla0 (\n    .A(A[4:1]),\n    .B(B[4:1]),\n    .C_in(1'b0),\n    .S(S[4:1]),\n    .C_out(c1)\n  );\n  \n  cla_4bit cla1 (\n    .A(A[8:5]),\n    .B(B[8:5]),\n    .C_in(c1),\n    .S(S[8:5]),\n    .C_out(c2)\n  );\n  \n  cla_4bit cla2 (\n    .A(A[12:9]),\n    .B(B[12:9]),\n    .C_in(c2),\n    .S(S[12:9]),\n    .C_out(c3)\n  );\n  \n  cla_4bit cla3 (\n    .A(A[16:13]),\n    .B(B[16:13]),\n    .C_in(c3),\n    .S(S[16:13]),\n    .C_out(C_out)\n  );\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n  input [7:0] X;\n  input [7:0] Y;\n  output P;\n\n  wire p_gen1, p_gen2;\n\n  parity_8bit gen1 (\n    .data(X),\n    .parity(p_gen1)\n  );\n\n  parity_8bit gen2 (\n    .data(Y),\n    .parity(p_gen2)\n  );\n\n  assign P = p_gen1 ^ p_gen2;\n  \nendmodule\n\nmodule parity_8bit(data, parity);\n  input [7:0] data;\n  output parity;\n\n  assign parity = ^data;\n  \nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0 (.a(a0), .b(b0), .sum(sum0));\n    adder_unit au1 (.a(a1), .b(b1), .sum(sum1));\n    adder_unit au2 (.a(a2), .b(b2), .sum(sum2));\n    adder_unit au3 (.a(a3), .b(b3), .sum(sum3));\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n\n  multiplier mult0 (\n    .clk(clk),\n    .rst(rst),\n    .a(x0),\n    .b(y0),\n    .product(p0)\n  );\n\n  multiplier mult1 (\n    .clk(clk),\n    .rst(rst),\n    .a(x1),\n    .b(y0),\n    .product(p1)\n  );\n\n  multiplier mult2 (\n    .clk(clk),\n    .rst(rst),\n    .a(x0),\n    .b(y1),\n    .product(p2)\n  );\n\n  multiplier mult3 (\n    .clk(clk),\n    .rst(rst),\n    .a(x1),\n    .b(y1),\n    .product(p3)\n  );\n\nendmodule\n\nmodule multiplier (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] product\n);\n\n  always @(posedge clk) begin\n    if (rst)\n      product <= 16'd0;\n    else\n      product <= a * b;\n  end\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module left_rotate(\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  wire [3:0] left_result;\n  wire [3:0] right_result;\n\n  left_rotate lr (\n    .in_data(in_data),\n    .out_data(left_result)\n  );\n\n  right_rotate rr (\n    .in_data(in_data),\n    .out_data(right_result)\n  );\n\n  assign out_data = en ? (rot_dir ? left_result : right_result) : in_data;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module Counter (\n    input clk,\n    input rst,\n    input enable,\n    input mode,\n    output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 1'b1;\n      else\n        count <= count - 1'b1;\n    end\n  end\nendmodule\n\nmodule dual_mode_counter (\n    input clk,\n    input rst,\n    input mode,\n    input enable,\n    output [7:0] count\n);\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .mode(mode),\n    .count(count)\n  );\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .q(out0)\n    );\n    \n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .q(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            q <= 8'b0;\n        else if (load)\n            q <= data;\n        else if (shift)\n            q <= {1'b0, q[7:1]};\n        else\n            q <= q;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    input        Carry_in,\n    output [7:0] Sum,\n    output       Carry_out\n);\n    wire [6:0] carry;\n    \n    full_adder fa0(\n        .a(X[0]),\n        .b(Y[0]),\n        .cin(Carry_in),\n        .sum(Sum[0]),\n        .cout(carry[0])\n    );\n    \n    full_adder fa1(\n        .a(X[1]),\n        .b(Y[1]),\n        .cin(carry[0]),\n        .sum(Sum[1]),\n        .cout(carry[1])\n    );\n    \n    full_adder fa2(\n        .a(X[2]),\n        .b(Y[2]),\n        .cin(carry[1]),\n        .sum(Sum[2]),\n        .cout(carry[2])\n    );\n    \n    full_adder fa3(\n        .a(X[3]),\n        .b(Y[3]),\n        .cin(carry[2]),\n        .sum(Sum[3]),\n        .cout(carry[3])\n    );\n    \n    full_adder fa4(\n        .a(X[4]),\n        .b(Y[4]),\n        .cin(carry[3]),\n        .sum(Sum[4]),\n        .cout(carry[4])\n    );\n    \n    full_adder fa5(\n        .a(X[5]),\n        .b(Y[5]),\n        .cin(carry[4]),\n        .sum(Sum[5]),\n        .cout(carry[5])\n    );\n    \n    full_adder fa6(\n        .a(X[6]),\n        .b(Y[6]),\n        .cin(carry[5]),\n        .sum(Sum[6]),\n        .cout(carry[6])\n    );\n    \n    full_adder fa7(\n        .a(X[7]),\n        .b(Y[7]),\n        .cin(carry[6]),\n        .sum(Sum[7]),\n        .cout(Carry_out)\n    );\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] X,\n    input  [31:0] Y,\n    output [31:0] Sum,\n    output        Carry_out\n);\n    wire c0, c1, c2;\n    \n    adder_8bit adder0(\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Carry_in(1'b0),\n        .Sum(Sum[7:0]),\n        .Carry_out(c0)\n    );\n    \n    adder_8bit adder1(\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Carry_in(c0),\n        .Sum(Sum[15:8]),\n        .Carry_out(c1)\n    );\n    \n    adder_8bit adder2(\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Carry_in(c1),\n        .Sum(Sum[23:16]),\n        .Carry_out(c2)\n    );\n    \n    adder_8bit adder3(\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Carry_in(c2),\n        .Sum(Sum[31:24]),\n        .Carry_out(Carry_out)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c0, c1, c2;\n\n    adder_8bit add0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c0)\n    );\n\n    adder_8bit add1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c0),\n        .Sum(Sum[15:8]),\n        .Cout(c1)\n    );\n\n    adder_8bit add2(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c1),\n        .Sum(Sum[23:16]),\n        .Cout(c2)\n    );\n\n    adder_8bit add3(\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c2),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input  [1:0]  op,\n    output [31:0] result,\n    output        carry_out\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire        add_carry;\n    wire        sub_carry;\n\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .sum(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .and_result(and_result)\n    );\n\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    (op == 2'b10) ? and_result : 32'b0;\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry : 1'b0;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] sum,\n    output        carry_out\n);\n    assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        carry_out\n);\n    assign {carry_out, diff} = A - B;\nendmodule\n\nmodule and_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] and_result\n);\n    assign and_result = A & B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    \n    mux0 u_mux0 (\n        .clk(clk),\n        .d(d0),\n        .q(mux0_out)\n    );\n    \n    mux1 u_mux1 (\n        .clk(clk),\n        .d(d1),\n        .q(mux1_out)\n    );\n    \n    mux2 u_mux2 (\n        .clk(clk),\n        .d(d2),\n        .q(mux2_out)\n    );\n    \n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'b0;\n    \nendmodule\n\nmodule mux0 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux1 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux2 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_hold #(\n    parameter SEL_CODE = 2'b00\n) (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (sel == SEL_CODE)\n            q <= d;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\nwire [7:0] q0, q1, q2, q3;\n\ndata_hold #(.SEL_CODE(2'b00)) hold0 (\n    .clk(clk),\n    .d(in0),\n    .sel(sel),\n    .q(q0)\n);\n\ndata_hold #(.SEL_CODE(2'b01)) hold1 (\n    .clk(clk),\n    .d(in1),\n    .sel(sel),\n    .q(q1)\n);\n\ndata_hold #(.SEL_CODE(2'b10)) hold2 (\n    .clk(clk),\n    .d(in2),\n    .sel(sel),\n    .q(q2)\n);\n\ndata_hold #(.SEL_CODE(2'b11)) hold3 (\n    .clk(clk),\n    .d(in3),\n    .sel(sel),\n    .q(q3)\n);\n\nassign out = (sel == 2'b00) ? q0 :\n             (sel == 2'b01) ? q1 :\n             (sel == 2'b10) ? q2 : q3;\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": ""}
{"task_id": "square_wave_v_42", "response": "module duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n    reg [7:0] counter;\n    \n    always @(posedge clk) begin\n        if (counter == 8'd255)\n            counter <= 8'd0;\n        else\n            counter <= counter + 1'b1;\n            \n        if (counter < duty_cycle)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule\n\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    wire [7:0] adjusted_duty;\n    \n    duty_ctrl u_duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n    \n    pulse_gen u_pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit(\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire eq\n);\n    assign eq = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n    \n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .eq(eq0)\n    );\n    \n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .eq(eq1)\n    );\n    \n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .eq(eq2)\n    );\n    \n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .eq(eq3)\n    );\n    \n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] intermediate;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(intermediate)\n    );\n\n    bit_reverse br2 (\n        .din(intermediate),\n        .dout(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin: reverse_loop\n            assign dout[i] = din[7 - i];\n        end\n    endgenerate\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum_out\n);\n    assign sum_out = a + b;\nendmodule\n\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] adder_result;\n    \n    my_adder8 adder_inst (\n        .a(a),\n        .b(b),\n        .sum_out(adder_result)\n    );\n    \n    always @(*) begin\n        if (ctrl)\n            sum = adder_result;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input  CLK_in,\n    input  RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_module_25 u_pwm25 (\n        .CLK_in(CLK_in),\n        .RST   (RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_module_50 u_pwm50 (\n        .CLK_in(CLK_in),\n        .RST   (RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_module_75 u_pwm75 (\n        .CLK_in(CLK_in),\n        .RST   (RST),\n        .PWM_out(PWM_75)\n    );\nendmodule\n\nmodule pwm_module_25 (\n    input  CLK_in,\n    input  RST,\n    output reg PWM_out\n);\n    parameter PWM_PERIOD = 100;\n    parameter THRESHOLD  = 25;\n    \n    reg [6:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            PWM_out  <= 0;\n        end\n        else begin\n            if (counter < PWM_PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n                \n            PWM_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_module_50 (\n    input  CLK_in,\n    input  RST,\n    output reg PWM_out\n);\n    parameter PWM_PERIOD = 100;\n    parameter THRESHOLD  = 50;\n    \n    reg [6:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            PWM_out  <= 0;\n        end\n        else begin\n            if (counter < PWM_PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n                \n            PWM_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_module_75 (\n    input  CLK_in,\n    input  RST,\n    output reg PWM_out\n);\n    parameter PWM_PERIOD = 100;\n    parameter THRESHOLD  = 75;\n    \n    reg [6:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            PWM_out  <= 0;\n        end\n        else begin\n            if (counter < PWM_PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n                \n            PWM_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    \n    pwm_duty_25 pwm25_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n    \n    pwm_duty_50 pwm50_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n    \n    pwm_duty_75 pwm75_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    localparam MAX_COUNT = 100;\n    localparam DUTY_COUNT = 25;\n    \n    reg [6:0] counter;\n    \n    always @(posedge CLK_in) begin\n        if(RST) begin\n            counter  <= 0;\n            PWM_out  <= 0;\n        end\n        else begin\n            if(counter == MAX_COUNT - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            PWM_out <= (counter < DUTY_COUNT);\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    localparam MAX_COUNT = 100;\n    localparam DUTY_COUNT = 50;\n    \n    reg [6:0] counter;\n    \n    always @(posedge CLK_in) begin\n        if(RST) begin\n            counter  <= 0;\n            PWM_out  <= 0;\n        end\n        else begin\n            if(counter == MAX_COUNT - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            PWM_out <= (counter < DUTY_COUNT);\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    localparam MAX_COUNT = 100;\n    localparam DUTY_COUNT = 75;\n    \n    reg [6:0] counter;\n    \n    always @(posedge CLK_in) begin\n        if(RST) begin\n            counter  <= 0;\n            PWM_out  <= 0;\n        end\n        else begin\n            if(counter == MAX_COUNT - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            PWM_out <= (counter < DUTY_COUNT);\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": ""}
{"task_id": "alu_v_50", "response": "module mult_signed(\n    input signed [31:0] a,\n    input signed [31:0] b,\n    output signed [63:0] y\n);\n    assign y = a * b;\nendmodule\n\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n    wire signed [63:0] result_signed;\n    wire [63:0] result_unsigned;\n    wire [63:0] result;\n\n    mult_signed u_mult_signed (\n        .a(a),\n        .b(b),\n        .y(result_signed)\n    );\n\n    mult_unsigned u_mult_unsigned (\n        .a(a),\n        .b(b),\n        .y(result_unsigned)\n    );\n\n    assign result = multc ? result_unsigned : result_signed;\n    assign y = result;\n    assign msb = result[63:32];\n    assign lsb = result[31:0];\n    assign zero = (result == 64'd0);\n    \nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n\n    u_count_control u_count_control_inst (\n        .clk    (clk),\n        .rst    (rst),\n        .en     (en),\n        .count  (count)\n    );\n\n    u_overflow_detection u_overflow_detection_inst (\n        .clk      (clk),\n        .rst      (rst),\n        .en       (en),\n        .count    (count),\n        .overflow (overflow)\n    );\n\n    assign count_out = count;\n\nendmodule\n\nmodule u_count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg  [3:0]   count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1;\n    end\nendmodule\n\nmodule u_overflow_detection (\n    input               clk,\n    input               rst,\n    input               en,\n    input       [3:0]   count,\n    output reg          overflow\n);\n\n    reg [3:0] prev_count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'b0000;\n            overflow   <= 1'b0;\n        end\n        else begin\n            if (prev_count == 4'b1111 && en && count == 4'b0000)\n                overflow <= 1'b1;\n            else\n                overflow <= 1'b0;\n            prev_count <= count;\n        end\n    end\n\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module add(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtract(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_and(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] res\n);\n    assign res = a & b;\nendmodule\n\nmodule bitwise_or(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] res\n);\n    assign res = a | b;\nendmodule\n\nmodule simple_alu(\n    input         clk,\n    input         rst,\n    input  [1:0]  op_code,\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    add         u_add         ( .a(operand_a), .b(operand_b), .sum(add_result) );\n    subtract    u_subtract    ( .a(operand_a), .b(operand_b), .diff(sub_result) );\n    bitwise_and u_and         ( .a(operand_a), .b(operand_b), .res(and_result) );\n    bitwise_or  u_or          ( .a(operand_a), .b(operand_b), .res(or_result) );\n\n    reg [31:0] alu_next;\n\n    always @(*) begin\n        case(op_code)\n            2'b00: alu_next = add_result;\n            2'b01: alu_next = sub_result;\n            2'b10: alu_next = and_result;\n            2'b11: alu_next = or_result;\n            default: alu_next = 32'd0;\n        endcase\n    end\n\n    always @(posedge clk) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= alu_next;\n    end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": ""}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Bin,\n    output [7:0] D,\n    output Bout\n);\n    assign {Bout, D} = {1'b0, A} - {1'b0, B} - Bin;\nendmodule\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Bin,\n    output [31:0] D,\n    output        Bout\n);\n    wire b1, b2, b3;\n    \n    subtractor_8bit U0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Bin(Bin),\n        .D(D[7:0]),\n        .Bout(b1)\n    );\n    \n    subtractor_8bit U1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Bin(b1),\n        .D(D[15:8]),\n        .Bout(b2)\n    );\n    \n    subtractor_8bit U2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Bin(b2),\n        .D(D[23:16]),\n        .Bout(b3)\n    );\n    \n    subtractor_8bit U3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Bin(b3),\n        .D(D[31:24]),\n        .Bout(Bout)\n    );\nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire q0, q1, q2;\n\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(q0)\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(q0),\n        .q(q1)\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(q0 & q1),\n        .q(q2)\n    );\n\n    assign count = {q2, q1, q0};\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n    reg [3:0] count;\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n\n    count_initializer init_inst (\n        .reset(reset),\n        .init_val(init_val)\n    );\n\n    count_incrementer inc_inst (\n        .current(count),\n        .next(inc_val)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n\n    assign out = count;\nendmodule\n\nmodule count_initializer (\n    input wire reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule count_incrementer (\n    input wire [3:0] current,\n    output wire [3:0] next\n);\n    assign next = current + 1;\nendmodule"}
{"task_id": "up_down_counter", "response": "module counter_logic (\n    input wire [15:0] current,\n    input wire up_down,\n    output reg [15:0] next_value\n);\n    always @(*) begin\n        if (up_down)\n            next_value = current + 16'd1;\n        else\n            next_value = current - 16'd1;\n    end\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] data,\n    output reg [15:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 16'd0;\n        else\n            q <= data;\n    end\nendmodule\n\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .current(count),\n        .up_down(up_down),\n        .next_value(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .data(next_count),\n        .q(count)\n    );\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    reg [7:0] state;\n    wire [7:0] init_state;\n    wire [7:0] next_state;\n\n    init_submodule init_inst (\n        .reset(reset),\n        .out(init_state)\n    );\n\n    transition_submodule trans_inst (\n        .current_state(state),\n        .out(next_state)\n    );\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= init_state;\n        else\n            state <= next_state;\n    end\n\n    assign out = state;\n\nendmodule\n\nmodule init_submodule (\n    input wire reset,\n    output wire [7:0] out\n);\n    assign out = 8'b00000001;\nendmodule\n\nmodule transition_submodule (\n    input wire [7:0] current_state,\n    output wire [7:0] out\n);\n    assign out = (current_state == 8'b10000000) ? 8'b00000001 : (current_state << 1);\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_val;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count_val)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .in(count_val),\n        .out(out)\n    );\n  \nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n        else\n            count <= count;\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= in;\n        else\n            out <= out;\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input        clk,\n    input        rst_n,\n    output [63:0] Q\n);\n\n    wire [63:0] current_state;\n    wire [63:0] next_state;\n\n    JC_register u_register (\n        .clk(clk),\n        .rst_n(rst_n),\n        .D(next_state),\n        .Q(current_state)\n    );\n\n    JC_logic u_logic (\n        .current_state(current_state"}
{"task_id": "freq_div", "response": "module clk_div_2 (\n    input  CLK_in,\n    input  RST,\n    output reg clk_out\n);\n  always @(posedge CLK_in or posedge RST) begin\n    if (RST)\n      clk_out <= 1'b0;\n    else\n      clk_out <= ~clk_out;\n  end\nendmodule\n\nmodule clk_div_10 (\n    input  CLK_in,\n    input  RST,\n    output reg clk_out\n);\n  reg [2:0] count;\n  \n  always @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n      clk_out <= 1'b0;\n      count   <= 3'd0;\n    end else begin\n      if (count == 3'd4) begin\n        clk_out <= ~clk_out;\n        count   <= 3'd0;\n      end else\n        count <= count + 3'd1;\n    end\n  end\nendmodule\n\nmodule clk_div_100 (\n    input  CLK_in,\n    input  RST,\n    output reg clk_out\n);\n  reg [5:0] count;\n  \n  always @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n      clk_out <= 1'b0;\n      count   <= 6'd0;\n    end else begin\n      if (count == 6'd49) begin\n        clk_out <= ~clk_out;\n        count   <= 6'd0;\n      end else\n        count <= count + 6'd1;\n    end\n  end\nendmodule\n\nmodule freq_div (\n    input  CLK_in,\n    input  RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n  wire clk_50_w, clk_10_w, clk_1_w;\n  \n  clk_div_2   u_clk_div_2   ( .CLK_in(CLK_in), .RST(RST), .clk_out(clk_50_w) );\n  clk_div_10  u_clk_div_10  ( .CLK_in(CLK_in), .RST(RST), .clk_out(clk_10_w) );\n  clk_div_100 u_clk_div_100 ( .CLK_in(CLK_in), .RST(RST), .clk_out(clk_1_w) );\n  \n  assign CLK_50 = clk_50_w;\n  assign CLK_10 = clk_10_w;\n  assign CLK_1  = clk_1_w;\n  \nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": ""}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven #(parameter NUM_DIV = 4) (\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    localparam HALF_COUNT = NUM_DIV/2 - 1;\n\n    wire tick;\n\n    u_counter #(\n        .COUNT_MAX(HALF_COUNT)\n    ) i_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n\n    u_clk_divider i_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule u_counter #(parameter COUNT_MAX = 1) (\n    input clk,\n    input rst_n,\n    output reg tick\n);\n    reg [3:0] count;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'd0;\n            tick  <= 1'b0;\n        end else begin\n            if (count == COUNT_MAX) begin\n                count <= 4'd0;\n                tick  <= 1'b1;\n            end else begin\n                count <= count + 1'b1;\n                tick  <= 1'b0;\n            end\n        end\n    end\nendmodule\n\nmodule u_clk_divider (\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] in,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 32'd0;\n        else\n            current_value <= current_value + in;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n    wire [31:0] acc_result;\n    \n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n    \n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .in(mult_result[31:0]),\n        .current_value(acc_result)\n    );\n    \n    assign c = acc_result;\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n  reg [7:0] ins_p1, ins_p2;\n\n  always @(posedge clk or negedge rst) begin\n    if (!rst) begin\n      ins_p1 <= 8'b0;\n      ins_p2 <= 8'b0;\n    end else begin\n      if (fetch == 2'b01)\n        ins_p1 <= data;\n      if (fetch == 2'b10)\n        ins_p2 <= data;\n    end\n  end\n\n  assign ins = ins_p1[7:5];\n  assign ad1 = ins_p1[4:0];\n  assign ad2 = ins_p2;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq != 8'd0);\n\n    counter cnt_inst (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg_inst (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if(count == freq - 1)\n                count <= 8'd0;\n            else\n                count <= count + 1;\n        end\n        else begin\n            count <= 8'd0;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if(count == freq - 1)\n            wave_out <= ~wave_out;\n        else\n            wave_out <= wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module state_control (\n    input        clk,\n    input        rst_n,\n    input  [4:0] wave,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n        else if (state == 2'b00 && wave == 5'd31)\n            state <= 2'b01;\n        else if (state == 2'b01 && wave == 5'd0)\n            state <= 2'b00;\n        else\n            state <= state;\n    end\nendmodule\n\nmodule waveform_generation (\n    input        clk,\n    input        rst_n,\n    input  [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave <= 5'd0;\n        else begin\n            case (state)\n                2'b00: wave <= wave + 5'd1;\n                2'b01: wave <= wave - 5'd1;\n                default: wave <= wave;\n            endcase\n        end\n    end\nendmodule\n\nmodule signal_generator (\n    input        clk,\n    input        rst_n,\n    output [4:0] wave\n);\n    wire [1:0] state;\n\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .wave(wave),\n        .state(state)\n    );\n\n    waveform_generation wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave)\n    );\nendmodule"}
{"task_id": "shift8", "response": "module my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n  wire w0, w1;\n\n  my_dff dff0 (\n      .clk(clk),\n      .d(d),\n      .q(w0)\n  );\n\n  my_dff dff1 (\n      .clk(clk),\n      .d(w0),\n      .q(w1)\n  );\n\n  my_dff dff2 (\n      .clk(clk),\n      .d(w1),\n      .q(q)\n  );\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module pe(\n  input  clk,\n  input  rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + a * b;\n  end\nendmodule\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  \nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c,\n  output reg [15:0] b_out\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      c <= 32'd0;\n      b_out <= 16'd0;\n    end\n    else begin\n      c <= c + (a * b);\n      b_out <= b;\n    end\n  end\nendmodule\n\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b_out0;\n  wire [15:0] b_out1;\n  wire [15:0] b_out2;\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0),\n    .b_out(b_out0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b_out0),\n    .c(c1),\n    .b_out(b_out1)\n  );\n\n  pe pe2_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b_out1),\n    .c(c2),\n    .b_out(b_out2)\n  );\n\n  pe pe3_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b_out2),\n    .c(c3),\n    .b_out()\n  );\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] dividend_prepped,\n    output wire [31:0] divisor_prepped\n);\n    assign dividend_prepped = A;\n    assign divisor_prepped  = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input wire [31:0] dividend_prepped,\n    input wire [31:0] divisor_prepped,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] r;\n    reg [31:0] q;\n    \n    always @(*) begin\n        r = 32'd0;\n        q = 32'd0;\n        for(i = 31; i >= 0; i = i - 1) begin\n            r = {r[30:0], dividend_prepped[i]};\n            if(r >= divisor_prepped) begin\n                r = r - divisor_prepped;\n                q[i] = 1'b1;\n            end else begin\n                q[i] = 1'b0;\n            end\n        end\n        quotient  = q;\n        remainder = r;\n    end\nendmodule\n\nmodule div_32bit(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n    wire [31:0] dividend_prepped;\n    wire [31:0] divisor_prepped;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    \n    prep_dividend prep_inst (\n        .A(A),\n        .B(B),\n        .dividend_prepped(dividend_prepped),\n        .divisor_prepped(divisor_prepped)\n    );\n    \n    div_operation div_op_inst (\n        .dividend_prepped(dividend_prepped),\n        .divisor_prepped(divisor_prepped),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n    \n    assign result = quotient;\n    assign odd    = remainder;\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n);\n    ctrl ctrl_inst (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\nendmodule\n\nmodule ctrl (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output reg [15:0] result,\n    output reg [15:0] odd\n);\n    integer i;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [15:0] divisor_ext;\n    \n    always @(*) begin\n        quotient   = 16'b0;\n        remainder  = 16'b0;\n        divisor_ext = {8'b0, B};\n        if (B == 8'b0) begin\n            quotient  = 16'b0;\n            remainder = A;\n        end else begin\n            for (i = 15; i >= 0; i = i - 1) begin\n                remainder = {remainder[14:0], A[i]};\n                if (remainder >= divisor_ext) begin\n                    remainder = remainder - divisor_ext;\n                    quotient[i] = 1'b1;\n                end else begin\n                    quotient[i] = 1'b0;\n                end\n            end\n        end\n        result = quotient;\n        odd    = remainder;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input  A,\n    input  B,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum = A ^ B ^ cin;\n    assign cout = (A & B) | (A & cin) | (B & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        cin,\n    output [7:0] sum,\n    output       cout\n);\n    wire [8:0] c;\n    assign c[0] = cin;\n    \n    genvar i;\n    generate\n        for(i = 0; i < 8; i = i + 1) begin : full_adders\n            full_adder fa (\n                .A   (A[i]),\n                .B   (B[i]),\n                .cin (c[i]),\n                .sum (sum[i]),\n                .cout(c[i+1])\n            );\n        end\n    endgenerate\n    assign cout = c[8];\nendmodule\n\nmodule sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    output [7:0] D,\n    output       B_out\n);\n    wire [7:0] B_comp;\n    wire       cout;\n    \n    assign B_comp = ~B;\n    \n    adder_8bit adder_inst (\n        .A   (A),\n        .B   (B_comp),\n        .cin (1'b1),\n        .sum (D),\n        .cout(cout)\n    );\n    \n    assign B_out = ~cout;\nendmodule"}
{"task_id": "sub_32bit", "response": ""}
{"task_id": "sub_64bit", "response": ""}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    wire [32:0] full_diff;\n    assign full_diff = {1'b0, A} - {1'b0, B};\n    assign diff      = full_diff[31:0];\n    assign borrow    = full_diff[32];\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater, \n    output        A_equal,   \n    output        A_less     \n);\n    wire [31:0] diff;\n    wire        borrow;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n    \n    assign A_equal   = (diff == 32'd0);\n    assign A_less    = borrow;\n    assign A_greater = ~(A_equal | A_less);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module ripple_carry_adder_4bit(a, b, cin, sum, cout);\n  input  [3:0] a;\n  input  [3:0] b;\n  input        cin;\n  output [3:0] sum;\n  output       cout;\n  wire c1, c2, c3;\n\n  assign sum[0] = a[0] ^ b[0] ^ cin;\n  assign c1     = (a[0] & b[0]) | (a[0] & cin) | (b[0] & cin);\n\n  assign sum[1] = a[1] ^ b[1] ^ c1;\n  assign c2     = (a[1] & b[1]) | (a[1] & c1) | (b[1] & c1);\n\n  assign sum[2] = a[2] ^ b[2] ^ c2;\n  assign c3     = (a[2] & b[2]) | (a[2] & c2) | (b[2] & c2);\n\n  assign sum[3] = a[3] ^ b[3] ^ c3;\n  assign cout   = (a[3] & b[3]) | (a[3] & c3) | (b[3] & c3);\nendmodule\n\nmodule carry_select_adder_slice(a, b, cin, sum, cout);\n  input  [3:0] a;\n  input  [3:0] b;\n  input        cin;\n  output [3:0] sum;\n  output       cout;\n  wire [3:0] sum0, sum1;\n  wire       cout0, cout1;\n\n  ripple_carry_adder_4bit rca0 (\n    .a(a),\n    .b(b),\n    .cin(1'b0),\n    .sum(sum0),\n    .cout(cout0)\n  );\n\n  ripple_carry_adder_4bit rca1 (\n    .a(a),\n    .b(b),\n    .cin(1'b1),\n    .sum(sum1),\n    .cout(cout1)\n  );\n\n  assign sum   = cin ? sum1   : sum0;\n  assign cout  = cin ? cout1  : cout0;\nendmodule\n\nmodule adder_16bit_csa(a, b, cin, sum, cout);\n  input  [15:0] a;\n  input  [15:0] b;\n  input         cin;\n  output [15:0] sum;\n  output        cout;\n  wire c4, c8, c12;\n\n  ripple_carry_adder_4bit rca0 (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(cin),\n    .sum(sum[3:0]),\n    .cout(c4)\n  );\n\n  carry_select_adder_slice csa1 (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(c4),\n    .sum(sum[7:4]),\n    .cout(c8)\n  );\n\n  carry_select_adder_slice csa2 (\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(c8),\n    .sum(sum[11:8]),\n    .cout(c12)\n  );\n\n  carry_select_adder_slice csa3 (\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .cin(c12),\n    .sum(sum[15:12]),\n    .cout(cout)\n  );\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry)\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .y(y[15:8]),\n        .Co(Co)\n    );\n    \nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input      a,\n    input      b,\n    input      cin,\n    output     sum,\n    output     cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a, \n    input  [7:0] b, \n    input        cin, \n    output [7:0] sum, \n    output       cout\n);\n    wire [6:0] carry;\n\n    full_adder FA0(.a(a[0]), .b(b[0]), .cin(cin),      .sum(sum[0]), .cout(carry[0]));\n    full_adder FA1(.a(a[1]), .b(b[1]), .cin(carry[0]),  .sum(sum[1]), .cout(carry[1]));\n    full_adder FA2(.a(a[2]), .b(b[2]), .cin(carry[1]),  .sum(sum[2]), .cout(carry[2]));\n    full_adder FA3(.a(a[3]), .b(b[3]), .cin(carry[2]),  .sum(sum[3]), .cout(carry[3]));\n    full_adder FA4(.a(a[4]), .b(b[4]), .cin(carry[3]),  .sum(sum[4]), .cout(carry[4]));\n    full_adder FA5(.a(a[5]), .b(b[5]), .cin(carry[4]),  .sum(sum[5]), .cout(carry[5]));\n    full_adder FA6(.a(a[6]), .b(b[6]), .cin(carry[5]),  .sum(sum[6]), .cout(carry[6]));\n    full_adder FA7(.a(a[7]), .b(b[7]), .cin(carry[6]),  .sum(sum[7]), .cout(cout));\n    \nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n\n    adder32 u_adder (\n        .a(op1),\n        .b(op2),\n        .sum(add_result)\n    );\n\n    subtractor32 u_subtractor (\n        .a(op1),\n        .b(op2),\n        .diff(sub_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule\n\nmodule adder32(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor32(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    output reg [31:0] quotient\n);\n    always @(posedge clk) begin\n        if (rst)\n            quotient <= 32'd0;\n        else\n            quotient <= (y == 32'd0) ? 32'd0 : x / y;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] z,\n    output reg [31:0] difference\n);\n    always @(posedge clk) begin\n        if (rst)\n            difference <= 32'd0;\n        else\n            difference <= a - z;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_result;\n    \n    u_divider divider_inst (\n        .clk(clk),\n        .rst(rst),\n        .x(x),\n        .y(y),\n        .quotient(div_result)\n    );\n    \n    u_subtractor subtractor_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(div_result),\n        .z(z),\n        .difference(difference)\n    );\n    \n    assign quotient = div_result;\n    \nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\nwire [31:0] sum;\nwire [31:0] diff;\nwire [31:0] and_out;\nwire [31:0] or_out;\n\nu_adder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nu_subtractor subtractor_inst (\n    .a(a),\n    .b(b),\n    .diff(diff)\n);\n\nu_and and_inst (\n    .a(a),\n    .b(b),\n    .and_out(and_out)\n);\n\nu_or or_inst (\n    .a(a),\n    .b(b),\n    .or_out(or_out)\n);\n\nalways @(posedge clk) begin\n    case (op_sel)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_out;\n        2'b11: result <= or_out;\n        default: result <= 32'd0;\n    endcase\nend\n\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_out\n);\nassign and_out = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_out\n);\nassign or_out = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input         clk,\n    input         op_sel,\n    input  [31:0] a,\n    input  [31:0] b,\n    output reg [31:0] result\n);\n\n  wire [31:0] add_out;\n  wire [31:0] and_out;\n\n  u_adder u_adder_inst (\n    .a(a),\n    .b(b),\n    .result(add_out)\n  );\n\n  u_bitwise_and u_bitwise_and_inst (\n    .a(a),\n    .b(b),\n    .result(and_out)\n  );\n\n  always @(posedge clk) begin\n    if (op_sel == 1'b0)\n      result <= add_out;\n    else\n      result <= and_out;\n  end\n\nendmodule\n\nmodule u_adder(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] result\n);\n  assign result = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] result\n);\n  assign result = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module u_adder(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= a - b;\n    end\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n\n    u_adder u_adder_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~a | b) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire ["}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~(a ^ b)) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire [6:0] borrow;\n\n    subtractor_1bit S0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow[0])\n    );\n\n    subtractor_1bit S1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow[0]),\n        .diff(diff[1]),\n        .bout(borrow[1])\n    );\n\n    subtractor_1bit S2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow[1]),\n        .diff(diff[2]),\n        .bout(borrow[2])\n    );\n\n    subtractor_1bit S3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow[2]),\n        .diff(diff[3]),\n        .bout(borrow[3])\n    );\n\n    subtractor_1bit S4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow[3]),\n        .diff(diff["}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~(a ^ b)) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a, \n    input [7:0] b, \n    input bin,\n    output [7:0] diff,\n    output bout\n);\n\nwire b0, b1, b2, b3, b4, b5, b6;\n\nfull_subtractor FS0 (\n    .a(a[0]),\n    .b(b[0]),\n    .bin(bin),\n    .diff(diff[0]),\n    .bout(b0)\n);\n\nfull_subtractor FS1 (\n    .a(a[1]),\n    .b(b[1]),\n    .bin(b0),\n    .diff(diff[1]),\n    .bout(b1)\n);\n\nfull_subtractor FS2 (\n    .a(a[2]),\n    .b(b[2]),\n    .bin(b1),\n    .diff(diff[2]),\n    .bout(b2)\n);\n\nfull_subtractor FS3 (\n    .a(a[3]),\n    .b(b[3]),\n    .bin(b2),\n    .diff(diff[3]),\n    .bout(b3)\n);\n\nfull_subtractor FS4 (\n    .a(a[4]),\n    .b(b[4]),\n    .bin(b3),\n    .diff(diff[4]),\n    .bout(b4)\n);\n\nfull_subtractor FS5 (\n    .a(a[5]),\n    .b(b[5]),\n    .bin(b4),\n    .diff(diff[5]),\n    .bout(b5)\n);\n\nfull_subtractor FS6 (\n    .a(a[6]),\n    .b(b[6]),\n    .bin(b5),\n    .diff(diff[6]),\n    .bout(b6)\n);\n\nfull_subtractor FS7 (\n    .a(a[7]),\n    .b(b[7]),\n    .bin(b6),\n    .diff(diff[7]),\n    .bout(bout)\n);\n\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module SAA0(\n    input  [3:0] a,\n    input        control,\n    output [7:0] partial\n);\n    assign partial = control ? {4'b0000, a} : 8'b0;\nendmodule\n\nmodule SAA1(\n    input  [3:0] a,\n    input        control,\n    output [7:0] partial\n);\n    assign partial = control ? {3'b000, a, 1'b0} : 8'b0;\nendmodule\n\nmodule SAA2(\n    input  [3:0] a,\n    input        control,\n    output [7:0] partial\n);\n    assign partial = control ? {2'b00, a, 2'b00} : 8'b0;\nendmodule\n\nmodule SAA3(\n    input  [3:0] a,\n    input        control,\n    output [7:0] partial\n);\n    assign partial = control ? {1'b0, a, 3'b000} : 8'b0;\nendmodule\n\nmodule multiplier_4bit(\n    input  [3:0] a, b,\n    output [7:0] product\n);\n    wire [7:0] pp0, pp1, pp2, pp3;\n\n    SAA0 u_SAA0(\n        .a(a),\n        .control(b[0]),\n        .partial(pp0)\n    );\n    \n    SAA1 u_SAA1(\n        .a(a),\n        .control(b[1]),\n        .partial(pp1)\n    );\n    \n    SAA2 u_SAA2(\n        .a(a),\n        .control(b[2]),\n        .partial(pp2)\n    );\n    \n    SAA3 u_SAA3(\n        .a(a),\n        .control(b[3]),\n        .partial(pp3)\n    );\n    \n    assign product = pp0 + pp1 + pp2 + pp3;\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": ""}
{"task_id": "up_down_counter_v_11", "response": "module u_adder (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule u_and_logic (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule u_or_logic (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule modular_alu (\n    input  wire [1:0] op_code,\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output reg  [31:0] result,\n    output wire zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    u_adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_subtractor subtractor_inst (\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n\n    u_and_logic and_logic_inst (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n\n    u_or_logic or_logic_inst (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n\n    always @(*) begin\n        case(op_code)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 32'b0;\n        endcase\n    end\n\n    assign zero = (result == 32'b0);\n\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module u_adder (\n    input  wire [31:0] in1,\n    input  wire [31:0] in2,\n    output wire [31:0] sum\n);\n    assign sum = in1 + in2;\nendmodule\n\nmodule u_subtractor (\n    input  wire [31:0] in1,\n    input  wire [31:0] in2,\n    output wire [31:0] diff\n);\n    assign diff = in1 - in2;\nendmodule\n\nmodule u_and_bit (\n    input  wire [31:0] in1,\n    input  wire [31:0] in2,\n    output wire [31:0] out\n);\n    assign out = in1 & in2;\nendmodule\n\nmodule u_or_bit (\n    input  wire [31:0] in1,\n    input  wire [31:0] in2,\n    output wire [31:0] out\n);\n    assign out = in1 | in2;\nendmodule\n\nmodule u_xor_bit (\n    input  wire [31:0] in1,\n    input  wire [31:0] in2,\n    output wire [31:0] out\n);\n    assign out = in1 ^ in2;\nendmodule\n\nmodule multi_function_alu (\n    input  wire [2:0]  op_code,\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire        zero\n);\n    wire [31:0] add_result, sub_result, and_result, or_result, xor_result;\n    reg  [31:0] res;\n\n    u_adder    u_adder_inst    (.in1(operand_a), .in2(operand_b), .sum(add_result));\n    u_subtractor u_subtractor_inst (.in1(operand_a), .in2(operand_b), .diff(sub_result));\n    u_and_bit  u_and_bit_inst  (.in1(operand_a), .in2(operand_b), .out(and_result));\n    u_or_bit   u_or_bit_inst   (.in1(operand_a), .in2(operand_b), .out(or_result));\n    u_xor_bit  u_xor_bit_inst  (.in1(operand_a), .in2(operand_b), .out(xor_result));\n\n    always @(*) begin\n        case(op_code)\n            3'b000: res = add_result;\n            3'b001: res = sub_result;\n            3'b010: res = and_result;\n            3'b011: res = or_result;\n            3'b100: res = xor_result;\n            default: res = 32'b0;\n        endcase\n    end\n\n    assign result = res;\n    assign zero   = (res == 32'b0);\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] bitwise_out;\n    wire bitwise_select;\n\n    assign bitwise_select = op_code[0];\n\n    adder u_adder (\n        .clk(clk),\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_out)\n    );\n\n    subtractor u_subtractor (\n        .clk(clk),\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_out)\n    );\n\n    bitwise_operator u_bitwise_operator (\n        .clk(clk),\n        .select(bitwise_select),\n        .a(operand_a),\n        .b(operand_b),\n        .result(bitwise_out)\n    );\n\n    always @(posedge clk) begin\n        case(op_code)\n            2'b00: result <= add_out;\n            2'b01: result <= sub_out;\n            2'b10: result <= bitwise_out;\n            2'b11: result <= bitwise_out;\n            default: result <= 32'b0;\n        endcase\n    end\n\nendmodule\n\nmodule adder (\n    input wire clk,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] sum\n);\n    always @(posedge clk) begin\n        sum <= a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire clk,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] diff\n);\n    always @(posedge clk) begin\n        diff <= a - b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input wire clk,\n    input wire select,  // 0 for AND, 1 for OR\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk) begin\n        if (select == 1'b0)\n            result <= a & b;\n        else\n            result <= a | b;\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0)\n(\n    input  [7:0] X,\n    input        Y_bit,\n    output [15:0] PP\n);\n    assign PP = Y_bit ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n    \n    gen_product #(.SHIFT(0)) gp0 (.X(X), .Y_bit(Y[0]), .PP(pp0));\n    gen_product #(.SHIFT(1)) gp1 (.X(X), .Y_bit(Y[1]), .PP(pp1));\n    gen_product #(.SHIFT(2)) gp2 (.X(X), .Y_bit(Y[2]), .PP(pp2));\n    gen_product #(.SHIFT(3)) gp3 (.X(X), .Y_bit(Y[3]), .PP(pp3));\n    gen_product #(.SHIFT(4)) gp4 (.X(X), .Y_bit(Y[4]), .PP(pp4));\n    gen_product #(.SHIFT(5)) gp5 (.X(X), .Y_bit(Y[5]), .PP(pp5));\n    gen_product #(.SHIFT(6)) gp6 (.X(X), .Y_bit(Y[6]), .PP(pp6));\n    gen_product #(.SHIFT(7)) gp7 (.X(X), .Y_bit(Y[7]), .PP(pp7));\n    \n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift #(parameter SHIFT = 0) (\n    input [15:0] in_acc,\n    input        sel,\n    input  [7:0] X,\n    output [15:0] out_acc\n);\n  assign out_acc = in_acc + (sel ? ({8'b0, X} << SHIFT) : 16'd0);\nendmodule\n\nmodule mult_8bit(X, Y, P);\n  input  [7:0] X;\n  input  [7:0] Y;\n  output [15:0] P;\n  \n  wire [15:0] acc0;\n  wire [15:0] acc1;\n  wire [15:0] acc2;\n  wire [15:0] acc3;\n  wire [15:0] acc4;\n  wire [15:0] acc5;\n  wire [15:0] acc6;\n  wire [15:0] acc7;\n  \n  assign acc0 = 16'd0;\n  \n  add_shift #(.SHIFT(0)) AS0 (\n    .in_acc(acc0),\n    .sel(Y[0]),\n    .X(X),\n    .out_acc(acc1)\n  );\n  \n  add_shift #(.SHIFT(1)) AS1 (\n    .in_acc(acc1),\n    .sel(Y[1]),\n    .X(X),\n    .out_acc(acc2)\n  );\n  \n  add_shift #(.SHIFT(2)) AS2 (\n    .in_acc(acc2),\n    .sel(Y[2]),\n    .X(X),\n    .out_acc(acc3)\n  );\n  \n  add_shift #(.SHIFT(3)) AS3 (\n    .in_acc(acc3),\n    .sel(Y[3]),\n    .X(X),\n    .out_acc(acc4)\n  );\n  \n  add_shift #(.SHIFT(4)) AS4 (\n    .in_acc(acc4),\n    .sel(Y[4]),\n    .X(X),\n    .out_acc(acc5)\n  );\n  \n  add_shift #(.SHIFT(5)) AS5 (\n    .in_acc(acc5),\n    .sel(Y[5]),\n    .X(X),\n    .out_acc(acc6)\n  );\n  \n  add_shift #(.SHIFT(6)) AS6 (\n    .in_acc(acc6),\n    .sel(Y[6]),\n    .X(X),\n    .out_acc(acc7)\n  );\n  \n  add_shift #(.SHIFT(7)) AS7 (\n    .in_acc(acc7),\n    .sel(Y[7]),\n    .X(X),\n    .out_acc(P)\n  );\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module adder(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_logical(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule simple_alu4bit(\n    input        clk,\n    input  [1:0] op_code,\n    input  [3:0] operand_a,\n    input  [3:0] operand_b,\n    output reg [3:0] result\n);\n    wire [3:0] add_res;\n    wire [3:0] sub_res;\n    wire [3:0] and_res;\n    wire [3:0] or_res;\n    \n    adder       u_adder       ( .a(operand_a), .b(operand_b), .sum(add_res) );\n    subtractor  u_subtractor  ( .a(operand_a), .b(operand_b), .diff(sub_res) );\n    and_logical u_and_logical ( .a(operand_a), .b(operand_b), .result(and_res) );\n    or_logical  u_or_logical  ( .a(operand_a), .b(operand_b), .result(or_res) );\n    \n    always @(posedge clk) begin\n        case(op_code)\n            2'b00: result <= add_res;\n            2'b01: result <= sub_res;\n            2'b10: result <= and_res;\n            2'b11: result <= or_res;\n            default: result <= 4'b0000;\n        endcase\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n    \n    adder u_adder(\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    subtractor u_subtractor(\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n    \n    and_module u_and(\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n    \n    or_module u_or(\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n    \n    always @(*) begin\n        case(op)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "module simple_alu(\n    input        clk,\n    input        rst,\n    input  [1:0] op_code,\n    input  [3:0] data_a,\n    input  [3:0] data_b,\n    output [3:0] result,\n    output       zero\n);\n    wire        add, sub, and_op, or_op;\n    wire [3:0]  alu_result;\n\n    op_decoder u_op_decoder (\n        .op_code(op_code),\n        .add(add),\n        .sub(sub),\n        .and_op(and_op),\n        .or_op(or_op)\n    );\n\n    arithmetic_logic u_arithmetic_logic (\n        .data_a(data_a),\n        .data_b(data_b),\n        .add(add),\n        .sub(sub),\n        .and_op(and_op),\n        .or_op(or_op),\n        .result(alu_result)\n    );\n\n    result_manager u_result_manager (\n        .clk(clk),\n        .rst(rst),\n        .alu_result(alu_result),\n        .result(result),\n        .zero(zero)\n    );\n\nendmodule\n\nmodule op_decoder(\n    input  [1:0] op_code,\n    output reg add,\n    output reg sub,\n    output reg and_op,\n    output reg or_op\n);\n    always @(*) begin\n        add    = 1'b0;\n        sub    = 1'b0;\n        and_op = 1'b0;\n        or_op  = 1'b0;\n        case(op_code)\n            2'b00: add    = 1'b1; // Addition\n            2'b01: sub    = 1'b1; // Subtraction\n            2'b10: and_op = 1'b1; // Bitwise AND\n            2'b11: or_op  = 1'b1; // Bitwise OR\n            default: begin\n                add    = 1'b0;\n                sub    = 1'b0;\n                and_op = 1'b0;\n                or_op  = 1'b0;\n            end\n        endcase\n    end\nendmodule\n\nmodule arithmetic_logic(\n    input  [3:0] data_a,\n    input  [3:0] data_b,\n    input        add,\n    input       "}
{"task_id": "stagepipe3_v_21", "response": ""}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare (\n    input a,\n    input b,\n    input gt_in,\n    input lt_in,\n    input eq_in,\n    output gt_out,\n    output lt_out,\n    output eq_out\n);\n    assign eq_out = eq_in & ~(a ^ b);\n    assign gt_out = gt_in | (eq_in & a & ~b);\n    assign lt_out = lt_in | (eq_in & ~a & b);\nendmodule\n\nmodule magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt;\n    output lt;\n    output eq;\n    \n    wire gt3, lt3, eq3;\n    wire gt2, lt2, eq2;\n    wire gt1, lt1, eq1;\n    \n    bit_compare bc0 (\n        .a(A[3]),\n        .b(B[3]),\n        .gt_in(1'b0),\n        .lt_in(1'b0),\n        .eq_in(1'b1),\n        .gt_out(gt3),\n        .lt_out(lt3),\n        .eq_out(eq3)\n    );\n    \n    bit_compare bc1 (\n        .a(A[2]),\n        .b(B[2]),\n        .gt_in(gt3),\n        .lt_in(lt3),\n        .eq_in(eq3),\n        .gt_out(gt2),\n        .lt_out(lt2),\n        .eq_out(eq2)\n    );\n    \n    bit_compare bc2 (\n        .a(A[1]),\n        .b(B[1]),\n        .gt_in(gt2),\n        .lt_in(lt2),\n        .eq_in(eq2),\n        .gt_out(gt1),\n        .lt_out(lt1),\n        .eq_out(eq1)\n    );\n    \n    bit_compare bc3 (\n        .a(A[0]),\n        .b(B[0]),\n        .gt_in(gt1),\n        .lt_in(lt1),\n        .eq_in(eq1),\n        .gt_out(gt),\n        .lt_out(lt),\n        .eq_out(eq)\n    );\n    \nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "`timescale 1ns/1ps\n\nmodule bitwise_and(a, b, result);\n  input  [3:0] a, b;\n  output [3:0] result;\n  assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n  input  [3:0] a, b;\n  output [3:0] result;\n  assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, carry_in, sum, carry_out);\n  input  [3:0] a, b;\n  input        carry_in;\n  output [3:0] sum;\n  output       carry_out;\n  assign {carry_out, sum} = a + b + carry_in;\nendmodule\n\nmodule subtractor_4bit(a, b, diff, borrow);\n  input  [3:0] a, b;\n  output [3:0] diff;\n  output       borrow;\n  assign diff = a - b;\n  assign borrow = (a < b);\nendmodule\n\nmodule simple_alu(a, b, op, result, carry_borrow);\n  input  [3:0] a, b;\n  input  [1:0] op;\n  output [3:0] result;\n  output       carry_borrow;\n  \n  wire [3:0] and_result;\n  wire [3:0] or_result;\n  wire [3:0] add_result;\n  wire [3:0] sub_result;\n  wire       add_carry;\n  wire       sub_borrow;\n\n  bitwise_and u_and(.a(a), .b(b), .result(and_result));\n  bitwise_or  u_or (.a(a), .b(b), .result(or_result));\n  adder_4bit  u_add(.a(a), .b(b), .carry_in(1'b0), .sum(add_result), .carry_out(add_carry));\n  subtractor_4bit u_sub(.a(a), .b(b), .diff(sub_result), .borrow(sub_borrow));\n\n  assign result = (op == 2'b00) ? and_result :\n                  (op == 2'b01) ? or_result  :\n                  (op == 2'b10) ? add_result :\n                                  sub_result;\n\n  assign carry_borrow = (op == 2'b10) ? add_carry :\n                        (op == 2'b11) ? sub_borrow : 1'b0;\nendmodule`"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module compare_temp (\n    input  [7:0] temp_sensor,\n    output       comp_out\n);\n    parameter THRESHOLD = 8'd100;\n    assign comp_out = (temp_sensor > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic (\n    input  in1,\n    input  in2,\n    output or_out\n);\n    assign or_out = in1 | in2;\nendmodule\n\nmodule alarm_system (\n    input  [7:0] temp_sensor,\n    input        smoke_sensor,\n    output       alarm_out\n);\n    wire temp_trigger;\n    \n    compare_temp comp_inst (\n        .temp_sensor(temp_sensor),\n        .comp_out(temp_trigger)\n    );\n    \n    or_logic or_inst (\n        .in1(temp_trigger),\n        .in2(smoke_sensor),\n        .or_out(alarm_out)\n    );\n    \nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": ""}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(input [7:0] data, output parity);\n    assign parity = ^data;\nendmodule\n\nmodule parity_16bit(input [7:0] X, input [7:0] Y, output P);\n    wire parity_X;\n    wire parity_Y;\n    \n    parity_8bit gen1(.data(X), .parity(parity_X));\n    parity_8bit gen2(.data(Y), .parity(parity_Y));\n    \n    assign P = parity_X ^ parity_Y;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0 (\n        .a(a0),\n        .b(b0),\n        .sum(sum0)\n    );\n    \n    adder_unit au1 (\n        .a(a1),\n        .b(b1),\n        .sum(sum1)\n    );\n    \n    adder_unit au2 (\n        .a(a2),\n        .b(b2),\n        .sum(sum2)\n    );\n    \n    adder_unit au3 (\n        .a(a3),\n        .b(b3),\n        .sum(sum3)\n    );\n    \nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module multiplier_unit(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] product\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            product <= 16'd0;\n        else\n            product <= a * b;\n    end\nendmodule\n\nmodule matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n    multiplier_unit mult0 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .product(p0)\n    );\n\n    multiplier_unit mult1 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .product(p1)\n    );\n\n    multiplier_unit mult2 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .product(p2)\n    );\n\n    multiplier_unit mult3 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .product(p3)\n    );\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n\n  wire [3:0] left_result;\n  wire [3:0] right_result;\n\n  left_rotate lr_inst (\n    .in(in_data),\n    .out(left_result)\n  );\n\n  right_rotate rr_inst (\n    .in(in_data),\n    .out(right_result)\n  );\n\n  assign out_data = en ? (rot_dir ? left_result : right_result) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] in,\n  output [3:0] out\n);\n  assign out = {in[2:0], in[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] in,\n  output [3:0] out\n);\n  assign out = {in[0], in[3:1]};\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] count_internal;\n  \n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count_internal)\n  );\n  \n  assign count = count_internal;\n  \nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'b0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 1;\n      else\n        count <= count - 1;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      out <= 8'b0;\n    else if (load)\n      out <= data;\n    else if (shift)\n      out <= {1'b0, out[7:1]};\n    else\n      out <= out;\n  end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n  shift_register sr0 (\n    .clk(clk),\n    .rst(rst),\n    .load(load0),\n    .shift(shift0),\n    .data(data0),\n    .out(out0)\n  );\n\n  shift_register sr1 (\n    .clk(clk),\n    .rst(rst),\n    .load(load1),\n    .shift(shift1),\n    .data(data1),\n    .out(out1)\n  );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder fa0(.a(X[0]), .b(Y[0]), .cin(Cin), .sum(Sum[0]), .cout(c1));\n    full_adder fa1(.a(X[1]), .b(Y[1]), .cin(c1),  .sum(Sum[1]), .cout(c2));\n    full_adder fa2(.a(X[2]), .b(Y[2]), .cin(c2),  .sum(Sum[2]), .cout(c3));\n    full_adder fa3(.a(X[3]), .b(Y[3]), .cin(c3),  .sum(Sum[3]), .cout(c4));\n    full_adder fa4(.a(X[4]), .b(Y[4]), .cin(c4),  .sum(Sum[4]), .cout(c5));\n    full_adder fa5(.a(X[5]), .b(Y[5]), .cin(c5),  .sum(Sum[5]), .cout(c6));\n    full_adder fa6(.a(X[6]), .b(Y[6]), .cin(c6),  .sum(Sum[6]), .cout(c7));\n    full_adder fa7(.a(X[7]), .b(Y[7]), .cin(c7),  .sum(Sum[7]), .cout(Cout));\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] X,\n    input  [31:0] Y,\n    output [31:0] Sum,\n    output        Carry_out\n);\n    wire c1, c2, c3;\n\n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Cin(1'b0),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n\n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n\n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n\n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Carry_out)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c1, c2, c3;\n\n    adder_8bit add0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n\n    adder_8bit add1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n\n    adder_8bit add2(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n\n    adder_8bit add3(\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input  [1:0]  op,\n    output [31:0] result,\n    output        carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire        add_carry;\n    wire        sub_carry;\n\n    // Instantiate the 32-bit adder\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .sum(add_result),\n        .carry(add_carry)\n    );\n\n    // Instantiate the 32-bit subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(sub_result),\n        .carry(sub_carry)\n    );\n\n    // Instantiate the 32-bit bitwise AND unit\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .and_out(and_result)\n    );\n\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    (op == 2'b10) ? and_result : 32'd0;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry : 1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] sum,\n    output        carry\n);\n    assign {carry, sum} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        carry\n);\n    assign {carry, diff} = A - B;\nendmodule\n\nmodule and_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] and_out\n);\n    assign and_out = A & B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux0 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux1 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule mux2 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n    wire [7:0] q0, q1, q2;\n    \n    mux0 u_mux0 (\n        .clk(clk),\n        .d(d0),\n        .q(q0)\n    );\n    \n    mux1 u_mux1 (\n        .clk(clk),\n        .d(d1),\n        .q(q1)\n    );\n    \n    mux2 u_mux2 (\n        .clk(clk),\n        .d(d2),\n        .q(q2)\n    );\n    \n    assign data_out = (sel == 3'b000) ? q0 :\n                      (sel == 3'b001) ? q1 :\n                      (sel == 3'b010) ? q2 :\n                      8'b0;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_hold (\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge clk) begin\n    if (load)\n      q <= d;\n  end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n  wire [7:0] data0, data1, data2, data3;\n  wire load0, load1, load2, load3;\n\n  assign load0 = (sel == 2'b00);\n  assign load1 = (sel == 2'b01);\n  assign load2 = (sel == 2'b10);\n  assign load3 = (sel == 2'b11);\n\n  data_hold hold0 (\n    .clk(clk),\n    .load(load0),\n    .d(in0),\n    .q(data0)\n  );\n\n  data_hold hold1 (\n    .clk(clk),\n    .load(load1),\n    .d(in1),\n    .q(data1)\n  );\n\n  data_hold hold2 (\n    .clk(clk),\n    .load(load2),\n    .d(in2),\n    .q(data2)\n  );\n\n  data_hold hold3 (\n    .clk(clk),\n    .load(load3),\n    .d(in3),\n    .q(data3)\n  );\n\n  assign out = (sel == 2'b00) ? data0 :\n               (sel == 2'b01) ? data1 :\n               (sel == 2'b10) ? data2 : data3;\n\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input        clk,\n    input  [7:0] duty_cycle,\n    input  [7:0] freq,\n    output       pwm_out\n);\n    wire [15:0] count;\n    wire        reset;\n\n    assign reset = 1'b0;\n\n    pwm_counter u_pwm_counter (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(count)\n    );\n\n    pwm_signal u_pwm_signal (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule\n\nmodule pwm_counter(\n    input         clk,\n    input         reset,\n    input  [7:0]  freq,\n    output reg [15:0] count\n);\n    always @(posedge clk) begin\n        if (reset)\n            count <= 16'd0;\n        else if (count == freq - 1)\n            count <= 16'd0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule pwm_signal(\n    input         clk,\n    input  [15:0] count,\n    input  [7:0]  duty_cycle,\n    input  [7:0]  freq,\n    output reg    pwm_out\n);\n    wire [15:0] threshold;\n    \n    assign threshold = (freq * duty_cycle) / 100;\n    \n    always @(posedge clk) begin\n        if (count < threshold)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n    reg [7:0] counter;\n    \n    always @(posedge clk) begin\n        counter <= counter + 1;\n        if (counter < duty_cycle)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule\n\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    wire [7:0] adjusted_duty;\n    \n    duty_ctrl u_duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n    \n    pulse_gen u_pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] mid;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(mid)\n    );\n\n    bit_reverse br2 (\n        .din(mid),\n        .dout(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] add_result;\n\n    my_adder8 u_my_adder8 (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    always @(*) begin\n        if (ctrl)\n            sum = add_result;\n        else\n            sum = 8'd0;\n    end\n\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input  CLK_in,\n    input  RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_module_25 u_pwm_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n    \n    pwm_module_50 u_pwm_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_duty_25 u_pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_25)\n    );\n\n    pwm_duty_50 u_pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_50)\n    );\n\n    pwm_duty_75 u_pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(PWM_75)\n    );\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 25) / 100;\n    localparam COUNTER_WIDTH = 7;\n    reg [COUNTER_WIDTH-1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            PWM_out  <= 1'b0;\n        end else begin\n            if (counter < PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n            PWM_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 50) / 100;\n    localparam COUNTER_WIDTH = 7;\n    reg [COUNTER_WIDTH-1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            PWM_out  <= 1'b0;\n        end else begin\n            if (counter < PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n            PWM_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 75) / 100;\n    localparam COUNTER_WIDTH = 7;\n    reg [COUNTER_WIDTH-1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            PWM_out  <= 1'b0;\n        end else begin\n            if (counter < PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n            PWM_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50;\n    parameter MAX_COUNT = 255;\n    parameter COUNTER_WIDTH = 8;\n    \n    localparam THRESHOLD = (DUTY_CYCLE * MAX_COUNT) / 100;\n    \n    wire [COUNTER_WIDTH-1:0] count;\n    \n    counter #(\n        .MAX_COUNT(MAX_COUNT),\n        .COUNTER_WIDTH(COUNTER_WIDTH)\n    ) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count)\n    );\n    \n    comparator #(\n        .THRESHOLD(THRESHOLD),\n        .COUNTER_WIDTH(COUNTER_WIDTH)\n    ) u_comparator (\n        .count(count),\n        .pwm(pwm_out)\n    );\n    \nendmodule\n\nmodule counter #(\n    parameter MAX_COUNT = 255,\n    parameter COUNTER_WIDTH = 8\n)(\n    input clk,\n    input rst_n,\n    output reg [COUNTER_WIDTH-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == MAX_COUNT - 1)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule comparator #(\n    parameter THRESHOLD = 128,\n    parameter COUNTER_WIDTH = 8\n)(\n    input [COUNTER_WIDTH-1:0] count,\n    output pwm\n);\n    assign pwm = (count < THRESHOLD);\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input  [31:0] a,\n    input  [31:0] b,\n    input         multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output        zero\n);\n    wire [63:0] product_signed;\n    wire [63:0] product_unsigned;\n    \n    mult_signed mult_signed_inst (\n        .a(a),\n        .b(b),\n        .result(product_signed)\n    );\n    \n    mult_unsigned mult_unsigned_inst (\n        .a(a),\n        .b(b),\n        .result(product_unsigned)\n    );\n    \n    assign y = (multc == 1'b0) ? product_signed : product_unsigned;\n    assign msb = y[63:32];\n    assign lsb = y[31:0];\n    assign zero = (y == 64'd0);\n    \nendmodule\n\nmodule mult_signed(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] result\n);\n    assign result = $signed(a) * $signed(b);\nendmodule\n\nmodule mult_unsigned(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n    output      [3:0]   count_out,\n    output              overflow\n);\n    wire [3:0] count_wire;\n    \n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count_wire)\n    );\n    \n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .count(count_wire),\n        .overflow(overflow)\n    );\n    \n    assign count_out = count_wire;\nendmodule\n\nmodule count_control (\n    input           clk,\n    input           rst,\n    input           en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'd0;\n        else if (en)\n            count <= count + 1;\n        else\n            count <= count;\n    end\nendmodule\n\nmodule overflow_detection (\n    input           clk,\n    input           rst,\n    input  [3:0]    count,\n    output reg      overflow\n);\n    reg [3:0] prev_count;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'd0;\n            overflow   <= 1'b0;\n        end else begin\n            overflow   <= (prev_count == 4'd15 && count == 4'd0) ? 1'b1 : 1'b0;\n            prev_count <= count;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    \n    add add_inst(\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(add_result)\n    );\n    \n    subtract subtract_inst(\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(sub_result)\n    );\n    \n    bitwise_and bitwise_and_inst(\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(and_result)\n    );\n    \n    bitwise_or bitwise_or_inst(\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(or_result)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else begin\n            case(op_code)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= and_result;\n                2'b11: result <= or_result;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule add(\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtract(\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule bitwise_and(\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule bitwise_or(\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": ""}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_8bit(A, B, Bin, D, Bout);\n  input  [8:1] A;\n  input  [8:1] B;\n  input        Bin;\n  output [8:1] D;\n  output       Bout;\n\n  assign D = A - B - Bin;\n  assign Bout = ({1'b0, A} < ({1'b0, B} + Bin)) ? 1'b1 : 1'b0;\nendmodule\n\nmodule subtractor_32bit(A, B, Bin, D, Bout);\n  input  [32:1] A;\n  input  [32:1] B;\n  input         Bin;\n  output [32:1] D;\n  output        Bout;\n  \n  wire borrow1, borrow2, borrow3;\n  \n  subtractor_8bit sub1 (.A(A[8:1]),    .B(B[8:1]),    .Bin(Bin),     .D(D[8:1]),    .Bout(borrow1));\n  subtractor_8bit sub2 (.A(A[16:9]),   .B(B[16:9]),   .Bin(borrow1), .D(D[16:9]),   .Bout(borrow2));\n  subtractor_8bit sub3 (.A(A[24:17]),  .B(B[24:17]),  .Bin(borrow2), .D(D[24:17]),  .Bout"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0] & count[1]),\n        .q(count[2])\n    );\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module counter_init (\n    input wire reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule counter_increment (\n    input wire [3:0] current,\n    output wire [3:0] inc_val\n);\n    assign inc_val = current + 4'b0001;\nendmodule\n\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] out\n);\n\nwire [3:0] init_val;\nwire [3:0] inc_val;\n\ncounter_init u_counter_init (\n    .reset(reset),\n    .init_val(init_val)\n);\n\ncounter_increment u_counter_increment (\n    .current(out),\n    .inc_val(inc_val)\n);\n\nalways @(posedge clk) begin\n    if (reset)\n        out <= init_val;\n    else\n        out <= inc_val;\nend\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\nwire [15:0] next_count;\n\ncounter_logic u_counter_logic (\n    .current_count(count),\n    .up_down(up_down),\n    .next_count(next_count)\n);\n\ncounter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .data_in(next_count),\n    .data_out(count)\n);\n\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\nassign next_count = up_down ? (current_count + 16'd1) : (current_count - 16'd1);\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] data_in,\n    output reg [15:0] data_out\n);\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        data_out <= 16'd0;\n    else\n        data_out <= data_in;\nend\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_val;\n    wire [7:0] next_state;\n    reg  [7:0] state;\n\n    ring_counter_init init_inst (\n        .init_val(init_val)\n    );\n\n    ring_counter_transition trans_inst (\n        .current(state),\n        .next(next_state)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            state <= init_val;\n        else\n            state <= next_state;\n    end\n\n    assign out = state;\n\nendmodule\n\nmodule ring_counter_init (\n    output wire [7:0] init_val\n);\n    assign init_val = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition (\n    input wire [7:0] current,\n    output wire [7:0] next\n);\n    assign next = { current[6:0], current[7] };\nendmodule"}
{"task_id": "counter_12", "response": "module counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1'b1;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] data_in,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= data_in;\n    end\nendmodule\n\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .data_in(count),\n        .out(out)\n    );\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module clk_div_2(\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 0;\n        else\n            CLK_out <= ~CLK_out;\n    end\nendmodule\n\nmodule clk_div_10(\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 4) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else\n            counter <= counter + 1;\n    end\nendmodule\n\nmodule clk_div_100(\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            CLK_out <= 0;\n        end\n        else if (counter == 49) begin\n            counter <= 0;\n            CLK_out <= ~CLK_out;\n        end\n        else\n            counter <= counter + 1;\n    end\nendmodule\n\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    wire div2;\n    wire div10;\n    wire div100;\n    \n    clk_div_2 u_clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(div2)\n    );\n    \n    clk_div_10 u_clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(div10)\n    );\n    \n    clk_div_100 u_clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(div100)\n    );\n    \n    assign CLK_50 = div2;\n    assign CLK_10 = div10;\n    assign CLK_1  = div100;\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": ""}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven #(\n    parameter NUM_DIV = 4\n)(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\n    localparam HALF_COUNT = (NUM_DIV >> 1) - 1;\n    wire tick;\n\n    u_counter #(\n        .HALF_COUNT(HALF_COUNT)\n    ) u_counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n\n    u_clk_divider u_clk_divider_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule u_counter #(\n    parameter HALF_COUNT = 1\n)(\n    input clk,\n    input rst_n,\n    output reg tick\n);\n\n    reg [3:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt  <= 4'd0;\n            tick <= 1'b0;\n        end else begin\n            if (cnt == HALF_COUNT) begin\n                cnt  <= 4'd0;\n                tick <= 1'b1;\n            end else begin\n                cnt  <= cnt + 4'd1;\n                tick <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule u_clk_divider (\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\n\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input         clk,\n    input         rst,\n    input  [31:0] data,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 32'b0;\n        else\n            current_value <= current_value + data;\n    end\nendmodule\n\nmodule pe(\n    input         clk,\n    input         rst,\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .product(mult_result)\n    );\n\n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .data(mult_result[31:0]),\n        .current_value(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": "module ins_p1(\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (!rst)\n            q <= 8'b0;\n        else if (fetch == 2'b01)\n            q <= data;\n        else\n            q <= q;\n    end\nendmodule\n\nmodule ins_p2(\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (!rst)\n            q <= 8'b0;\n        else if (fetch == 2'b10)\n            q <= data;\n        else\n            q <= q;\n    end\nendmodule\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] ins1;\n    wire [7:0] ins2;\n\n    ins_p1 u_ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .q(ins1)\n    );\n\n    ins_p2 u_ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .q(ins2)\n    );\n\n    assign ins  = ins1[7:5];\n    assign ad1  = ins1[4:0];\n    assign ad2  = ins2;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq != 8'd0);\n\n    counter cnt_inst (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg_inst (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1)\n                count <= 8'd0;\n            else\n                count <= count + 1;\n        end else begin\n            count <= 8'd0;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial begin\n        wave_out = 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if(count == freq - 1)\n            wave_out <= ~wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": ""}
{"task_id": "shift8", "response": "module my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk)\n        q <= d;\nendmodule\n\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] stage1;\n    wire [7:0] stage2;\n    wire [7:0] stage3;\n    \n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(stage1)\n    );\n    \n    my_dff8 u1 (\n        .clk(clk),\n        .d(stage1),\n        .q(stage2)\n    );\n    \n    my_dff8 u2 (\n        .clk(clk),\n        .d(stage2),\n        .q(stage3)\n    );\n    \n    always @(*) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = stage1;\n            2'b10: q = stage2;\n            2'b11: q = stage3;\n            default: q = d;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n  wire q0, q1;\n\n  my_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n  );\n\n  my_dff u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n  );\n\n  my_dff u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q)\n  );\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\n\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b_in,\n  output reg [31:0] acc,\n  output reg [15:0] b_out\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      acc   <= 32'd0;\n      b_out <= 16'd0;\n    end\n    else begin\n      acc   <= acc + a * b_in;\n      b_out <= b_in;\n    end\n  end\nendmodule\n\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  wire [15:0] b1, b2, b3;\n  \n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b_in(b0),\n    .acc(c0),\n    .b_out(b1)\n  );\n  \n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b_in(b1),\n    .acc(c1),\n    .b_out(b2)\n  );\n  \n  pe pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b_in(b2),\n    .acc(c2),\n    .b_out(b3)\n  );\n  \n  pe pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b_in(b3),\n    .acc(c3),\n    .b_out() // Not connected\n  );\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n    wire [31:0] prep_A;\n    wire [31:0] prep_B;\n    wire [31:0] quot;\n    wire [31:0] rem;\n    \n    prep_dividend u_prep_dividend (\n        .A(A),\n        .B(B),\n        .prep_A(prep_A),\n        .prep_B(prep_B)\n    );\n    \n    div_operation u_div_operation (\n        .dividend(prep_A),\n        .divisor(prep_B),\n        .quotient(quot),\n        .remainder(rem)\n    );\n    \n    assign result = quot;\n    assign odd    = rem;\n    \nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] prep_A,\n    output wire [31:0] prep_B\n);\n    assign prep_A = A;\n    assign prep_B = {16'b0, B};\n    \nendmodule\n\nmodule div_operation(\n    input  wire [31:0] dividend,\n    input  wire [31:0] divisor,\n    output reg  [31:0] quotient,\n    output reg  [31:0] remainder\n);\n    integer i;\n    always @(*) begin\n        quotient  = 32'b0;\n        remainder = 32'b0;\n        for(i = 31; i >= 0; i = i - 1) begin\n            remainder = {remainder[30:0], dividend[i]};\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient[i] = 1'b1;\n            end else begin\n                quotient[i] = 1'b0;\n            end\n        end\n    end\nendmodule"}
{"task_id": "div_16bit", "response": ""}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n    wire [7:0] carry;\n    \n    full_adder FA0 (\n        .a(A[0]),\n        .b(B[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n    \n    genvar i;\n    generate\n        for(i = 1; i < 8; i = i + 1) begin : add_loop\n            full_adder FA (\n                .a(A[i]),\n                .b(B[i]),\n                .cin(carry[i-1]),\n                .sum(sum[i]),\n                .cout(carry[i])\n            );\n        end\n    endgenerate\n    \n    assign cout = carry[7];\nendmodule\n\nmodule sub_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n    wire [7:0] B_inv;\n    wire c;\n    \n    assign B_inv = ~B;\n    \n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_inv),\n        .cin(1'b1),\n        .sum(D),\n        .cout(c)\n    );\n    \n    assign B_out = ~c;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_16bit(\n    input  [15:0] A,\n    input  [15:0] B,\n    input         borrow_in,\n    output [15:0] Diff,\n    output        borrow_out\n);\n    wire [16:0] result;\n    assign result = {1'b0, A} - {1'b0, B} - borrow_in;\n    assign Diff = result[15:0];\n    assign borrow_out = result[16];\nendmodule\n\nmodule sub_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] Diff,\n    output        B_out\n);\n    wire borrow_lower;\n\n    sub_16bit lower_sub (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(1'b0),\n        .Diff(Diff[15:0]),\n        .borrow_out(borrow_lower)\n    );\n\n    sub_16bit upper_sub (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_lower),\n        .Diff(Diff[31:16]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_64bit", "response": ""}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    assign {borrow, diff} = {1'b0, A} - {1'b0, B};\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output        A_greater, \n    output        A_equal,   \n    output        A_less     \n);\n    wire [31:0] diff;\n    wire        borrow;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_less    = borrow;\n    assign A_equal   = (~borrow) & (diff == 32'b0);\n    assign A_greater = (~borrow) & (|diff);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module ripple_carry_adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n  assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule csa_slice(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n  wire [3:0] sum0, sum1;\n  wire       cout0, cout1;\n  \n  ripple_carry_adder_4bit rca0 (\n    .a(a),\n    .b(b),\n    .cin(1'b0),\n    .sum(sum0),\n    .cout(cout0)\n  );\n  \n  ripple_carry_adder_4bit rca1 (\n    .a(a),\n    .b(b),\n    .cin(1'b1),\n    .sum(sum1),\n    .cout(cout1)\n  );\n  \n  assign sum  = cin ? sum1 : sum0;\n  assign cout = cin ? cout1 : cout0;\nendmodule\n\nmodule adder_16bit_csa(\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n  wire c1, c2, c3;\n  \n  ripple_carry_adder_4bit rca1 (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .cin(cin),\n    .sum(sum[3:0]),\n    .cout(c1)\n  );\n  \n  csa_slice csa_slice1 (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .cin(c1),\n    .sum(sum[7:4]),\n    .cout(c2)\n  );\n  \n  csa_slice csa_slice2 (\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .cin(c2),\n    .sum(sum[11:8]),\n    .cout(c3)\n  );\n  \n  csa_slice csa_slice3 (\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .cin(c3),\n    .sum(sum[15:12]),\n    .cout(cout)\n  );\n  \nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire c0;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(c0)\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(c0),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a, b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder FA1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder FA2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder FA3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(c4));\n    full_adder FA4(.a(a[4]), .b(b[4]), .cin(c4), .sum(sum[4]), .cout(c5));\n    full_adder FA5(.a(a[5]), .b(b[5]), .cin(c5), .sum(sum[5]), .cout(c6));\n    full_adder FA6(.a(a[6]), .b(b[6]), .cin(c6), .sum(sum[6]), .cout(c7));\n    full_adder FA7(.a(a[7]), .b(b[7]), .cin(c7), .sum(sum[7]), .cout(cout));\n    \nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\nu_adder adder_inst (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\nu_subtractor subtractor_inst (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result <= 32'b0;\n    else\n        result <= (mode == 1'b0) ? add_result : sub_result;\nend\n\nendmodule\n\nmodule u_adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\nassign result = op1 + op2;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\nassign result = op1 - op2;\nendmodule"}
{"task_id": "pe_v_1", "response": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n  wire [31:0] div_result;\n  \n  u_divider divider (\n    .clk(clk),\n    .rst(rst),\n    .x(x),\n    .y(y),\n    .quotient(div_result)\n  );\n  \n  u_subtractor subtractor (\n    .clk(clk),\n    .rst(rst),\n    .dividend(div_result),\n    .z(z),\n    .difference(difference)\n  );\n  \n  assign quotient = div_result;\n\nendmodule\n\nmodule u_divider(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    output reg [31:0] quotient\n);\n\n  always @(posedge clk) begin\n    if (rst)\n      quotient <= 32'd0;\n    else if (y == 32'd0)\n      quotient <= 32'd0;\n    else\n      quotient <= x / y;\n  end\n\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] z,\n    output reg [31:0] difference\n);\n\n  always @(posedge clk) begin\n    if (rst)\n      difference <= 32'd0;\n    else\n      difference <= dividend - z;\n  end\n\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    \n    u_adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    u_subtractor subtractor_inst (\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n    \n    u_and and_inst (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n    \n    u_or or_inst (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n    \n    always @(posedge clk) begin\n        case(op_sel)\n            2'b00: result <= add_result;\n            2'b01: result <= sub_result;\n            2'b10: result <= and_result;\n            2'b11: result <= or_result;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] and_result;\n\n    u_adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_bitwise_and and_inst (\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    always @(posedge clk) begin\n        result <= op_sel ? and_result : add_result;\n    end\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module u_adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] adder_result;\n    wire [15:0] subtractor_result;\n\n    u_adder u_adder (\n        .a(a),\n        .b(b),\n        .result(adder_result)\n    );\n\n    u_subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .result(subtractor_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'd0;\n        else\n            result <= (mode == 1'b0) ? adder_result : subtractor_result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire [6:0] borrow;\n\n    full_subtractor FS0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow[0])\n    );\n    \n    full_subtractor FS1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow[0]),\n        .diff(diff[1]),\n        .bout(borrow[1])\n    );\n    \n    full_subtractor FS2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow[1]),\n        .diff(diff[2]),\n        .bout(borrow[2])\n    );\n    \n    full_subtractor FS3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow[2]),\n        .diff(diff[3]),\n        .bout(borrow[3])\n    );\n    \n    full_subtractor FS4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow[3]),\n        .diff(diff[4]),\n        .bout(borrow[4])\n    );\n    \n    full_subtractor FS5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(borrow[4]),\n        .diff(diff[5]),\n        .bout(borrow[5])\n    );\n    \n    full_subtractor FS6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(borrow[5]),\n        .diff(diff[6]),\n        .bout(borrow[6])\n    );\n    \n    full_subtractor FS7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(borrow[6]),\n        .diff(diff[7]),\n        .bout(bout)\n    );\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | (~a & bin) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire [8:0] borrow;\n    \n    assign borrow[0] = bin;\n    \n    subtractor_1bit s0(\n        .a(a[0]),\n        .b(b[0]),\n        .bin(borrow[0]),\n        .diff(diff[0]),\n        .bout(borrow[1])\n    );\n    \n    subtractor_1bit s1(\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow[1]),\n        .diff(diff[1]),\n        .bout(borrow[2])\n    );\n    \n    subtractor_1bit s2(\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow[2]),\n        .diff(diff[2]),\n        .bout(borrow[3])\n    );\n    \n    subtractor_1bit s3(\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow[3]),\n        .diff(diff[3]),\n        .bout(borrow[4])\n    );\n    \n    subtractor_1bit s4(\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow[4]),\n        .diff(diff[4]),\n        .bout(borrow[5])\n    );\n    \n    subtractor_1bit s5(\n        .a(a[5]),\n        .b(b[5]),\n"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire [6:0] borrow;\n    \n    full_subtractor FS0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow[0])\n    );\n    \n    full_subtractor FS1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow[0]),\n        .diff(diff[1]),\n        .bout(borrow[1])\n    );\n    \n    full_subtractor FS2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow[1]),\n        .diff(diff[2]),\n        .bout(borrow[2])\n    );\n    \n    full_subtractor FS3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow[2]),\n        .diff(diff[3]),\n        .bout(borrow[3])\n    );\n    \n    full_subtractor FS4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow[3]),\n        .diff(diff[4]),\n        .bout(borrow[4])\n    );\n    \n    full_subtractor FS5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(borrow[4]),\n        .diff(diff[5]),\n        .bout(borrow[5])\n    );\n    \n    full_subtractor FS6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(borrow[5]),\n        .diff(diff[6]),\n        .bout(borrow[6])\n    );\n    \n    full_subtractor FS7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(borrow[6]),\n        .diff(diff[7]),\n        .bout(bout)\n    );\n    \nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [7:0] product\n);\n  wire [7:0] pp0, pp1, pp2, pp3;\n\n  assign pp0 = b[0] ? {4'b0, a}       : 8'b0;\n  assign pp1 = b[1] ? {3'b0, a, 1'b0}   : 8'b0;\n  assign pp2 = b[2] ? {2'b0, a, 2'b0}   : 8'b0;\n  assign pp3 = b[3] ? {1'b0, a, 3'b0}   : 8'b0;\n\n  assign product = pp0 + pp1 + pp2 + pp3;\n  \nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module toggle_logic(\n    input  wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic(\n    input  wire [31:0] current_count,\n    input  wire        toggle,\n    output wire [31:0] next_count\n);\n    assign next_count = toggle ? (current_count + 32'd1) : 32'd0;\nendmodule\n\nmodule counter_register(\n    input  wire        clk,\n    input  wire [31:0] next_count,\n    output reg  [31:0] count\n);\n    always @(posedge clk) begin\n        count <= next_count;\n    end\nendmodule\n\nmodule binary_ripple_counter (\n    input  wire        clk,\n    input  wire        control_signal,\n    output wire [31:0] count\n);\n    wire        toggle;\n    wire [31:0] next_count;\n    wire [31:0] current_count;\n    \n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle        (toggle)\n    );\n    \n    counter_logic u_counter_logic (\n        .current_count(current_count),\n        .toggle       (toggle),\n        .next_count   (next_count)\n    );\n    \n    counter_register u_counter_register (\n        .clk       (clk),\n        .next_count(next_count),\n        .count     (current_count)\n    );\n    \n    assign count = current_count;\n    \nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\nu_adder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\nu_subtractor subtractor_inst (\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n);\n\nu_and_logic and_inst (\n    .a(a),\n    .b(b),\n    .and_out(and_result)\n);\n\nu_or_logic or_inst (\n    .a(a),\n    .b(b),\n    .or_out(or_result)\n);\n\nreg [31:0] result_int;\nalways @(*) begin\n    case (op_code)\n        2'b00: result_int = add_result;\n        2'b01: result_int = sub_result;\n        2'b10: result_int = and_result;\n        2'b11: result_int = or_result;\n        default: result_int = 32'b0;\n    endcase\nend\n\nassign result = result_int;\nassign zero = (result_int == 32'b0);\n\nendmodule\n\nmodule u_adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule u_subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule u_and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\nassign and_out = a & b;\nendmodule\n\nmodule u_or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\nassign or_out = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] out\n);\n    assign out = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] out\n);\n    assign out = a ^ b;\nendmodule\n\nmodule multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n    wire [31:0] adder_result;\n    wire [31:0] subtractor_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    \n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(adder_result)\n    );\n    \n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(subtractor_result)\n    );\n    \n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .out(and_result)\n    );\n    \n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .out(or_result)\n    );\n    \n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .out(xor_result)\n    );\n    \n    reg [31:0] result_reg;\n    \n    always @(*) begin\n        case(op_code)\n            3'b000: result_reg = adder_result;\n            3'b001: result_reg = subtractor_result;\n            3'b010: result_reg = and_result;\n            3'b011: result_reg = or_result;\n            3'b100: result_reg = xor_result;\n            default: result_reg = 32'd0;\n        endcase\n    end\n    \n    assign result = result_reg;\n    assign zero = (result_reg == 32'd0);\n    \nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module adder (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    input  wire        op,  // 0 for AND, 1 for OR\n    output wire [31:0] res\n);\n    assign res = (op == 1'b0) ? (a & b) : (a | b);\nendmodule\n\nmodule configurable_alu (\n    input  wire        clk,\n    input  wire [1:0]  op_code,\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] bitwise_result;\n    \n    // Determine the bitwise operation control: \n    // 0: when op_code == 2'b10 (bitwise AND)\n    // 1: when op_code == 2'b11 (bitwise OR)\n    wire bitwise_op;\n    assign bitwise_op = (op_code == 2'b11) ? 1'b1 : 1'b0;\n    \n    adder u_adder (\n        .a   (operand_a),\n        .b   (operand_b),\n        .sum (add_result)\n    );\n    \n    subtractor u_subtractor (\n        .a    (operand_a),\n        .b    (operand_b),\n        .diff (sub_result)\n    );\n    \n    bitwise_operator u_bitwise_operator (\n        .a   (operand_a),\n        .b   (operand_b),\n        .op  (bitwise_op),\n        .res (bitwise_result)\n    );\n    \n    reg [31:0] result_reg;\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result_reg <= add_result;\n            2'b01: result_reg <= sub_result;\n            2'b10,\n            2'b11: result_reg <= bitwise_result;\n            default: result_reg <= 32'b0;\n        endcase\n    end\n    \n    assign result = result_reg;\n\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        y_bit,\n    output [15:0] partial\n);\n    assign partial = y_bit ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n    \n    gen_product #(.SHIFT(0)) gp0 (.X(X), .y_bit(Y[0]), .partial(pp0));\n    gen_product #(.SHIFT(1)) gp1 (.X(X), .y_bit(Y[1]), .partial(pp1));\n    gen_product #(.SHIFT(2)) gp2 (.X(X), .y_bit(Y[2]), .partial(pp2));\n    gen_product #(.SHIFT(3)) gp3 (.X(X), .y_bit(Y[3]), .partial(pp3));\n    gen_product #(.SHIFT(4)) gp4 (.X(X), .y_bit(Y[4]), .partial(pp4));\n    gen_product #(.SHIFT(5)) gp5 (.X(X), .y_bit(Y[5]), .partial(pp5));\n    gen_product #(.SHIFT(6)) gp6 (.X(X), .y_bit(Y[6]), .partial(pp6));\n    gen_product #(.SHIFT(7)) gp7 (.X(X), .y_bit(Y[7]), .partial(pp7));\n    \n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift #(parameter SHIFT = 0) (\n    input  [7:0]   X,\n    input  [15:0]  acc_in,\n    input          y_bit,\n    output [15:0]  acc_out\n);\n    assign acc_out = acc_in + (y_bit ? ({8'b0, X} << SHIFT) : 16'b0);\nendmodule\n\nmodule mult_8bit(\n    input  [7:0]  X,\n    input  [7:0]  Y,\n    output [15:0] P\n);\n    wire [15:0] acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7;\n\n    add_shift #(.SHIFT(0)) AS0 (\n        .X(X),\n        .acc_in(16'b0),\n        .y_bit(Y[0]),\n        .acc_out(acc0)\n    );\n\n    add_shift #(.SHIFT(1)) AS1 (\n        .X(X),\n        .acc_in(acc0),\n        .y_bit(Y[1]),\n        .acc_out(acc1)\n    );\n\n    add_shift #(.SHIFT(2)) AS2 (\n        .X(X),\n        .acc_in(acc1),\n        .y_bit(Y[2]),\n        .acc_out(acc2)\n    );\n\n    add_shift #(.SHIFT(3)) AS3 (\n        .X(X),\n        .acc_in(acc2),\n        .y_bit(Y[3]),\n        .acc_out(acc3)\n    );\n\n    add_shift #(.SHIFT(4)) AS4 (\n        .X(X),\n        .acc_in(acc3),\n        .y_bit(Y[4]),\n        .acc_out(acc4)\n    );\n\n    add_shift #(.SHIFT(5)) AS5 (\n        .X(X),\n        .acc_in(acc4),\n        .y_bit(Y[5]),\n        .acc_out(acc5)\n    );\n\n    add_shift #(.SHIFT(6)) AS6 (\n        .X(X),\n        .acc_in(acc5),\n        .y_bit(Y[6]),\n        .acc_out(acc6)\n    );\n\n    add_shift #(.SHIFT(7)) AS7 (\n        .X(X),\n        .acc_in(acc6),\n        .y_bit(Y[7]),\n        .acc_out(acc7)\n    );\n\n    assign P = acc7;\n    \nendmodule"}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n\n    wire [3:0] adder_result;\n    wire [3:0] subtractor_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .result(adder_result)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .result(subtractor_result)\n    );\n\n    and_logical u_and_logical (\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n\n    or_logical u_or_logical (\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result <= adder_result;\n            2'b01: result <= subtractor_result;\n            2'b10: result <= and_result;\n            2'b11: result <= or_result;\n            default: result <= 4'b0000;\n        endcase\n    end\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n    \n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n    \n    and_module u_and (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n    \n    or_module u_or (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n    \n    always @(*) begin\n        case(op)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": ""}
{"task_id": "stagepipe3_v_21", "response": "module add_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule sub_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule mul_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule div_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] result,\n    output valid\n);\n    assign valid  = (b != 0);\n    assign result = (b != 0) ? (a / b) : 16'b0;\nendmodule\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n    wire        div_valid;\n\n    add_module u_add (\n        .a(data_a),\n        .b(data_b),\n        .result(add_result)\n    );\n\n    sub_module u_sub (\n        .a(data_a),\n        .b(data_b),\n        .result(sub_result)\n    );\n\n    mul_module u_mul (\n        .a(data_a),\n        .b(data_b),\n        .result(mul_result)\n    );\n\n    div_module u_div (\n        .a(data_a),\n        .b(data_b),\n        .result(div_result),\n        .valid(div_valid)\n    );\n\n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 16'b0;\n            valid  <= 1'b0;\n        end else begin\n            case (opcode)\n                2'b00: begin\n                    result <= add_result;\n                    valid  <= 1'b1;\n                end\n                2'b01: begin\n                    result <= sub_result;\n                    valid  <= 1'b1;\n                end\n                2'b10: begin\n                    result <= mul_result;\n                    valid  <= 1'b1;\n                end\n                2'b11: begin\n                    result <= div_result;\n                    valid  <= div_valid;\n                end\n                default: begin\n                    result <= 16'b0;\n                    valid  <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n    input  [3:0] A, B;\n    output       gt, lt, eq;\n    \n    wire gt3, lt3, eq3;\n    wire gt2, lt2, eq2;\n    wire gt1, lt1, eq1;\n    wire gt0, lt0, eq0;\n    \n    bit_compare bc3 (\n        .a(A[3]),\n        .b(B[3]),\n        .gt(gt3),\n        .lt(lt3),\n        .eq(eq3)\n    );\n    \n    bit_compare bc2 (\n        .a(A[2]),\n        .b(B[2]),\n        .gt(gt2),\n        .lt(lt2),\n        .eq(eq2)\n    );\n    \n    bit_compare bc1 (\n        .a(A[1]),\n        .b(B[1]),\n        .gt(gt1),\n        .lt(lt1),\n        .eq(eq1)\n    );\n    \n    bit_compare bc0 (\n        .a(A[0]),\n        .b(B[0]),\n        .gt(gt0),\n        .lt(lt0),\n        .eq(eq0)\n    );\n    \n    assign gt = gt3 || (eq3 && gt2) || (eq3 && eq2 && gt1) || (eq3 && eq2 && eq1 && gt0);\n    assign lt = lt3 || (eq3 && lt2) || (eq3 && eq2 && lt1) || (eq3 && eq2 && eq1 && lt0);\n    assign eq = eq3 && eq2 && eq1 && eq0;\n    \nendmodule\n\nmodule bit_compare(input a, input b, output gt, output lt, output eq);\n    assign gt = a & ~b;\n    assign lt = ~a & b;\n    assign eq = ~(a ^ b);\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module bitwise_and(a, b, result);\n  input [3:0] a;\n  input [3:0] b;\n  output [3:0] result;\n  assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n  input [3:0] a;\n  input [3:0] b;\n  output [3:0] result;\n  assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, sum, carry);\n  input [3:0] a;\n  input [3:0] b;\n  output [3:0] sum;\n  output carry;\n  assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, diff, borrow);\n  input [3:0] a;\n  input [3:0] b;\n  output [3:0] diff;\n  output borrow;\n  assign diff = a - b;\n  assign borrow = (a < b) ? 1'b1 : 1'b0;\nendmodule\n\nmodule simple_alu(a, b, op, result, carry_borrow);\n  input [3:0] a;\n  input [3:0] b;\n  input [1:0] op;\n  output reg [3:0] result;\n  output reg carry_borrow;\n  \n  wire [3:0] and_result;\n  wire [3:0] or_result;\n  wire [3:0] add_result;\n  wire add_carry;\n  wire [3:0] sub_result;\n  wire sub_borrow;\n  \n  bitwise_and u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n  );\n  \n  bitwise_or u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n  );\n  \n  adder_4bit u_add (\n    .a(a),\n    .b(b),\n    .sum(add_result),\n    .carry(add_carry)\n  );\n  \n  subtractor_4bit u_sub (\n    .a(a),\n    .b(b),\n    .diff(sub_result),\n    .borrow(sub_borrow)\n  );\n  \n  always @(*) begin\n    case(op)\n      2'b00: begin\n        result = and_result;\n        carry_borrow = 1'b0;\n      end\n      2'b01: begin\n        result = or_result;\n        carry_borrow = 1'b0;\n      end\n      2'b10: begin\n        result = add_result;\n        carry_borrow = add_carry;\n      end\n      2'b11: begin\n        result = sub_result;\n        carry_borrow = sub_borrow;\n      end\n      default: begin\n        result = 4'b0;\n        carry_borrow = 1'b0;\n      end\n    endcase\n  end\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n  input  [7:0] temp_sensor;\n  input        smoke_sensor;\n  output       alarm_out;\n  \n  wire temp_trigger;\n  \n  compare_temp comp_inst (\n    .temp_sensor(temp_sensor),\n    .temp_trigger(temp_trigger)\n  );\n  \n  or_logic or_inst (\n    .a(temp_trigger),\n    .b(smoke_sensor),\n    .alarm(alarm_out)\n  );\nendmodule\n\nmodule compare_temp (temp_sensor, temp_trigger);\n  input  [7:0] temp_sensor;\n  output       temp_trigger;\n  \n  parameter THRESHOLD = 8'd100;\n  \n  assign temp_trigger = (temp_sensor > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic (a, b, alarm);\n  input  a;\n  input  b;\n  output alarm;\n  \n  assign alarm = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": ""}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(\n    input  [7:0] data,\n    output       p\n);\n    assign p = ^data;\nendmodule\n\nmodule parity_16bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output       P\n);\n    wire p1, p2;\n\n    parity_8bit gen1 (.data(X), .p(p1));\n    parity_8bit gen2 (.data(Y), .p(p2));\n\n    assign P = p1 ^ p2;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module cla_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input Cin,\n    output [3:0] S,\n    output Cout\n);\n    wire [3:0] p, g;\n    wire [3:0] c;\n    \n    assign p = A ^ B;\n    assign g = A & B;\n    \n    assign c[0] = Cin;\n    assign c[1] = g[0] | (p[0] & c[0]);\n    assign c[2] = g[1] | (p[1] & g[0]) | (p[1] & p[0] & c[0]);\n    assign c[3] = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & c[0]);\n    assign Cout = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & c[0]);\n    \n    assign S = p ^ c;\nendmodule\n\nmodule add_16bit(\n    input [16:1] A,\n    input [16:1] B,\n    output [16:1] S,\n    output C_out\n);\n    wire c1, c2, c3;\n    \n    cla_4bit u0(.A(A[4:1]),   .B(B[4:1]),   .Cin(1'b0), .S(S[4:1]),   .Cout(c1));\n    cla_4bit u1(.A(A[8:5]),   .B(B[8:5]),   .Cin(c1),   .S(S[8:5]),   .Cout(c2));\n    cla_4bit u2(.A(A[12:9]),  .B(B[12:9]),  .Cin(c2),   .S(S[12:9]),  .Cout(c3));\n    cla_4bit u3(.A(A[16:13]), .B(B[16:13]), .Cin(c3),   .S(S[16:13]), .Cout(C_out));\nendmodule"}
{"task_id": "systolic1x4_v_30", "response": "module parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n  \n  adder_unit au0 (\n    .a(a0),\n    .b(b0),\n    .sum(sum0)\n  );\n  \n  adder_unit au1 (\n    .a(a1),\n    .b(b1),\n    .sum(sum1)\n  );\n  \n  adder_unit au2 (\n    .a(a2),\n    .b(b2),\n    .sum(sum2)\n  );\n  \n  adder_unit au3 (\n    .a(a3),\n    .b(b3),\n    .sum(sum3)\n  );\n  \nendmodule\n\nmodule adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n\n  assign sum = a + b;\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'd0;\n        else\n            result <= a * b;\n    end\nendmodule\n\nmodule matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n    multiplier mult0(\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .result(p0)\n    );\n    \n    multiplier mult1(\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .result(p1)\n    );\n    \n    multiplier mult2(\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .result(p2)\n    );\n    \n    multiplier mult3(\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .result(p3)\n    );\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module left_rotate(\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  wire [3:0] left_result;\n  wire [3:0] right_result;\n  \n  left_rotate lr (\n    .in_data(in_data),\n    .out_data(left_result)\n  );\n  \n  right_rotate rr (\n    .in_data(in_data),\n    .out_data(right_result)\n  );\n  \n  assign out_data = en ? (rot_dir ? left_result : right_result) : in_data;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 8'd1;\n      else\n        count <= count - 8'd1;\n    end\n  end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .q(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .q(out1)\n    );\n\nendmodule\n\nmodule shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] q\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            q <= 8'b0;\n        else if (load)\n            q <= data;\n        else if (shift)\n            q <= {1'b0, q[7:1]};\n        else\n            q <= q;\n    end\n\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_32bit(\n    input [31:0] X,\n    input [31:0] Y,\n    output [31:0] Sum,\n    output Carry_out\n);\n\n    wire c1, c2, c3;\n    \n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Cin(1'b0),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n    \n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n    \n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n    \n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Carry_out)\n    );\n    \nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,\n    input [7:0] Y,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n\n    wire [8:0] c;\n    assign c[0] = Cin;\n\n    genvar i;\n    generate\n        for(i = 0; i < 8; i = i + 1) begin : adder_bit\n            full_adder FA (\n                .a(X[i]),\n                .b(Y[i]),\n                .cin(c[i]),\n                .sum(Sum[i]),\n                .cout(c[i+1])\n            );\n        end\n    endgenerate\n    assign Cout = c[8];\n    \nendmodule\n\nmodule full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    \n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\n    \nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "`timescale 1ns / 1ps\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n    wire c1, c2, c3;\n\n    adder_8bit u_adder0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n\n    adder_8bit u_adder1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n\n    adder_8bit u_adder2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n\n    adder_8bit u_adder3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule`"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result, sub_result, and_result;\n    wire add_carry, sub_carry;\n\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry(sub_carry)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    reg [31:0] result_mux;\n    reg carry_mux;\n\n    always @(*) begin\n        case(op)\n            2'b00: begin\n                result_mux = add_result;\n                carry_mux  = add_carry;\n            end\n            2'b01: begin\n                result_mux = sub_result;\n                carry_mux  = sub_carry;\n            end\n            2'b10: begin\n                result_mux = and_result;\n                carry_mux  = 1'b0;\n            end\n            default: begin\n                result_mux = 32'b0;\n                carry_mux  = 1'b0;\n            end\n        endcase\n    end\n\n    assign result = result_mux;\n    assign carry_out = carry_mux;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry\n);\n    assign {carry, result} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result,\n    output carry\n);\n    assign {carry, result} = A + (~B) + 1;\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux_path0(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= d;\n    end\nendmodule\n\nmodule mux_path1(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= d;\n    end\nendmodule\n\nmodule mux_path2(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= d;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n    wire [7:0] data0;\n    wire [7:0] data1;\n    wire [7:0] data2;\n\n    mux_path0 u0 (\n        .clk(clk),\n        .d(d0),\n        .data_out(data0)\n    );\n\n    mux_path1 u1 (\n        .clk(clk),\n        .d(d1),\n        .data_out(data1)\n    );\n\n    mux_path2 u2 (\n        .clk(clk),\n        .d(d2),\n        .data_out(data2)\n    );\n\n    assign data_out = (sel == 3'b000) ? data0 :\n                      (sel == 3'b001) ? data1 :\n                      (sel == 3'b010) ? data2 : 8'd0;\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold (\n    input clk,\n    input en,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (en)\n            q <= d;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n    \n    wire en0 = (sel == 2'b00);\n    wire en1 = (sel == 2'b01);\n    wire en2 = (sel == 2'b10);\n    wire en3 = (sel == 2'b11);\n    \n    hold hold0 (\n        .clk(clk),\n        .en(en0),\n        .d(in0),\n        .q(hold0_out)\n    );\n    \n    hold hold1 (\n        .clk(clk),\n        .en(en1),\n        .d(in1),\n        .q(hold1_out)\n    );\n    \n    hold hold2 (\n        .clk(clk),\n        .en(en2),\n        .d(in2),\n        .q(hold2_out)\n    );\n    \n    hold hold3 (\n        .clk(clk),\n        .en(en3),\n        .d(in3),\n        .q(hold3_out)\n    );\n    \n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out :\n                 hold3_out;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n    always @(posedge clk) begin\n        if (reset)\n            count <= 16'd0;\n        else if (count >= (freq - 1))\n            count <= 16'd0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n    wire [15:0] threshold;\n    assign threshold = (freq * duty_cycle) / 100;\n\n    always @(posedge clk) begin\n        if(count < threshold)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule\n\nmodule pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n    wire [15:0] pwm_count;\n\n    pwm_counter counter_inst (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(pwm_count)\n    );\n\n    pwm_signal signal_inst (\n        .clk(clk),\n        .count(pwm_count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n  wire [7:0] adjusted_duty;\n\n  duty_ctrl u_duty_ctrl (\n    .clk(clk),\n    .duty_cycle(duty_cycle),\n    .adjusted_duty(adjusted_duty)\n  );\n\n  pulse_gen u_pulse_gen (\n    .clk(clk),\n    .duty_cycle(adjusted_duty),\n    .pwm_out(pwm_out)\n  );\n  \nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n  always @(posedge clk) begin\n    adjusted_duty <= duty_cycle;\n  end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n  reg [7:0] counter;\n  \n  always @(posedge clk) begin\n    if(counter == 8'd255)\n      counter <= 8'd0;\n    else\n      counter <= counter + 1;\n    \n    if(counter < duty_cycle)\n      pwm_out <= 1'b1;\n    else\n      pwm_out <= 1'b0;\n  end\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire eq\n);\n    assign eq = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .eq(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .eq(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .eq(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .eq(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout[0] = din[7];\n    assign dout[1] = din[6];\n    assign dout[2] = din[5];\n    assign dout[3] = din[4];\n    assign dout[4] = din[3];\n    assign dout[5] = din[2];\n    assign dout[6] = din[1];\n    assign dout[7] = din[0];\nendmodule\n\nmodule bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] mid;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(mid)\n    );\n\n    bit_reverse br2 (\n        .din(mid),\n        .dout(dout)\n    );\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule adder_selector (\n    input  [7:0] a,\n    input  [7:0] b,\n    input        ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] adder_result;\n\n    my_adder8 u1 (\n        .a(a),\n        .b(b),\n        .sum(adder_result)\n    );\n\n    always @(*) begin\n        if (ctrl)\n            sum = adder_result;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n  pwm_module_25 u_pwm_25 (\n    .clk(CLK_in),\n    .rst(RST),\n    .pwm(PWM_25)\n  );\n\n  pwm_module_50 u_pwm_50 (\n    .clk(CLK_in),\n    .rst(RST),\n    .pwm(PWM_50)\n  );\n\n  pwm_module_75 u_pwm_75 (\n    .clk(CLK_in),\n    .rst(RST),\n    .pwm(PWM_75)\n  );\n\nendmodule\n\nmodule pwm_module_25 (\n    input clk,\n    input rst,\n    output reg pwm\n);\n  parameter PERIOD = 100;\n  parameter THRESHOLD = 25;\n  reg [6:0] count;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n      pwm   <= 1'b0;\n    end else begin\n      if (count < PERIOD - 1)\n        count <= count + 1;\n      else\n        count <= 0;\n      pwm <= (count < THRESHOLD) ? 1'b1 : 1'b0;\n    end\n  end\nendmodule\n\nmodule pwm_module_50 (\n    input clk,\n    input rst,\n    output reg pwm\n);\n  parameter PERIOD = 100;\n  parameter THRESHOLD = 50;\n  reg [6:0] count;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n      pwm   <= 1'b0;\n    end else begin\n      if (count < PERIOD - 1)\n        count <= count + 1;\n      else\n        count <= 0;\n      pwm <= (count < THRESHOLD) ? 1'b1 : 1'b0;\n    end\n  end\nendmodule\n\nmodule pwm_module_75 (\n    input clk,\n    input rst,\n    output reg pwm\n);\n  parameter PERIOD = 100;\n  parameter THRESHOLD = 75;\n  reg [6:0] count;\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n      pwm   <= 1'b0;\n    end else begin\n      if (count < PERIOD - 1)\n        count <= count + 1;\n      else\n        count <= 0;\n      pwm <= (count < THRESHOLD) ? 1'b1 : 1'b0;\n    end\n  end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n  wire pwm_25_signal;\n  wire pwm_50_signal;\n  wire pwm_75_signal;\n\n  pwm_duty_25 u_pwm_duty_25 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(pwm_25_signal)\n  );\n\n  pwm_duty_50 u_pwm_duty_50 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(pwm_50_signal)\n  );\n\n  pwm_duty_75 u_pwm_duty_75 (\n    .CLK_in(CLK_in),\n    .RST(RST),\n    .PWM_out(pwm_75_signal)\n  );\n\n  assign PWM_25 = pwm_25_signal;\n  assign PWM_50 = pwm_50_signal;\n  assign PWM_75 = pwm_75_signal;\n\nendmodule\n\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n  parameter MAX_COUNT = 100;\n  parameter HIGH_COUNT = MAX_COUNT / 4;  // 25% duty cycle\n  localparam COUNTER_WIDTH = 7;\n\n  reg [COUNTER_WIDTH-1:0] counter;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n      counter  <= 0;\n      PWM_out  <= 1'b0;\n    end else begin\n      if (counter == MAX_COUNT - 1)\n        counter <= 0;\n      else\n        counter <= counter + 1;\n      PWM_out <= (counter < HIGH_COUNT) ? 1'b1 : 1'b0;\n    end\n  end\nendmodule\n\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n  parameter MAX_COUNT = 100;\n  parameter HIGH_COUNT = MAX_COUNT / 2;  // 50% duty cycle\n  localparam COUNTER_WIDTH = 7;\n\n  reg [COUNTER_WIDTH-1:0] counter;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n      counter  <= 0;\n      PWM_out  <= 1'b0;\n    end else begin\n      if (counter == MAX_COUNT - 1)\n        counter <= 0;\n      else\n        counter <= counter + 1;\n      PWM_out <= (counter < HIGH_COUNT) ? 1'b1 : 1'b0;\n    end\n  end\nendmodule\n\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n  parameter MAX_COUNT = 100;\n  parameter HIGH_COUNT = (MAX_COUNT * 3) / 4;  // 75% duty cycle\n  localparam COUNTER_WIDTH = 7;\n\n  reg [COUNTER_WIDTH-1:0] counter;\n\n  always @(posedge CLK_in or posedge RST) begin\n    if (RST) begin\n      counter  <= 0;\n      PWM_out  <= 1'b0;\n    end else begin\n      if ("}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller #(\n    parameter DUTY_CYCLE = 50,\n    parameter MAX_COUNT  = 100\n)(\n    input  clk,\n    input  rst_n,\n    output pwm_out\n);\n\n  localparam COUNTER_WIDTH = $clog2(MAX_COUNT+1);\n  localparam THRESHOLD     = (DUTY_CYCLE * (MAX_COUNT+1)) / 100;\n\n  wire [COUNTER_WIDTH-1:0] count;\n\n  counter #(\n    .MAX_COUNT(MAX_COUNT),\n    .COUNTER_WIDTH(COUNTER_WIDTH)\n  ) u_counter (\n    .clk   (clk),\n    .rst_n (rst_n),\n    .count (count)\n  );\n\n  comparator #(\n    .WIDTH(COUNTER_WIDTH)\n  ) u_comparator (\n    .count     (count),\n    .threshold (THRESHOLD),\n    .pwm       (pwm_out)\n  );\n\nendmodule\n\nmodule counter #(\n  parameter MAX_COUNT     = 100,\n  parameter COUNTER_WIDTH = 7\n)(\n  input              clk,\n  input              rst_n,\n  output reg [COUNTER_WIDTH-1:0] count\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      count <= 0;\n    else if (count == MAX_COUNT)\n      count <= 0;\n    else\n      count <= count + 1;\n  end\n\nendmodule\n\nmodule comparator #(\n  parameter WIDTH = 7\n)(\n  input  [WIDTH-1:0] count,\n  input  [WIDTH-1:0] threshold,\n  output             pwm\n);\n\n  assign pwm = (count < threshold);\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input  [31:0] a,\n    input  [31:0] b,\n    input         multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output        zero\n);\n    wire [63:0] res_signed;\n    wire [63:0] res_unsigned;\n\n    mult_signed u_mult_signed (\n        .a(a),\n        .b(b),\n        .y(res_signed)\n    );\n\n    mult_unsigned u_mult_unsigned (\n        .a(a),\n        .b(b),\n        .y(res_unsigned)\n    );\n\n    assign y   = (multc == 1'b0) ? res_signed : res_unsigned;\n    assign msb = y[63:32];\n    assign lsb = y[31:0];\n    assign zero = (y == 64'd0) ? 1'b1 : 1'b0;\nendmodule\n\nmodule mult_signed(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\nmodule mult_unsigned(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module count_control (\n    input        clk,\n    input        rst,\n    input        en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst)\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= (count == 4'b1111) ? 4'b0000 : count + 1;\n        else\n            count <= count;\nendmodule\n\nmodule overflow_detection (\n    input        clk,\n    input        rst,\n    input  [3:0] count,\n    output reg   overflow\n);\n    reg [3:0] prev_count;\n    always @(posedge clk or posedge rst)\n        if (rst) begin\n            prev_count <= 4'b0000;\n            overflow   <= 1'b0;\n        end else begin\n            if (prev_count == 4'b1111 && count == 4'b0000)\n                overflow <= 1'b1;\n            else\n                overflow <= 1'b0;\n            prev_count <= count;\n        end\nendmodule\n\nmodule binary_up_counter (\n    input        clk,\n    input        rst,\n    input        en,\n    output [3:0] count_out,\n    output       overflow\n);\n    wire [3:0] count;\n    \n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count)\n    );\n    \n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .count(count),\n        .overflow(overflow)\n    );\n    \n    assign count_out = count;\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\nadd add_inst (\n    .a(operand_a),\n    .b(operand_b),\n    .y(add_result)\n);\n\nsubtract subtract_inst (\n    .a(operand_a),\n    .b(operand_b),\n    .y(sub_result)\n);\n\nbitwise_and bitwise_and_inst (\n    .a(operand_a),\n    .b(operand_b),\n    .y(and_result)\n);\n\nbitwise_or bitwise_or_inst (\n    .a(operand_a),\n    .b(operand_b),\n    .y(or_result)\n);\n\nalways @(posedge clk) begin\n    if (rst)\n        result <= 32'b0;\n    else begin\n        case (op_code)\n            2'b00: result <= add_result;\n            2'b01: result <= sub_result;\n            2'b10: result <= and_result;\n            2'b11: result <= or_result;\n            default: result <= 32'b0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule add(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] y\n);\nassign y = a + b;\nendmodule\n\nmodule subtract(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] y\n);\nassign y = a - b;\nendmodule\n\nmodule bitwise_and(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] y\n);\nassign y = a & b;\nendmodule\n\nmodule bitwise_or(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] y\n);\nassign y = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": ""}
{"task_id": "adder_32bit_v_54", "response": ""}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\nwire q0, q1, q2;\nwire t0 = 1'b1;\nwire t1 = q0;\nwire t2 = q0 & q1;\n\nmy_tff u0 (\n    .clk(clk),\n    .reset(reset),\n    .t(t0),\n    .q(q0)\n);\n\nmy_tff u1 (\n    .clk(clk),\n    .reset(reset),\n    .t(t1),\n    .q(q1)\n);\n\nmy_tff u2 (\n    .clk(clk),\n    .reset(reset),\n    .t(t2),\n    .q(q2)\n);\n\nassign count = {q2, q1, q0};\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module counter_init (\n    input wire reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule counter_increment (\n    input wire [3:0] current,\n    output wire [3:0] next\n);\n    assign next = current + 4'd1;\nendmodule\n\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] out\n);\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n    \n    counter_init init_inst (\n        .reset(reset),\n        .init_val(init_val)\n    );\n    \n    counter_increment inc_inst (\n        .current(out),\n        .next(inc_val)\n    );\n    \n    always @(posedge clk) begin\n        if (reset)\n            out <= init_val;\n        else\n            out <= inc_val;\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    u_counter_logic u_counter_logic_inst (\n        .count(count),\n        .up_down(up_down),\n        .next_count(next_count)\n    );\n\n    u_counter_register u_counter_register_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(next_count),\n        .q(count)\n    );\n\nendmodule\n\nmodule u_counter_logic (\n    input wire [15:0] count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? (count + 1) : (count - 1);\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] d,\n    output reg [15:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 16'd0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input  wire       clk,\n    input  wire       reset,\n    output wire [7:0] out\n);\n    reg [7:0] state;\n    wire [7:0] init_state;\n    wire [7:0] next_state;\n    \n    ring_counter_init init_inst (\n        .reset(reset),\n        .init_out(init_state)\n    );\n    \n    ring_counter_transition trans_inst (\n        .state_in(state),\n        .state_out(next_state)\n    );\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= init_state;\n        else\n            state <= next_state;\n    end\n\n    assign out = state;\n    \nendmodule\n\nmodule ring_counter_init (\n    input  wire       reset,\n    output wire [7:0] init_out\n);\n    assign init_out = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition (\n    input  wire [7:0] state_in,\n    output wire [7:0] state_out\n);\n    assign state_out = {state_in[6:0], state_in[7]};\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .data_in(count),\n        .data_out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1'b1;\n        end\n    end\n\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            data_out <= 4'b0000;\n        else if (valid_count)\n            data_out <= data_in;\n    end\n\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    clk_div_2 div2_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n    \n    clk_div_10 div10_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n    \n    clk_div_100 div100_inst (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 1'b0;\n        else\n            CLK_out <= ~CLK_out;\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 3'd0;\n            CLK_out <= 1'b0;\n        end else begin\n            if (count == 3'd4) begin\n                count <= 3'd0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count <= 6'd0;\n            CLK_out <= 1'b0;\n        end else begin\n            if (count == 6'd49) begin\n                count <= 6'd0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": ""}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4;\n    localparam HALF_DIV = NUM_DIV/2;\n\n    wire tick;\n\n    u_counter #(.HALF_DIV(HALF_DIV)) counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n\n    u_clk_divider clk_div_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n    \nendmodule\n\nmodule u_counter #(\n    parameter HALF_DIV = 2\n)(\n    input clk,\n    input rst_n,\n    output reg tick\n);\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'b0;\n            tick  <= 1'b0;\n        end\n        else if (count == HALF_DIV - 1) begin\n            count <= 4'b0;\n            tick  <= 1'b1;\n        end\n        else begin\n            count <= count + 1;\n            tick  <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n    wire [63:0] product;\n\n    u_multiplier mul_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n\n    u_accumulator acc_inst (\n        .clk(clk),\n        .rst(rst),\n        .d(product[31:0]),\n        .acc(c)\n    );\n\nendmodule\n\nmodule u_multiplier(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [63:0] product\n);\n    always @(posedge clk) begin\n        if (rst)\n            product <= 64'd0;\n        else\n            product <= a * b;\n    end\nendmodule\n\nmodule u_accumulator(\n    input clk,\n    input rst,\n    input [31:0] d,\n    output reg [31:0] acc\n);\n    always @(posedge clk) begin\n        if (rst)\n            acc <= 32'd0;\n        else\n            acc <= acc + d;\n    end\nendmodule"}
{"task_id": "instr_reg", "response": "module ins_p1(\n    input       clk,\n    input       rst,\n    input       en,\n    input [7:0] data,\n    output reg [7:0] q\n);\n  always @(posedge clk or negedge rst)\n    if (!rst)\n      q <= 8'b0;\n    else if (en)\n      q <= data;\nendmodule\n\nmodule ins_p2(\n    input       clk,\n    input       rst,\n    input       en,\n    input [7:0] data,\n    output reg [7:0] q\n);\n  always @(posedge clk or negedge rst)\n    if (!rst)\n      q <= 8'b0;\n    else if (en)\n      q <= data;\nendmodule\n\nmodule instr_reg (\n    input       clk,\n    input       rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n  wire p1_en = (fetch == 2'b01);\n  wire p2_en = (fetch == 2'b10);\n\n  wire [7:0] p1_out;\n  wire [7:0] p2_out;\n\n  ins_p1 u_ins_p1 (\n      .clk(clk),\n      .rst(rst),\n      .en(p1_en),\n      .data(data),\n      .q(p1_out)\n  );\n\n  ins_p2 u_ins_p2 (\n      .clk(clk),\n      .rst(rst),\n      .en(p2_en),\n      .data(data),\n      .q(p2_out)\n  );\n\n  assign ins = p1_out[7:5];\n  assign ad1 = p1_out[4:0];\n  assign ad2 = p2_out;\n\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq != 8'd0);\n\n    counter u_counter (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator u_wave_generator (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n    \nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if(enable) begin\n            if(count == (freq - 1))\n                count <= 8'd0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial wave_out = 1'b0;\n    \n    always @(posedge clk) begin\n        if(count == (freq - 1))\n            wave_out <= ~wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module state_control (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [1:0]"}
{"task_id": "shift8", "response": "module my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] dff0_q;\n    wire [7:0] dff1_q;\n    wire [7:0] dff2_q;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(dff0_q)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(dff0_q),\n        .q(dff1_q)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(dff1_q),\n        .q(dff2_q)\n    );\n\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = dff0_q;\n            2'b10: q = dff1_q;\n            2'b11: q = dff2_q;\n            default: q = 8'd0;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n    wire q0, q1;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q)\n    );\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "`timescale 1ns/1ps\nmodule pe (\n  input         clk,\n  input         rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + a * b;\n  end\nendmodule\n\nmodule systolic1x2 (\n  input         clk,\n  input         rst,\n  input  [15:0] a0,\n  input  [15:0] a1,\n  input  [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule`"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe (\n  input         clk,\n  input         rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 32'b0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x4(\n  input         clk,\n  input         rst,\n  input  [15:0] a0,\n  input  [15:0] a1,\n  input  [15:0] a2,\n  input  [15:0] a3,\n  input  [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  reg [15:0] b1, b2, b3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n    end \n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  pe pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  pe pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n    wire [31:0] prep_A;\n    wire [31:0] prep_B;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend u_prep (\n        .dividend(A),\n        .divisor(B),\n        .prep_A(prep_A),\n        .prep_B(prep_B)\n    );\n\n    div_operation u_div_op (\n        .prep_A(prep_A),\n        .prep_B(prep_B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd    = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] dividend,\n    input  wire [15:0] divisor,\n    output wire [31:0] prep_A,\n    output wire [31:0] prep_B\n);\n    assign prep_A = dividend;\n    assign prep_B = {16'b0, divisor};\nendmodule\n\nmodule div_operation(\n    input  wire [31:0] prep_A,\n    input  wire [31:0] prep_B,\n    output reg  [31:0] quotient,\n    output reg  [31:0] remainder\n);\n    integer i;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n    \n   "}
{"task_id": "div_16bit", "response": "module div_ctrl (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output reg  [15:0] quotient,\n    output reg  [15:0] remainder\n);\n    integer i;\n    reg [15:0] temp_remainder;\n    reg [15:0] temp_quotient;\n    \n    always @(*) begin\n        temp_remainder = 16'b0;\n        temp_quotient  = 16'b0;\n        for (i = 15; i >= 0; i = i - 1) begin\n            temp_remainder = {temp_remainder[14:0], A[i]};\n            if (temp_remainder >= {8'b0, B}) begin\n                temp_remainder = temp_remainder - {8'b0, B};\n                temp_quotient[i] = 1'b1;\n            end else begin\n                temp_quotient[i] = 1'b0;\n            end\n        end\n        quotient  = temp_quotient;\n        remainder = temp_remainder;\n    end\nendmodule\n\nmodule div_16bit (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n);\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n    \n    div_ctrl ctrl_inst (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n    \n    assign result = quotient;\n    assign odd    = remainder;\nendmodule"}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input c_in,\n    output sum,\n    output c_out\n);\n  assign sum = a ^ b ^ c_in;\n  assign c_out = (a & b) | (a & c_in) | (b & c_in);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n  wire [6:0] carry;\n  \n  full_adder fa0(.a(A[0]), .b(B[0]), .c_in(Cin),     .sum(Sum[0]), .c_out(carry[0]));\n  full_adder fa1(.a(A[1]), .b(B[1]), .c_in(carry[0]),  .sum(Sum[1]), .c_out(carry[1]));\n  full_adder fa2(.a(A[2]), .b(B[2]), .c_in(carry[1]),  .sum(Sum[2]), .c_out(carry[2]));\n  full_adder fa3(.a(A[3]), .b(B[3]), .c_in(carry[2]),  .sum(Sum[3]), .c_out(carry[3]));\n  full_adder fa4(.a(A[4]), .b(B[4]), .c_in(carry[3]),  .sum(Sum[4]), .c_out(carry[4]));\n  full_adder fa5(.a(A[5]), .b(B[5]), .c_in(carry[4]),  .sum(Sum[5]), .c_out(carry[5]));\n  full_adder fa6(.a(A[6]), .b(B[6]), .c_in(carry[5]),  .sum(Sum[6]), .c_out(carry[6]));\n  full_adder fa7(.a(A[7]), .b(B[7]), .c_in(carry[6]),  .sum(Sum[7]), .c_out(Cout));\nendmodule\n\nmodule sub_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output"}
{"task_id": "sub_32bit", "response": "module sub_16bit(A, B, Bin, Diff, Bout);\n  input  [15:0] A, B;\n  input         Bin;\n  output [15:0] Diff;\n  output        Bout;\n  \n  assign Diff = A - B - Bin;\n  assign Bout = (A < (B + Bin));\nendmodule\n\nmodule sub_32bit(A, B, Diff, B_out);\n  input  [31:0] A, B;\n  output [31:0] Diff;\n  output        B_out;\n  \n  wire borrow_lower;\n  \n  sub_16bit u_sub16_lower (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .Bin(1'b0),\n    .Diff(Diff[15:0]),\n    .Bout(borrow_lower)\n  );\n  \n  sub_16bit u_sub16_upper (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .Bin(borrow_lower),\n    .Diff(Diff[31:16]),\n    .Bout(B_out)\n  );\n  \nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_8bit(A, B, borrow_in, D, borrow_out);\n  input  [7:0] A, B;\n  input        borrow_in;\n  output [7:0] D;\n  output       borrow_out;\n\n  assign D = A - B - borrow_in;\n  assign borrow_out = (A < (B + borrow_in));\nendmodule\n\nmodule sub_16bit(A, B, borrow_in, D, borrow_out);\n  input  [15:0] A, B;\n  input         borrow_in;\n  output [15:0] D;\n  output        borrow_out;\n  \n  wire borrow_int;\n\n  sub_8bit u0 (\n    .A(A[7:0]),\n    .B(B[7:0]),\n    .borrow_in(borrow_in),\n    .D(D[7:0]),\n    .borrow_out(borrow_int)\n  );\n\n  sub_8bit u1 (\n    .A(A[15:8]),\n    .B(B[15:8]),\n    .borrow_in(borrow_int),\n    .D(D[15:8]),\n    .borrow_out(borrow_out)\n  );\nendmodule\n\nmodule sub_32bit(A, B, borrow_in, D, borrow_out);\n  input  [31:0] A, B;\n  input         borrow_in;\n  output [31:0] D;\n  output        borrow_out;\n  \n  wire borrow_int;\n\n  sub_16bit u0 (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .borrow_in(borrow_in),\n    .D(D[15:0]),\n    .borrow_out(borrow_int)\n  );\n\n  sub_16bit u1 (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .borrow_in(borrow_int),\n    .D(D[31:16]),\n    .borrow_out(borrow_out)\n  );\nendmodule\n\nmodule sub_64bit(A, B, D, B_out);\n  input  [63:0] A, B;\n  output [63:0] D;\n  output       "}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater,\n    output        A_equal,\n    output        A_less\n);\n\n    wire [31:0] diff;\n    wire        borrow;\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_equal   = (diff == 32'b0);\n    assign A_less    = borrow;\n    assign A_greater = (~borrow) && (diff != 32'b0);\n\nendmodule\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n\n    assign diff = A - B;\n    assign borrow = (A < B);\n\nendmodule"}
{"task_id": "adder_32bit", "response": "module cla_16bit(A, B, Cin, S, Cout);\n    input  [16:1] A, B;\n    input         Cin;\n    output [16:1] S;\n    output        Cout;\n    \n    wire   [16:0] carry;\n    wire   [16:1] p, g;\n    \n    assign carry[1] = Cin;\n    \n    genvar i;\n    generate\n        for(i = 1; i <= 16; i = i + 1) begin: cla_stage\n            assign g[i] = A[i] & B[i];\n            assign p[i] = A[i] ^ B[i];\n            assign carry[i+1] = g[i] | (p[i] & carry[i]);\n            assign S[i] = p[i] ^ carry[i];\n        end\n    endgenerate\n    \n    assign Cout = carry[17];\nendmodule\n\nmodule adder_32bit(A, B, S, C32);\n    input  [32:1] A, B;\n    output [32:1] S;\n    output        C32;\n    \n    wire c16;\n    \n    cla_16bit cla_lower (\n        .A(A[16:1]),\n        .B(B[16:1]),\n        .Cin(1'b0),\n        .S(S[16:1]),\n        .Cout(c16)\n    );\n    \n    cla_16bit cla_upper (\n        .A(A[32:17]),\n        .B(B[32:17]),\n        .Cin(c16),\n        .S(S[32:17]),\n        .Cout(C32)\n    );\nendmodule"}
{"task_id": "adder_16bit_csa", "response": ""}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] sum,\n    output wire Cout\n);\n    assign {Cout, sum} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry_lower;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .sum(y[7:0]),\n        .Cout(carry_lower)\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry_lower),\n        .sum(y[15:8]),\n        .Cout(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        cin,\n    output [7:0] sum,\n    output       cout\n);\n    wire [8:0] carry;\n    assign carry[0] = cin;\n    \n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(carry[0]), .sum(sum[0]), .cout(carry[1]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(carry[1]), .sum(sum[1]), .cout(carry[2]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(carry[2]), .sum(sum[2]), .cout(carry[3]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(carry[3]), .sum(sum[3]), .cout(carry[4]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(carry[4]), .sum(sum[4]), .cout(carry[5]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(carry[5]), .sum(sum[5]), .cout(carry[6]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(carry[6]), .sum(sum[6]), .cout(carry[7]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(carry[7]), .sum(sum[7]), .cout(carry[8]));\n    \n    assign cout = carry[8];\n    \nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module adder(\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\nmodule subtractor(\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule\n\nmodule as_module(\n    input         clk,\n    input         rst,\n    input         mode,\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output reg [31:0] result\n);\n    wire [31:0] adder_result;\n    wire [31:0] subtractor_result;\n    \n    adder u_adder (\n        .op1(op1),\n        .op2(op2),\n        .result(adder_result)\n    );\n    \n    subtractor u_subtractor (\n        .op1(op1),\n        .op2(op2),\n        .result(subtractor_result)\n    );\n    \n    always @(posedge clk) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= (mode == 1'b0) ? adder_result : subtractor_result;\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient\n);\n    always @(posedge clk) begin\n        if (rst)\n            quotient <= 32'd0;\n        else\n            quotient <= (divisor == 32'd0) ? 32'd0 : dividend / divisor;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] minuend,\n    input [31:0] subtrahend,\n    output reg [31:0] difference\n);\n    always @(posedge clk) begin\n        if (rst)\n            difference <= 32'd0;\n        else\n            difference <= minuend - subtrahend;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_result;\n    \n    u_divider u_div_inst(\n        .clk(clk),\n        .rst(rst),\n        .dividend(x),\n        .divisor(y),\n        .quotient(div_result)\n    );\n    \n    u_subtractor u_sub_inst(\n        .clk(clk),\n        .rst(rst),\n        .minuend(div_result),\n        .subtrahend(z),\n        .difference(difference)\n    );\n    \n    assign quotient = div_result;\nendmodule"}
{"task_id": "pe_v_2", "response": "module adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n    wire [31:0] adder_result;\n    wire [31:0] subtractor_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(adder_result)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(subtractor_result)\n    );\n\n    bitwise_and u_and (\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n\n    bitwise_or u_or (\n        .a(a),\n        .b(b),\n        .result(or_result)\n    );\n\n    always @(posedge clk) begin\n        case(op_sel)\n            2'b00: result <= adder_result;\n            2'b01: result <= subtractor_result;\n            2'b10: result <= and_result;\n            2'b11: result <= or_result;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] and_result;\n    \n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    u_bitwise_and u_bitwise_and_inst (\n        .a(a),\n        .b(b),\n        .out(and_result)\n    );\n    \n    always @(posedge clk) begin\n        if (op_sel == 1'b0)\n            result <= add_result;\n        else\n            result <= and_result;\n    end\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module u_adder(\n    input  [15:0] a,\n    input  [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input  [15:0] a,\n    input  [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n\n    u_adder u_adder_inst(\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_subtractor u_subtractor_inst(\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n\n    always @(posedge clk) begin\n        if(rst)\n            result <= 16'd0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire [6:0] borrow;\n\n    full_subtractor FS0(.a(a[0]), .b(b[0]), .bin(bin),      .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1(.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2(.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3(.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4(.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5(.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6(.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7(.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire borrow0, borrow1, borrow2, borrow3, borrow4, borrow5, borrow6;\n    \n    subtractor_1bit sub0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow0)\n    );\n    \n    subtractor_1bit sub1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow0),\n        .diff(diff[1]),\n        .bout(borrow1)\n    );\n    \n    subtractor_1bit sub2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow1),\n        .diff(diff[2]),\n        .bout(borrow2)\n    );\n    \n    subtractor_1bit sub3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow2),\n        .diff(diff[3]),\n        .bout(borrow3)\n    );\n    \n    subtractor_1bit sub4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow3),\n        .diff(diff[4]),\n        .bout(borrow4)\n    );\n    \n    subtractor_1bit sub5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(borrow4),\n        .diff(diff[5]),\n        .bout(borrow5)\n    );\n    \n    subtractor_1bit sub6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(borrow5),\n        .diff(diff[6]),\n        .bout(borrow6)\n    );\n    \n    subtractor_1bit sub7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(borrow6),\n        .diff(diff[7]),\n        .bout(bout)\n    );\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~(a ^ b)) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire [6:0] borrow;\n\n    full_subtractor fs0(.a(a[0]), .b(b[0]), .bin(bin),      .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor fs1(.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor fs2(.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor fs3(.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor fs4(.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor fs5(.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor fs6(.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor fs7(.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] product\n);\n\nassign product = (b[0] ? {4'b0, a}      : 8'b0) +\n                 (b[1] ? ({4'b0, a} << 1) : 8'b0) +\n                 (b[2] ? ({4'b0, a} << 2) : 8'b0) +\n                 (b[3] ? ({4'b0, a} << 3) : 8'b0);\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module toggle_logic (\n    input  wire control_signal,\n    output wire toggle\n);\n  assign toggle = control_signal;\nendmodule\n\nmodule counter_logic (\n    input  wire [31:0] current_count,\n    input  wire        toggle,\n    output wire [31:0] next_count\n);\n  assign next_count = toggle ? (current_count + 32'd1) : 32'd0;\nendmodule\n\nmodule counter_register (\n    input  wire        clk,\n    input  wire        control_signal,\n    input  wire [31:0] next_count,\n    output reg  [31:0] current_count\n);\n  always @(posedge clk) begin\n    if (!control_signal)\n      current_count <= 32'd0;\n    else\n      current_count <= next_count;\n  end\nendmodule\n\nmodule binary_ripple_counter (\n    input  wire        clk,\n    input  wire        control_signal,\n    output wire [31:0] count\n);\n  wire        toggle;\n  wire [31:0] next_count;\n  wire [31:0] current_count;\n\n  toggle_logic u_toggle_logic (\n    .control_signal(control_signal),\n    .toggle         (toggle)\n  );\n\n  counter_logic u_counter_logic (\n    .current_count(current_count),\n    .toggle       (toggle),\n    .next_count   (next_count)\n  );\n\n  counter_register u_counter_register (\n    .clk            (clk),\n    .control_signal (control_signal),\n    .next_count     (next_count),\n    .current_count  (current_count)\n  );\n\n  assign count = current_count;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\nwire [31:0] adder_result;\nwire [31:0] subtractor_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\nu_adder u_adder_inst (\n    .a(a),\n    .b(b),\n    .sum(adder_result)\n);\n\nu_subtractor u_subtractor_inst (\n    .a(a),\n    .b(b),\n    .diff(subtractor_result)\n);\n\nu_and_logic u_and_logic_inst (\n    .a(a),\n    .b(b),\n    .out(and_result)\n);\n\nu_or_logic u_or"}
{"task_id": "up_down_counter_v_12", "response": "module adder (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule and_bit (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule or_bit (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule\n\nmodule xor_bit (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a ^ operand_b;\nendmodule\n\nmodule multi_function_alu (\n    input  wire [2:0]  op_code,\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire        zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    \n    adder      u_adder      ( .operand_a(operand_a), .operand_b(operand_b), .result(add_result) );\n    subtractor u_subtractor ( .operand_a(operand_a), .operand_b(operand_b), .result(sub_result) );\n    and_bit    u_and_bit    ( .operand_a(operand_a), .operand_b(operand_b), .result(and_result) );\n    or_bit     u_or_bit     ( .operand_a(operand_a), .operand_b(operand_b), .result(or_result) );\n    xor_bit    u_xor_bit    ( .operand_a(operand_a), .operand_b(operand_b), .result(xor_result) );\n    \n    assign result = (op_code == 3'b000) ? add_result :\n                    (op_code == 3'b001) ? sub_result :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result :\n                    (op_code == 3'b100) ? xor_result : 32'b0;\n                    \n    assign zero = (result == 32'b0);\n    \nendmodule"}
{"task_id": "up_down_counter_v_13", "response": ""}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input [7:0] X,\n    input y,\n    output [15:0] product\n);\n    assign product = y ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input [7:0] X,\n    input [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n\n    gen_product #(0) GP0 (.X(X), .y(Y[0]), .product(pp0));\n    gen_product #(1) GP1 (.X(X), .y(Y[1]), .product(pp1));\n    gen_product #(2) GP2 (.X(X), .y(Y[2]), .product(pp2));\n    gen_product #(3) GP3 (.X(X), .y(Y[3]), .product(pp3));\n    gen_product #(4) GP4 (.X(X), .y(Y[4]), .product(pp4));\n    gen_product #(5) GP5 (.X(X), .y(Y[5]), .product(pp5));\n    gen_product #(6) GP6 (.X(X), .y(Y[6]), .product(pp6));\n    gen_product #(7) GP7 (.X(X), .y(Y[7]), .product(pp7));\n\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift #(parameter SHIFT = 0) (\n    input  [15:0] acc_in,\n    input  [7:0]  X,\n    input         y_bit,\n    output [15:0] acc_out\n);\n    wire [15:0] shifted_X;\n    assign shifted_X = {8'b0, X} << SHIFT;\n    assign acc_out = y_bit ? (acc_in + shifted_X) : acc_in;\nendmodule\n\nmodule mult_8bit (\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] ac0, ac1, ac2, ac3, ac4, ac5, ac6, ac7;\n    wire [15:0] initial_acc = 16'd0;\n\n    add_shift #(.SHIFT(0)) as0 (\n        .acc_in(initial_acc),\n        .X(X),\n        .y_bit(Y[0]),\n        .acc_out(ac0)\n    );\n    \n    add_shift #(.SHIFT(1)) as1 (\n        .acc_in(ac0),\n        .X(X),\n        .y_bit(Y[1]),\n        .acc_out(ac1)\n    );\n    \n    add_shift #(.SHIFT(2)) as2 (\n        .acc_in(ac1),\n        .X(X),\n        .y_bit(Y[2]),\n        .acc_out(ac2)\n    );\n    \n    add_shift #(.SHIFT(3)) as3 (\n        .acc_in(ac2),\n        .X(X),\n        .y_bit(Y[3]),\n        .acc_out(ac3)\n    );\n    \n    add_shift #(.SHIFT(4)) as4 (\n        .acc_in(ac3),\n        .X(X),\n        .y_bit(Y[4]),\n        .acc_out(ac4)\n    );\n    \n    add_shift #(.SHIFT(5)) as5 (\n        .acc_in(ac4),\n        .X(X),\n        .y_bit(Y[5]),\n        .acc_out(ac5)\n    );\n    \n    add_shift #(.SHIFT(6)) as6 (\n        .acc_in(ac5),\n        .X(X),\n        .y_bit(Y[6]),\n        .acc_out(ac6)\n    );\n    \n    add_shift #(.SHIFT(7)) as7 (\n        .acc_in(ac6),\n        .X(X),\n        .y_bit(Y[7]),\n        .acc_out(ac7)\n    );\n    \n    assign P = ac7;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output s,\n    output cout\n);\n    assign s = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] s\n);\n    wire c1, c2, c3, c4, c5, c6, c7, c8;\n    \n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(1'b0), .s(s[0]), .cout(c1));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(c1),   .s(s[1]), .cout(c2));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(c2),   .s(s[2]), .cout(c3));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(c3),   .s(s[3]), .cout(c4));\n    full_adder fa4 (.a(a[4]), .b(b[4]), .cin(c4),   .s(s[4]), .cout(c5));\n    full_adder fa5 (.a(a[5]), .b(b[5]), .cin(c5),   .s(s[5]), .cout(c6));\n    full_adder fa6 (.a(a[6]), .b(b[6]), .cin(c6),   .s(s[6]), .cout(c7));\n    full_adder fa7 (.a(a[7]), .b(b[7]), .cin(c7),   .s(s[7]), .cout(c8));\nendmodule\n\nmodule mul_4bit(\n    input  [3:0] X,\n    input  [3:0] Y,\n    output [7:0] P\n);\n    wire [7:0] pp0, pp1, pp2, pp3;\n    wire [7:0] sum1, sum2;\n    \n    assign pp0 = Y[0] ? {4'b0, X}       : 8'b0;\n    assign pp1 = Y[1] ? {3'b0, X, 1'b0}   : 8'b0;\n    assign pp2 = Y[2] ? {2'b0, X, 2'b0}   : 8'b0;\n    assign pp3 = Y[3] ? {1'b0, X, 3'b0}   : 8'b0;\n    \n    adder_8bit add1 (.a(pp0), .b(pp1), .s(sum1));\n    adder_8bit add2 (.a(sum1), .b(pp2), .s(sum2));\n    adder_8bit add3 (.a(sum2), .b(pp3), .s(P));\n    \nendmodule"}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n    wire [3:0] sum_out;\n    wire [3:0] diff_out;\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n\n    adder adder_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum_out)\n    );\n\n    subtractor subtractor_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .diff(diff_out)\n    );\n\n    and_logical and_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .and_res(and_out)\n    );\n\n    or_logical or_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .or_res(or_out)\n    );\n\n    always @(posedge clk) begin\n        case(op_code)\n            2'b00: result <= sum_out;\n            2'b01: result <= diff_out;\n            2'b10: result <= and_out;\n            2'b11: result <= or_out;\n            default: result <= 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_res\n);\n    assign and_res = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_res\n);\n    assign or_res = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module adder(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule simple_alu(\n    input  [3:0] a,\n    input  [3:0] b,\n    input  [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] add_out;\n    wire [3:0] sub_out;\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n\n    adder u_adder(\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n\n    subtractor u_subtractor(\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n\n    and_module u_and_module(\n        .a(a),\n        .b(b),\n        .and_result(and_out)\n    );\n\n    or_module u_or_module(\n        .a(a),\n        .b(b),\n        .or_result(or_out)\n    );\n\n    always @(*) begin\n        case(op)\n            2'b00: result = add_out;\n            2'b01: result = sub_out;\n            2'b10: result = and_out;\n            2'b11: result = or_out;\n            default: result = 4'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\n\nwire [1:0] operation;\nwire [3:0] alu_result;\n\nop_decoder u_op_decoder (\n    .op_code(op_code),\n    .operation(operation)\n);\n\narithmetic_logic u_arithmetic_logic (\n    .data_a(data_a),\n    .data_b(data_b),\n    .operation(operation),\n    .alu_result(alu_result)\n);\n\nreg [3:0] result_reg;\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result_reg <= 4'b0;\n    else\n        result_reg <= alu_result;\nend\nassign result = result_reg;\n\nresult_manager u_result_manager (\n    .alu_result(result_reg),\n    .zero(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    output reg [1:0] operation\n);\nalways @(*) begin\n    case(op_code)\n        2'b00: operation = 2'b00; // addition\n        2'b01: operation = 2'b01; // subtraction\n        2'b10: operation = 2'b10; // logical AND\n        2'b11: operation = 2'b11; // logical OR\n        default: operation = 2'b00;\n    endcase\nend\nendmodule\n\nmodule arithmetic_logic(\n    input [3:0] data_a,\n    input [3:0] data_b,\n    input [1:0] operation,\n    output reg [3:0] alu_result\n);\nalways @(*) begin\n    case(operation)\n        2'b00: alu_result = data_a + data_b;\n        2'b01: alu_result = data_a - data_b;\n        2'b10: alu_result = data_a & data_b;\n        2'b11: alu_result = data_a | data_b;\n        default: alu_result = 4'b0000;\n    endcase\nend\nendmodule\n\nmodule result_manager(\n    input [3:0] alu_result,\n    output zero\n);\nassign zero = (alu_result == 4'b0000) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "stagepipe3_v_21", "response": ""}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare(\n    input a,\n    input b,\n    input eq_in,\n    output gt,\n    output lt,\n    output eq_out\n);\n    assign gt = eq_in & a & ~b;\n    assign lt = eq_in & ~a & b;\n    assign eq_out = eq_in & ~(a ^ b);\nendmodule\n\nmodule magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A, B;\n    output gt, lt, eq;\n    \n    wire eq3, eq2, eq1, eq0;\n    wire gt3, gt2, gt1, gt0;\n    wire lt3, lt2, lt1, lt0;\n    \n    bit_compare bc3 (\n        .a(A[3]),\n        .b(B[3]),\n        .eq_in(1'b1),\n        .gt(gt3),\n        .lt(lt3),\n        .eq_out(eq3)\n    );\n    \n    bit_compare bc2 (\n        .a(A[2]),\n        .b(B[2]),\n        .eq_in(eq3),\n        .gt(gt2),\n        .lt(lt2),\n        .eq_out(eq2)\n    );\n    \n    bit_compare bc1 (\n        .a(A[1]),\n        .b(B[1]),\n        .eq_in(eq2),\n        .gt(gt1),\n        .lt(lt1),\n        .eq_out(eq1)\n    );\n    \n    bit_compare bc0 (\n        .a(A[0]),\n        .b(B[0]),\n        .eq_in(eq1),\n        .gt(gt0),\n        .lt(lt0),\n        .eq_out(eq0)\n    );\n    \n    assign gt = gt3 | gt2 | gt1 | gt0;\n    assign lt = lt3 | lt2 | lt1 | lt0;\n    assign eq = eq0;\n    \nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n  input  [3:0] a;\n  input  [3:0] b;\n  input  [1:0] op;\n  output [3:0] result;\n  output       carry_borrow;\n\n  wire [3:0] and_result;\n  wire [3:0] or_result;\n  wire [3:0] add_result;\n  wire [3:0] sub_result;\n  wire       add_carry;\n  wire       sub_borrow;\n\n  bitwise_and and_unit (\n    .a(a),\n    .b(b),\n    .result(and_result)\n  );\n\n  bitwise_or or_unit (\n    .a(a),\n    .b(b),\n    .result(or_result)\n  );\n\n  adder_4bit add_unit (\n    .a(a),\n    .b(b),\n    .result(add_result),\n    .carry(add_carry)\n  );\n\n  subtractor_4bit sub_unit (\n    .a(a),\n    .b(b),\n    .result(sub_result),\n    .borrow(sub_borrow)\n  );\n\n  reg [3:0] alu_result;\n  reg       alu_carry_borrow;\n\n  assign result = alu_result;\n  assign carry_borrow = alu_carry_borrow;\n\n  always @(*) begin\n    case(op)\n      2'b00: begin\n               alu_result = and_result;\n               alu_carry_borrow = 1'b0;\n             end\n      2'b01: begin\n               alu_result = or_result;\n               alu_carry_borrow = 1'b0;\n             end\n      2'b10: begin\n               alu_result = add_result;\n               alu_carry_borrow = add_carry;\n             end\n      2'b11: begin\n               alu_result = sub_result;\n               alu_carry_borrow = sub_borrow;\n             end\n      default: begin\n                 alu_result = 4'b0000;\n                 alu_carry_borrow = 1'b0;\n               end\n    endcase\n  end\n\nendmodule\n\nmodule bitwise_and(a, b, result);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] result;\n  \n  assign result = a & b;\n  \nendmodule\n\nmodule bitwise_or(a, b, result);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] result;\n  \n  assign result = a | b;\n  \nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] result;\n  output       carry;\n  \n  assign {carry, result} = a + b;\n  \nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] result;\n  output       borrow;\n  \n  wire carry;\n  assign {carry, result} = a + (~b) + 1;\n  assign borrow = ~carry;\n  \nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input  [7:0] temp_sensor;\n    input        smoke_sensor;\n    output       alarm_out;\n    \n    wire temp_trigger;\n    \n    compare_temp ct_inst (\n        .temp_in(temp_sensor),\n        .temp_out(temp_trigger)\n    );\n    \n    or_logic or_inst (\n        .in1(temp_trigger),\n        .in2(smoke_sensor),\n        .out(alarm_out)\n    );\nendmodule\n\nmodule compare_temp (temp_in, temp_out);\n    input  [7:0] temp_in;\n    output       temp_out;\n    \n    parameter [7:0] TEMP_THRESHOLD = 8'd100;\n    \n    assign temp_out = (temp_in > TEMP_THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic (in1, in2, out);\n    input  in1, in2;\n    output out;\n    \n    assign out = in1 | in2;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": "module cla_4bit(A, B, C_in, S, C_out);\n    input [4:1] A, B;\n    input C_in;\n    output [4:1] S;\n    output C_out;\n    \n    wire [4:1] p, g;\n    wire c1, c2, c3;\n    \n    assign p[1] = A[1] ^ B[1];\n    assign g[1] = A[1] & B[1];\n    assign p[2] = A[2] ^ B[2];\n    assign g[2] = A[2] & B[2];\n    assign p[3] = A[3] ^ B[3];\n    assign g[3] = A[3] & B[3];\n    assign p[4] = A[4] ^ B[4];\n    assign g[4] = A[4] & B[4];\n    \n    assign c1 = g[1] | (p[1] & C_in);\n    assign c2 = g[2] | (p[2] & g[1]) | (p[2] & p[1] & C_in);\n    assign c3 = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & C_in);\n    assign C_out = g[4] | (p[4] & g[3]) | (p[4] & p[3] & g[2]) | (p[4] & p[3] & p[2] & g[1]) | (p[4] & p[3] & p[2] & p[1] & C_in);\n    \n    assign S[1] = p[1] ^ C_in;\n    assign S[2] = p[2] ^ c1;\n    assign S[3] = p[3] ^ c2;\n    assign S[4] = p[4] ^ c3;\nendmodule\n\nmodule add_16bit(A, B, S, C_out);\n    input [16:1] A, B;\n    output [16:1] S;\n    output C_out;\n    \n    wire c1, c2, c3;\n    \n    cla_4bit add1 (\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n    \n    cla_4bit add2 (\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n    \n   "}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(data, p);\n  input [7:0] data;\n  output p;\n  \n  assign p = ^data;\n  \nendmodule\n\nmodule parity_16bit(X, Y, P);\n  input [7:0] X, Y;\n  output P;\n  \n  wire p_x, p_y;\n  \n  parity_8bit gen1 (\n    .data(X),\n    .p(p_x)\n  );\n  \n  parity_8bit gen2 (\n    .data(Y),\n    .p(p_y)\n  );\n  \n  assign P = p_x ^ p_y;\n  \nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0 (\n        .a(a0),\n        .b(b0),\n        .sum(sum0)\n    );\n    \n    adder_unit au1 (\n        .a(a1),\n        .b(b1),\n        .sum(sum1)\n    );\n    \n    adder_unit au2 (\n        .a(a2),\n        .b(b2),\n        .sum(sum2)\n    );\n    \n    adder_unit au3 (\n        .a(a3),\n        .b(b3),\n        .sum(sum3)\n    );\n    \nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n    multiplier mult0 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .product(p0)\n    );\n\n    multiplier mult1 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .product(p1)\n    );\n\n    multiplier mult2 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .product(p2)\n    );\n\n    multiplier mult3 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .product(p3)\n    );\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] product\n);\n    always @(posedge clk) begin\n        if (rst)\n            product <= 16'd0;\n        else\n            product <= a * b;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n\n  wire [3:0] left_rot;\n  wire [3:0] right_rot;\n\n  left_rotate u_left_rotate (\n    .in_data(in_data),\n    .out_data(left_rot)\n  );\n\n  right_rotate u_right_rotate (\n    .in_data(in_data),\n    .out_data(right_rot)\n  );\n\n  assign out_data = en ? (rot_dir ? left_rot : right_rot) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 8'd1;\n      else\n        count <= count - 8'd1;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 8'b0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .out(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input a,\n    input b,\n    input Cin,\n    output Sum,\n    output Cout\n);\n    assign Sum = a ^ b ^ Cin;\n    assign Cout = (a & b) | (b & Cin) | (a & Cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,\n    input [7:0] Y,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [7:0] c;\n\n    full_adder fa0(.a(X[0]), .b(Y[0]), .Cin(Cin),  .Sum(Sum[0]), .Cout(c[0]));\n    full_adder fa1(.a(X[1]), .b(Y[1]), .Cin(c[0]), .Sum(Sum[1]), .Cout(c[1]));\n    full_adder fa2(.a(X[2]), .b(Y[2]), .Cin(c[1]), .Sum(Sum[2]), .Cout(c[2]));\n    full_adder fa3(.a(X[3]), .b(Y[3]), .Cin(c[2]), .Sum(Sum[3]), .Cout(c[3]));\n    full_adder fa4(.a(X[4]), .b(Y[4]), .Cin(c[3]), .Sum(Sum[4]), .Cout(c[4]));\n    full_adder fa5(.a(X[5]), .b(Y[5]), .Cin(c[4]), .Sum(Sum[5]), .Cout(c[5]));\n    full_adder fa6(.a(X[6]), .b(Y[6]), .Cin(c[5]), .Sum(Sum[6]), .Cout(c[6]));\n    full_adder fa7(.a(X[7]), .b(Y[7]), .Cin(c[6]), .Sum(Sum[7]), .Cout(Cout));\nendmodule\n\nmodule adder_32bit(\n    input [31:0] X,\n    input [31:0] Y,\n    output [31:0] Sum,\n    output Carry_out\n);\n    wire c0, c1, c2;\n\n    adder_8bit adder0(\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Cin(1'b0),\n        .Sum(Sum[7:0]),\n        .Cout(c0)\n    );\n    \n    adder_8bit adder1(\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Cin(c0),\n        .Sum(Sum[15:8]),\n        .Cout(c1)\n    );\n    \n    adder_8bit adder2(\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Cin(c1),\n        .Sum(Sum[23:16]),\n        .Cout(c2)\n    );\n    \n    adder_8bit adder3(\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Cin(c2),\n        .Sum(Sum[31:24]),\n        .Cout(Carry_out)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c1, c2, c3;\n    \n    adder_8bit u_adder0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n    \n    adder_8bit u_adder1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n    \n    adder_8bit u_adder2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n    \n    adder_8bit u_adder3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n    \nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire add_carry;\n    wire sub_carry;\n\n    adder_32 add_inst (\n        .A(A),\n        .B(B),\n        .sum(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32 sub_inst (\n        .A(A),\n        .B(B),\n        .diff(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    and_32 and_inst (\n        .A(A),\n        .B(B),\n        .out(and_result)\n    );\n\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    (op == 2'b10) ? and_result : 32'b0;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry : 1'b0;\n\nendmodule\n\nmodule adder_32(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output carry_out\n);\n    assign {carry_out, diff} = A - B;\nendmodule\n\nmodule and_32(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] out\n);\n    assign out = A & B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux0 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] y\n);\n  always @(posedge clk) begin\n    y <= d;\n  end\nendmodule\n\nmodule mux1 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] y\n);\n  always @(posedge clk) begin\n    y <= d;\n  end\nendmodule\n\nmodule mux2 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] y\n);\n  always @(posedge clk) begin\n    y <= d;\n  end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n  wire [7:0] mux0_out;\n  wire [7:0] mux1_out;\n  wire [7:0] mux2_out;\n\n  mux0 u_mux0 (\n      .clk(clk),\n      .d(d0),\n      .y(mux0_out)\n  );\n\n  mux1 u_mux1 (\n      .clk(clk),\n      .d(d1),\n      .y(mux1_out)\n  );\n\n  mux2 u_mux2 (\n      .clk(clk),\n      .d(d2),\n      .y(mux2_out)\n  );\n\n  assign data_out = (sel == 3'b000) ? mux0_out :\n                    (sel == 3'b001) ? mux1_out :\n                    (sel == 3'b010) ? mux2_out : 8'b0;\n\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold0(\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge clk)\n    if (load)\n      q <= d;\nendmodule\n\nmodule hold1(\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge clk)\n    if (load)\n      q <= d;\nendmodule\n\nmodule hold2(\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge clk)\n    if (load)\n      q <= d;\nendmodule\n\nmodule hold3(\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge clk)\n    if (load)\n      q <= d;\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n  wire [7:0] data0, data1, data2, data3;\n  wire load0, load1, load2, load3;\n\n  assign load0 = (sel == 2'b00);\n  assign load1 = (sel == 2'b01);\n  assign load2 = (sel == 2'b10);\n  assign load3 = (sel == 2'b11);\n\n  hold0 hold0_inst (\n      .clk(clk),\n      .load(load0),\n      .d(in0),\n      .q(data0)\n  );\n\n  hold1 hold1_inst (\n      .clk(clk),\n      .load(load1),\n      .d(in1),\n      .q(data1)\n  );\n\n  hold2 hold2_inst (\n      .clk(clk),\n      .load(load2),\n      .d(in2),\n      .q(data2)\n  );\n\n  hold3 hold3_inst (\n      .clk(clk),\n      .load(load3),\n      .d(in3),\n      .q(data3)\n  );\n\n  assign out = (sel == 2'b00) ? data0 :\n               (sel == 2'b01) ? data1 :\n               (sel == 2'b10) ? data2 : data3;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n  always @(posedge clk) begin\n    if (reset)\n      count <= 16'd0;\n    else if (count == (freq - 1))\n      count <= 16'd0;\n    else\n      count <= count + 16'd1;\n  end\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n  wire [15:0] threshold;\n  assign threshold = (freq * duty_cycle) / 100;\n\n  always @(posedge clk) begin\n    pwm_out <= (count < threshold) ? 1'b1 : 1'b0;\n  end\nendmodule\n\nmodule pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n  wire [15:0] count;\n  wire reset;\n  assign reset = 1'b0;\n\n  pwm_counter pc (\n    ."}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    wire [7:0] adjusted_duty;\n\n    duty_ctrl u_duty_ctrl(\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    pulse_gen u_pulse_gen(\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter >= 8'd255)\n            counter <= 8'd0;\n        else\n            counter <= counter + 8'd1;\n            \n        if (counter < duty_cycle)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [15:0] prod\n);\n    assign prod = a * b;\nendmodule\n\nmodule multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n    wire [7:0] x_low, x_high, y_low, y_high;\n    assign x_low  = x[7:0];\n    assign x_high = x[15:8];\n    assign y_low  = y[7:0];\n    assign y_high = y[15:8];\n\n    wire [15:0] p_ll, p_lh, p_hl, p_hh;\n    \n    mult8 mult8_inst1 (.a(x_low),  .b(y_low),  .prod(p_ll));\n    mult8 mult8_inst2 (.a(x_low),  .b(y_high), .prod(p_lh));\n    mult8 mult8_inst3 (.a(x_high), .b(y_low),  .prod(p_hl));\n    mult8 mult8_inst4 (.a(x_high), .b(y_high), .prod(p_hh));\n    \n    wire [31:0] term_ll = {16'b0, p_ll};\n    wire [31:0] term_lh = ({16'b0, p_lh} << 8);\n    wire [31:0] term_hl = ({16'b0, p_hl} << 8);\n    wire [31:0] term_hh = ({16'b0, p_hh} << 16);\n    \n    assign prod = term_ll + term_lh + term_hl + term_hh;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] mid;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(mid)\n    );\n\n    bit_reverse br2 (\n        .din(mid),\n        .dout(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] adder_result;\n    \n    my_adder8 u1 (\n        .a(a),\n        .b(b),\n        .sum(adder_result)\n    );\n    \n    always @(*) begin\n        if (ctrl)\n            sum = adder_result;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": ""}
{"task_id": "freq_div_v_48", "response": "`timescale 1ns / 1ps\n\nmodule pwm_duty_25(\n    input CLK,\n    input RST,\n    output reg pwm\n);\n    parameter PERIOD = 100;\n    parameter THRESHOLD = PERIOD / 4;\n    \n    reg [31:0] counter;\n    \n    always @(posedge CLK or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter >= PERIOD - 1)\n            counter <= 0;\n        else\n            counter <= counter + 1;\n    end\n    \n    always @(posedge CLK or posedge RST) begin\n        if (RST)\n            pwm <= 0;\n        else if (counter < THRESHOLD)\n            pwm <= 1;\n        else\n            pwm <= 0;\n    end\nendmodule\n\nmodule pwm_duty_50(\n    input CLK,\n    input RST,\n    output reg pwm\n);\n    parameter PERIOD = 100;\n    parameter THRESHOLD = PERIOD / 2;\n    \n    reg [31:0] counter;\n    \n    always @(posedge CLK or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter >= PERIOD - 1)\n            counter <= 0;\n        else\n            counter <= counter + 1;\n    end\n    \n    always @(posedge CLK or posedge RST) begin\n        if (RST)\n            pwm <= 0;\n        else if (counter < THRESHOLD)\n            pwm <= 1;\n        else\n            pwm <= 0;\n    end\nendmodule\n\nmodule pwm_duty_75(\n    input CLK,\n    input RST,\n    output reg pwm\n);\n    parameter PERIOD = 100;\n    parameter THRESHOLD = (PERIOD * 3) / 4;\n    \n    reg [31:0] counter;\n    \n    always @(posedge CLK or posedge RST) begin\n        if (RST)\n            counter <= 0;\n        else if (counter >= PERIOD - 1)\n            counter <= 0;\n        else\n            counter <= counter + 1;\n    end\n    \n    always @(posedge CLK or posedge RST) begin\n        if (RST)\n            pwm <= 0;\n        else if (counter < THRESHOLD)\n            pwm <= 1;\n        else\n            pwm <= 0;\n    end\nendmodule\n\nmodule pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_duty_25 u_pwm_25 (\n        .CLK(CLK_in),\n        .RST(RST),\n        .pwm(PWM_25)\n    );\n    \n    pwm_duty_50 u_pwm_50 (\n        .CLK(CLK_in),\n        .RST(RST),\n        .pwm(PWM_50)\n    );\n    \n    pwm_duty_75 u_pwm_75 (\n        .CLK(CLK_in),\n        .RST(RST),\n        .pwm(PWM_75)\n    );\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller #(\n    parameter DUTY_CYCLE   = 50,\n    parameter MAX_COUNT    = 255,\n    parameter COUNTER_WIDTH = $clog2(MAX_COUNT+1)\n)(\n    input  clk,\n    input  rst_n,\n    output pwm_out\n);\n\nwire [COUNTER_WIDTH-1:0] count;\n\nu_counter #(\n    .COUNTER_WIDTH(COUNTER_WIDTH),\n    .MAX_COUNT(MAX_COUNT)\n) counter_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count)\n);\n\nu_comparator #(\n    .DUTY_CYCLE(DUTY_CYCLE),\n    .MAX_COUNT(MAX_COUNT),\n    .COUNTER_WIDTH(COUNTER_WIDTH)\n) comparator_inst (\n    .count(count),\n    .pwm_out(pwm_out)\n);\n\nendmodule\n\nmodule u_counter #(\n    parameter COUNTER_WIDTH = 8,\n    parameter MAX_COUNT     = 255\n)(\n    input clk,\n    input rst_n,\n    output reg [COUNTER_WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else if (count == MAX_COUNT)\n        count <= 0;\n    else\n        count <= count + 1;\nend\n\nendmodule\n\nmodule u_comparator #(\n    parameter DUTY_CYCLE    = 50,\n    parameter MAX_COUNT     = 255,\n    parameter COUNTER_WIDTH = 8\n)(\n    input  [COUNTER_WIDTH-1:0] count,\n    output pwm_out\n);\n\nlocalparam THRESHOLD = (DUTY_CYCLE * (MAX_COUNT + 1)) / 100;\n\nassign pwm_out = (count < THRESHOLD) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input  [31:0] a,\n    input  [31:0] b,\n    input         multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output        zero\n);\n    wire [63:0] signed_result;\n    wire [63:0] unsigned_result;\n\n    mult_signed u_mult_signed (\n        .a(a),\n        .b(b),\n        .y(signed_result)\n    );\n\n    mult_unsigned u_mult_unsigned (\n        .a(a),\n        .b(b),\n        .y(unsigned_result)\n    );\n\n    assign y    = (multc == 1'b0) ? signed_result : unsigned_result;\n    assign msb  = y[63:32];\n    assign lsb  = y[31:0];\n    assign zero = (y == 64'b0);\n    \nendmodule\n\nmodule mult_signed(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\nmodule mult_unsigned(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module count_control (\n    input clk,\n    input rst,\n    input en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 4'd1;\n    end\nendmodule\n\nmodule overflow_detection (\n    input clk,\n    input rst,\n    input [3:0] count,\n    output reg overflow\n);\n    reg [3:0] prev_count;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'b0000;\n            overflow   <= 1'b0;\n        end\n        else begin\n            if (prev_count == 4'b1111 && count == 4'b0000)\n                overflow <= 1'b1;\n            else\n                overflow <= 1'b0;\n            prev_count <= count;\n        end\n    end\nendmodule\n\nmodule binary_up_counter (\n    input         clk,\n    input         rst,\n    input         en,\n    output [3:0]  count_out,\n    output        overflow\n);\n    wire [3:0] count_internal;\n    \n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count_internal)\n    );\n    \n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .count(count_internal),\n        .overflow(overflow)\n    );\n    \n    assign count_out = count_internal;\n    \nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module add(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtract(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule bitwise_and(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule bitwise_or(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule\n\nmodule simple_alu(\n    input           clk,\n    input           rst,\n    input  [1:0]    op_code,\n    input  [31:0]   operand_a,\n    input  [31:0]   operand_b,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    add         u_add      (.operand_a(operand_a), .operand_b(operand_b), .result(add_result));\n    subtract    u_subtract (.operand_a(operand_a), .operand_b(operand_b), .result(sub_result));\n    bitwise_and u_and      (.operand_a(operand_a), .operand_b(operand_b), .result(and_result));\n    bitwise_or  u_or       (.operand_a(operand_a), .operand_b(operand_b), .result(or_result));\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else begin\n            case (op_code)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= and_result;\n                2'b11: result <= or_result;\n                default: result <= 32'd0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "module comparator_4bit(a, b, eq, gt, lt);\n  input  [3:0] a, b;\n  output       eq, gt, lt;\n  \n  assign eq = (a == b);\n  assign gt = (a > b);\n  assign lt = (a < b);\n  \nendmodule\n\nmodule comparator_16bit(a, b, eq, gt, lt);\n  input  [15:0] a, b;\n  output        eq, gt, lt;\n  \n  wire eq0, gt0, lt0;\n  wire eq1, gt1, lt1;\n  wire eq2, gt2, lt2;\n  wire eq3, gt3, lt3;\n  \n  comparator_4bit comp_slice1(.a(a[3:0]),   .b(b[3:0]),   .eq(eq0), .gt(gt0), .lt(lt0));\n  comparator_4bit comp_slice2(.a(a[7:4]),   .b(b[7:4]),   .eq(eq1), .gt(gt1), .lt(lt1));\n  comparator_4bit comp_slice3(.a(a[11:8]),  .b(b[11:8]),  .eq(eq2), .gt(gt2), .lt(lt2));\n  comparator_4bit comp_slice4(.a(a[15:12]), .b(b[15:12]), .eq(eq3), .gt(gt3), .lt(lt3));\n  \n  assign eq = eq3 & eq2 & eq1 & eq0;\n  assign gt = gt3 | (eq3 & gt2) | (eq3 & eq2 & gt1) | (eq3 & eq2 & eq1 & gt0);\n  assign lt = lt3 | (eq3 & lt2) | (eq3 & eq2 & lt1) | (eq3 & eq2 & eq1 & lt0);\n  \nendmodule"}
{"task_id": "adder_32bit_v_54", "response": ""}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\nwire t0, t1;\n\nassign t0 = 1'b1;\nassign t1 = count[0];\n\nmy_tff u0 (\n    .clk(clk),\n    .reset(reset),\n    .t(t0),\n    .q(count[0])\n);\n\nmy_tff u1 (\n    .clk(clk),\n    .reset(reset),\n    .t(t1),\n    .q(count[1])\n);\n\nmy_tff u2 (\n    .clk(clk),\n    .reset(reset),\n    .t(count[0] & count[1]),\n    .q(count[2])\n);\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module init_sub (\n    input wire reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule increment_sub (\n    input wire [3:0] in_count,\n    output wire [3:0] out_count\n);\n    assign out_count = in_count + 4'b0001;\nendmodule\n\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n    reg [3:0] count;\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n    \n    init_sub u_init (\n        .reset(reset),\n        .init_val(init_val)\n    );\n    \n    increment_sub u_increment (\n        .in_count(count),\n        .out_count(inc_val)\n    );\n    \n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n    \n    assign out = count;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .current_count(count),\n        .up_down(up_down),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\nendmodule\n\nmodule counter_logic (\n    input wire [15:0] current_count,\n    input wire up_down,\n    output wire [15:0] next_count\n);\n    assign next_count = up_down ? (current_count + 16'd1) : (current_count - 16'd1);\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 16'd0;\n        else\n            current_count <= next_count;\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    reg [7:0] state;\n    wire [7:0] init_val;\n    wire [7:0] next_state;\n    \n    state_init init_inst (\n        .reset(reset),\n        .init_val(init_val)\n    );\n    \n    state_transition trans_inst (\n        .state(state),\n        .next_state(next_state)\n    );\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= init_val;\n        else\n            state <= next_state;\n    end\n    \n    assign out = state;\n    \nendmodule\n\nmodule state_init (\n    input wire reset,\n    output wire [7:0] init_val\n);\n    assign init_val = 8'b00000001;\nendmodule\n\nmodule state_transition (\n    input wire [7:0] state,\n    output wire [7:0] next_state\n);\n    assign next_state = (state == 8'b10000000) ? 8'b00000001 : (state << 1);\nendmodule"}
{"task_id": "counter_12", "response": "module counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'd0;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'd0;\n            else\n                count <= count + 4'd1;\n        end else\n            count <= count;\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in_data,\n    output reg [3:0] out_data\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out_data <= 4'd0;\n        else if (valid_count)\n            out_data <= in_data;\n        else\n            out_data <= out_data;\n    end\nendmodule\n\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_internal;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count_internal)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .in_data(count_internal),\n        .out_data(out)\n    );\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module clk_div_2(\n    input CLK_in,\n    input RST,\n    output reg clk_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            clk_out <= 1'b0;\n        else\n            clk_out <= ~clk_out;\n    end\nendmodule\n\nmodule clk_div_10(\n    input CLK_in,\n    input RST,\n    output reg clk_out\n);\n    reg [2:0] counter;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 3'b0;\n            clk_out <= 1'b0;\n        end\n        else begin\n            if (counter == 4) begin\n                counter <= 3'b0;\n                clk_out <= ~clk_out;\n            end\n            else begin\n                counter <= counter + 1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100(\n    input CLK_in,\n    input RST,\n    output reg clk_out\n);\n    reg [5:0] counter;\n    always @(posedge CLK_in or posedge"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": ""}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven #(\n    parameter NUM_DIV = 8\n)(\n    input  clk,\n    input  rst_n,\n    output clk_div\n);\n\n    wire tick;\n    \n    u_counter #(.NUM_DIV(NUM_DIV)) u_counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n    \n    u_clk_divider u_clk_divider_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n\nendmodule\n\nmodule u_counter #(\n    parameter NUM_DIV = 8\n)(\n    input  clk,\n    input  rst_n,\n    output reg tick\n);\n\n    localparam HALF_DIV = NUM_DIV / 2;\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'd0;\n            tick  <= 1'b0;\n        end\n        else begin\n            if (count == HALF_DIV - 1) begin\n                count <= 4'd0;\n                tick  <= 1'b1;\n            end\n            else begin\n                count <= count + 4'd1;\n                tick  <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\nmodule u_clk_divider(\n    input  clk,\n    input  rst_n,\n    input  tick,\n    output reg clk_div\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\n\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 32'b0;\n        else\n            out <= out + in;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n    \n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .y(mult_result)\n    );\n    \n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .in(mult_result[31:0]),\n        .out(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_submodule (\n    input clk,\n    input rst,\n    input ld,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            q <= 8'b0;\n        else if (ld)\n            q <= d;\n        else\n            q <= q;\n    end\nendmodule\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire ld1, ld2;\n    assign ld1 = (fetch == 2'b01);\n    assign ld2 = (fetch == 2'b10);\n\n    wire [7:0] ins_p1;\n    wire [7:0] ins_p2;\n\n    instr_submodule u_ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .ld(ld1),\n        .d(data),\n        .q(ins_p1)\n    );\n\n    instr_submodule u_ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .ld(ld2),\n        .d(data),\n        .q(ins_p2)\n    );\n\n    assign ins = ins_p1[7:5];\n    assign ad1 = ins_p1[4:0];\n    assign ad2 = ins_p2;\nendmodule"}
{"task_id": "square_wave", "response": ""}
{"task_id": "signal_generator", "response": ""}
{"task_id": "shift8", "response": "module my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n    \n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n    \n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n    \n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n    \n    always @(*) begin\n        case(sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\n  wire q0, q1;\n\n  my_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n  );\n\n  my_dff u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n  );\n\n  my_dff u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q)\n  );\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n\n  reg [15:0] b1;\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'b0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\nendmodule\n\nmodule pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'b0;\n    else\n      c <= c + (a * b);\n  end\n\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": ""}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input  wire [31:0] A,       // 32\u2010bit dividend\n    input  wire [15:0] B,       // 16\u2010bit divisor\n    output wire [31:0] result,  // 32\u2010bit quotient\n    output wire [31:0] odd      // 32\u2010bit remainder\n);\n    wire [31:0] prep_A;\n    wire [31:0] prep_B;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend u_prep_dividend (\n        .A(A),\n        .B(B),\n        .prep_A(prep_A),\n        .prep_B(prep_B)\n    );\n\n    div_operation u_div_operation (\n        .dividend(prep_A),\n        .divisor(prep_B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd    = remainder;\nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] prep_A,\n    output wire [31:0] prep_B\n);\n    assign prep_A = A;\n    assign prep_B = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input  wire [31:0] dividend,\n    input  wire [31:0] divisor,\n    output reg  [31:0] quotient,\n    output reg  [31:0] remainder\n);\n    integer i;\n    reg [31:0] temp_quo;\n    reg [31:0] temp_rem;\n\n    always @(*) begin\n        temp_quo = 32'd0;\n        temp_rem = 32'd0;\n        for (i = 31; i >= 0; i = i - 1) begin\n            temp_rem = {temp_rem[30:0], dividend[i]};\n            if (temp_rem >= divisor) begin\n                temp_rem = temp_rem - divisor;\n                temp_quo[i] = 1'b1;\n            end\n            else begin\n                temp_quo[i] = 1'b0;\n            end\n        end\n        quotient  = temp_quo;\n        remainder = temp_rem;\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0]  B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n  wire [15:0] quotient;\n  wire [15:0] remainder;\n\n  ctrl_divider u_ctrl_divider (\n    .dividend(A),\n    .divisor(B),\n    .quotient(quotient),\n    .remainder(remainder)\n  );\n\n  assign result = quotient;\n  assign odd = remainder;\n\nendmodule\n\nmodule ctrl_divider (\n    input wire [15:0] dividend,\n    input wire [7:0]  divisor,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n  integer i;\n  reg [15:0] r;\n  reg [15:0] q;\n  reg [15:0] d_ext;\n\n  always @(*) begin\n    r = 16'b0;\n    q = 16'b0;\n    d_ext = {8'b0, divisor};\n    for (i = 15; i >= 0; i = i - 1) begin\n      r = {r[14:0], dividend[i]};\n      if (r >= d_ext) begin\n        r = r - d_ext;\n        q[i] = 1'b1;\n      end else begin\n        q[i] = 1'b0;\n      end\n    end\n    quotient = q;\n    remainder = r;\n  end\n\nendmodule"}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        cin,\n    output [7:0] sum,\n    output       cout\n);\n    wire [6:0] c;\n    \n    full_adder fa0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c[0])\n    );\n    \n    genvar i;\n    generate\n        for(i = 1; i < 8; i = i + 1) begin : full_adders\n            full_adder fa(\n                .a(a[i]),\n                .b(b[i]),\n                .cin(i==0 ? cin : c[i-1]),  // This is safe; i==0 branch never occurs here.\n                .sum(sum[i]),\n                .cout(c[i])\n            );\n        end\n    endgenerate\n    assign cout = c[7];\nendmodule\n\nmodule sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    output [7:0] D,\n    output       B_out\n);\n    wire [7:0] B_comp;\n    wire       cout;\n    \n    assign B_comp = ~B;\n    \n    adder_8bit adder_inst(\n        .a(A),\n        .b(B_comp),\n        .cin(1'b1),\n        .sum(D),\n        .cout(cout)\n    );\n    \n    assign B_out = ~cout;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_16bit(\n    input  [15:0] A,\n    input  [15:0] B,\n    input         borrow_in,\n    output [15:0] Diff,\n    output        borrow_out\n);\n    assign {borrow_out, Diff} = {1'b0, A} - {1'b0, B} - borrow_in;\nendmodule\n\nmodule sub_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] Diff,\n    output        B_out\n);\n    wire borrow_mid;\n\n    sub_16bit lower_sub(\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(1'b0),\n        .Diff(Diff[15:0]),\n        .borrow_out(borrow_mid)\n    );\n\n    sub_16bit upper_sub(\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_mid),\n        .Diff(Diff[31:16]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_8bit (A, B, borrow_in, D, borrow_out);\n    input  [7:0] A;\n    input  [7:0] B;\n    input        borrow_in;\n    output [7:0] D;\n    output       borrow_out;\n    \n    wire [8:0] diff;\n    \n    assign diff = {1'b0, A} - {1'b0, B} - borrow_in;\n    assign D = diff[7:0];\n    assign borrow_out = diff[8];\nendmodule\n\nmodule sub_16bit (A, B, borrow_in, D, borrow_out);\n    input  [15:0] A;\n    input  [15:0] B;\n    input         borrow_in;\n    output [15:0] D;\n    output        borrow_out;\n    \n    wire borrow_mid;\n    \n    sub_8bit sub0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .borrow_in(borrow_in),\n        .D(D[7:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_8bit sub1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .borrow_in(borrow_mid),\n        .D(D[15:8]),\n        .borrow_out(borrow_out)\n    );\nendmodule\n\nmodule sub_32bit (A, B, borrow_in, D, borrow_out);\n    input  [31:0] A;\n    input  [31:0] B;\n    input         borrow_in;\n    output [31:0] D;\n    output        borrow_out;\n    \n    wire borrow_mid;\n    \n    sub_16bit sub0 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(borrow_in),\n        .D(D[15:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_16bit sub1 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_mid),\n        .D(D[31:16]),\n        .borrow_out(borrow_out)\n    );\nendmodule\n\nmodule sub_64bit (A, B, D, B_out);\n    input  [63:0] A;\n    input  [63:0] B;\n    output [63:0] D;\n    output        B_out;\n    \n    wire borrow_mid;\n    \n    sub_32bit sub0 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .borrow_in(1'b0),\n        .D(D[31:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_32bit sub1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .borrow_in(borrow_mid),\n        .D(D[63:32]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign diff = A - B;\n    assign borrow = (A < B) ? 1'b1 : 1'b0;\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n    wire [31:0] diff;\n    wire borrow;\n    \n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n    \n    assign A_equal = (diff == 32'd0);\n    assign A_less  = borrow;\n    assign A_greater = (~borrow) && (diff != 32'd0);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module ripple_carry_adder_4(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule carry_select_slice_4(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       cout0, cout1;\n    \n    ripple_carry_adder_4 u0 (\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .sum(sum0),\n        .cout(cout0)\n    );\n    \n    ripple_carry_adder_4 u1 (\n        .a(a),\n        .b(b),\n        .cin(1'b1),\n        .sum(sum1),\n        .cout(cout1)\n    );\n    \n    assign sum  = cin ? sum1  : sum0;\n    assign cout = cin ? cout1 : cout0;\n    \nendmodule\n\nmodule adder_16bit_csa(\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n    wire c1, c2, c3;\n    \n    ripple_carry_adder_4 u0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c1)\n    );\n    \n    carry_select_slice_4 u1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c1),\n        .sum(sum[7:4]),\n        .cout(c2)\n    );\n    \n    carry_select_slice_4 u2 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c2),\n        .sum(sum[11:8]),\n        .cout(c3)\n    );\n    \n    carry_select_slice_4 u3 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c3),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\n    \nendmodule"}
{"task_id": "adder_16bit", "response": "`timescale 1ns/1ps\nmodule adder_8bit(\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry;\n    \n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry)\n    );\n    \n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule`"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a, b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n\n    full_adder FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n\n    full_adder FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n\n    full_adder FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(c4)\n    );\n\n    full_adder FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(c4),\n        .sum(sum[4]),\n        .cout(c5)\n    );\n\n    full_adder FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(c5),\n        .sum(sum[5]),\n        .cout(c6)\n    );\n\n    full_adder FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(c6),\n        .sum(sum[6]),\n        .cout(c7)\n    );\n\n    full_adder FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(c7),\n        .sum(sum[7]),\n        .cout(cout)\n    );\nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module u_adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule\n\nmodule as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    \n    u_adder u_adder_inst (\n        .op1(op1),\n        .op2(op2),\n        .result(add_result)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .op1(op1),\n        .op2(op2),\n        .result(sub_result)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    output reg [31:0] quotient\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            quotient <= 32'b0;\n        else\n            quotient <= x / y;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] subtrahend,\n    output reg [31:0] difference\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            difference <= 32'b0;\n        else\n            difference <= dividend - subtrahend;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_result;\n    \n    u_divider u_divider_inst (\n        .clk(clk),\n        .rst(rst),\n        .x(x),\n        .y(y),\n        .quotient(div_result)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .clk(clk),\n        .rst(rst),\n        .dividend(div_result),\n        .subtrahend(z),\n        .difference(difference)\n    );\n    \n    assign quotient = div_result;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n\n    bitwise_and u_and (\n        .a(a),\n        .b(b),\n        .result(and_out)\n    );\n\n    bitwise_or u_or (\n        .a(a),\n        .b(b),\n        .result(or_out)\n    );\n\n    always @(posedge clk) begin\n        case (op_sel)\n            2'b00: result <= add_out;\n            2'b01: result <= sub_out;\n            2'b10: result <= and_out;\n            2'b11: result <= or_out;\n            default: result <= 32'b0;\n        endcase\n    end\n\nendmodule\n\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    wire [31:0] result_adder;\n    wire [31:0] result_and;\n\n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .result(result_adder)\n    );\n\n    u_bitwise_and u_bitwise_and_inst (\n        .a(a),\n        .b(b),\n        .result(result_and)\n    );\n\n    assign result = (op_sel == 1'b0) ? result_adder : result_and;\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input         clk,\n    input         rst,\n    input         mode,\n    input [15:0]  a,\n    input [15:0]  b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n\n    u_adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n\n    always @(posedge clk) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule\n\nmodule u_adder(\n    input  [15:0] a,\n    input  [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input  [15:0] a,\n    input  [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b ^ bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input  bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6;\n\n    full_subtractor FS0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(b0)\n    );\n\n    full_subtractor FS1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(b0),\n        .diff(diff[1]),\n        .bout(b1)\n    );\n\n    full_subtractor FS2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(b1),\n        .diff(diff[2]),\n        .bout(b2)\n    );\n\n    full_subtractor FS3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(b2),\n        .diff(diff[3]),\n        .bout(b3)\n    );\n\n    full_subtractor FS4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(b3),\n        .diff(diff[4]),\n        .bout(b4)\n    );\n\n    full_subtractor FS5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(b4),\n        .diff(diff[5]),\n        .bout(b5)\n    );\n\n    full_subtractor FS6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(b5),\n        .diff(diff[6]),\n        .bout(b6)\n    );\n\n    full_subtractor FS7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(b6),\n        .diff(diff[7]),\n        .bout(bout)\n    );\n    \nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b1, b2, b3, b4, b5, b6, b7;\n\n    subtractor_1bit S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b1));\n    subtractor_1bit S1 (.a(a[1]), .b(b[1]), .bin(b1),  .diff(diff[1]), .bout(b2));\n    subtractor_1bit S2 (.a(a[2]), .b(b[2]), .bin(b2),  .diff(diff[2]), .bout(b3));\n    subtractor_1bit S3 (.a(a[3]), .b(b[3]), .bin(b3),  .diff(diff[3]), .bout(b4));\n    subtractor_1bit S4 (.a(a[4]), .b(b[4]), .bin(b4),  .diff(diff[4]), .bout(b5));\n    subtractor_1bit S5 (.a(a[5]), .b(b[5]), .bin(b5),  .diff(diff[5]), .bout(b6));\n    subtractor_1bit S6 (.a(a[6]), .b(b[6]), .bin(b6),  .diff(diff[6]), .bout(b7));\n    subtractor_1bit S7 (.a(a[7]), .b(b[7]), .bin(b7),  .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire [6:0] borrow;\n    \n    full_subtractor FS0(.a(a[0]), .b(b[0]), .bin(bin),       .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1(.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2(.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3(.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4(.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5(.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6(.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7(.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input  [3:0] a, b,\n    output [7:0] product\n);\n    wire [7:0] p0, p1, p2, p3;\n    \n    SAA #(0) SAA0 (.a(a), .b_bit(b[0]), .partial(p0));\n    SAA #(1) SAA1 (.a(a), .b_bit(b[1]), .partial(p1));\n    SAA #(2) SAA2 (.a(a), .b_bit(b[2]), .partial(p2));\n    SAA #(3) SAA3 (.a(a), .b_bit(b[3]), .partial(p3));\n    \n    assign product = p0 + p1 + p2 + p3;\n    \nendmodule\n\nmodule SAA #(\n    parameter SHIFT = 0\n)(\n    input  [3:0] a,\n    input        b_bit,\n    output [7:0] partial\n);\n    assign partial = b_bit ? (a << SHIFT) : 8'b0;\n    \nendmodule"}
{"task_id": "up_down_counter_v_10", "response": ""}
{"task_id": "up_down_counter_v_11", "response": "module u_adder (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_subtractor (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule u_and_logic (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule u_or_logic (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule modular_alu (\n    input  wire [1:0]   op_code,\n    input  wire [31:0]  a,\n    input  wire [31:0]  b,\n    output wire [31:0]  result,\n    output wire         zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    u_adder       u_adder_inst      (.a(a), .b(b), .result(add_result));\n    u_subtractor  u_subtractor_inst (.a(a), .b(b), .result(sub_result));\n    u_and_logic   u_and_logic_inst  (.a(a), .b(b), .result(and_result));\n    u_or_logic    u_or_logic_inst   (.a(a), .b(b), .result(or_result));\n\n    assign result = (op_code == 2'b00) ? add_result  :\n                    (op_code == 2'b01) ? sub_result  :\n                    (op_code == 2'b10) ? and_result  :\n                                         or_result;\n\n    assign zero = (result == 32'b0) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output reg [31:0] result,\n    output wire zero\n);\n    wire [31:0] adder_result;\n    wire [31:0] subtractor_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(adder_result)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(subtractor_result)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_out(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_out(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_out(xor_result)\n    );\n\n    always @(*) begin\n        case (op_code)\n            3'b000: result = adder_result;\n            3'b001: result = subtractor_result;\n            3'b010: result = and_result;\n            3'b011: result = or_result;\n            3'b100: result = xor_result;\n            default: result = 32'b0;\n        endcase\n    end\n\n    assign zero = (result == 32'b0) ? 1'b1 : 1'b0;\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_out\n);\n    assign xor_out = a ^ b;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    wire [31:0] adder_result;\n    wire [31:0] subtractor_result;\n    wire [31:0] bitwise_result;\n    wire        bitwise_sel;\n\n    assign bitwise_sel = op_code[0];\n\n    adder u_adder (\n        .clk(clk),\n        .a(operand_a),\n        .b(operand_b),\n        .sum(adder_result)\n    );\n\n    subtractor u_sub"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product(\n    input  [7:0] X,\n    input        Y_bit,\n    input  [3:0] shift,\n    output [15:0] partial\n);\n    assign partial = Y_bit ? ({8'b0, X} << shift) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n    \n    gen_product GP0(.X(X), .Y_bit(Y[0]), .shift(4'd0), .partial(pp0));\n    gen_product GP1(.X(X), .Y_bit(Y[1]), .shift(4'd1), .partial(pp1));\n    gen_product GP2(.X(X), .Y_bit(Y[2]), .shift(4'd2), .partial(pp2));\n    gen_product GP3(.X(X), .Y_bit(Y[3]), .shift(4'd3), .partial(pp3));\n    gen_product GP4(.X(X), .Y_bit(Y[4]), .shift(4'd4), .partial(pp4));\n    gen_product GP5(.X(X), .Y_bit(Y[5]), .shift(4'd5), .partial(pp5));\n    gen_product GP6(.X(X), .Y_bit(Y[6]), .shift(4'd6), .partial(pp6));\n    gen_product GP7(.X(X), .Y_bit(Y[7]), .shift(4'd7), .partial(pp7));\n    \n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n    \nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift(\n    input [15:0] acc,\n    input [7:0] X,\n    input bit_sel,\n    output [15:0] out\n);\n  parameter SHIFT = 0;\n  assign out = acc + (bit_sel ? ({8'b0, X} << SHIFT) : 16'b0);\nendmodule\n\nmodule mult_8bit(\n    input [7:0] X,\n    input [7:0] Y,\n    output [15:0] P\n);\n  wire [15:0] acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7;\n\n  add_shift #(.SHIFT(0)) AS0 (\n    .acc(16'b0),\n    .X(X),\n    .bit_sel(Y[0]),\n    .out(acc0)\n  );\n\n  add_shift #(.SHIFT(1)) AS1 (\n    .acc(acc0),\n    .X(X),\n    .bit_sel(Y[1]),\n    .out(acc1)\n  );\n\n  add_shift #(.SHIFT(2)) AS2 (\n    .acc(acc1),\n    .X(X),\n    .bit_sel(Y[2]),\n    .out(acc2)\n  );\n\n  add_shift #(.SHIFT(3)) AS3 (\n    .acc(acc2),\n    .X(X),\n    .bit_sel(Y[3]),\n    .out(acc3)\n  );\n\n  add_shift #(.SHIFT(4)) AS4 (\n    .acc(acc3),\n    .X(X),\n    .bit_sel(Y[4]),\n    .out(acc4)\n  );\n\n  add_shift #(.SHIFT(5)) AS5 (\n    .acc(acc4),\n    .X(X),\n    .bit_sel(Y[5]),\n    .out(acc5)\n  );\n\n  add_shift #(.SHIFT(6)) AS6 (\n    .acc(acc5),\n    .X(X),\n    .bit_sel(Y[6]),\n    .out(acc6)\n  );\n\n  add_shift #(.SHIFT(7)) AS7 (\n    .acc(acc6),\n    .X(X),\n    .bit_sel(Y[7]),\n    .out(acc7)\n  );\n\n  assign P = acc7;\n  \nendmodule"}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module adder4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] res\n);\n    assign res = a & b;\nendmodule\n\nmodule or_logical4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] res\n);\n    assign res = a | b;\nendmodule\n\nmodule simple_alu4bit(\n    input        clk,\n    input  [1:0] op_code,\n    input  [3:0] operand_a,\n    input  [3:0] operand_b,\n    output reg [3:0] result\n);\n\n    wire [3:0] sum;\n    wire [3:0] diff;\n    wire [3:0] and_res;\n    wire [3:0] or_res;\n\n    adder4bit    u_adder      (.a(operand_a), .b(operand_b), .sum(sum));\n    subtractor4bit u_subtractor (.a(operand_a), .b(operand_b), .diff(diff));\n    and_logical4bit u_and      (.a(operand_a), .b(operand_b), .res(and_res));\n    or_logical4bit  u_or       (.a(operand_a), .b(operand_b), .res(or_res));\n\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result <= sum;\n            2'b01: result <= diff;\n            2'b10: result <= and_res;\n            2'b11: result <= or_res;\n            default: result <= 4'b0;\n        endcase\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] add_out;\n    wire [3:0] sub_out;\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n\n    and_module u_and (\n        .a(a),\n        .b(b),\n        .and_res(and_out)\n    );\n\n    or_module u_or (\n        .a(a),\n        .b(b),\n        .or_res(or_out)\n    );\n\n    always @(*) begin\n        case(op)\n            2'b00: result = add_out;\n            2'b01: result = sub_out;\n            2'b10: result = and_out;\n            2'b11: result = or_out;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_res\n);\n    assign and_res = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_res\n);\n    assign or_res = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "module op_decoder(\n    input  [1:0] op_code,\n    output reg add,\n    output reg sub,\n    output reg and_op,\n    output reg or_op\n);\n    always @(*) begin\n        add    = 1'b0;\n        sub    = 1'b0;\n        and_op = 1'b0;\n        or_op  = 1'b0;\n        case(op_code)\n            2'b00: add    = 1'b1;\n            2'b01: sub    = 1'b1;\n            2'b10: and_op = 1'b1;\n            2'b11: or_op  = 1'b1;\n            default: ;\n        endcase\n    end\nendmodule\n\nmodule arithmetic_logic(\n    input  [3:0] data_a,\n    input  [3:0] data_b,\n    input        add,\n    input        sub,\n    input        and_op,\n    input        or_op,\n    output reg [3:0] result\n);\n    always @(*) begin\n        if (add)\n            result = data_a + data_b;\n        else if (sub)\n            result = data_a - data_b;\n        else if (and_op)\n            result = data_a & data_b;\n        else if (or_op)\n            result = data_a | data_b;\n        else\n            result = 4'b0000;\n    end\nendmodule\n\nmodule result_manager(\n    input  [3:0] result,\n    output       zero\n);\n    assign zero = (result == 4'b0000);\n"}
{"task_id": "stagepipe3_v_21", "response": "module arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\n  wire [15:0] add_result;\n  wire [15:0] sub_result;\n  wire [15:0] mul_result;\n  wire [15:0] div_result;\n  wire       div_valid;\n\n  add_module u_add (\n    .a(data_a),\n    .b(data_b),\n    .result(add_result)\n  );\n\n  sub_module u_sub (\n    .a(data_a),\n    .b(data_b),\n    .result(sub_result)\n  );\n\n  mul_module u_mul (\n    .a(data_a),\n    .b(data_b),\n    .result(mul_result)\n  );\n\n  div_module u_div (\n    .a(data_a),\n    .b(data_b),\n    .result(div_result),\n    .valid(div_valid)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if(rst) begin\n      result <= 16'd0;\n      valid <= 1'b0;\n    end\n    else begin\n      case(opcode)\n        2'b00: begin\n          result <= add_result;\n          valid  <= 1'b1;\n        end\n        2'b01: begin\n          result <= sub_result;\n          valid  <= 1'b1;\n        end\n        2'b10: begin\n          result <= mul_result;\n          valid  <= 1'b1;\n        end\n        2'b11: begin\n          result <= div_result;\n          valid  <= div_valid;\n        end\n        default: begin\n          result <= 16'd0;\n          valid  <= 1'b0;\n        end\n      endcase\n    end\n  end\n\nendmodule\n\nmodule add_module(\n  input [7:0] a,\n  input [7:0] b,\n  output [15:0] result\n);\n  assign result = a + b;\nendmodule\n\nmodule sub_module(\n  input [7:0] a,\n  input [7:0] b,\n  output [15:0] result\n);\n  assign result = a - b;\nendmodule\n\nmodule mul_module(\n  input [7:0] a,\n  input [7:0] b,\n  output [15:0] result\n);\n  assign result = a * b;\nendmodule\n\nmodule div_module(\n  input [7:0] a,\n  input [7:0] b,\n  output reg [15:0] result,\n  output reg valid\n);\n  always @(*) begin\n    if(b == 8'd0) begin\n      result = 16'd0;\n      valid  = 1'b0;\n   "}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare(\n    input a,\n    input b,\n    input eq_in,\n    output gt,\n    output lt,\n    output eq\n);\n    assign gt = eq_in & a & ~b;\n    assign lt = eq_in & ~a & b;\n    assign eq = eq_in & ~(a ^ b);\nendmodule\n\nmodule magnitude_comparator(\n    input  [3:0] A,\n    input  [3:0] B,\n    output       gt,\n    output       lt,\n    output       eq\n);\n    wire gt3, lt3, eq3;\n    wire gt2, lt2, eq2;\n    wire gt1, lt1, eq1;\n    wire gt0, lt0, eq0;\n\n    bit_compare bc3(\n        .a(A[3]),\n        .b(B[3]),\n        .eq_in(1'b1),\n        .gt(gt3),\n        .lt(lt3),\n        .eq(eq3)\n    );\n\n    bit_compare bc2(\n        .a(A[2]),\n        .b(B[2]),\n        .eq_in(eq3),\n        .gt(gt2),\n        .lt(lt2),\n        .eq(eq2)\n    );\n\n    bit_compare bc1(\n        .a(A[1]),\n        .b(B[1]),\n        .eq_in(eq2),\n        .gt(gt1),\n        .lt(lt1),\n        .eq(eq1)\n    );\n\n    bit_compare bc0(\n        .a(A[0]),\n        .b(B[0]),\n        .eq_in(eq1),\n        .gt(gt0),\n        .lt(lt0),\n        .eq(eq0)\n    );\n\n    assign gt = gt3 | gt2 | gt1 | gt0;\n    assign lt = lt3 | lt2 | lt1 | lt0;\n    assign eq = eq0;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module bitwise_and(a, b, result);\n  input [3:0] a, b;\n  output [3:0] result;\n  assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n  input [3:0] a, b;\n  output [3:0] result;\n  assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, result, carry);\n  input [3:0] a, b;\n  output [3:0] result;\n  output carry;\n  wire [4:0] sum;\n  \n  assign sum = a + b;\n  assign result = sum[3:0];\n  assign carry = sum[4];\nendmodule\n\nmodule subtractor_4bit(a, b, result, borrow);\n  input [3:0] a, b;\n  output [3:0] result;\n  output borrow;\n  wire [4:0] diff;\n  \n  assign diff = {1'b0, a} - {1'b0, b};\n  assign result = diff[3:0];\n  assign borrow = diff[4];\nendmodule\n\nmodule simple_alu(a, b, op, result, carry_borrow);\n  input [3:0] a, b;\n  input [1:0] op;\n  output [3:0] result;\n  output carry_borrow;\n  \n  wire [3:0] and_result, or_result, add_result, sub_result;\n  wire add_carry, sub_borrow;\n  \n  bitwise_and u_and (.a(a), .b(b), .result(and_result));\n  bitwise_or  u_or  (.a(a), .b(b), .result(or_result));\n  adder_4bit  u_add (.a(a), .b(b), .result(add_result), .carry(add_carry));\n  subtractor_4bit u_sub (.a(a), .b(b), .result(sub_result), .borrow(sub_borrow));\n  \n  reg [3:0] res_reg;\n  reg        cb_reg;\n  \n  always @(*) begin\n    case (op)\n      2'b00: begin\n        res_reg = and_result;\n        cb_reg  = 1'b0;\n      end\n      2'b01: begin\n        res_reg = or_result;\n        cb"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n  input  [7:0] temp_sensor;\n  input        smoke_sensor;\n  output       alarm_out;\n\n  wire temp_flag;\n  \n  compare_temp comp_temp_inst (\n    .temp(temp_sensor),\n    .temp_high(temp_flag)\n  );\n  \n  or_gate or_gate_inst (\n    .a(temp_flag),\n    .b(smoke_sensor),\n    .y(alarm_out)\n  );\nendmodule\n\nmodule compare_temp (temp, temp_high);\n  input  [7:0] temp;\n  output       temp_high;\n  parameter    THRESHOLD = 8'd50;\n  \n  assign temp_high = (temp > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_gate (a, b, y);\n  input  a, b;\n  output y;\n  \n  assign y = a | b;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": ""}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(D, P);\n  input  [7:0] D;\n  output       P;\n  assign P = ^D;\nendmodule\n\nmodule parity_16bit(X, Y, P);\n  input  [7:0] X, Y;\n  output       P;\n  wire         p1, p2;\n  \n  parity_8bit gen1(.D(X), .P(p1));\n  parity_8bit gen2(.D(Y), .P(p2));\n  \n  assign P = p1 ^ p2;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0 (\n        .a(a0),\n        .b(b0),\n        .sum(sum0)\n    );\n    \n    adder_unit au1 (\n        .a(a1),\n        .b(b1),\n        .sum(sum1)\n    );\n    \n    adder_unit au2 (\n        .a(a2),\n        .b(b2),\n        .sum(sum2)\n    );\n    \n    adder_unit au3 (\n        .a(a3),\n        .b(b3),\n        .sum(sum3)\n    );\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n    multiplier mult0 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .p(p0)\n    );\n    \n    multiplier mult1 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .p(p1)\n    );\n    \n    multiplier mult2 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .p(p2)\n    );\n    \n    multiplier mult3 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .p(p3)\n    );\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 16'd0;\n        else\n            p <= a * b;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module left_rotate(\n  input  [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule\n\nmodule right_rotate(\n  input  [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule cyclic_rotator4(\n  input        en,\n  input        rot_dir,\n  input  [3:0] in_data,\n  output [3:0] out_data\n);\n  wire [3:0] left_data;\n  wire [3:0] right_data;\n  \n  left_rotate lr_inst (\n    .in_data(in_data),\n    .out_data(left_data)\n  );\n  \n  right_rotate rr_inst (\n    .in_data(in_data),\n    .out_data(right_data)\n  );\n  \n  assign out_data = en ? (rot_dir ? left_data : right_data) : in_data;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input  clk,\n  input  rst,\n  input  mode,\n  input  enable,\n  output [7:0] count\n);\n\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\n\nendmodule\n\nmodule Counter (\n  input       clk,\n  input       rst,\n  input       mode,\n  input       enable,\n  output reg [7:0] count\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 8'd1;\n      else\n        count <= count - 8'd1;\n    end\n  end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n\n  latch latch0_inst (\n    .clk(clk),\n    .reset(reset),\n    .load(load0),\n    .d(d0),\n    .q(q0)\n  );\n  \n  latch latch1_inst (\n    .clk(clk),\n    .reset(reset),\n    .load(load1),\n    .d(d1),\n    .q(q1)\n  );\n\nendmodule\n\nmodule latch (\n    input clk,\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge load or posedge reset)\n    if (reset)\n      q <= 8'b0;\n    else\n      q <= d;\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (rst)\n            out <= 8'd0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n    \n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module adder_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    input        Carry_in,\n    output [7:0] Sum,\n    output       Carry_out\n);\n    wire [8:0] carry;\n    assign carry[0] = Carry_in;\n    genvar i;\n    generate\n        for(i = 0; i < 8; i = i + 1) begin : full_adder_block\n            assign Sum[i] = X[i] ^ Y[i] ^ carry[i];\n            assign carry[i+1] = (X[i] & Y[i]) | (carry[i] & (X[i] ^ Y[i]));\n        end\n    endgenerate\n    assign Carry_out = carry[8];\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] X,    // First 32-bit input operand\n    input  [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum,  // 32-bit output sum\n    output        Carry_out  // Carry output\n);\n    wire c1, c2, c3;\n    \n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .Carry_in(1'b0),\n        .Sum(Sum[7:0]),\n        .Carry_out(c1)\n    );\n    \n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .Carry_in(c1),\n        .Sum(Sum[15:8]),\n        .Carry_out(c2)\n    );\n    \n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .Carry_in(c2),\n        .Sum(Sum[23:16]),\n        .Carry_out(c3)\n    );\n    \n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .Carry_in(c3),\n        .Sum(Sum[31:24]),\n        .Carry_out(Carry_out)\n    );\n    \nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c1, c2, c3;\n    \n    adder_8bit add0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n    \n    adder_8bit add1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n    \n    adder_8bit add2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n    \n    adder_8bit add3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output carry_out\n);\n    assign {carry_out, diff} = A + (~B) + 1;\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] res\n);\n    assign res = A & B;\nendmodule\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result;\n    wire        add_carry;\n    wire [31:0] sub_result;\n    wire        sub_carry;\n    wire [31:0] and_result;\n    \n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .sum(add_result),\n        .carry_out(add_carry)\n    );\n    \n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(sub_result),\n        .carry_out(sub_carry)\n    );\n    \n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .res(and_result)\n    );\n    \n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    (op == 2'b10) ? and_result : 32'b0;\n                    \n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry : 1'b0;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux_path0(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] y\n);\n    always @(posedge clk) begin\n        y <= d;\n    end\nendmodule\n\nmodule mux_path1(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] y\n);\n    always @(posedge clk) begin\n        y <= d;\n    end\nendmodule\n\nmodule mux_path2(\n    input clk,\n    input [7:0] d,\n    output reg [7:0] y\n);\n    always @(posedge clk) begin\n        y <= d;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    \n    mux_path0 u_mux0 (\n        .clk(clk),\n        .d(d0),\n        .y(mux0_out)\n    );\n    \n    mux_path1 u_mux1 (\n        .clk(clk),\n        .d(d1),\n        .y(mux1_out)\n    );\n    \n    mux_path2 u_mux2 (\n        .clk(clk),\n        .d(d2),\n        .y(mux2_out)\n    );\n    \n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'b0;\n                      \nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold (\n    input clk,\n    input en,\n    input [7:0] data,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (en)\n            q <= data;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n    wire en0, en1, en2, en3;\n    assign en0 = (sel == 2'b00);\n    assign en1 = (sel == 2'b01);\n    assign en2 = (sel == 2'b10);\n    assign en3 = (sel == 2'b11);\n\n    wire [7:0] q0, q1, q2, q3;\n\n    hold hold0 (\n        .clk(clk),\n        .en(en0),\n        .data(in0),\n        .q(q0)\n    );\n\n    hold hold1 (\n        .clk(clk),\n        .en(en1),\n        .data(in1),\n        .q(q1)\n    );\n\n    hold hold2 (\n        .clk(clk),\n        .en(en2),\n        .data(in2),\n        .q(q2)\n    );\n\n    hold hold3 (\n        .clk(clk),\n        .en(en3),\n        .data(in3),\n        .q(q3)\n    );\n\n    assign out = (sel == 2'b00) ? q0 :\n                 (sel == 2'b01) ? q1 :\n                 (sel == 2'b10) ? q2 : q3;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n    wire [15:0] count;\n    \n    pwm_counter u_pwm_counter (\n        .clk(clk),\n        .reset(1'b0),\n        .freq(freq),\n        .count(count)\n    );\n    \n    pwm_signal u_pwm_signal (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n    always @(posedge clk) begin\n        if (reset || (count == (freq - 1)))\n            count <= 16'd0;\n        else\n            count <= count + 16'd1;\n    end\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n    wire [15:0] threshold;\n    assign threshold = (freq * duty_cycle) / 100;\n    \n    always @(posedge clk) begin\n        if (count < threshold)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n    \n    duty_ctrl u_duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n    \n    pulse_gen u_pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n    reg [7:0] counter;\n    \n    always @(posedge clk) begin\n        if (counter == 8'd255)\n            counter <= 8'd0;\n        else\n            counter <= counter + 1;\n    end\n\n    always @(posedge clk) begin\n        if (counter < duty_cycle)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n    \n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n    \n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n    \n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n    \n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n    \n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [15:0] p\n);\n    assign p = a * b;\nendmodule\n\nmodule multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n    wire [15:0] pp0, pp1, pp2, pp3;\n\n    mult8 mult8_inst1 (\n        .a(x[7:0]),\n        .b(y[7:0]),\n        .p(pp0)\n    );\n\n    mult8 mult8_inst2 (\n        .a(x[7:0]),\n        .b(y[15:8]),\n        .p(pp1)\n    );\n\n    mult8 mult8_inst3 (\n        .a(x[15:8]),\n        .b(y[7:0]),\n        .p(pp2)\n    );\n\n    mult8 mult8_inst4 (\n        .a(x[15:8]),\n        .b(y[15:8]),\n        .p(pp3)\n    );\n\n    wire [31:0] partial0 = {16'b0, pp0};\n    wire [31:0] partial1 = {8'b0, pp1, 8'b0};\n    wire [31:0] partial2 = {8'b0, pp2, 8'b0};\n    wire [31:0] partial3 = {pp3, 16'b0};\n\n    assign prod = partial0 + partial1 + partial2 + partial3;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] br1_out;\n    \n    bit_reverse br1 (\n        .din(din),\n        .dout(br1_out)\n    );\n    \n    bit_reverse br2 (\n        .din(br1_out),\n        .dout(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8(\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] add_result;\n    \n    my_adder8 u_my_adder8 (\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n    \n    always @(*) begin\n        if (ctrl)\n            sum = add_result;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    pwm_module_25 u_pwm25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_25(PWM_25)\n    );\n\n    pwm_module_50 u_pwm50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_50(PWM_50)\n    );\n\n    pwm_module_75 u_pwm75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_75(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_module_25(\n    input CLK_in,\n    input RST,\n    output reg PWM_25\n);\n    parameter PERIOD = 8'd255;\n    parameter THRESHOLD = 8'd64;\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 8'd0;\n            PWM_25 <= 1'b0;\n        end else begin\n            if (cnt < THRESHOLD)\n                PWM_25 <= 1'b1;\n            else\n                PWM_25 <= 1'b0;\n                \n            if (cnt >= PERIOD)\n                cnt <= 8'd0;\n            else\n                cnt <= cnt + 1'b1;\n        end\n    end\nendmodule\n\nmodule pwm_module_50(\n    input CLK_in,\n    input RST,\n    output reg PWM_50\n);\n    parameter PERIOD = 8'd255;\n    parameter THRESHOLD = 8'd128;\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 8'd0;\n            PWM_50 <= 1'b0;\n        end else begin\n            if (cnt < THRESHOLD)\n                PWM_50 <= 1'b1;\n            else\n                PWM_50 <= 1'b0;\n                \n            if (cnt >= PERIOD)\n                cnt <= 8'd0;\n            else\n                cnt <= cnt + 1'b1;\n        end\n    end\nendmodule\n\nmodule pwm_module_75(\n    input CLK_in,\n    input RST,\n    output reg PWM_75\n);\n    parameter PERIOD = 8'd255;\n    parameter THRESHOLD = 8'd192;\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            cnt <= 8'd0;\n            PWM_75 <= 1'b0;\n       "}
{"task_id": "freq_div_v_48", "response": "`timescale 1ns/1ps\n\nmodule pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_duty_25 u_pwm25 (\n        .CLK(CLK_in),\n        .RST(RST),\n        .pwm(PWM_25)\n    );\n\n    pwm_duty_50 u_pwm50 (\n        .CLK(CLK_in),\n        .RST(RST),\n        .pwm(PWM_50)\n    );\n\n    pwm_duty_75 u_pwm75 (\n        .CLK(CLK_in),\n        .RST(RST),\n        .pwm(PWM_75)\n    );\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK,\n    input RST,\n    output reg pwm\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = PERIOD / 4;\n    reg [$clog2(PERIOD)-1:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm <= 0;\n        end else begin\n            if (counter == PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n                \n            if (counter < THRESHOLD)\n                pwm <= 1;\n            else\n                pwm <= 0;\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK,\n    input RST,\n    output reg pwm\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = PERIOD / 2;\n    reg [$clog2(PERIOD)-1:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm <= 0;\n        end else begin\n            if (counter == PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n                \n            if (counter < THRESHOLD)\n                pwm <= 1;\n            else\n                pwm <= 0;\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK,\n    input RST,\n    output reg pwm\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 3) / 4;\n    reg [$clog2(PERIOD)-1:0] counter;\n\n    always @(posedge CLK or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            pwm <= 0;\n        end else begin\n            if (counter == PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n                \n            if (counter < THRESHOLD)\n                pwm <= 1;\n            else\n                pwm <= 0;\n        end\n    end\nendmodule`"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE = 50;\n    parameter MAX_COUNT = 255;\n    localparam CNT_WIDTH = $clog2(MAX_COUNT + 1);\n\n    wire [CNT_WIDTH-1:0] counter_value;\n\n    counter #(\n        .MAX_COUNT(MAX_COUNT),\n        .CNT_WIDTH(CNT_WIDTH)\n    ) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(counter_value)\n    );\n\n    comparator #(\n        .DUTY_CYCLE(DUTY_CYCLE),\n        .MAX_COUNT(MAX_COUNT),\n        .CNT_WIDTH(CNT_WIDTH)\n    ) u_comparator (\n        .count(counter_value),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule\n\nmodule counter #(\n    parameter MAX_COUNT = 255,\n    parameter CNT_WIDTH = 8\n)(\n    input clk,\n    input rst_n,\n    output reg [CNT_WIDTH-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == MAX_COUNT)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule comparator #(\n    parameter DUTY_CYCLE = 50,\n    parameter MAX_COUNT = 255,\n    parameter CNT_WIDTH = 8\n)(\n    input [CNT_WIDTH-1:0] count,\n    output pwm_out\n);\n    localparam THRESHOLD = (DUTY_CYCLE * (MAX_COUNT + 1)) / 100;\n    assign pwm_out = (count < THRESHOLD) ? 1'b1 : 1'b0;\n    \nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n    wire [63:0] result_signed;\n    wire [63:0] result_unsigned;\n    wire [63:0] mult_result;\n    \n    mult_signed mult_signed_inst(\n        .a(a),\n        .b(b),\n        .y(result_signed)\n    );\n    \n    mult_unsigned mult_unsigned_inst(\n        .a(a),\n        .b(b),\n        .y(result_unsigned)\n    );\n    \n    assign mult_result = (multc == 1'b0) ? result_signed : result_unsigned;\n    assign y = mult_result;\n    assign msb = mult_result[63:32];\n    assign lsb = mult_result[31:0];\n    assign zero = (mult_result == 64'b0);\n    \nendmodule\n\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    wire signed [31:0] a_signed;\n    wire signed [31:0] b_signed;\n    \n    assign a_signed = a;\n    assign b_signed = b;\n    assign y = a_signed * b_signed;\n    \nendmodule\n\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = {32'b0, a} * {32'b0, b};\n    \nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input         clk,\n    input         rst,\n    input         en,\n    output [3:0]  count_out,\n    output        overflow\n);\n    wire [3:0] count;\n\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count)\n    );\n\n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .count(count),\n        .overflow(overflow)\n    );\n\n    assign count_out = count;\nendmodule\n\nmodule count_control (\n    input         clk,\n    input         rst,\n    input         en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1'b1;\n        else\n            count <= count;\n    end\nendmodule\n\nmodule overflow_detection (\n    input         clk,\n    input         rst,\n    input  [3:0]  count,\n    output reg    overflow\n);\n    reg [3:0] prev_count;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'b0000;\n            overflow   <= 1'b0;\n        end\n        else begin\n            if (prev_count == 4'd15 && count == 4'd0)\n                overflow <= 1'b1;\n            else\n                overflow <= 1'b0;\n            prev_count <= count;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module add(\n    input clk,\n    input rst,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= operand_a + operand_b;\n    end\nendmodule\n\nmodule subtract(\n    input clk,\n    input rst,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= operand_a - operand_b;\n    end\nendmodule\n\nmodule bitwise_and(\n    input clk,\n    input rst,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= operand_a & operand_b;\n    end\nendmodule\n\nmodule bitwise_or(\n    input clk,\n    input rst,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= operand_a | operand_b;\n    end\nendmodule\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] and_res;\n    wire [31:0] or_res;\n\n    add u_add(\n        .clk(clk),\n        .rst(rst),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(sum)\n    );\n\n    subtract u_subtract(\n        .clk(clk),\n        .rst(rst),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(diff)\n    );\n    \n    bitwise_and u_and(\n        .clk(clk),\n        .rst(rst),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(and_res)\n    );\n    \n    bitwise_or u_or(\n        .clk(clk),\n        .rst(rst),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(or_res)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else begin\n            case (op_code)\n                2'b00: result <= sum;\n                2'b01: result <= diff;\n                2'b10: result <= and_res;\n                2'b11: result <= or_res;\n                default: result <= 32'd0;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": ""}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_8bit(A, B, Bin, D, Bout);\n  input  [8:1] A;\n  input  [8:1] B;\n  input        Bin;\n  output [8:1] D;\n  output       Bout;\n  \n  assign D = A - B - Bin;\n  assign Bout = (A < (B + Bin)) ? 1'b1 : 1'b0;\nendmodule\n\nmodule subtractor_32bit(A, B, Bin, D, Bout);\n  input  [32:1] A;\n  input  [32:1] B;\n  input         Bin;\n  output [32:1] D;\n  output        Bout;\n  \n  wire b0, b1, b2;\n  \n  subtractor_"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\n  my_tff u0 (\n    .clk(clk),\n    .reset(reset),\n    .t(1'b1),\n    .q(count[0])\n  );\n\n  my_tff u1 (\n    .clk(clk),\n    .reset(reset),\n    .t(count[0]),\n    .q(count[1])\n  );\n\n  my_tff u2 (\n    .clk(clk),\n    .reset(reset),\n    .t(count[0] & count[1]),\n    .q(count[2])\n  );\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    reg [3:0] count;\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n    \n    counter_init init_inst (\n        .reset(reset),\n        .init_val(init_val)\n    );\n    \n    counter_increment inc_inst (\n        .current(count),\n        .inc_val(inc_val)\n    );\n    \n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n    \n    assign out = count;\n    \nendmodule\n\nmodule counter_init (\n    input wire reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule counter_increment (\n    input wire [3:0] current,\n    output wire [3:0] inc_val\n);\n    assign inc_val = current + 4'b0001;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input  wire         clk,\n    input  wire         reset,\n    input  wire         up_down,\n    output wire [15:0]  count\n);\n    wire [15:0] next_count;\n\n    u_counter_logic u_counter_logic_inst (\n        .current(count),\n        .up_down(up_down),\n        .next(next_count)\n    );\n\n    u_counter_register u_counter_register_inst (\n        .clk(clk),\n        .reset(reset),\n        .d(next_count),\n        .q(count)\n    );\nendmodule\n\nmodule u_counter_logic (\n    input  wire [15:0] current,\n    input  wire        up_down,\n    output wire [15:0] next\n);\n    assign next = up_down ? (current + 16'd1) : (current - 16'd1);\nendmodule\n\nmodule u_counter_register (\n    input  wire         clk,\n    input  wire         reset,\n    input  wire [15:0]  d,\n    output reg  [15:0]  q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 16'd0;\n        else\n            q <= d;\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_val;\n    wire [7:0] next_val;\n    reg [7:0] state;\n\n    ring_counter_init u_init (\n        .init_state(init_val)\n    );\n\n    ring_counter_transition u_transition (\n        .current_state(state),\n        .next_state(next_val)\n    );\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= init_val;\n        else\n            state <= next_val;\n    end\n\n    assign out = state;\nendmodule\n\nmodule ring_counter_init (\n    output wire [7:0] init_state\n);\n    assign init_state = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition (\n    input wire [7:0] current_state,\n    output wire [7:0] next_state\n);\n    assign next_state = {current_state[6:0], current_state[7]};\nendmodule"}
{"task_id": "counter_12", "response": "module counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      count <= 4'b0000;\n    else if (valid_count) begin\n      if (count == 4'd11)\n        count <= 4'b0000;\n      else\n        count <= count + 1;\n    end\n    else\n      count <= count;\n  end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] data_in,\n    output reg [3:0] data_out\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      data_out <= 4'b0000;\n    else if (valid_count)\n      data_out <= data_in;\n    else\n      data_out <= data_out;\n  end\nendmodule\n\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n  wire [3:0] current_count;\n\n  counter_logic u_counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .count(current_count)\n  );\n\n  output_register u_output_register (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .data_in(current_count),\n    .data_out(out)\n  );\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n    clk_div_2 div2 (\n        .clk(CLK_in),\n        .rst(RST),\n        .clk_out(CLK_50)\n    );\n\n    clk_div_10 div10 (\n        .clk(CLK_in),\n        .rst(RST),\n        .clk_out(CLK_10)\n    );\n\n    clk_div_100 div100 (\n        .clk(CLK_in),\n        .rst(RST),\n        .clk_out(CLK_1)\n    );\nendmodule\n\nmodule clk_div_2 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            clk_out <= 1'b0;\n        else\n            clk_out <= ~clk_out;\n    end\nendmodule\n\nmodule clk_div_10 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n    reg [2:0] count;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count   <= 0;\n            clk_out <= 1'b0;\n        end\n        else if (count == 4) begin\n            count   <= 0;\n            clk_out <= ~clk_out;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] count;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count   <= 0;\n            clk_out <= 1'b0;\n        end\n        else if (count == 49) begin\n            count   <= 0;\n            clk_out <= ~clk_out;\n        end\n        else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": ""}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven #\n(\n    parameter NUM_DIV = 4  // Must be an even number\n)\n(\n    input  clk,\n    input  rst_n,\n    output clk_div\n);\n\n  wire tick;\n\n  counter #(.COUNT_MAX((NUM_DIV/2)-1)) u_counter (\n    .clk   (clk),\n    .rst_n (rst_n),\n    .tick  (tick)\n  );\n\n  clk_divider u_clk_divider (\n    .clk    (clk),\n    .rst_n  (rst_n),\n    .tick   (tick),\n    .clk_div(clk_div)\n  );\n\nendmodule\n\nmodule counter #\n(\n    parameter COUNT_MAX = 1\n)\n(\n    input  clk,\n    input  rst_n,\n    output reg tick\n);\n\n  reg [3:0] cnt;\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n      cnt  <= 4'd0;\n      tick <= 1'b0;\n    end else begin\n      if (cnt == COUNT_MAX) begin\n        cnt  <= 4'd0;\n        tick <= 1'b1;\n      end else begin\n        cnt  <= cnt + 1;\n        tick <= 1'b0;\n      end\n    end\n  end\n\nendmodule\n\nmodule clk_divider\n(\n    input  clk,\n    input  rst_n,\n    input  tick,\n    output reg clk_div\n);\n\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      clk_div <= 1'b0;\n    else if (tick)\n      clk_div <= ~clk_div;\n  end\n\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] in,\n    output reg [31:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 32'b0;\n        else\n            out <= out + in;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] product;\n\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .product(product)\n    );\n    \n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .in(product[31:0]),\n        .out(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": "module ins_p1 (\n    input clk,\n    input rst,\n    input en,\n    input [7:0] data,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (!rst)\n            q <= 8'b0;\n        else if (en)\n            q <= data;\n        else\n            q <= q;\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input en,\n    input [7:0] data,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (!rst)\n            q <= 8'b0;\n        else if (en)\n            q <= data;\n        else\n            q <= q;\n    end\nendmodule\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire en_p1, en_p2;\n    assign en_p1 = (fetch == 2'b01);\n    assign en_p2 = (fetch == 2'b10);\n\n    wire [7:0] ins_p1_q;\n    wire [7:0] ins_p2_q;\n\n    ins_p1 u_ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .en(en_p1),\n        .data(data),\n        .q(ins_p1_q)\n    );\n\n    ins_p2 u_ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .en(en_p2),\n        .data(data),\n        .q(ins_p2_q)\n    );\n\n    assign ins  = ins_p1_q[7:5];\n    assign ad1  = ins_p1_q[4:0];\n    assign ad2  = ins_p2_q;\n    \nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq != 8'd0);\n\n    counter cnt_inst (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator wg_inst (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 8'd0;\n            else\n                count <= count + 1'b1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial begin\n        wave_out = 1'b0;\n    end\n\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            wave_out <= ~wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input  clk,\n    input  rst_n,\n    output [4:0] wave\n);\n\nwire [1:0] state;\nwire [4:0] wave_reg;\n\nstate_control state_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .wave(wave_reg),\n    .state(state)\n);\n\nwaveform_generation wave_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .state(state),\n    .wave(wave_reg)\n);\n\nassign wave = wave_reg;\n\nendmodule\n\nmodule state_control (\n    input        clk,\n    input        rst_n,\n    input  [4:0] wave,\n    output reg [1:0] state\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        state <= 2'b00;\n    else begin\n        case (state)\n            2'b00: begin\n                if (wave == 5'd31)\n                    state <= 2'b01;\n                else\n                    state <= 2'b00;\n            end\n            2'b01: begin\n                if (wave == 5'd0)\n                    state <= 2'b00;\n                else\n                    state <= 2'b01;\n            end\n            default: state <= 2'b00;\n        endcase\n    end\nend\n\nendmodule\n\nmodule waveform_generation (\n    input        clk,\n    input        rst_n,\n    input  [1:0] state,\n    output reg [4:0] wave\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        wave <= 5'd0;\n    else begin\n        case (state)\n            2'b00: begin\n                if (wave < 5'd31)\n                    wave <= wave + 1;\n                else\n                    wave <= wave;\n            end\n            2'b01: begin\n                if (wave > 5'd0)\n                    wave <= wave - 1;\n                else\n                    wave <= wave;\n            end\n            default: wave <= wave;\n        endcase\n    end\nend\n\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\nwire [7:0] q0, q1, q2;\n\nmy_dff8 u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff8 u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff8 u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q2)\n);\n\nalways @(*) begin\n    case (sel)\n        2'b00: q = d;\n        2'b01: q = q0;\n        2'b10: q = q1;\n        2'b11: q = q2;\n    endcase\nend\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\nwire q0, q1;\n\nmy_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q)\n);\n\nendmodule"}
{"task_id": "barrel_shifter", "response": "module mux2X1 (\n    input  in0,\n    input  in1,\n    input  sel,\n    output out\n);\n    assign out = sel ? in1 : in0;\nendmodule\n\nmodule barrel_shifter (\n    input  [7:0] in,\n    input  [2:0] ctrl,\n    output [7:0] out\n);\n    wire [7:0] stage0;\n    wire [7:0] stage1;\n    wire [7:0] stage2;\n    \n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : stage0_gen\n            mux2X1 m0 (\n                .in0(in[i]),\n                .in1(in[(i+4)%8]),\n                .sel(ctrl[2]),\n                .out(stage0[i])\n            );\n        end\n    endgenerate\n\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : stage1_gen\n            mux2X1 m1 (\n                .in0(stage0[i]),\n                .in1(stage0[(i+2)%8]),\n                .sel(ctrl[1]),\n                .out(stage1[i])\n            );\n        end\n    endgenerate\n\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : stage2_gen\n            mux2X1 m2 (\n                .in0(stage1[i]),\n                .in1(stage1[(i+1)%8]),\n                .sel(ctrl[0]),\n                .out(stage2[i])\n            );\n        end\n    endgenerate\n\n    assign out = stage2;\n    \nendmodule"}
{"task_id": "systolic1x2", "response": "module pe (\n  input         clk,\n  input         rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + a * b;\n  end\nendmodule\n\nmodule systolic1x2 (\n  input         clk,\n  input         rst,\n  input  [15:0] a0,\n  input  [15:0] a1,\n  input  [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe(\n  input         clk,\n  input         rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x4(\n  input         clk,\n  input         rst,\n  input  [15:0] a0,\n  input  [15:0] a1,\n  input  [15:0] a2,\n  input  [15:0] a3,\n  input  [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n\n  reg [15:0] b1, b2, b3;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'd0;\n      b2 <= 16'd0;\n      b3 <= 16'd0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  pe pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  pe pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n  wire [31:0] prepared_dividend;\n  wire [31:0] prepared_divisor;\n\n  prep_dividend u_prep_dividend (\n    .A(A),\n    .B(B),\n    .prepared_dividend(prepared_dividend),\n    .prepared_divisor(prepared_divisor)\n  );\n\n  div_operation u_div_operation (\n    .dividend(prepared_dividend),\n    .divisor(prepared_divisor),\n    .quotient(result),\n    .remainder(odd)\n  );\n\nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] prepared_dividend"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n);\n\n    wire [15:0] quotient_wire;\n    wire [15:0] remainder_wire;\n    \n    div_ctrl ctrl_inst (\n        .A(A),\n        .B(B),\n        .quotient(quotient_wire),\n        .remainder(remainder_wire)\n    );\n    \n    assign result = quotient_wire;\n    assign odd = remainder_wire;\n\nendmodule\n\nmodule div_ctrl (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    integer i;\n    reg [15:0] rem;\n    reg [15:0] quot;\n    \n    always @(*) begin"}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        cin,\n    output [7:0] S,\n    output       cout\n);\n    wire [8:0] carry;\n    assign carry[0] = cin;\n    genvar i;\n    generate\n        for(i = 0; i < 8; i = i + 1) begin : adder_gen\n            full_adder FA (\n                .a   (A[i]),\n                .b   (B[i]),\n                .cin (carry[i]),\n                .sum (S[i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n    assign cout = carry[8];\nendmodule\n\nmodule sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    output [7:0] D,\n    output       B_out\n);\n    wire [7:0] B_comp;\n    wire       cout;\n\n    assign B_comp = ~B;\n    adder_8bit adder_inst (\n        .A   (A),\n        .B   (B_comp),\n        .cin (1'b1),\n        .S   (D),\n        .cout(cout)\n    );\n    assign B_out = ~cout;\nendmodule"}
{"task_id": "sub_32bit", "response": "module subtractor_16bit(A, B, borrow_in, Diff, borrow_out);\n    input  [15:0] A;\n    input  [15:0] B;\n    input         borrow_in;\n    output [15:0] Diff;\n    output        borrow_out;\n\n    wire [16:0] temp;\n\n    assign temp = {1'b0, A} - {1'b0, B} - borrow_in;\n    assign Diff = temp[15:0];\n    assign borrow_out = temp[16];\nendmodule\n\nmodule sub_32bit(A, B, Diff, B_out);\n    input  [31:0] A;\n    input  [31:0] B;\n    output [31:0] Diff;\n    output        B_out;\n\n    wire borrow_lower;\n\n    subtractor_16bit u_lower (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(1'b0),\n        .Diff(Diff[15:0]),\n        .borrow_out(borrow_lower)\n    );\n\n    subtractor_16bit u_upper (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_lower),\n        .Diff(Diff[31:16]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        borrow_in,\n    output [7:0] D,\n    output       borrow"}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    assign {borrow, diff} = {1'b0, A} - {1'b0, B};\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater, \n    output        A_equal,   \n    output        A_less     \n);\n    wire [31:0] difference;\n    wire        borrow;\n    wire        diff_nonzero;\n    \n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(difference),\n        .borrow(borrow)\n    );\n    \n    assign diff_nonzero = |difference;\n    \n    assign A_less    = borrow;\n    assign A_greater = (~borrow) & diff_nonzero;\n    assign A_equal   = (~borrow) & (~diff_nonzero);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule ripple_carry_adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input  cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire c1, c2, c3;\n    \n    full_adder fa0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(a[1]), .b(b[1]), .cin(c1), .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(a[2]), .b(b[2]), .cin(c2), .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(a[3]), .b(b[3]), .cin(c3), .sum(sum[3]), .cout(cout));\nendmodule\n\nmodule csa_slice(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       cout0, cout1;\n    \n    ripple_carry_adder_4bit rca0(.a(a), .b(b), .cin(1'b0), .sum(sum0),"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Cout\n);\n    assign {Cout, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry0;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Cout(carry0)\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry0),\n        .y(y[15:8]),\n        .Cout(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (cin & a);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a, b,\n    input        cin,\n    output [7:0] sum,\n    output       cout\n);\n    wire c1, c2, c3, c4, c5, c6, c7;\n\n    full_adder FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n\n    full_adder FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n\n    full_adder FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n\n    full_adder FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(c4)\n    );\n\n    full_adder FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(c4),\n        .sum(sum[4]),\n        .cout(c5)\n    );\n\n    full_adder FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(c5),\n        .sum(sum[5]),\n        .cout(c6)\n    );\n\n    full_adder FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(c6),\n        .sum(sum[6]),\n        .cout(c7)\n    );\n\n    full_adder FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(c7),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n\nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module u_adder(\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] result\n);\nassign result = op1 + op2;\nendmodule\n\nmodule u_subtractor(\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] result\n);\nassign result = op1 - op2;\nendmodule\n\nmodule as_module(\n    input         clk,\n    input         rst,\n    input         mode,\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\nu_adder u_adder_inst (\n    .op1(op1),\n    .op2(op2),\n    .result(add_result)\n);\n\nu_subtractor u_subtractor_inst (\n    .op1(op1),\n    .op2(op2),\n    .result(sub_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result <= 32'b0;\n    else\n        result <= (mode == 1'b0) ? add_result : sub_result;\nend\n\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient\n);\n    always @(posedge clk) begin\n        if (rst)\n            quotient <= 32'd0;\n        else begin\n            if(divisor != 32'd0)\n                quotient <= dividend / divisor;\n            else\n                quotient <= 32'd0;\n        end\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] difference\n);\n    always @(posedge clk) begin\n        if (rst)\n            difference <= 32'd0;\n        else\n            difference <= a - b;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_result;\n    \n    u_divider divider_inst(\n        .clk(clk),\n        .rst(rst),\n        .dividend(x),\n        .divisor(y),\n        .quotient(div_result)\n    );\n    \n    u_subtractor subtractor_inst(\n        .clk(clk),\n        .rst(rst),\n        .a(div_result),\n        .b(z),\n        .difference(difference)\n    );\n    \n    assign quotient = div_result;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n\n    u_adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n\n    u_subtractor subtractor_inst (\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n\n    u_and and_inst (\n        .a(a),\n        .b(b),\n        .and_out(and_out)\n    );\n\n    u_or or_inst (\n        .a(a),\n        .b(b),\n        .or_out(or_out)\n    );\n\n    always @(posedge clk) begin\n        case (op_sel)\n            2'b00: result <= add_out;\n            2'b01: result <= sub_out;\n            2'b10: result <= and_out;\n            2'b11: result <= or_out;\n            default: result <= 32'b0;\n        endcase\n    end\n\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] bitwise_and_result;\n\n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_bitwise_and u_bitwise_and_inst (\n        .a(a),\n        .b(b),\n        .and_result(bitwise_and_result)\n    );\n\n    reg [31:0] result_reg;\n\n    always @(posedge clk) begin\n        if (op_sel == 1'b0)\n            result_reg <= add_result;\n        else\n            result_reg <= bitwise_and_result;\n    end\n\n    assign result = result_reg;\nendmodule"}
{"task_id": "pe_v_4", "response": "module adder(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst)\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= a + b;\nendmodule\n\nmodule subtractor(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst)\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n\n    adder u_adder(\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor(\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n\n    always @(posedge clk or posedge rst)\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6, b7;\n\n    full_subtractor FS0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(b0)\n    );\n\n    full_subtractor FS1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(b0),\n        .diff(diff[1]),\n        .bout(b1)\n    );\n\n    full_subtractor FS2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(b1),\n        .diff(diff[2]),\n        .bout(b2)\n    );\n\n    full_subtractor FS3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(b2),\n        .diff(diff[3]),\n        .bout(b3)\n    );\n\n    full_subtractor FS4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(b3),\n        .diff(diff[4]),\n        .bout(b4)\n    );\n\n    full_subtractor FS5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(b4),\n        .diff(diff[5]),\n        .bout(b5)\n    );\n\n    full_subtractor FS6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(b5),\n        .diff(diff[6]),\n        .bout(b6)\n    );\n\n    full_subtractor FS7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(b6),\n        .diff(diff[7]),\n        .bout(b7)\n    );\n\n    assign bout = b7;\nendmodule\n\nmodule full_subtractor(\n    input a, b, bin,\n    output diff, bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = ((~a) & b) | ((~(a ^ b)) & bin);\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire w0, w1, w2, w3, w4, w5, w6;\n\n    subtractor_1bit S0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(w0)\n    );\n\n    subtractor_1bit S1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(w0),\n        .diff(diff[1]),\n        .bout(w1)\n    );\n\n    subtractor_1bit S2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(w1),\n        .diff(diff[2]),\n        .bout(w2)\n    );\n\n    subtractor_1bit S3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(w2),\n        .diff(diff[3]),\n        .bout(w3)\n    );\n\n    subtractor_1bit S4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(w3),\n        .diff(diff[4]),\n        .bout(w4)\n    );\n\n    subtractor_1bit S5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(w4),\n        .diff(diff[5]),\n        .bout(w5)\n    );\n\n    subtractor_1bit S6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(w5),\n        .diff(diff[6]),\n        .bout(w6)\n    );\n\n    subtractor_1bit S7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(w6),\n        .diff(diff[7]),\n        .bout(bout)\n    );\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire [6:0] borrow;\n\n    full_subtractor FS0(.a(a[0]), .b(b[0]), .bin(bin),       .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1(.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2(.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3(.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4(.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5(.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6(.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7(.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(bout));\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [7:0] product\n);\n\nwire [7:0] partial0, partial1, partial2, partial3;\n\nassign partial0 = b[0] ? {4'b0, a} : 8'b0;\nassign partial1 = b[1] ? {3'b0, a, 1'b0} : 8'b0;\nassign partial2 = b[2] ? {2'b0, a, 2'b0} : 8'b0;\nassign partial3 = b[3] ? {1'b0, a, 3'b0} : 8'b0;\n\nassign product = partial0 + partial1 + partial2 + partial3;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": ""}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n  wire [31:0] add_result;\n  wire [31:0] sub_result;\n  wire [31:0] and_result;\n  wire [31:0] or_result;\n\n  adder u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n  );\n\n  subtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n  );\n\n  and_logic u_and_logic (\n    .a(a),\n    .b(b),\n    .and_out(and_result)\n  );\n\n  or_logic u_or_logic (\n    .a(a),\n    .b(b),\n    .or_out(or_result)\n  );\n\n  assign result = (op_code == 2'b00) ? add_result :\n                  (op_code == 2'b01) ? sub_result :\n                  (op_code == 2'b10) ? and_result :\n                  (op_code == 2'b11) ? or_result : 32'b0;\n\n  assign zero = (result == 32'b0) ? 1'b1 : 1'b0;\n  \nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n  assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n  assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n  assign and_out = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n  assign or_out = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] res\n);\n    assign res = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] res\n);\n    assign res = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] res\n);\n    assign res = a ^ b;\nendmodule\n\nmodule multi_function_alu (\n    input  wire [2:0]   op_code,\n    input  wire [31:0]  operand_a,\n    input  wire [31:0]  operand_b,\n    output reg  [31:0]  result,\n    output wire         zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    \n    adder      u_adder      ( .a(operand_a), .b(operand_b), .sum(add_result) );\n    subtractor u_subtractor ( .a(operand_a), .b(operand_b), .diff(sub_result) );\n    and_bit    u_and_bit    ( .a(operand_a), .b(operand_b), .res(and_result) );\n    or_bit     u_or_bit     ( .a(operand_a), .b(operand_b), .res(or_result) );\n    xor_bit    u_xor_bit    ( .a(operand_a), .b(operand_b), .res(xor_result) );\n\n    always @(*) begin\n        case (op_code)\n            3'b000: result = add_result;\n            3'b001: result = sub_result;\n            3'b010: result = and_result;\n            3'b011: result = or_result;\n            3'b100: result = xor_result;\n            default: result = 32'b0;\n        endcase\n    end\n\n    assign zero = (result == 32'b0) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module adder (\n    input  wire         clk,\n    input  wire [31:0]  in_a,\n    input  wire [31:0]  in_b,\n    output reg  [31:0]  sum\n);\n    always @(posedge clk) begin\n        sum <= in_a + in_b;\n    end\nendmodule\n\nmodule subtractor (\n    input  wire         clk,\n    input  wire [31:0]  in_a,\n    input  wire [31:0]  in_b,\n    output reg  [31:0]  diff\n);\n    always @(posedge clk) begin\n        diff <= in_a - in_b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input  wire         clk,\n    input  wire [31:0]  in_a,\n    input  wire [31:0]  in_b,\n    input  wire         op,  // 0: AND, 1: OR\n    output reg  [31:0]  out_bitwise\n);\n    always @(posedge clk) begin\n        if (op)\n            out_bitwise <= in_a | in_b;\n        else\n            out_bitwise <= in_a & in_b;\n    end\nendmodule\n\nmodule configurable_alu (\n    input  wire         clk,\n    input  wire [1:0]   op_code,\n    input  wire [31:0]  operand_a,\n    input  wire [31:0]  operand_b,\n    output reg  [31:0]  result\n);\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] bitwise_res;\n\n    adder u_adder (\n        .clk(clk),\n        .in_a(operand_a),\n        .in_b(operand_b),\n        .sum(sum)\n    );\n\n    subtractor u_subtractor (\n        .clk(clk),\n        .in_a(operand_a),\n        .in_b(operand_b),\n        .diff(diff)\n    );\n\n    bitwise_operator u_bitwise_operator (\n        .clk(clk),\n        .in_a(operand_a),\n        .in_b(operand_b),\n        .op(op_code[0]),\n        .out_bitwise(bitwise_res)\n    );\n\n    always @(posedge clk) begin\n        case(op_code)\n            2'b00: result <= sum;        // Addition\n            2'b01: result <= diff;       // Subtraction\n            2'b10: result <= bitwise_res; // Bitwise AND (op=0)\n            2'b11: result <= bitwise_res; // Bitwise OR  (op=1)\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        y_bit,\n    output [15:0] partial\n);\n    assign partial = y_bit ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n\n    gen_product #(.SHIFT(0)) gp0 (\n        .X(X),\n        .y_bit(Y[0]),\n        .partial(pp0)\n    );\n\n    gen_product #(.SHIFT(1)) gp1 (\n        .X(X),\n        .y_bit(Y[1]),\n        .partial(pp1)\n    );\n\n    gen_product #(.SHIFT(2)) gp2 (\n        .X(X),\n        .y_bit(Y[2]),\n        .partial(pp2)\n    );\n\n    gen_product #(.SHIFT(3)) gp3 (\n        .X(X),\n        .y_bit(Y[3]),\n        .partial(pp3)\n    );\n\n    gen_product #(.SHIFT(4)) gp4 (\n        .X(X),\n        .y_bit(Y[4]),\n        .partial(pp4)\n    );\n\n    gen_product #(.SHIFT(5)) gp5 (\n        .X(X),\n        .y_bit(Y[5]),\n        .partial(pp5)\n    );\n\n    gen_product #(.SHIFT(6)) gp6 (\n        .X(X),\n        .y_bit(Y[6]),\n        .partial(pp6)\n    );\n\n    gen_product #(.SHIFT(7)) gp7 (\n        .X(X),\n        .y_bit(Y[7]),\n        .partial(pp7)\n    );\n\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift(\n    input  [15:0] accum_in,\n    input  [7:0]  multiplicand,\n    input         add_en,\n    input  [2:0]  shift,\n    output [15:0] accum_out\n);\n  wire [15:0] shifted_value;\n  assign shifted_value = {8'b0, multiplicand} << shift;\n  assign accum_out = add_en ? accum_in + shifted_value : accum_in;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n  wire [15:0] stage0, stage1, stage2, stage3, stage4, stage5, stage6, stage7, stage8;\n  \n  assign stage0 = 16'b0;\n  \n  add_shift AS0 (.accum_in(stage0), .multiplicand(X), .add_en(Y[0]), .shift(3'd0), .accum_out(stage1));\n  add_shift AS1 (.accum_in(stage1), .multiplicand(X), .add_en(Y[1]), .shift(3'd1), .accum_out(stage2));\n  add_shift AS2 (.accum_in(stage2), .multiplicand(X), .add_en(Y[2]), .shift(3'd2), .accum_out(stage3));\n  add_shift AS3 (.accum_in(stage3), .multiplicand(X), .add_en(Y[3]), .shift(3'd3), .accum_out(stage4));\n  add_shift AS4 (.accum_in(stage4), .multiplicand(X), .add_en(Y[4]), .shift(3'd4), .accum_out(stage5));\n  add_shift AS5 (.accum_in(stage5), .multiplicand(X), .add_en(Y[5]), .shift(3'd5), .accum_out(stage6));\n  add_shift AS6 (.accum_in(stage6), .multiplicand(X), .add_en(Y[6]), .shift(3'd6), .accum_out(stage7));\n  add_shift AS7 (.accum_in(stage7), .multiplicand(X), .add_en(Y[7]), .shift(3'd7), .accum_out(stage8));\n  \n  assign P = stage8;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n  assign sum = a ^ b ^ cin;\n  assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] S\n);\n  wire [8:0] carry;\n  assign carry[0] = 1'b0;\n  \n  full_adder fa0(.a(A[0]), .b(B[0]), .cin(carry[0]), .sum(S[0]), .cout(carry[1]));\n  full_adder fa1(.a(A[1]), .b(B[1]), .cin(carry[1]), .sum(S[1]), .cout(carry[2]));\n  full_adder fa2(.a(A[2]), .b(B[2]), .cin(carry[2]),"}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n    \n    adder adder_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .result(add_result)\n    );\n    \n    subtractor subtractor_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .result(sub_result)\n    );\n    \n    and_logical and_logical_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n    \n    or_logical or_logical_inst(\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n    \n    always @(posedge clk) begin\n        case(op_code)\n            2'b00: result <= add_result;\n            2'b01: result <= sub_result;\n            2'b10: result <= and_result;\n            2'b11: result <= or_result;\n            default: result <= 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] add_result;\nwire [3:0] sub_result;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n);\n\nand_module u_and_module (\n    .a(a),\n    .b(b),\n    .and_out(and_result)\n);\n\nor_module u_or_module (\n    .a(a),\n    .b(b),\n    .or_out(or_result)\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = add_result;\n        2'b01: result = sub_result;\n        2'b10: result = and_result;\n        2'b11: result = or_result;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\nassign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\nassign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "module simple_alu(\n    input clk,\n    input rst,\n"}
{"task_id": "stagepipe3_v_21", "response": "module arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n    wire        div_valid;\n    \n    add_module adder_inst (\n        .data_a(data_a),\n        .data_b(data_b),\n        .sum(add_result)\n    );\n    \n    sub_module sub_inst (\n        .data_a(data_a),\n        .data_b(data_b),\n        .diff(sub_result)\n    );\n    \n    mul_module mul_inst (\n        .data_a(data_a),\n        .data_b(data_b),\n        .product(mul_result)\n    );\n    \n    div_module div_inst (\n        .data_a(data_a),\n        .data_b(data_b),\n        .quotient(div_result),\n        .valid(div_valid)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 16'b0;\n            valid  <= 1'b0;\n        end else begin\n            case (opcode)\n                2'b00: begin\n                    result <= add_result;\n                    valid  <= 1'b1;\n                end\n                2'b01: begin\n                    result <= sub_result;\n                    valid  <= 1'b1;\n                end\n                2'b10: begin\n                    result <= mul_result;\n                    valid  <= 1'b1;\n                end\n                2'b11: begin\n                    result <= div_result;\n                    valid  <= div_valid;\n                end\n                default: begin\n                    result <= 16'b0;\n                    valid  <= 1'b0;\n                end\n            endcase\n        end\n    end\nendmodule\n\nmodule add_module(\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [15:0] sum\n);\n    assign sum = data_a + data_b;\nendmodule\n\nmodule sub_module(\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [15:0] diff"}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare (\n    input  a,\n    input  b,\n    output gt,\n    output lt,\n    output eq\n);\n    assign gt = a & ~b;\n    assign lt = ~a & b;\n    assign eq = ~(a ^ b);\nendmodule\n\nmodule magnitude_comparator (\n    input  [3:0] A,\n    input  [3:0] B,\n    output       gt,\n    output       lt,\n    output       eq\n);\n    wire gt3, lt3, eq3;\n    wire gt2, lt2, eq2;\n    wire gt1, lt1, eq1;\n    wire gt0, lt0, eq0;\n    \n    bit_compare bc3 (\n        .a   (A[3]),\n        .b   (B[3]),\n        .gt  (gt3),\n        .lt  (lt3),\n        .eq  (eq3)\n    );\n    \n    bit_compare bc2 (\n        .a   (A[2]),\n        .b   (B[2]),\n        .gt  (gt2),\n        .lt  (lt2),\n        .eq  (eq2)\n    );\n    \n    bit_compare bc1 (\n        .a   (A[1]),\n        .b   (B[1]),\n        .gt  (gt1),\n        .lt  (lt1),\n        .eq  (eq1)\n    );\n    \n    bit_compare bc0 (\n        .a   (A[0]),\n        .b   (B[0]),\n        .gt  (gt0),\n        .lt  (lt0),\n        .eq  (eq0)\n    );\n    \n    assign gt = gt3 | (eq3 & gt2) | (eq3 & eq2 & gt1) | (eq3 & eq2 & eq1 & gt0);\n    assign lt = lt3 | (eq3 & lt2) | (eq3 & eq2 & lt1) | (eq3 & eq2 & eq1 & lt0);\n    assign eq = eq3 & eq2 & eq1 & eq0;\n    \nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n    input  [3:0] a, b;\n    input  [1:0] op;\n    output reg [3:0] result;\n    output reg carry_borrow;\n    \n    wire [3:0] and_res;\n    wire [3:0] or_res;\n    wire [3:0] add_res;\n    wire       add_carry;\n    wire [3:0] sub_res;\n    wire       sub_borrow;\n    \n    bitwise_and and_unit(.a(a), .b(b), .result(and_res));\n    bitwise_or  or_unit(.a(a), .b(b), .result(or_res));\n    adder_4bit  add_unit(.a(a), .b(b), .sum(add_res), .carry(add_carry));\n    subtractor_4bit sub_unit(.a(a), .b(b), .diff(sub_res), .borrow(sub_borrow));\n    \n    always @(*) begin\n        case (op)\n            2'b00: begin\n                result = and_res;\n                carry_borrow = 1'b0;\n            end\n            2'b01: begin\n                result = or_res;\n                carry_borrow = 1'b0;\n            end\n            2'b10: begin\n                result = add_res;\n                carry_borrow = add_carry;\n            end\n            2'b11: begin\n                result = sub_res;\n                carry_borrow = sub_borrow;\n            end\n            default: begin\n                result = 4'b0000;\n                carry_borrow = 1'b0;\n            end\n        endcase\n    end\nendmodule\n\nmodule bitwise_and(a, b, result);\n    input  [3:0] a, b;\n    output [3:0] result;\n    \n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n    input  [3:0] a, b;\n    output [3:0] result;\n    \n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, sum, carry);\n    input  [3:0] a, b;\n    output [3:0] sum;\n    output carry;\n    \n    assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, diff, borrow);\n    input  [3:0] a, b;\n    output [3:0] diff;\n    output borrow;\n    \n    wire [3:0] b_comp;\n    wire       temp_carry;\n    \n    assign b_comp = ~b;\n    assign {temp_carry, diff} = a + b_comp + 1'b1;\n    assign borrow = ~temp_carry;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system(temp_sensor, smoke_sensor, alarm_out);\n  input  [7:0] temp_sensor;\n  input        smoke_sensor;\n  output       alarm_out;\n  \n  wire temp_trigger;\n  \n  compare_temp comp_inst (\n    .temperature(temp_sensor),\n    .temp_trigger(temp_trigger)\n  );\n  \n  or_logic or_inst (\n    .in1(temp_trigger),\n    .in2(smoke_sensor),\n    .out(alarm_out)\n  );\nendmodule\n\nmodule compare_temp(temperature, temp_trigger);\n  input  [7:0] temperature;\n  output       temp_trigger;\n  parameter    THRESHOLD = 8'd100;\n  \n  assign temp_trigger = (temperature > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic(in1, in2, out);\n  input  in1, in2;\n  output out;\n  \n  assign out = in1 | in2;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": "module cla_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    input C_in,\n    output [3:0] S,\n    output C_out\n);\n    wire [3:0] p, g;\n    wire c1, c2, c3;\n\n    assign p = A ^ B;\n    assign g = A & B;\n\n    assign c1 = g[0] | (p[0] & C_in);\n    assign c2 = g[1] | (p[1] & g[0]) | (p[1] & p[0] & C_in);\n    assign c3 = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & C_in);\n    assign C_out = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & C_in);\n\n    assign S[0] = p[0] ^ C_in;\n    assign S[1] = p[1] ^ c1;\n    assign S[2] = p[2] ^ c2;\n    assign S[3] = p[3] ^ c3;\nendmodule\n\nmodule add_16bit(\n    input [16:1] A,\n    input [16:1] B,\n    output [16:1] S,\n    output C_out\n);\n    wire c1, c2, c3;\n\n    cla_4bit u_cla0 (\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(1'b0),\n        .S(S[4:1]),\n        .C_out(c1)\n    );\n\n    cla_4bit u_cla1 (\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c1),\n        .S(S[8:5]),\n        .C_out(c2)\n    );\n\n    cla_4bit u_cla2 (\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c2),\n        .S(S[12:9]),\n        .C_out(c3)\n    );\n\n    cla_4bit u_cla3 (\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c3),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule"}
{"task_id": "sub_16bit_v_28", "response": "module parity8(input [7:0] data, output parity);\n  assign parity = ^data;\nendmodule\n\nmodule parity_16bit(input [7:0] X, input [7:0] Y, output P);\n  wire p1, p2;\n  \n  parity8 gen1(.data(X), .parity(p1));\n  parity8 gen2(.data(Y), .parity(p2));\n  \n  assign P = p1 ^ p2;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0 (\n        .a(a0),\n        .b(b0),\n        .sum(sum0)\n    );\n    \n    adder_unit au1 (\n        .a(a1),\n        .b(b1),\n        .sum(sum1)\n    );\n    \n    adder_unit au2 (\n        .a(a2),\n        .b(b2),\n        .sum(sum2)\n    );\n    \n    adder_unit au3 (\n        .a(a3),\n        .b(b3),\n        .sum(sum3)\n    );\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module multiplier_unit(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      p <= 16'd0;\n    else\n      p <= a * b;\n  end\nendmodule\n\nmodule matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n  multiplier_unit mult0 (\n    .clk(clk),\n    .rst(rst),\n    .a(x0),\n    .b(y0),\n    .p(p0)\n  );\n  \n  multiplier_unit mult1 (\n    .clk(clk),\n    .rst(rst),\n    .a(x1),\n    .b(y0),\n    .p(p1)\n  );\n  \n  multiplier_unit mult2 (\n    .clk(clk),\n    .rst(rst),\n    .a(x0),\n    .b(y1),\n    .p(p2)\n  );\n  \n  multiplier_unit mult3 (\n    .clk(clk),\n    .rst(rst),\n    .a(x1),\n    .b(y1),\n    .p(p3)\n  );\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n\n  wire [3:0] left_out;\n  wire [3:0] right_out;\n\n  left_rotate lr_inst (\n    .data(in_data),\n    .rot_out(left_out)\n  );\n  \n  right_rotate rr_inst (\n    .data(in_data),\n    .rot_out(right_out)\n  );\n\n  assign out_data = en ? (rot_dir ? left_out : right_out) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  output [3:0] rot_out\n);\n\n  assign rot_out = {data[2:0], data[3]};\n\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] rot_out\n);\n\n  assign rot_out = {data[0], data[3:1]};\n\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module Counter(\n  input clk,\n  input rst,\n  input enable,\n  input mode,\n  output reg [7:0] count\n);\n  always @(posedge clk) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 1;\n      else\n        count <= count - 1;\n    end\n  end\nendmodule\n\nmodule dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .enable(enable),\n    .mode(mode),\n    .count(count)\n  );\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (rst)\n            out <= 8'd0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n        else\n            out <= out;\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .out(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": ""}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c1, c2, c3;\n\n    adder_8bit add0 (\n        .A   (A[7:0]),\n        .B   (B[7:0]),\n        .Cin (Cin),\n        .Sum (Sum[7:0]),\n        .Cout(c1)\n    );\n\n    adder_8bit add1 (\n        .A   (A[15:8]),\n        .B   (B[15:8]),\n        .Cin (c1),\n        .Sum (Sum[15:8]),\n        .Cout(c2)\n    );\n\n    adder_8bit add2 (\n        .A   (A[23:16]),\n        .B   (B[23:16]),\n        .Cin (c2),\n        .Sum (Sum[23:16]),\n        .Cout(c3)\n    );\n\n    adder_8bit add3 (\n        .A   (A[31:24]),\n        .B   (B[31:24]),\n        .Cin (c3),\n        .Sum (Sum[31:24]),\n        .Cout(Cout)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\n    assign {carry_out, result} = {1'b0, A} + {1'b0, B};\nendmodule\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\n    assign {carry_out, result} = {1'b0, A} + {1'b0, ~B} + 33'd1;\nendmodule\n\nmodule and_unit_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\n    assign result = A & B;\n    assign carry_out = 1'b0;\nendmodule\n\nmodule alu_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input  [1:0]  op,\n    output [31:"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path0 u_mux_path0 (\n        .clk(clk),\n        .in(d0),\n        .out(mux0_out)\n    );\n\n    mux_path1 u_mux_path1 (\n        .clk(clk),\n        .in(d1),\n        .out(mux1_out)\n    );\n\n    mux_path2 u_mux_path2 (\n        .clk(clk),\n        .in(d2),\n        .out(mux2_out)\n    );\n\n    assign data_out = (sel == 3'b000) ? mux0_out :\n                      (sel == 3'b001) ? mux1_out :\n                      (sel == 3'b010) ? mux2_out : 8'd0;\nendmodule\n\nmodule mux_path0 (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= in;\n    end\nendmodule\n\nmodule mux_path1 (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= in;\n    end\nendmodule\n\nmodule mux_path2 (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        out <= in;\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold0(\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'd0)\n            out <= in;\n    end\nendmodule\n\nmodule hold1(\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'd1)\n            out <= in;\n    end\nendmodule\n\nmodule hold2(\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'd2)\n            out <= in;\n    end\nendmodule\n\nmodule hold3(\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'd3)\n            out <= in;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n    wire [7:0] data0;\n    wire [7:0] data1;\n    wire [7:0] data2;\n    wire [7:0] data3;\n\n    hold0 u_hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(data0)\n    );\n\n    hold1 u_hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(data1)\n    );\n\n    hold2 u_hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(data2)\n    );\n\n    hold3 u_hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(data3)\n    );\n\n    assign out = (sel == 2'd0) ? data0 :\n                 (sel == 2'd1) ? data1 :\n                 (sel == 2'd2) ? data2 : data3;\nendmodule"}
{"task_id": "square_wave_v_41", "response": ""}
{"task_id": "square_wave_v_42", "response": "module duty_ctrl (\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n  always @(posedge clk) begin\n    adjusted_duty <= duty_cycle;\n  end\nendmodule\n\nmodule pulse_gen (\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n  reg [7:0] counter;\n\n  always @(posedge clk) begin\n    if (counter == 8'hFF)\n      counter <= 0;\n    else\n      counter <= counter + 1'b1;\n  end\n  \n  always @(posedge clk) begin\n    if (counter < duty_cycle)\n      pwm_out <= 1'b1;\n    else\n      pwm_out <= 1'b0;\n  end\nendmodule\n\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n  wire [7:0] adjusted_duty;\n\n  duty_ctrl u_duty_ctrl (\n    .clk(clk),\n    .duty_cycle(duty_cycle),\n    .adjusted_duty(adjusted_duty)\n  );\n\n  pulse_gen u_pulse_gen (\n    .clk(clk),\n    .duty_cycle(adjusted_duty),\n    .pwm_out(pwm_out)\n  );\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    output wire       equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire       equal\n);\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n\n    wire [7:0] tmp;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(tmp)\n    );\n\n    bit_reverse br2 (\n        .din(tmp),\n        .dout(dout)\n    );\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout[0] = din[7];\n    assign dout[1] = din[6];\n    assign dout[2] = din[5];\n    assign dout[3] = din[4];\n    assign dout[4] = din[3];\n    assign dout[5] = din[2];\n    assign dout[6] = din[1];\n    assign dout[7] = din[0];\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] add_out;\n    \n    my_adder8 u_adder (\n        .a(a),\n        .b(b),\n        .result(add_out)\n    );\n    \n    always @(*) begin\n        if (ctrl)\n            sum = add_out;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_25 (\n    input CLK_in,\n    input RST,\n    output reg pwm_out\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = PERIOD/4;\n    localparam WIDTH = $clog2(PERIOD);\n    reg [WIDTH-1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter == PERIOD-1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            pwm_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_50 (\n    input CLK_in,\n    input RST,\n    output reg pwm_out\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = PERIOD/2;\n    localparam WIDTH = $clog2(PERIOD);\n    reg [WIDTH-1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter == PERIOD-1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            pwm_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_75 (\n    input CLK_in,\n    input RST,\n    output reg pwm_out\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD*3)/4;\n    localparam WIDTH = $clog2(PERIOD);\n    reg [WIDTH-1:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter  <= 0;\n            pwm_out <= 0;\n        end else begin\n            if (counter == PERIOD-1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            pwm_out <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_25 u_pwm_25 (\n        .CLK_in(CLK_in),\n        .RST(R"}
{"task_id": "freq_div_v_48", "response": ""}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller #(\n    parameter DUTY_CYCLE   = 50,\n    parameter MAX_COUNT    = 1000,\n    parameter COUNTER_WIDTH = $clog2(MAX_COUNT)\n)(\n    input  clk,\n    input  rst_n,\n    output pwm_out\n);\n    wire [COUNTER_WIDTH-1:0] count;\n\n    counter #(\n        .MAX_COUNT(MAX_COUNT),\n        .COUNTER_WIDTH(COUNTER_WIDTH)\n    ) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count)\n    );\n\n    comparator #(\n        .MAX_COUNT(MAX_COUNT),\n        .COUNTER_WIDTH(COUNTER_WIDTH),\n        .DUTY_CYCLE(DUTY_CYCLE)\n    ) u_comparator (\n        .count(count),\n        .pwm_out(pwm_out)\n    );\nendmodule\n\nmodule counter #(\n    parameter MAX_COUNT    = 1000,\n    parameter COUNTER_WIDTH = $clog2(MAX_COUNT)\n)(\n    input  clk,\n    input  rst_n,\n    output reg [COUNTER_WIDTH-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count == MAX_COUNT - 1)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule comparator #(\n    parameter MAX_COUNT    = 1000,\n    parameter COUNTER_WIDTH = $clog2(MAX_COUNT),\n    parameter DUTY_CYCLE   = 50\n)(\n    input  [COUNTER_WIDTH-1:0] count,\n    output pwm_out\n);\n    localparam integer THRESHOLD = (DUTY_CYCLE * MAX_COUNT) / 100;\n    assign pwm_out = (count < THRESHOLD) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input  [31:0] a,\n    input  [31:0] b,\n    input         multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output        zero\n);\n  wire [63:0] prod_signed;\n  wire [63:0] prod_unsigned;\n\n  mult_signed u_mult_signed (\n    .a(a),\n    .b(b),\n    .product(prod_signed)\n  );\n\n  mult_unsigned u_mult_unsigned (\n    .a(a),\n    .b(b),\n    .product(prod_unsigned)\n  );\n\n  assign y   = (multc == 1'b0) ? prod_signed : prod_unsigned;\n  assign msb = y[63:32];\n  assign lsb = y[31:0];\n  assign zero = (y == 64'b0) ? 1'b1 : 1'b0;\n  \nendmodule\n\nmodule mult_signed(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] product\n);\n  assign product = $signed(a) * $signed(b);\nendmodule\n\nmodule mult_unsigned(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] product\n);\n  assign product = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": ""}
{"task_id": "stagepipe5_v_52", "response": "module add(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtract(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_and(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule bitwise_or(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule simple_alu(\n    input             clk,\n    input             rst,\n    input      [1:0]  op_code,\n    input      [31:0] operand_a,\n    input      [31:0] operand_b,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    add u_add (\n        .a   (operand_a),\n        .b   (operand_b),\n        .sum (add_result)\n    );\n\n    subtract u_subtract (\n        .a    (operand_a),\n        .b    (operand_b),\n        .diff (sub_result)\n    );\n\n    bitwise_and u_bitwise_and (\n        .a       (operand_a),\n        .b       (operand_b),\n        .and_out (and_result)\n    );\n\n    bitwise_or u_bitwise_or (\n        .a      (operand_a),\n        .b      (operand_b),\n        .or_out (or_result)\n    );\n\n    always @(posedge clk) begin\n        if (rst)\n            result <= 32'b0;\n        else begin\n            case (op_code)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= and_result;\n                2'b11: result <= or_result;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "module comp_slice(\n    input  [3:0] a,\n    input  [3:0] b,\n    output       eq,\n    output       gt,\n    output       lt\n);\n    assign eq = (a == b);\n    assign gt = (a > b);\n    assign lt = (a < b);\nendmodule\n\nmodule comparator_16bit(\n    input  [15:0] a,\n    input  [15:0] b,\n    output        eq,\n    output        gt,\n    output        lt\n);\n    wire eq_slice1, eq_slice2, eq_slice3, eq_slice4;\n    wire gt_slice1, gt_slice2, gt_slice3, gt_slice4;\n    wire lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n    \n    // Lower 4 bits\n    comp_slice comp_slice1_inst (\n        .a   (a[3:0]),\n        .b   (b[3:0]),\n        .eq  (eq_slice1),\n        .gt  (gt_slice1),\n        .lt  (lt_slice1)\n    );\n    \n    // Next 4 bits\n    comp_slice comp_slice2_inst (\n        .a   (a[7:4]),\n        .b   (b[7:4]),\n        .eq  (eq_slice2),\n        .gt  (gt_slice2),\n        .lt  (lt_slice2)\n    );\n    \n    // Next 4 bits\n    comp_slice comp_slice3_inst (\n        .a   (a[11:8]),\n        .b   (b[11:8]),\n        .eq  (eq_slice3),\n        .gt  (gt_slice3),\n        .lt  (lt_slice3)\n    );\n    \n    // Most significant 4 bits\n    comp_slice comp_slice4_inst (\n        .a   (a[15:12]),\n        .b   (b[15:12]),\n        .eq  (eq_slice4),\n        .gt  (gt_slice4),\n        .lt  (lt_slice4)\n    );\n    \n    // Overall equality: all slices must be equal.\n    assign eq = eq_slice4 & eq_slice3 & eq_slice2 & eq_slice1;\n    \n    // Hierarchical greater-than: the MSB slice that is not equal determines the result.\n    assign gt = gt_slice4 | \n                (eq_slice4 & gt_slice3) | \n                (eq_slice4 & eq_slice3 & gt_slice2) |\n                (eq_slice4 & eq_slice3 & eq_slice2 & gt_slice1);\n                \n    // Hierarchical less-than.\n    assign lt = lt_slice4 | \n                (eq_slice4 & lt_slice3) | \n                (eq_slice4 & eq_slice3 & lt_slice2) |\n                (eq_slice4 & eq_slice3 & eq_slice2 & lt_slice1);\n                \nendmodule"}
{"task_id": "adder_32bit_v_54", "response": ""}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\nwire q0, q1, q2;\n\nmy_tff u0 (\n    .clk(clk),\n    .reset(reset),\n    .t(1'b1),\n    .q(q0)\n);\n\nmy_tff u1 (\n    .clk(clk),\n    .reset(reset),\n    .t(q0),\n    .q(q1)\n);\n\nmy_tff u2 (\n    .clk(clk),\n    .reset(reset),\n    .t(q0 & q1),\n    .q(q2)\n);\n\nassign count = {q2, q1, q0};\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input  wire       clk,\n    input  wire       reset,\n    output wire [3:0] out\n);\n    reg [3:0] count;\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n\n    init_submodule init_inst (\n        .out(init_val)\n    );\n\n    increment_submodule inc_inst (\n        .in(count),\n        .out(inc_val)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n\n    assign out = count;\n    \nendmodule\n\nmodule init_submodule (\n    output wire [3:0] out\n);\n    assign out = 4'b0000;\nendmodule\n\nmodule increment_submodule (\n    input  wire [3:0] in,\n    output wire [3:0] out\n);\n    assign out = in + 1;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input  wire        clk,\n    input  wire        reset,\n    input  wire        up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    counter_logic u_counter_logic (\n        .up_down      (up_down),\n        .current_count(count),\n        .next_count   (next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk          (clk),\n        .reset        (reset),\n        .next_count   (next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input  wire        up_down,\n    input  wire [15:0] current_count,\n    output reg  [15:0] next_count\n);\n    always @(*) begin\n        if (up_down)\n            next_count = current_count + 16'd1;\n        else\n            next_count = current_count - 16'd1;\n    end\nendmodule\n\nmodule counter_register (\n    input  wire        clk,\n    input  wire        reset,\n    input  wire [15:0] next_count,\n    output reg  [15:0] current_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            current_count <= 16'd0;\n        else\n            current_count <= next_count;\n    end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_init(\n    input wire reset,\n    output wire [7:0] init_state\n);\n    assign init_state = 8'b00000001;\nendmodule\n\nmodule ring_transition(\n    input wire [7:0] in_state,\n    output wire [7:0] out_state\n);\n    assign out_state = {in_state[6:0], in_state[7]};\nendmodule\n\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    reg [7:0] state;\n    wire [7:0] init_state;\n    wire [7:0] next_state;\n\n    ring_init init_inst (\n        .reset(reset),\n        .init_state(init_state)\n    );\n\n    ring_transition trans_inst (\n        .in_state(state),\n        .out_state(next_state)\n    );\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= init_state;\n        else\n            state <= next_state;\n    end\n\n    assign out = state;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_val\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count_val <= 4'b0000;\n        else if (valid_count) begin\n            if (count_val == 4'd11)\n                count_val <= 4'b0000;\n            else\n                count_val <= count_val + 1;\n        end\n        else\n            count_val <= count_val;\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in_val,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= in_val;\n        else\n            out <= out;\n    end\nendmodule\n\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_val;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_val(count_val)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .in_val(count_val),\n        .out(out)\n    );\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module freq_div (\n    input  CLK_in,\n    input  RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n    \n    clk_div_2 u_clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n    \n    clk_div_10 u_clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n    \n    clk_div_100 u_clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2(\n    input  CLK_in,\n    input  RST,\n    output reg CLK_out\n);\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 1'b0;\n        else\n            CLK_out <= ~CLK_out;\n    end\n\nendmodule\n\nmodule clk_div_10(\n    input  CLK_in,\n    input  RST,\n    output reg CLK_out\n);\n\n    reg [2:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 3'd0;\n            CLK_out <= 1'b0;\n        end\n        else begin\n            if (counter == 3'd4) begin\n                counter <= 3'd0;\n                CLK_out <= ~CLK_out;\n            end\n            else\n                counter <= counter + 3'd1;\n        end\n    end\n\nendmodule\n\nmodule clk_div_100(\n    input  CLK_in,\n    input  RST,\n    output reg CLK_out\n);\n\n    reg [5:0] counter;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 6'd0;\n            CLK_out <= 1'b0;\n        end\n        else begin\n            if (counter == 6'd49) begin\n                counter <= 6'd0;\n                CLK_out <= ~CLK_out;\n            end\n            else\n                counter <= counter + 6'd1;\n        end\n    end\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": ""}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4; // Must be even\n    localparam HALF_DIV = NUM_DIV / 2;\n    \n    wire tick;\n    \n    u_counter #(.HALF_DIV(HALF_DIV)) counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n    \n    u_clk_divider clk_divider_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n    \nendmodule\n\nmodule u_counter #(parameter HALF_DIV = 2)(\n    input clk,\n    input rst_n,\n    output reg tick\n);\n    reg [3:0] count;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            tick  <= 0;\n        end else begin\n            if (count == HALF_DIV - 1) begin\n                count <= 0;\n                tick  <= 1;\n            end else begin\n                count <= count + 1;\n                tick  <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module u_multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule u_accumulator(\n    input clk,\n    input rst,\n    input [31:0] in_data,\n    output reg [31:0] current_value\n);\n    always @(posedge clk) begin\n        if (rst)\n            current_value <= 32'b0;\n        else\n            current_value <= current_value + in_data;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n    wire [31:0] lower_mult;\n\t\n    assign lower_mult = mult_result[31:0];\n    \n    u_multiplier u_multiplier_inst (\n        .a(a),\n        .b(b),\n        .result(mult_result)\n    );\n    \n    u_accumulator u_accumulator_inst (\n        .clk(clk),\n        .rst(rst),\n        .in_data(lower_mult),\n        .current_value(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n  reg [7:0] ins_p1, ins_p2;\n  \n  always @(posedge clk) begin\n    if (!rst) begin\n      ins_p1 <= 8'd0;\n      ins_p2 <= 8'd0;\n    end else begin\n      if (fetch == 2'b01)\n        ins_p1 <= data;\n      if (fetch == 2'b10)\n        ins_p2 <= data;\n    end\n  end\n  \n  assign ins = ins_p1[7:5];\n  assign ad1 = ins_p1[4:0];\n  assign ad2 = ins_p2;\n\nendmodule"}
{"task_id": "square_wave", "response": "module counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    initial count = 8'd0;\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == (freq - 1))\n                count <= 8'd0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial wave_out = 1'b0;\n    always @(posedge clk) begin\n        if (freq != 8'd0 && (count == (freq - 1)))\n            wave_out <= ~wave_out;\n    end\nendmodule\n\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq != 8'd0);\n\n    counter u_counter(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator u_wave_generator(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule"}
{"task_id": "signal_generator", "response": ""}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n  wire [7:0] q0;\n  wire [7:0] q1;\n  wire [7:0] q2;\n\n  my_dff8 u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n  );\n\n  my_dff8 u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n  );\n\n  my_dff8 u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q2)\n  );\n\n  always @(*) begin\n    case (sel)\n      2'b00: q = d;\n      2'b01: q = q0;\n      2'b10: q = q1;\n      2'b11: q = q2;\n      default: q = d;\n    endcase\n  end\n\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n  always @(posedge clk) begin\n    q <= d;\n  end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\nwire q0, q1;\n\nmy_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q)\n);\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'b0;\n    else\n      c <= c + a * b;\n  end\nendmodule\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n  \n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'b0;\n    else\n      b1 <= b0;\n  end\n  \n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  \n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n\n  reg [15:0] b1, b2, b3;\n  \n  always @(posedge clk) begin\n    if (rst) begin\n      b1 <= 16'd0;\n      b2 <= 16'd0;\n      b3 <= 16'd0;\n    end\n    else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n  \n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  \n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  \n  pe pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n  \n  pe pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n  \nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n    wire [31:0] prep_A;\n    wire [31:0] prep_B;\n\n    prep_dividend u_prep_dividend (\n        .A(A),\n        .B(B),\n        .prep_A(prep_A),\n        .prep_B(prep_B)\n    );\n\n    div_operation u_div_operation (\n        .dividend(prep_A),\n        .divisor(prep_B),\n        .result(result),\n        .odd(odd)\n    );\nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] prep_A,\n    output wire [31:0] prep_B\n);\n    assign prep_A = A;\n    assign prep_B = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input  wire [31:0] dividend,\n    input  wire [31:0] divisor,\n    output reg  [31:0] result,\n    output reg  [31:0] odd\n);\n    reg [31:0] quotient;\n    reg [31:0] remainder;\n    integer i;\n\n    always @(*) begin\n        quotient  = 32'd0;\n        remainder = 32'd0;\n        for (i = 31; i >= 0; i = i - 1) begin\n            remainder = {remainder[30:0], dividend[i]};\n            if (remainder >= divisor) begin\n                remainder = remainder - divisor;\n                quotient[i] = 1'b1;\n            end else begin\n                quotient[i] = 1'b0;\n            end\n        end\n    end\n\n    always @(*) begin\n        result = quotient;\n        odd    = remainder;\n    end\nendmodule"}
{"task_id": "div_16bit", "response": ""}
{"task_id": "sub_8bit", "response": ""}
{"task_id": "sub_32bit", "response": "module sub_16bit(\n    input  [15:0] A,\n    input  [15:0] B,\n    input         borrow_in,\n    output [15:0] Diff,\n    output        borrow_out\n);\n    assign Diff = A - B - borrow_in;\n    assign borrow_out = (A < (B + borrow_in));\nendmodule\n\nmodule sub_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] Diff,\n    output        B_out\n);\n    wire borrow_low;\n    \n    sub_16bit lower_sub (\n        .A       (A[15:0]),\n        .B       (B[15:0]),\n        .borrow_in(1'b0),\n        .Diff    (Diff[15:0]),\n        .borrow_out(borrow_low)\n    );\n    \n    sub_16bit upper_sub (\n        .A       (A[31:16]),\n        .B       (B[31:16]),\n        .borrow_in(borrow_low),\n        .Diff    (Diff[31:16]),\n        .borrow_out(B_out)\n    );\n    \nendmodule"}
{"task_id": "sub_64bit", "response": ""}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] in1,\n    input  [31:0] in2,\n    output [31:0] diff,\n    output        borrow\n);\n    assign {borrow, diff} = {1'b0, in1} - {1'b0, in2};\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater, \n    output        A_equal,   \n    output        A_less     \n);\n\n    wire [31:0] diff;\n    wire        borrow;\n\n    subtractor_32bit sub_inst (\n        .in1(A),\n        .in2(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n\n    assign A_equal   = (~borrow) && (diff == 32'd0);\n    assign A_less    = borrow;\n    assign A_greater = (~borrow) && (diff != 32'd0);\n\nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module ripple_carry_adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule csa_slice_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       cout0, cout1;\n    \n    ripple_carry_adder_4bit rca0 (\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .sum(sum0),\n        .cout(cout0)\n    );\n    \n    ripple_carry_adder_4bit rca1 (\n        .a(a),\n        .b(b),\n        .cin(1'b1),\n        .sum(sum1),\n        .cout(cout1)\n    );\n    \n    assign sum  = (cin == 1'b0) ? sum0  : sum1;\n    assign cout = (cin == 1'b0) ? cout0 : cout1;\nendmodule\n\nmodule adder_16bit_csa(\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n    wire c4, c8, c12;\n    \n    ripple_carry_adder_4bit rca_lower (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c4)\n    );\n    \n    csa_slice_4bit csa1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c4),\n        .sum(sum[7:4]),\n        .cout(c8)\n    );\n    \n    csa_slice"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    input  wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input  wire [15:0] a,\n    input  wire [15:0] b,\n    input  wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry;\n    \n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry)\n    );\n    \n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a, \n    input  [7:0] b, \n    input        cin, \n    output [7:0] sum, \n    output       cout\n);\n    wire [6:0] carry;\n    \n    full_adder FA0(.a(a[0]), .b(b[0]), .cin(cin),     .sum(sum[0]), .cout(carry[0]));\n    full_adder FA1(.a(a[1]), .b(b[1]), .cin(carry[0]), .sum(sum[1]), .cout(carry[1]));\n    full_adder FA2(.a(a[2]), .b(b[2]), .cin(carry[1]), .sum(sum[2]), .cout(carry[2]));\n    full_adder FA3(.a(a[3]), .b(b[3]), .cin(carry[2]), .sum(sum[3]), .cout(carry[3]));\n    full_adder FA4(.a(a[4]), .b(b[4]), .cin(carry[3]), .sum(sum[4]), .cout(carry[4]));\n    full_adder FA5(.a(a[5]), .b(b[5]), .cin(carry[4]), .sum(sum[5]), .cout(carry[5]));\n    full_adder FA6(.a(a[6]), .b(b[6]), .cin(carry[5]), .sum(sum[6]), .cout(carry[6]));\n    full_adder FA7(.a(a[7]), .b(b[7]), .cin(carry[6]), .sum(sum[7]), .cout(cout));\n    \nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\nu_adder adder_inst (\n    .op1(op1),\n    .op2(op2),\n    .sum(add_result)\n);\n\nu_subtractor subtractor_inst (\n    .op1(op1),\n    .op2(op2),\n    .diff(sub_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst)\n        result <= 32'b0;\n    else begin\n        case (mode)\n            1'b0: result <= add_result;\n            1'b1: result <= sub_result;\n            default: result <= 32'b0;\n        endcase\n    end\nend\n\nendmodule\n\nmodule u_adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] sum\n);\n\nassign sum = op1 + op2;\n\nendmodule\n\nmodule u_subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] diff\n);\n\nassign diff = op1 - op2;\n\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider (\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    output reg [31:0] quotient\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            quotient <= 32'd0;\n        else begin\n            if (y != 32'd0)\n                quotient <= x / y;\n            else\n                quotient <= 32'd0;\n        end\n    end\nendmodule\n\nmodule u_subtractor (\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] difference\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            difference <= 32'd0;\n        else\n            difference <= a - b;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_result;\n    \n    u_divider u_divider_inst (\n        .clk(clk),\n        .rst(rst),\n        .x(x),\n        .y(y),\n        .quotient(div_result)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(div_result),\n        .b(z),\n        .difference(difference)\n    );\n    \n    assign quotient = div_result;\n    \nendmodule"}
{"task_id": "pe_v_2", "response": "module u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n    \n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .result(add_out)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .a(a),\n        .b(b),\n        .result(sub_out)\n    );\n    \n    u_and u_and_inst (\n        .a(a),\n        .b(b),\n        .result(and_out)\n    );\n    \n    u_or u_or_inst (\n        .a(a),\n        .b(b),\n        .result(or_out)\n    );\n    \n    always @(posedge clk) begin\n        case (op_sel)\n            2'b00: result <= add_out;\n            2'b01: result <= sub_out;\n            2'b10: result <= and_out;\n            2'b11: result <= or_out;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input             clk,\n    input             op_sel,\n    input      [31:0] a,\n    input      [31:0] b,\n    output reg [31:0] result\n);\n    wire [31:0] adder_result;\n    wire [31:0] and_result;\n\n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .sum(adder_result)\n    );\n\n    u_bitwise_and u_bitwise_and_inst (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n\n    always @(posedge clk) begin\n        result <= (op_sel == 1'b0) ? adder_result : and_result;\n    end\nendmodule\n\nmodule u_adder(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module adder_16(\n    input  [15:0] a,\n    input  [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor_16(\n    input  [15:0] a,\n    input  [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input         clk,\n    input         rst,\n    input         mode,\n    input  [15:0] a,\n    input  [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_out;\n    wire [15:0] sub_out;\n    \n    adder_16 u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n    \n    subtractor_16 u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n    \n    wire [15:0] mux_out;\n    assign mux_out = (mode == 1'b0) ? add_out : sub_out;\n    \n    always @(posedge clk) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= mux_out;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = ((~a) & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input  bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6;\n    \n    full_subtractor fs0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(b0)\n    );\n    \n    full_subtractor fs1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(b0),\n        .diff(diff[1]),\n        .bout(b1)\n    );\n    \n    full_subtractor fs2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(b1),\n        .diff(diff[2]),\n        .bout(b2)\n    );\n    \n    full_subtractor fs3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(b2),\n        .diff(diff[3]),\n        .bout(b3)\n    );\n    \n    full_subtractor fs4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(b3),\n        .diff(diff[4]),\n        .bout(b4)\n    );\n    \n    full_subtractor fs5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(b4),\n        .diff(diff[5]),\n        .bout(b5)\n    );\n    \n    full_subtractor fs6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(b5),\n        .diff(diff[6]),\n        .bout(b6)\n    );\n    \n    full_subtractor fs7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(b6),\n        .diff(diff[7]),\n        .bout(bout)\n    );\n    \nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n  wire [6:0] borrow;\n  \n  subtractor_1bit bit0 (.a(a[0]), .b(b[0]), .bin(bin),      .diff(diff[0]), .bout(borrow[0]));\n  subtractor_1bit bit1 (.a(a[1]), .b(b[1]), .bin(borrow[0]),.diff(diff[1]), .bout(borrow[1]));\n  subtractor_1bit bit2 (.a(a[2]), .b(b[2]), .bin(borrow[1]),.diff(diff[2]), .bout(borrow[2]));\n  subtractor_1bit bit3 (.a(a[3]), .b(b[3]), .bin(borrow[2]),.diff(diff[3]), .bout(borrow[3]));\n  subtractor_1bit bit4 (.a(a[4]), .b(b[4]), .bin(borrow[3]),.diff(diff[4]), .bout(borrow[4]));\n  subtractor_1bit bit5 (.a(a[5]), .b(b[5]), .bin(borrow[4]),.diff(diff[5]), .bout(borrow[5]));\n  subtractor_1bit bit6 (.a(a[6]), .b(b[6]), .bin(borrow[5]),.diff(diff[6]), .bout(borrow[6]));\n  subtractor_1bit bit7 (.a(a[7]), .b(b[7]), .bin(borrow[6]),.diff(diff[7]), .bout(bout));\n  \nendmodule\n\nmodule subtractor_1bit(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n  assign diff = a ^ b ^ bin;\n  assign bout = (~a & (b | bin)) | (b & bin);\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6;\n\n    full_subtractor FS0(.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(b0));\n    full_subtractor FS1(.a(a[1]), .b(b[1]), .bin(b0),  .diff(diff[1]), .bout(b1));\n    full_subtractor FS2(.a(a[2]), .b(b[2]), .bin(b1),  .diff(diff[2]), .bout(b2));\n    full_subtractor FS3(.a(a[3]), .b(b[3]), .bin(b2),  .diff(diff[3]), .bout(b3));\n    full_subtractor FS4(.a(a[4]), .b(b[4]), .bin(b3),  .diff(diff[4]), .bout(b4));\n    full_subtractor FS5(.a(a[5]), .b(b[5]), .bin(b4),  .diff(diff[5]), .bout(b5));\n    full_subtractor FS6(.a(a[6]), .b(b[6]), .bin(b5),  .diff(diff[6]), .bout(b6));\n    full_subtractor FS7(.a(a[7]), .b(b[7]), .bin(b6),  .diff(diff[7]), .bout(bout));\nendmodule\n\nmodule full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] product\n);\n    wire [7:0] pp0, pp1, pp2, pp3;\n    \n    assign pp0 = b[0] ? {4'b0000, a} : 8'b0;\n    assign pp1 = b[1] ? {3'b000, a, 1'b0} : 8'b0;\n    assign pp2 = b[2] ? {2'b00, a, 2'b00} : 8'b0;\n    assign pp3 = b[3] ? {1'b0, a, 3'b000} : 8'b0;\n    \n    assign product = pp0 + pp1 + pp2 + pp3;\n    \nendmodule"}
{"task_id": "up_down_counter_v_10", "response": ""}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n  wire [31:0] add_out;\n  wire [31:0] sub_out;\n  wire [31:0] and_out;\n  wire [31:0] or_out;\n  reg  [31:0] alu_result;\n\n  adder         u_adder       (.a(a), .b(b), .sum(add_out));\n  subtractor    u_subtractor  (.a(a), .b(b), .diff(sub_out));\n  and_logic     u_and_logic   (.a(a), .b(b), .result(and_out));\n  or_logic      u_or_logic    (.a(a), .b(b), .result(or_out));\n\n  always @(*) begin\n    case(op_code)\n     "}
{"task_id": "up_down_counter_v_12", "response": "module adder(\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit(\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_bit(\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule xor_bit(\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_out\n);\n    assign xor_out = a ^ b;\nendmodule\n\nmodule multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_out(and_result)\n    );\n\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_out(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_out(xor_result)\n    );\n\n    reg [31:0] alu_result;\n    always @(*) begin\n        case(op_code)\n            3'b000: alu_result = add_result;   // ADD\n            3'b001: alu_result = sub_result;   // SUB\n            3'b010: alu_result = and_result;   // AND\n            3'b011: alu_result = or_result;    // OR\n            3'b100: alu_result = xor_result;   // XOR\n            default: alu_result = 32'd0;\n        endcase\n    end\n\n    assign result = alu_result;\n    assign zero = (alu_result == 32'd0) ? 1'b1 : 1'b0;\n\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] bit_result;\n\nadder u_adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(sub_result)\n);\n\nbitwise_operator u_bitwise_operator (\n    .a(operand_a),\n    .b(operand_b),\n    .op_ctrl(op_code[0]),\n    .result(bit_result)\n);\n\nalways @(posedge clk) begin\n    case (op_code)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10, 2'b11: result <= bit_result;\n        default: result <= 32'd0;\n    endcase\nend\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire op_ctrl,  // 0 for AND, 1 for OR\n    output wire [31:0] result\n);\nassign result = op_ctrl ? (a | b) : (a & b);\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        Y_bit,\n    output [15:0] product\n);\n    assign product = Y_bit ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit (\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n\n    gen_product #(.SHIFT(0)) GP0 (\n        .X(X),\n        .Y_bit(Y[0]),\n        .product(pp0)\n    );\n    gen_product #(.SHIFT(1)) GP1 (\n        .X(X),\n        .Y_bit(Y[1]),\n        .product(pp1)\n    );\n    gen_product #(.SHIFT(2)) GP2 (\n        .X(X),\n        .Y_bit(Y[2]),\n        .product(pp2)\n    );\n    gen_product #(.SHIFT(3)) GP3 (\n        .X(X),\n        .Y_bit(Y[3]),\n        .product(pp3)\n    );\n    gen_product #(.SHIFT(4)) GP4 (\n        .X(X),\n        .Y_bit(Y[4]),\n        .product(pp4)\n    );\n    gen_product #(.SHIFT(5)) GP5 (\n        .X(X),\n        .Y_bit(Y[5]),\n        .product(pp5)\n    );\n    gen_product #(.SHIFT(6)) GP6 (\n        .X(X),\n        .Y_bit(Y[6]),\n        .product(pp6)\n    );\n    gen_product #(.SHIFT(7)) GP7 (\n        .X(X),\n        .Y_bit(Y[7]),\n        .product(pp7)\n    );\n\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        y_bit,\n    input  [15:0] sum_in,\n    output [15:0] sum_out\n);\n    assign sum_out = y_bit ? sum_in + ({8'b0, X} << SHIFT) : sum_in;\nendmodule\n\nmodule mult_8bit (\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] res0, res1, res2, res3, res4, res5, res6, res7, res8;\n\n    assign res0 = 16'b0;\n\n    add_shift #(.SHIFT(0)) AS0 (.X(X), .y_bit(Y[0]), .sum_in(res0), .sum_out(res1));\n    add_shift #(.SHIFT(1)) AS1 (.X(X), .y_bit(Y[1]), .sum_in(res1), .sum_out(res2));\n    add_shift #(.SHIFT(2)) AS2 (.X(X), .y_bit(Y[2]), .sum_in(res2), .sum_out(res3));\n    add_shift #(.SHIFT(3)) AS3 (.X(X), .y_bit(Y[3]), .sum_in(res3), .sum_out(res4));\n    add_shift #(.SHIFT(4)) AS4 (.X(X), .y_bit(Y[4]), .sum_in(res4), .sum_out(res5));\n    add_shift #(.SHIFT(5)) AS5 (.X(X), .y_bit(Y[5]), .sum_in(res5), .sum_out(res6));\n    add_shift #(.SHIFT(6)) AS6 (.X(X), .y_bit(Y[6]), .sum_in(res6), .sum_out(res7));\n    add_shift #(.SHIFT(7)) AS7 (.X(X), .y_bit(Y[7]), .sum_in(res7), .sum_out(res8));\n\n    assign P = res8;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module adder(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_logical(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] out\n);\n    assign out = a | b;\nendmodule\n\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n\nwire [3:0] add_result;\nwire [3:0] sub_result;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder u_adder (\n    .a(operand_a),\n    .b(operand_b),\n    .sum(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(operand_a),\n    .b(operand_b),\n    .diff(sub_result)\n);\n\nand_logical u_and_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .out(and_result)\n);\n\nor_logical u_or_logical (\n    .a(operand_a),\n    .b(operand_b),\n    .out(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] add_result, sub_result, and_result, or_result;\n    \n    adder u_adder(\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    subtractor u_subtractor(\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n    \n    and_module u_and(\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n    \n    or_module u_or(\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n    \n    always @(*) begin\n        case(op)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result,\n    output zero\n);\n    wire add_en, sub_en, and_en, or_en;\n    wire [3:0] alu_result;\n    wire zero_flag;\n\n    op_decoder decoder (\n        .op_code(op_code),\n        .add_en(add_en),\n        .sub_en(sub_en),\n        .and_en(and_en),\n        .or_en(or_en)\n    );\n\n    arithmetic"}
{"task_id": "stagepipe3_v_21", "response": "module arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\n  wire [15:0] add_res;\n  wire [15:0] sub_res;\n  wire [15:0] mul_res;\n  wire [15:0] div_res;\n  wire        div_valid;\n\n  add_module u_add (\n    .a(data_a),\n    .b(data_b),\n    .sum(add_res)\n  );\n\n  sub_module u_sub (\n    .a(data_a),\n    .b(data_b),\n    .diff(sub_res)\n  );\n\n  mul_module u_mul (\n    .a(data_a),\n    .b(data_b),\n    .product(mul_res)\n  );\n\n  div_module u_div (\n    .a(data_a),\n    .b(data_b),\n    .quotient(div_res),\n    .valid(div_valid)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      result <= 16'd0;\n      valid  <= 1'b0;\n    end else begin\n      case (opcode)\n        2'b00: begin\n          result <= add_res;\n          valid  <= 1'b1;\n        end\n        2'b01: begin\n          result <= sub_res;\n          valid  <= 1'b1;\n        end\n        2'b10: begin\n          result <= mul_res;\n          valid  <= 1'b1;\n        end\n        2'b11: begin\n          result <= div_res;\n          valid  <= div_valid;\n        end\n        default: begin\n          result <= 16'd0;\n          valid  <= 1'b0;\n        end\n      endcase\n    end\n  end\n\nendmodule\n\nmodule add_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] sum\n);\n  assign sum = a + b;\nendmodule\n\nmodule sub_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] diff\n);\n  assign diff = a - b;\nendmodule\n\nmodule mul_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] product\n);\n  assign product = a * b;\nendmodule\n\nmodule div_module(\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] quotient,\n    output reg valid\n);\n  always"}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare(\n    input  a,\n    input  b,\n    output gt,\n    output lt,\n    output eq\n);\n    assign gt = a & ~b;\n    assign lt = ~a & b;\n    assign eq = ~(a ^ b);\nendmodule\n\nmodule magnitude_comparator(\n    input  [3:0] A,\n    input  [3:0] B,\n    output       gt,\n    output       lt,\n    output       eq\n);\n    wire gt3, lt3, eq3;\n    wire gt2, lt2, eq2;\n    wire gt1, lt1, eq1;\n    wire gt0, lt0, eq0;\n    \n    bit_compare bc3 (\n        .a   (A[3]),\n        .b   (B[3]),\n        .gt  (gt3),\n        .lt  (lt3),\n        .eq  (eq3)\n    );\n    \n    bit_compare bc2 (\n        .a   (A[2]),\n        .b   (B[2]),\n        .gt  (gt2),\n        .lt  (lt2),\n        .eq  (eq2)\n    );\n    \n    bit_compare bc1 (\n        .a   (A[1]),\n        .b   (B[1]),\n        .gt  (gt1),\n        .lt  (lt1),\n        .eq  (eq1)\n    );\n    \n    bit_compare bc0 (\n        .a   (A[0]),\n        .b   (B[0]),\n        .gt  (gt0),\n        .lt  (lt0),\n        .eq  (eq0)\n    );\n    \n    assign gt = gt3 | (eq3 & gt2) | (eq3 & eq2 & gt1) | (eq3 & eq2 & eq1 & gt0);\n    assign lt = lt3 | (eq3 & lt2) | (eq3 & eq2 & lt1) | (eq3 & eq2 & eq1 & lt0);\n    assign eq = eq3 & eq2 & eq1 & eq0;\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module bitwise_and(a, b, out);\n  input [3:0] a, b;\n  output [3:0] out;\n  assign out = a & b;\nendmodule\n\nmodule bitwise_or(a, b, out);\n  input [3:0] a, b;\n  output [3:0] out;\n  assign out = a | b;\nendmodule\n\nmodule adder_4bit(a, b, sum, carry);\n  input [3:0] a, b;\n  output [3:0] sum;\n  output carry;\n  assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_4bit(a, b, diff, borrow);\n  input [3:0] a, b;\n  output [3:0] diff;\n  output borrow;\n  wire carry;\n  assign {carry, diff} = {1'b0, a} + {1'b0, ~b} + 5'b00001;\n  assign borrow = ~carry;\nendmodule\n\nmodule simple_alu(a, b, op, result, carry_borrow);\n  input [3:0] a, b;\n  input [1:0] op;\n  output reg [3:0] result;\n  output reg carry_borrow;\n\n  wire [3:0] and_result;\n  wire [3:0] or_result;\n  wire [3:0] add_result;\n  wire add_carry;\n  wire [3:0] sub_result;\n  wire sub_borrow;\n\n  bitwise_and u_and(.a(a), .b(b), .out(and_result));\n  bitwise_or u_or(.a(a), .b(b), .out(or_result));\n  adder_4bit u_add(.a(a), .b(b), .sum(add_result), .carry(add_carry));\n  subtractor_4bit u_sub(.a(a), .b(b), .diff(sub_result), .borrow(sub_borrow));\n\n  always @(*) begin\n    case (op)\n      "}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module compare_temp (\n    temp_sensor,\n    temp_high\n);\n    input [7:0] temp_sensor;\n    output temp_high;\n    parameter THRESHOLD = 8'd100;\n    \n    assign temp_high = (temp_sensor > THRESHOLD) ? 1'b1 : 1'b0;\n    \nendmodule\n\nmodule or_gate (\n    in1,\n    in2,\n    out\n);\n    input in1;\n    input in2;\n    output out;\n    \n    assign out = in1 | in2;\n    \nendmodule\n\nmodule alarm_system (\n    temp_sensor,\n    smoke_sensor,\n    alarm_out\n);\n    input  [7:0] temp_sensor;\n    input         smoke_sensor;\n    output        alarm_out;\n    \n    wire cmp_out;\n    \n    compare_temp cmp_inst (\n        .temp_sensor(temp_sensor),\n        .temp_high(cmp_out)\n    );\n    \n    or_gate or_inst (\n        .in1(cmp_out),\n        .in2(smoke_sensor),\n        .out(alarm_out)\n    );\n    \nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module cla_4bit(A, B, C_in, S, C_out);\n    input  [3:0] A, B;\n    input        C_in;\n    output [3:0] S;\n    output       C_out;\n    \n    wire [3:0] P, G;\n    wire       c1, c2, c3;\n    \n    assign P = A ^ B;\n    assign G = A & B;\n    \n    assign c1 = G[0] | (P[0] & C_in);\n    assign c2 = G[1] | (P[1] & G"}
{"task_id": "sub_16bit_v_27", "response": ""}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(\n    input  [7:0] A,\n    output       P\n);\n    assign P = ^A;\nendmodule\n\nmodule parity_16bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output       P\n);\n    wire p1, p2;\n\n    parity_8bit gen1 (\n        .A(X),\n        .P(p1)\n    );\n\n    parity_8bit gen2 (\n        .A(Y),\n        .P(p2)\n    );\n\n    assign P = p1 ^ p2;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit (\n    input  [7:0] in_a,\n    input  [7:0] in_b,\n    output [8:0] out_sum\n);\n    assign out_sum = in_a + in_b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n\n    adder_unit au0 (\n        .in_a(a0),\n        .in_b(b0),\n        .out_sum(sum0)\n    );\n    \n    adder_unit au1 (\n        .in_a(a1),\n        .in_b(b1),\n        .out_sum(sum1)\n    );\n    \n    adder_unit au2 (\n        .in_a(a2),\n        .in_b(b2),\n        .out_sum(sum2)\n    );\n    \n    adder_unit au3 (\n        .in_a(a3),\n        .in_b(b3),\n        .out_sum(sum3)\n    );\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n\n    multiplier mult0 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .p(p0)\n    );\n\n    multiplier mult1 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .p(p1)\n    );\n\n    multiplier mult2 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .p(p2)\n    );\n\n    multiplier mult3 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .p(p3)\n    );\n\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            p <= 16'd0;\n        else\n            p <= a * b;\n    end\n\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input        en,\n  input        rot_dir,\n  input  [3:0] in_data,\n  output [3:0] out_data\n);\n  wire [3:0] left_out;\n  wire [3:0] right_out;\n\n  left_rotate u_left_rotate (\n    .data(in_data),\n    .out(left_out)\n  );\n\n  right_rotate u_right_rotate (\n    .data(in_data),\n    .out(right_out)\n  );\n\n  assign out_data = en ? (rot_dir ? left_out : right_out) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input  [3:0] data,\n  output [3:0] out\n);\n  assign out = {data[2:0], data[3]};\nendmodule\n\nmodule right_rotate(\n  input  [3:0] data,\n  output [3:0] out\n);\n  assign out = {data[0], data[3:1]};\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 8'd1;\n      else\n        count <= count - 8'd1;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (rst)\n            out <= 8'b0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n        else\n            out <= out;\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .out(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input  A,\n    input  B,\n    input  Cin,\n    output Sum,\n    output Cout\n);\n    assign Sum  = A ^ B ^ Cin;\n    assign Cout = (A & B) | (B & Cin) | (A & Cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    wire [8:0] carry;\n    assign carry[0] = Cin;\n    \n    genvar i;\n    generate\n        for(i = 0; i < 8; i = i + 1) begin: fulladder_block\n            full_adder fa (\n                .A(   X[i]      ),\n                .B(   Y[i]      ),\n                .Cin( carry[i]  ),\n                .Sum( Sum[i]    ),\n                .Cout(carry[i+1])\n            );\n        end\n    endgenerate\n    assign Cout = carry[8];\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] X,    // First 32-bit input operand\n    input  [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum,  // 32-bit output sum\n    output        Carry_out  // Carry output\n);\n    wire c1, c2, c3;\n    \n    adder_8bit adder0 (\n        .X(   X[7:0]    ),\n        .Y(   Y[7:0]    ),\n        .Cin( 1'b0       ),\n        .Sum( Sum[7:0]   ),\n        .Cout(c1         )\n    );\n    \n    adder_8bit adder1 (\n        .X(   X[15:8]   ),\n        .Y(   Y[15:8]   ),\n        .Cin( c1         ),\n        .Sum( Sum[15:8]  ),\n        .Cout(c2         )\n    );\n    \n    adder_8bit adder2 (\n        .X(   X[23:16]  ),\n        .Y(   Y[23:16]  ),\n        .Cin( c2         ),\n        .Sum( Sum[23:16] ),\n        .Cout(c3         )\n    );\n    \n    adder_8bit adder3 (\n        .X(   X[31:24]  ),\n        .Y(   Y[31:24]  ),\n        .Cin( c3         ),\n        .Sum( Sum[31:24] ),\n        .Cout(Carry_out  )\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c0, c1, c2;\n\n    adder_8bit add0 (\n        .A   (A[7:0]),\n        .B   (B[7:0]),\n        .Cin (Cin),\n        .Sum (Sum[7:0]),\n        .Cout(c0)\n    );\n\n    adder_8bit add1 (\n        .A   (A[15:8]),\n        .B   (B[15:8]),\n        .Cin (c0),\n        .Sum (Sum[15:8]),\n        .Cout(c1)\n    );\n\n    adder_8bit add2 (\n        .A   (A[23:16]),\n        .B   (B[23:16]),\n        .Cin (c1),\n        .Sum (Sum[23:16]),\n        .Cout(c2)\n    );\n\n    adder_8bit add3 (\n        .A   (A[31:24]),\n        .B   (B[31:24]),\n        .Cin (c2),\n        .Sum (Sum[31:24]),\n        .Cout(Cout)\n    );\n\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input  [1:0]  op,\n    output [31:0] result,\n    output        carry_out\n);\n\n  wire [31:0] add_result;\n  wire        add_carry;\n  wire [31:0] sub_result;\n  wire        sub_carry;\n  wire [31:0] and_result;\n  \n  adder_32 add_inst (\n    .A(A),\n    .B(B),\n    .sum(add_result),\n    .carry_out(add_carry)\n  );\n  \n  subtractor_32 sub_inst (\n    .A(A),\n    .B(B),\n    .diff(sub_result),\n    .carry_out(sub_carry)\n  );\n  \n  and_32 and_inst (\n    .A(A),\n    .B(B),\n    .and_result(and_result)\n  );\n  \n  assign result = (op == 2'b00) ? add_result :\n                  (op == 2'b01) ? sub_result :\n                  (op == 2'b10) ? and_result : 32'd0;\n  \n  assign carry_out = (op == 2'b00) ? add_carry :\n                     (op == 2'b01) ? sub_carry : 1'b0;\n  \nendmodule\n\nmodule adder_32(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] sum,\n    output        carry_out\n);\n  assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        carry_out\n);\n  wire [32:0] tmp;\n  assign tmp = {1'b0, A} + {1'b0, ~B} + 33'd1;\n  assign diff = tmp[31:0];\n  assign carry_out = tmp[32];\nendmodule\n\nmodule and_32(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] and_result\n);\n  assign and_result = A & B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\nwire [7:0] mux0_out;\nwire [7:0] mux1_out;\nwire [7:0] mux2_out;\n\nmux_path0 u_mux0 (\n    .clk(clk),\n    .d(d0),\n    .data_out(mux0_out)\n);\n\nmux_path1 u_mux1 (\n    .clk(clk),\n    .d(d1),\n    .data_out(mux1_out)\n);\n\nmux_path2 u_mux2 (\n    .clk(clk),\n    .d(d2),\n    .data_out(mux2_out)\n);\n\nassign data_out = (sel == 3'b000) ? mux0_out :\n                  (sel == 3'b001) ? mux1_out :\n                  (sel == 3'b010) ? mux2_out :\n                  8'b0;\n\nendmodule\n\nmodule mux_path0 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] data_out\n);\nalways @(posedge clk) begin\n    data_out <= d;\nend\nendmodule\n\nmodule mux_path1 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] data_out\n);\nalways @(posedge clk) begin\n    data_out <= d;\nend\nendmodule\n\nmodule mux_path2 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] data_out\n);\nalways @(posedge clk) begin\n    data_out <= d;\nend\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold_data #(parameter SEL_CODE = 2'b00) (\n    input clk,\n    input [7:0] data_in,\n    input [1:0] sel,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        if (sel == SEL_CODE)\n            data_out <= data_in;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    hold_data #(.SEL_CODE(2'b00)) hold0 (\n        .clk(clk),\n        .data_in(in0),\n        .sel(sel),\n        .data_out(hold0_out)\n    );\n\n    hold_data #(.SEL_CODE(2'b01)) hold1 (\n        .clk(clk),\n        .data_in(in1),\n        .sel(sel),\n        .data_out(hold1_out)\n    );\n\n    hold_data #(.SEL_CODE(2'b10)) hold2 (\n        .clk(clk),\n        .data_in(in2),\n        .sel(sel),\n        .data_out(hold2_out)\n    );\n\n    hold_data #(.SEL_CODE(2'b11)) hold3 (\n        .clk(clk),\n        .data_in(in3),\n        .sel(sel),\n        .data_out(hold3_out)\n    );\n\n    reg [7:0] mux_out;\n    always @(*) begin\n        case (sel)\n            2'b00: mux_out = hold0_out;\n            2'b01: mux_out = hold1_out;\n            2'b10: mux_out = hold2_out;\n            2'b11: mux_out = hold3_out;\n            default: mux_out = 8'b0;\n        endcase\n    end\n\n    assign out = mux_out;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n    wire [15:0] count;\n    wire reset;\n    \n    assign reset = 1'b0;\n    \n    pwm_counter u_pwm_counter (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(count)\n    );\n    \n    pwm_signal u_pwm_signal (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n    \n    always @(posedge clk) begin\n        if (reset)\n            count <= 16'd0;\n        else if (count == (freq - 1))\n            count <= 16'd0;\n        else\n            count <= count + 1;\n    end\n    \nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n    \n    always @(posedge clk) begin\n        if (count < ((freq * duty_cycle) / 100))\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\n    \nendmodule"}
{"task_id": "square_wave_v_42", "response": "`timescale 1ns/1ps\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    wire [7:0] adjusted_duty;\n\n    duty_ctrl duty_ctrl_inst (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    pulse_gen pulse_gen_inst (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n    reg [7:0] counter;\n\n    always @(posedge clk) begin\n        if (counter == 8'hFF)\n            counter <= 8'b0;\n        else\n            counter <= counter + 1;\n\n        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;\n    end\nendmodule\n"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    output wire       equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire       equal\n);\n\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n\nwire [7:0] intermediate;\n\nbit_reverse br1 (\n    .data_in(din),\n    .data_out(intermediate)\n);\n\nbit_reverse br2 (\n    .data_in(intermediate),\n    .data_out(dout)\n);\n\nendmodule\n\nmodule bit_reverse (\n    input [7:0] data_in,\n    output [7:0] data_out\n);\nassign data_out = {data_in[0], data_in[1], data_in[2], data_in[3],\n                   data_in[4], data_in[5], data_in[6], data_in[7]};\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input  [7:0] a,\n    input  [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule adder_selector (\n    input  [7:0] a,\n    input  [7:0] b,\n    input        ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] add_result;\n    \n    my_adder8 u_my_adder8 (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    always @(*) begin\n        if (ctrl)\n            sum = add_result;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    pwm_module_25 u_pwm_module_25 (\n        .clk(CLK_in),\n        .rst(RST),\n        .pwm_out(PWM_25)\n    );\n\n    pwm_module_50 u_pwm_module_50 (\n        .clk(CLK_in),\n        .rst(RST),\n        .pwm_out(PWM_50)\n    );\n\n    pwm_module_75 u_pwm_module_75 (\n        .clk(CLK_in),\n        .rst(RST),\n        .pwm_out(PWM_75)\n    );\n\nendmodule\n\nmodule pwm_module_25 (\n    input clk,\n    input rst,\n    output pwm_out\n);\n    localparam PERIOD = 100;\n    localparam THRESH = 25;\n    reg [6:0] counter;\n    reg pwm_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            pwm_reg <= 1'b0;\n        end else begin\n            if (counter >= PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            pwm_reg <= (counter < THRESH) ? 1'b1 : 1'b0;\n        end\n    end\n\n    assign pwm_out = pwm_reg;\nendmodule\n\nmodule pwm_module_50 (\n    input clk,\n    input rst,\n    output pwm_out\n);\n    localparam PERIOD = 100;\n    localparam THRESH = 50;\n    reg [6:0] counter;\n    reg pwm_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            pwm_reg <= 1'b0;\n        end else begin\n            if (counter >= PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            pwm_reg <= (counter < THRESH) ? 1'b1 : 1'b0;\n        end\n    end\n\n    assign pwm_out = pwm_reg;\nendmodule\n\nmodule pwm_module_75 (\n    input clk,\n    input rst,\n    output pwm_out\n);\n    localparam PERIOD = 100;\n    localparam THRESH = 75;\n    reg [6:0] counter;\n    reg pwm_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter <= 0;\n            pwm_reg <= 1'b0;\n        end else begin\n            if (counter >= PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n            pwm_reg <= (counter < THRESH) ? 1'b1 : 1'b0;\n        end\n    end\n\n    assign pwm_out = pwm_reg;\nendmodule"}
{"task_id": "freq_div_v_48", "response": ""}
{"task_id": "freq_divbyodd_v_49", "response": ""}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n    wire [63:0] y_signed;\n    wire [63:0] y_unsigned;\n\n    mult_signed u_mult_signed (\n        .a(a),\n        .b(b),\n        .y(y_signed)\n    );\n\n    mult_unsigned u_mult_unsigned (\n        .a(a),\n        .b(b),\n        .y(y_unsigned)\n    );\n\n    assign y = (multc == 1'b0) ? y_signed : y_unsigned;\n    assign msb = y[63:32];\n    assign lsb = y[31:0];\n    assign zero = (y == 64'b0);\n\nendmodule\n\nmodule mult_signed(\n    input signed [31:0] a,\n    input signed [31:0] b,\n    output signed [63:0] y\n);\n    assign y = a * b;\nendmodule\n\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module count_control (\n    input         clk,\n    input         rst,\n    input         en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 4'b0001;\n        else\n            count <= count;\n    end\nendmodule\n\nmodule overflow_detection (\n    input         clk,\n    input         rst,\n    input         en,\n    input  [3:0]  count,\n    output reg    overflow\n);\n    reg [3:0] prev_count;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'b0000;\n            overflow   <= 1'b0;\n        end else begin\n            if (en && (prev_count == 4'b1111) && (count == 4'b0000))\n                overflow <= 1'b1;\n            else\n                overflow <= 1'b0;\n            prev_count <= count;\n        end\n    end\nendmodule\n\nmodule binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n    output      [3:0]   count_out,\n    output              overflow\n);\n    wire [3:0] count_int;\n    \n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count_int)\n    );\n    \n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count_int),\n        .overflow(overflow)\n    );\n    \n    assign count_out = count_int;\n    \nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    \n    add u_add(\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n    \n    subtract u_subtract(\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n    \n    bitwise_and u_and(\n        .a(operand_a),\n        .b(operand_b),\n        .result(and_result)\n    );\n    \n    bitwise_or u_or(\n        .a(operand_a),\n        .b(operand_b),\n        .result(or_result)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else begin\n            case (op_code)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= and_result;\n                2'b11: result <= or_result;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtract(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": ""}
{"task_id": "adder_32bit_v_54", "response": ""}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\nwire t0, t1, t2;\n\nassign t0 = 1'b1;\nassign t1 = count[0];\nassign t2 = count[0] & count[1];\n\nmy_tff u0 (\n    .clk(clk),\n    .reset(reset),\n    .t(t0),\n    .q(count[0])\n);\n\nmy_tff u1 (\n    .clk(clk),\n    .reset(reset),\n    .t(t1),\n    .q(count[1])\n);\n\nmy_tff u2 (\n    .clk(clk),\n    .reset(reset),\n    .t(t2),\n    .q(count[2])\n);\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module init_submodule(\n    input wire reset,\n    output wire [3:0] init_value\n);\n    assign init_value = 4'b0000;\nendmodule\n\nmodule increment_submodule(\n    input wire [3:0] current,\n    output wire [3:0] incremented\n);\n    assign incremented = current + 1;\nendmodule\n\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output reg [3:0] out\n);\n    wire [3:0] init_value;\n    wire [3:0] inc_value;\n\n    init_submodule u_init (\n        .reset(reset),\n        .init_value(init_value)\n    );\n\n    increment_submodule u_inc (\n        .current(out),\n        .incremented(inc_value)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            out <= init_value;\n        else\n            out <= inc_value;\n    end\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input  wire         clk,\n    input  wire         reset,\n    input  wire         up_down,\n    output wire [15:0]  count\n);\n\n  wire [15:0] next_count;\n  wire [15:0] current_count;\n\n  u_counter_logic ucl_inst (\n      .count      (current_count),\n      .up_down    (up_down),\n      .next_count (next_count)\n  );\n\n  u_counter_register ucr_inst (\n      .clk       (clk),\n      .reset     (reset),\n      .next_count(next_count),\n      .count     (current_count)\n  );\n\n  assign count = current_count;\n\nendmodule\n\nmodule u_counter_logic (\n    input  wire [15:0] count,\n    input  wire        up_down,\n    output wire [15:0] next_count\n);\n  assign next_count = up_down ? count + 16'd1 : count - 16'd1;\nendmodule\n\nmodule u_counter_register (\n    input  wire         clk,\n    input  wire         reset,\n    input  wire [15:0]  next_count,\n    output reg  [15:0]  count\n);\n  always @(posedge clk or posedge reset) begin\n    if (reset)\n      count <= 16'd0;\n    else\n      count <= next_count;\n  end\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] init_state;\n    wire [7:0] next_state;\n    reg  [7:0] state;\n\n    ring_counter_init init_inst (\n        .reset(reset),\n        .init_state(init_state)\n    );\n\n    ring_counter_transition trans_inst (\n        .state(state),\n        .next_state(next_state)\n    );\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= init_state;\n        else\n            state <= next_state;\n    end\n\n    assign out = state;\n\nendmodule\n\nmodule ring_counter_init (\n    input wire reset,\n    output wire [7:0] init_state\n);\n    assign init_state = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition (\n    input wire [7:0] state,\n    output wire [7:0] next_state\n);\n    assign next_state = {state[6:0], state[7]};\nendmodule"}
{"task_id": "counter_12", "response": "module counter_logic(\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule output_register(\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= count;\n    end\nendmodule\n\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count),\n        .out(out)\n    );\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input                clk,\n    input                rst_n,\n    output       [63:0]  Q\n);\n    wire [63:0] next_state;\n    \n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .D(next_state),\n        .Q(Q)\n    );\n    \n    JC_logic logic_inst (\n        .Q_in(Q),\n        .Q_next(next_state)\n    );\n    \nendmodule\n\nmodule JC_register(\n    input               clk,\n    input               rst_n,\n    input       [63:0]  D,\n    output reg  [63:0]  Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            Q"}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n    wire clk_div2_out;\n    wire clk_div10_out;\n    wire clk_div100_out;\n\n    clk_div_2 u_clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div2_out)\n    );\n\n    clk_div_10 u_clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div10_out)\n    );\n\n    clk_div_100 u_clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_div100_out)\n    );\n\n    assign CLK_50 = clk_div2_out;\n    assign CLK_10 = clk_div10_out;\n    assign CLK_1  = clk_div100_out;\n    \nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 1'b0;\n        else\n            CLK_out <= ~CLK_out;\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] count;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count   <= 3'd0;\n            CLK_out <= 1'b0;\n        end else begin\n            if(count == 3'd4) begin\n                count   <= 3'd0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 3'd1;\n            end\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] count;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count   <= 6'd0;\n            CLK_out <= 1'b0;\n        end else begin\n            if(count == 6'd49) begin\n                count   <= 6'd0;\n                CLK_out <= ~CLK_out;\n            end else begin\n                count <= count + 6'd1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": "module pos_edge_counter #(\n    parameter NUM_DIV = 5\n) (\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam CNT_WIDTH = $clog2(NUM_DIV);\n    reg [CNT_WIDTH-1:0] cnt;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 0;\n        end\n        else begin\n            if (cnt == NUM_DIV - 1) begin\n                cnt <= 0;\n                clk_div <= ~clk_div;\n            end\n            else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter #(\n    parameter NUM_DIV = 5\n) (\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam CNT_WIDTH = $clog2(NUM_DIV"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 10; // Must be an even number\n    localparam HALF_DIV = NUM_DIV / 2;\n\n    wire tick;\n\n    u_counter #(\n        .HALF_DIV(HALF_DIV)\n    ) counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n\n    u_clk_divider clk_div_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n    \nendmodule\n\nmodule u_counter #(\n    parameter HALF_DIV = 5\n)(\n    input clk,\n    input rst_n,\n    output reg tick\n);\n    reg [3:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'd0;\n            tick  <= 1'b0;\n        end else begin\n            if (count == HALF_DIV - 1) begin\n                count <= 4'd0;\n                tick  <= 1'b1;\n            end else begin\n                count <= count + 1;\n                tick  <= 1'b0;\n            end\n        end\n    end\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier (\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule accumulator (\n    input clk,\n    input rst,\n    input [31:0] data,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 32'd0;\n        else\n            current_value <= current_value + data;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n    wire [31:0] lower_result;\n\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .product(mult_result)\n    );\n\n    assign lower_result = mult_result[31:0];\n\n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .data(lower_result),\n        .current_value(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_storage(\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    output reg [7:0] instr\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            instr <= 8'b0;\n        else if (load)\n            instr <= data;\n    end\nendmodule\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire [7:0] instr1, instr2;\n    wire load1, load2;\n\n    assign load1 = (fetch == 2'b01);\n    assign load2 = (fetch == 2'b10);\n\n    instr_storage ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data),\n        .instr(instr1)\n    );\n\n    instr_storage ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .load(load2),\n        .data(data),\n        .instr(instr2)\n    );\n\n    assign ins = instr1[7:5];\n    assign ad1 = instr1[4:0];\n    assign ad2 = instr2;\nendmodule"}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n    \n    assign enable = (freq != 8'd0);\n    \n    counter u_counter (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wave_generator u_wave (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n    \nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 8'd1)\n                count <= 8'd0;\n            else\n                count <= count + 8'd1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (freq != 8'd0) begin\n            if (count == freq - 8'd1)\n                wave_out <= ~wave_out;\n        end\n        else begin\n            wave_out <= 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n    wire [1:0] state;\n    wire [4:0] wave_sig;\n\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .wave(wave_sig),\n        .state(state)\n    );\n\n    wave_generator wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave_sig)\n    );\n\n    assign wave = wave_sig;\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [1:0] state\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            state <= 2'b00;\n        else begin\n            case (state)\n                2'b00: begin\n                    if (wave == 5'd31)\n                        state <= 2'b01;\n                    else\n                        state <= 2'b00;\n                end\n                2'b01: begin\n                    if (wave == 5'd0)\n                        state <= 2'b00;\n                    else\n                        state <= 2'b01;\n                end\n                default: state <= 2'b00;\n            endcase\n        end\n    end\nendmodule\n\nmodule wave_generator (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            wave <= 5'd0;\n        else begin\n            case (state)\n                2'b00: begin\n                    if (wave < 5'd31)\n                        wave <= wave + 1;\n                    else\n                        wave <= wave;\n                end\n                2'b01: begin\n                    if (wave > 5'd0)\n                        wave <= wave - 1;\n                    else\n                        wave <= wave;\n                end\n                default: wave <= wave;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = d;\n        endcase\n    end\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q)\n    );\n    \nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n  \n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  \n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  \nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module systolic1x4(\n    input clk,\n    input rst,\n    input [15:0] a0,\n    input [15:0] a1,\n    input [15:0] a2,\n    input [15:0] a3,\n    input [15:0] b0,\n    output [31:0] c0,\n    output [31:0] c1,\n    output [31:0] c2,\n    output [31:0] c3\n);\n\n  reg [15:0] b1, b2, b3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1 <= 16'b0;\n      b2 <= 16'b0;\n      b3 <= 16'b0;\n    end else begin\n      b1 <= b0;\n      b2 <= b1;\n      b3 <= b2;\n    end\n  end\n\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  PE pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  PE pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule\n\nmodule PE(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] c\n);\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 32'b0;\n    else\n      c <= c + (a * b);\n  end\n\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] result,\n    output wire [31:0] odd\n);\n\n    wire [31:0] prepared_dividend;\n    wire [31:0] prepared_divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n    \n    prep_dividend prep_inst(\n        .A(A),\n        .B(B),\n        .p_dividend(prepared_dividend),\n        .p_divisor(prepared_divisor)\n    );\n    \n    div_operation div_inst(\n        .p_dividend(prepared_dividend),\n        .p_divisor(prepared_divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n    \n    assign result = quotient;\n    assign odd = remainder;\n    \nendmodule\n\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output wire [31:0] p_dividend,\n    output wire [31:0] p_divisor\n);\n    assign p_dividend = A;\n    assign p_divisor = {16'b0, B};\nendmodule\n\nmodule div_operation(\n    input wire [31:0] p_dividend,\n    input wire [31:0] p_divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [31:0] temp_quotient;\n    reg [31:0] temp_remainder;\n    \n    always @(*) begin\n        temp_remainder = 32'b0;\n        temp_quotient = 32'b0;\n        for (i = 31; i >= 0; i = i - 1) begin\n            temp_remainder = temp_remainder << 1;\n            temp_remainder[0] = p_dividend[i];\n            if (temp_remainder >= p_divisor) begin\n                temp_remainder = temp_remainder - p_divisor;\n                temp_quotient[i] = 1'b1;\n            end else begin\n                temp_quotient[i] = 1'b0;\n            end\n        end\n        quotient = temp_quotient;\n        remainder = temp_remainder;\n    end\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input  wire [15:0] A,       // 16-bit dividend\n    input  wire [7:0]  B,       // 8-bit divisor\n    output wire [15:0] result,  // 16-bit quotient\n    output wire [15:0] odd      // 16-bit remainder\n);\n    div_ctrl ctrl_inst (\n        .A(A),\n        .B(B),\n        .result(result),\n        .odd(odd)\n    );\nendmodule\n\nmodule div_ctrl (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output reg  [15:0] result,\n    output reg  [15:0] odd\n);\n    integer i;\n    reg [15:0] quotient;\n    reg [15:0] remainder;\n    reg [15:0] B_ext;\n    \n    always @(*) begin\n        B_ext = {8'b0, B};\n        if (B == 0) begin\n            quotient  = 16'b0;\n            remainder = A;\n        end else begin\n            quotient  = 16'b0;\n            remainder = A;\n            for (i = 15; i >= 0; i = i - 1) begin\n                if (remainder >= (B_ext << i)) begin\n                    quotient  = quotient | (16'b1 << i);\n                    remainder = remainder - (B_ext << i);\n                end\n            end\n        end\n        result = quotient;\n        odd    = remainder;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module full_adder(a, b, c_in, sum, c_out);\n  input  a;\n  input  b;\n  input  c_in;\n  output sum;\n  output c_out;\n  \n  assign {c_out, sum} = a + b + c_in;\nendmodule\n\nmodule adder_8bit(a, b, c_in, sum, c_out);\n  input  [7:0] a;\n  input  [7:0] b;\n  input        c_in;\n  output [7:0] sum;\n  output       c_out;\n  wire   [6:0] carry;\n  \n  full_adder fa0(.a(a[0]), .b(b[0]), .c_in(c_in),    .sum(sum[0]), .c_out(carry[0]));\n  full_adder fa1(.a(a[1]), .b(b[1]), .c_in(carry[0]), .sum(sum[1]), .c_out(carry[1]));\n  full_adder fa2(.a(a[2]), .b(b[2]), .c_in(carry[1]), .sum(sum[2]), .c_out(carry[2]));\n  full_adder fa3(.a(a[3]), .b(b[3]), .c_in(carry[2]), .sum(sum[3]), .c_out(carry[3]));\n  full_adder fa4(.a(a[4]), .b(b[4]), .c_in(carry[3]), .sum(sum[4]), .c_out(carry[4]));\n  full_adder fa5(.a(a[5]), .b(b[5]), .c_in(carry[4]), .sum(sum[5]), .c_out(carry[5]));\n  full_adder fa6(.a(a[6]), .b(b[6]), .c_in(carry[5]), .sum(sum[6]), .c_out(carry[6]));\n  full_adder fa7(.a(a[7]), .b(b[7]), .c_in(carry[6]), .sum(sum[7]), .c_out(c_out));\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n  input  [7:0] A;\n  input  [7:0] B;\n  output [7:0] D;\n  output       B_out;\n  wire   [7:0] B_comp;\n  wire         c_out;\n  \n  assign B_comp = ~B;\n  \n  adder_8bit adder_inst(.a(A), .b(B_comp), .c_in(1'b1), .sum(D), .c_out(c_out));\n  \n  assign B_out = ~c_out;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_16bit (\n    input  [15:0] A,\n    input  [15:0] B,\n    input         borrow_in,\n    output [15:0] Diff,\n    output        borrow_out\n);\n    assign Diff = A - B - borrow_in;\n    assign borrow_out = (A < (B + borrow_in));\nendmodule\n\nmodule sub_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] Diff,\n    output        B_out\n);\n    wire borrow_lower;\n\n    sub_16bit sub_low (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(1'b0),\n        .Diff(Diff[15:0]),\n        .borrow_out(borrow_lower)\n    );\n\n    sub_16bit sub_high (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_lower),\n        .Diff(Diff[31:16]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_64bit", "response": ""}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    wire [32:0] result;\n    assign result = {1'b0, A} - {1'b0, B};\n    assign diff   = result[31:0];\n    assign borrow = result[32];\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater, \n    output        A_equal,   \n    output        A_less     \n);\n    wire [31:0] diff;\n    wire        borrow;\n    \n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n    \n    assign A_equal   = (diff == 32'b0) ? 1'b1 : 1'b0;\n    assign A_less    = borrow;\n    assign A_greater = (~borrow) & (~A_equal);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module ripple_carry_adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule csa_slice_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        sel,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       c0, c1;\n    \n    ripple_carry_adder_4bit rca0(\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .sum(sum0),\n        .cout(c0)\n    );\n    \n    ripple_carry_adder_4bit rca1(\n        .a(a),\n        .b(b),\n        .cin(1'b1),\n        .sum(sum1),\n        .cout(c1)\n    );\n    \n    assign sum  = sel ? sum1 : sum0;\n    assign cout = sel ? c1   : c0;\nendmodule\n\nmodule adder_16bit_csa(\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n    wire"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    input  wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input  wire [15:0] a,\n    input  wire [15:0] b,\n    input  wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry)\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  ci,\n    output sum,\n    output co\n);\n    assign sum = a ^ b ^ ci;\n    assign co  = (a & b) | (a & ci) | (b & ci);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input  cin,\n    output [7:0] sum,\n    output cout\n);\n    wire [8:0] carry;\n    \n    assign carry[0] = cin;\n    \n    full_adder FA0 (\n        .a(a[0]),\n        .b(b[0]),\n        .ci(carry[0]),\n        .sum(sum[0]),\n        .co(carry[1])\n    );\n    \n    full_adder FA1 (\n        .a(a[1]),\n        .b(b[1]),\n        .ci(carry[1]),\n        .sum(sum[1]),\n        .co(carry[2])\n    );\n    \n    full_adder FA2 (\n        .a(a[2]),\n        .b(b[2]),\n        .ci(carry[2]),\n        .sum(sum[2]),\n        .co(carry[3])\n    );\n    \n    full_adder FA3 (\n        .a(a[3]),\n        .b(b[3]),\n        .ci(carry[3]),\n        .sum(sum[3]),\n        .co(carry[4])\n    );\n    \n    full_adder FA4 (\n        .a(a[4]),\n        .b(b[4]),\n        .ci(carry[4]),\n        .sum(sum[4]),\n        .co(carry[5])\n    );\n    \n    full_adder FA5 (\n        .a(a[5]),\n        .b(b[5]),\n        .ci(carry[5]),\n        .sum(sum[5]),\n        .co(carry[6])\n    );\n    \n    full_adder FA6 (\n        .a(a[6]),\n        .b(b[6]),\n        .ci(carry[6]),\n        .sum(sum[6]),\n        .co(carry[7])\n    );\n    \n    full_adder FA7 (\n        .a(a[7]),\n        .b(b[7]),\n        .ci(carry[7]),\n        .sum(sum[7]),\n        .co(carry[8])\n    );\n    \n    assign cout = carry[8];\n    \nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module adder(\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 + op2;\nendmodule\n\nmodule subtractor(\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output [31:0] result\n);\n    assign result = op1 - op2;\nendmodule\n\nmodule as_module(\n    input        clk,\n    input        rst,\n    input        mode,\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n\n    adder u_adder (\n        .op1   (op1),\n        .op2   (op2),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor (\n        .op1   (op1),\n        .op2   (op2),\n        .result(sub_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      quotient <= 32'd0;\n    else if(divisor != 32'd0)\n      quotient <= dividend / divisor;\n    else\n      quotient <= 32'd0;\n  end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] difference\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      difference <= 32'd0;\n    else\n      difference <= a - b;\n  end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n  wire [31:0] div_result;\n  \n  u_divider divider_inst (\n    .clk(clk),\n    .rst(rst),\n    .dividend(x),\n    .divisor(y),\n    .quotient(div_result)\n  );\n  \n  u_subtractor subtractor_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(div_result),\n    .b(z),\n    .difference(difference)\n  );\n  \n  assign quotient = div_result;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\nu_adder adder_inst (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\nu_subtractor subtractor_inst (\n    .a(a),\n    .b(b),\n    .diff(sub_result)\n);\n\nu_and and_inst (\n    .a(a),\n    .b(b),\n    .res_and(and_result)\n);\n\nu_or or_inst (\n    .a(a),\n    .b(b),\n    .res_or(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'd0;\n    endcase\nend\n\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] res_and\n);\nassign res_and = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] res_or\n);\nassign res_or = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n    wire [31:0] adder_result;\n    wire [31:0] and_result;\n\n    u_adder u1 (\n        .a(a),\n        .b(b),\n        .result(adder_result)\n    );\n\n    u_bitwise_and u2 (\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n\n    always @(posedge clk) begin\n        case (op_sel)\n            1'b0: result <= adder_result;\n            1'b1: result <= and_result;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule"}
{"task_id": "pe_v_4", "response": "module u_adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n\n    u_adder u_adder_inst(\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_subtractor u_subtractor_inst(\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n  assign diff = a ^ b ^ bin;\n  assign bout = ((~a) & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n  wire [6:0] borrow;\n\n  full_subtractor fs0 (\n    .a(a[0]),\n    .b(b[0]),\n    .bin(bin),\n    .diff(diff[0]),\n    .bout(borrow[0])\n  );\n\n  full_subtractor fs1 (\n    .a(a[1]),\n    .b(b[1]),\n    .bin(borrow[0]),\n    .diff(diff[1]),\n    .bout(borrow[1])\n  );\n\n  full_subtractor fs2 (\n    .a(a[2]),\n    .b(b[2]),\n    .bin(borrow[1]),\n    .diff(diff[2]),\n    .bout(borrow[2])\n  );\n\n  full_subtractor fs3 (\n    .a(a[3]),\n    .b(b[3]),\n    .bin(borrow[2]),\n    .diff(diff[3]),\n    .bout(borrow[3])\n  );\n\n  full_subtractor fs4 (\n    .a(a[4]),\n    .b(b[4]),\n    .bin(borrow[3]),\n    .diff(diff[4]),\n    .bout(borrow[4])\n  );\n\n  full_subtractor fs5 (\n    .a(a[5]),\n    .b(b[5]),\n    .bin(borrow[4]),\n    .diff(diff[5]),\n    .bout(borrow[5])\n  );\n\n  full_subtractor fs6 (\n    .a(a[6]),\n    .b(b[6]),\n    .bin(borrow[5]),\n    .diff(diff[6]),\n    .bout(borrow[6])\n  );\n\n  full_subtractor fs7 (\n    .a(a[7]),\n    .b(b[7]),\n    .bin(borrow[6]),\n    .diff(diff[7]),\n    .bout(bout)\n  );\n  \nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input  a,\n    input  b,\n    input  bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire borrow0, borrow1, borrow2, borrow3, borrow4, borrow5, borrow6;\n    \n    subtractor_1bit S0 (.a(a[0]), .b(b[0]), .bin(bin),    .diff(diff[0]), .bout(borrow0));\n    subtractor_1bit S1 (.a(a[1]), .b(b[1]), .bin(borrow0), .diff(diff[1]), .bout(borrow1));\n    subtractor_1bit S2 (.a(a[2]), .b(b[2]), .bin(borrow1), .diff(diff[2]), .bout(borrow2));\n    subtractor_1bit S3 (.a(a[3]), .b(b[3]), .bin(borrow2), .diff(diff[3]), .bout(borrow3));\n    subtractor_1bit S4 (.a(a[4]), .b(b[4]), .bin(borrow3), .diff(diff[4]), .bout(borrow4));\n    subtractor_1bit S5 (.a(a[5]), .b(b[5]), .bin(borrow4), .diff(diff[5]), .bout(borrow5));\n    subtractor_1bit S6 (.a(a[6]), .b(b[6]), .bin(borrow5), .diff(diff[6]), .bout(borrow6));\n    subtractor_1bit S7 (.a(a[7]), .b(b[7]), .bin(borrow6), .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire borrow0, borrow1, borrow2, borrow3, borrow4, borrow5, borrow6;\n    \n    full_subtractor FS0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow0)\n    );\n    \n    full_subtractor FS1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow0),\n        .diff(diff[1]),\n        .bout(borrow1)\n    );\n    \n    full_subtractor FS2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow1),\n        .diff(diff[2]),\n        .bout(borrow2)\n    );\n    \n    full_subtractor FS3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow2),\n        .diff(diff[3]),\n        .bout(borrow3)\n    );\n    \n    full_subtractor FS4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow3),\n        .diff(diff[4]),\n        .bout(borrow4)\n    );\n    \n    full_subtractor FS5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(borrow4),\n        .diff(diff[5]),\n        .bout(borrow5)\n    );\n    \n    full_subtractor FS6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(borrow5),\n        .diff(diff[6]),\n        .bout(borrow6)\n    );\n    \n    full_subtractor FS7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(borrow6),\n        .diff(diff[7]),\n        .bout(bout)\n    );\n    \nendmodule"}
{"task_id": "adder_8bit_v_9", "response": ""}
{"task_id": "up_down_counter_v_10", "response": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    counter_logic u_counter_logic (\n        .current_count(count),\n        .toggle(toggle),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .next_count(next_count),\n        .count(count)\n    );\n    \nendmodule\n\nmodule toggle_logic(\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\n    \nendmodule\n\nmodule counter_logic(\n    input wire [31:0] current_count,\n    input wire toggle,\n    output wire [31:0] next_count\n);\n    assign next_count = toggle ? current_count + 1 : current_count;\n    \nendmodule\n\nmodule counter_register(\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] count\n);\n    always @(posedge clk) begin\n        if (!control_signal)\n            count <= 32'b0;\n        else\n            count <= next_count;\n    end\n    \nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n    \n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n    \n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n    \n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_out(and_out)\n    );\n    \n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_out(or_out)\n    );\n    \n    assign result = (op_code == 2'b00) ? add_out :\n                    (op_code == 2'b01) ? sub_out :\n                    (op_code == 2'b10) ? and_out :\n                    (op_code == 2'b11) ? or_out : 32'b0;\n                    \n    assign zero = (result == 32'b0);\n                    \nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n    \n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n    \n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n    \n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_out(and_result)\n    );\n    \n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_out(or_result)\n    );\n    \n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_out(xor_result)\n    );\n    \n    reg [31:0] result_reg;\n    \n    always @(*) begin\n        case (op_code)\n            3'b000: result_reg = add_result;\n            3'b001: result_reg = sub_result;\n            3'b010: result_reg = and_result;\n            3'b011: result_reg = or_result;\n            3'b100: result_reg = xor_result;\n            default: result_reg = 32'b0;\n        endcase\n    end\n    \n    assign result = result_reg;\n    assign zero = (result_reg == 32'b0);\n    \nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_out\n);\n    assign xor_out = a ^ b;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_res;\n    wire [31:0] sub_res;\n    wire [31:0] bit_res;\n    \n    adder u_adder (\n        .clk(clk),\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_res)\n    );\n    \n    subtractor u_subtractor (\n        .clk(clk),\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_res)\n    );\n    \n    bitwise_operator u_bitwise_operator (\n        .clk(clk),\n        .op_bit(op_code[0]),\n        .a(operand_a),\n        .b(operand_b),\n        .res(bit_res)\n    );\n    \n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result <= add_res;\n            2'b01: result <= sub_res;\n            2'b10: result <= bit_res;\n            2'b11: result <= bit_res;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule\n\nmodule adder (\n    input wire clk,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] sum\n);\n    always @(posedge clk) begin\n        sum <= a + b;\n    end\nendmodule\n\nmodule subtractor (\n    input wire clk,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] diff\n);\n    always @(posedge clk) begin\n        diff <= a - b;\n    end\nendmodule\n\nmodule bitwise_operator (\n    input wire clk,\n    input wire op_bit,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [31:0] res\n);\n    always @(posedge clk) begin\n        if (op_bit == 1'b0)\n            res <= a & b;\n        else\n            res <= a | b;\n    end\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        y,\n    output [15:0] pp\n);\n    assign pp = y ? ({8'd0, X} << SHIFT) : 16'd0;\nendmodule\n\nmodule mult_8bit (\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0;\n    wire [15:0] pp1;\n    wire [15:0] pp2;\n    wire [15:0] pp3;\n    wire [15:0] pp4;\n    wire [15:0] pp5;\n    wire [15:0] pp6;\n    wire [15:0] pp7;\n\n    gen_product #(.SHIFT(0)) GP0 (.X(X), .y(Y[0]), .pp(pp0));\n    gen_product #(.SHIFT(1)) GP1 (.X(X), .y(Y[1]), .pp(pp1));\n    gen_product #(.SHIFT(2)) GP2 (.X(X), .y(Y[2]), .pp(pp2));\n    gen_product #(.SHIFT(3)) GP3 (.X(X), .y(Y[3]), .pp(pp3));\n    gen_product #(.SHIFT(4)) GP4 (.X(X), .y(Y[4]), .pp(pp4));\n    gen_product #(.SHIFT(5)) GP5 (.X(X), .y(Y[5]), .pp(pp5));\n    gen_product #(.SHIFT(6)) GP6 (.X(X), .y(Y[6]), .pp(pp6));\n    gen_product #(.SHIFT(7)) GP7 (.X(X), .y(Y[7]), .pp(pp7));\n\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module add_shift #(parameter SHIFT = 0) (\n    input [15:0] in_acc,\n    input [7:0] X,\n    input y,\n    output [15:0] out_acc\n);\n    assign out_acc = in_acc + (y ? ({8'b0, X} << SHIFT) : 16'b0);\nendmodule\n\nmodule mult_8bit(\n    input [7:0] X,\n    input [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7;\n\n    assign acc0 = 16'd0;\n\n    add_shift #(.SHIFT(0)) AS0 (.in_acc(acc0), .X(X), .y(Y[0]), .out_acc(acc1));\n    add_shift #(.SHIFT(1)) AS1 (.in_acc(acc1), .X(X), .y(Y[1]), .out_acc(acc2));\n    add_shift #(.SHIFT(2)) AS2 (.in_acc(acc2), .X(X), .y(Y[2]), .out_acc(acc3));\n    add_shift #(.SHIFT(3)) AS3 (.in_acc(acc3), .X(X), .y(Y[3]), .out_acc(acc4));\n    add_shift #(.SHIFT(4)) AS4 (.in_acc(acc4), .X(X), .y(Y[4]), .out_acc"}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n    wire [3:0] sum;\n    wire [3:0] diff;\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n\n    adder         u_adder      (.a(operand_a), .b(operand_b), .sum(sum));\n    subtractor    u_subtractor (.a(operand_a), .b(operand_b), .diff(diff));\n    and_logical   u_and        (.a(operand_a), .b(operand_b), .and_out(and_out));\n    or_logical    u_or         (.a(operand_a), .b(operand_b), .or_out(or_out));\n\n    always @(posedge clk) begin\n        case(op_code)\n            2'b00: result <= sum;\n            2'b01: result <= diff;\n            2'b10: result <= and_out;\n            2'b11: result <= or_out;\n            default: result <= 4'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n    \n    adder adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n    \n    subtractor subtractor_inst (\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n    \n    and_module and_inst (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n    \n    or_module or_inst (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n    \n    always @(*) begin\n        case(op)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\n\n  wire [1:0] op_ctrl;\n  wire [3"}
{"task_id": "stagepipe3_v_21", "response": "module arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\n  wire [15:0] add_result;\n  wire [15:0] sub_result;\n  wire [15:0] mul_result;\n  wire [15:0] div_result;\n  wire        div_valid;\n\n  add_module u_add (\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(add_result)\n  );\n\n  sub_module u_sub (\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(sub_result)\n  );\n\n  mul_module u_mul (\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(mul_result)\n  );\n\n  div_module u_div (\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(div_result),\n    .valid(div_valid)\n  );\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      result <= 16'b0;\n      valid  <= 1'b0;\n    end else begin\n      case (opcode)\n        2'b00: begin\n          result <= add_result;\n          valid  <= 1'b1;\n        end\n        2'b01: begin\n          result <= sub_result;\n          valid  <= 1'b1;\n        end\n        2'b10: begin\n          result <= mul_result;\n          valid  <= 1'b1;\n        end\n        2'b11: begin\n          result <= div_result;\n          valid  <= div_valid;\n        end\n        default: begin\n          result <= 16'b0;\n          valid  <= 1'b0;\n        end\n      endcase\n    end\n  end\n\nendmodule\n\nmodule add_module(\n  input [7:0] data_a,\n  input [7:0] data_b,\n  output [15:0] result\n);\n  assign result = data_a + data_b;\nendmodule\n\nmodule sub_module(\n  input [7:0] data_a,\n  input [7:0] data_b,\n  output [15:0] result\n);\n  assign result = data_a - data_b;\nendmodule\n\nmodule mul_module(\n  input [7:0] data_a,\n  input [7:0] data_b,\n  output [15:0] result\n);\n  assign result = data_a * data_b;\nendmodule\n\nmodule div_module(\n  input [7:0] data_a,\n  input [7:0] data_b,\n  output [15:0] result,\n  output valid\n);\n  assign valid  = (data_b != 8'd0);\n  assign result = (data_b != 8'd0) ? (data_a / data_b) : 16'b0;\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module magnitude_comparator (A, B, gt, lt, eq);\n  input  [3:0] A;\n  input  [3:0] B;\n  output       gt;\n  output       lt;\n  output       eq;\n\n  wire [3:0] gt_bit;\n  wire [3:0] lt_bit;\n  wire [3:0] eq_bit;\n\n  bit_compare bc3 (.a(A[3]), .b(B[3]), .gt(gt_bit[3]), .lt(lt_bit[3]), .eq(eq_bit[3]));\n  bit_compare bc2 (.a(A[2]), .b(B[2]), .gt(gt_bit[2]), .lt(lt_bit[2]), .eq(eq_bit[2]));\n  bit_compare bc1 (.a(A[1]), .b(B[1]), .gt(gt_bit[1]), .lt(lt_bit[1]), .eq(eq_bit[1]));\n  bit_compare bc0 (.a(A[0]), .b(B[0]), .gt(gt_bit[0]), .lt(lt_bit[0]), .eq(eq_bit[0]));\n\n  assign gt = gt_bit[3] |\n              (eq_bit[3] & gt_bit[2]) |\n              (eq_bit[3] & eq_bit[2] & gt_bit[1]) |\n              (eq_bit[3] & eq_bit[2] & eq_bit[1] & gt_bit[0]);\n\n  assign lt = lt_bit[3] |\n              (eq_bit[3] & lt_bit[2]) |\n              (eq_bit[3] & eq_bit[2] & lt_bit[1]) |\n              (eq_bit[3] & eq_bit[2] & eq_bit[1] & lt_bit[0]);\n\n  assign eq = eq_bit[3] & eq_bit[2] & eq_bit[1] & eq_bit[0];\nendmodule\n\nmodule bit_compare (a, b, gt, lt, eq);\n  input  a;\n  input  b;\n  output gt;\n  output lt;\n  output eq;\n\n  assign gt = a & ~b;\n  assign lt = ~a & b;\n  assign eq = ~(a ^ b);\nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module bitwise_and(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule bitwise_or(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result,\n    output       carry\n);\n    wire [4:0] sum;\n    assign sum = a + b;\n    assign result = sum[3:0];\n    assign carry = sum[4];\nendmodule\n\nmodule subtractor_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    output [3:0] result,\n    output       borrow\n);\n    assign result = a - b;\n    assign borrow = (a < b) ? 1'b1 : 1'b0;\nendmodule\n\nmodule simple_alu(a, b, op, result, carry_borrow);\n    input  [3:0] a;\n    input  [3:0] b;\n    input  [1:0] op;\n    output [3:0] result;\n    output       carry_borrow;\n\n    wire [3:0] and_res;\n    wire [3:0] or_res;\n    wire [3:0] add_res;\n    wire [3:0] sub_res;\n    wire       add_carry;\n    wire       sub_borrow;\n\n    bitwise_and u_and(\n        .a(a),\n        .b(b),\n        .result(and_res)\n    );\n\n    bitwise_or u_or(\n        .a(a),\n        .b(b),\n        .result(or_res)\n    );\n\n    adder_4bit u_adder(\n        .a(a),\n        .b(b),\n        .result(add_res),\n        .carry(add_carry)\n    );\n\n    subtractor_4bit u_subtractor(\n        .a(a),\n        .b(b),\n        .result(sub_res),\n        .borrow(sub_borrow)\n    );\n\n    reg [3:0] result_reg;\n    reg       carry_borrow_reg;\n\n    assign result = result_reg;\n    assign carry_borrow = carry_borrow_reg;\n\n    always @(*) begin\n        case(op)\n            2'b00: begin\n                result_reg = and_res;\n                carry_borrow_reg = 1'b0;\n            end\n            2'b01: begin\n                result_reg = or_res;\n                carry_borrow_reg = 1'b0;\n            end\n            2'b10: begin\n                result_reg = add_res;\n                carry_borrow_reg = add_carry;\n            end\n            2'b11: begin\n                result_reg = sub_res;\n                carry_borrow_reg = sub_borrow;\n            end\n            default: begin\n                result_reg = 4'b0000;\n                carry_borrow_reg = 1'b0;\n            end\n        endcase\n    end\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n  input  [7:0] temp_sensor;\n  input        smoke_sensor;\n  output       alarm_out;\n\n  wire         comp_result;\n\n  comp_temp u_comp_temp (.temp_sensor(temp_sensor), .result(comp_result));\n  or_gate   u_or_gate   (.in1(comp_result),   .in2(smoke_sensor), .result(alarm_out));\nendmodule\n\nmodule comp_temp (temp_sensor, result);\n  input  [7:0] temp_sensor;\n  output       result;\n  parameter TEMP_THRESHOLD = 8'd100;\n\n  assign result = (temp_sensor > TEMP_THRESHOLD);\nendmodule\n\nmodule or_gate (in1, in2, result);\n  input  in1;\n  input  in2;\n  output result;\n\n  assign result = in1 | in2;\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": "module cla_4bit(A, B, Cin, S, Cout);\n    input  [3:0] A, B;\n    input        Cin;\n    output [3:0] S;\n    output       Cout;\n    \n    wire [3:0] g, p;\n    wire c1, c2, c3;\n    \n    assign g = A & B;\n    assign p = A ^ B;\n    \n    assign c1 = g[0] | (p[0] & Cin);\n    assign c2 = g[1] | (p[1] & g[0]) | (p[1] & p[0] & Cin);\n    assign c3 = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & Cin);\n    assign Cout = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & Cin);\n    \n    assign S[0] = p[0] ^ Cin;\n    assign S[1] = p[1] ^ c1;\n    assign S[2] = p[2] ^ c2;\n    assign S[3] = p[3] ^ c3;\n    \nendmodule\n\nmodule add_16bit(A, B, S, C_out);\n    input  [16:1] A, B;\n    output [16:1] S;\n    output        C_out;\n    \n    wire c1, c2, c3;\n    \n    cla_4bit add1 (\n        .A   (A[4:1]),\n        .B   (B[4:1]),\n        ."}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(\n    input  [7:0] d,\n    output       p\n);\n    assign p = ^d;\nendmodule\n\nmodule parity_16bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output       P\n);\n    wire p1, p2;\n    \n    parity_8bit gen1(.d(X), .p(p1));\n    parity_8bit gen2(.d(Y), .p(p2));\n    \n    assign P = p1 ^ p2;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n\n    adder_unit au0 (\n        .a(a0),\n        .b(b0),\n        .sum(sum0)\n    );\n\n    adder_unit au1 (\n        .a(a1),\n        .b(b1),\n        .sum(sum1)\n    );\n\n    adder_unit au2 (\n        .a(a2),\n        .b(b2),\n        .sum(sum2)\n    );\n\n    adder_unit au3 (\n        .a(a3),\n        .b(b3),\n        .sum(sum3)\n    );\n\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n\nwire [15:0] mult0_out;\nwire [15:0] mult1_out;\nwire [15:0] mult2_out;\nwire [15:0] mult3_out;\n\nmultiplier mult0 (\n    .clk(clk),\n    .rst(rst),\n    .a(x0),\n    .b(y0),\n    .product(mult0_out)\n);\n\nmultiplier mult1 (\n    .clk(clk),\n    .rst(rst),\n    .a(x1),\n    .b(y0),\n    .product(mult1_out)\n);\n\nmultiplier mult2 (\n    .clk(clk),\n    .rst(rst),\n    .a(x0),\n    .b(y1),\n    .product(mult2_out)\n);\n\nmultiplier mult3 (\n    .clk(clk),\n    .rst(rst),\n    .a(x1),\n    .b(y1),\n    .product(mult3_out)\n);\n\nassign p0 = mult0_out;\nassign p1 = mult1_out;\nassign p2 = mult2_out;\nassign p3 = mult3_out;\n\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] product\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            product <= 16'd0;\n        else\n            product <= a * b;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module left_rotate(\n  input  [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[2:0], in_data[3]};\nendmodule\n\nmodule right_rotate(\n  input  [3:0] in_data,\n  output [3:0] out_data\n);\n  assign out_data = {in_data[0], in_data[3:1]};\nendmodule\n\nmodule cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  wire [3:0] left_out;\n  wire [3:0] right_out;\n  wire [3:0] rotated;\n\n  left_rotate lr(\n    .in_data(in_data),\n    .out_data(left_out)\n  );\n\n  right_rotate rr(\n    .in_data(in_data),\n    .out_data(right_out)\n  );\n\n  assign rotated = (rot_dir) ? left_out : right_out;\n  assign out_data = en ? rotated : in_data;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\n\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'b0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 1;\n      else\n        count <= count - 1;\n    end\n  end\n\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (rst)\n            out <= 8'd0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .out(out0)\n    );\n    \n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .out(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input  A,\n    input  B,\n    input  Cin,\n    output Sum,\n    output Cout\n);\n    assign Sum  = A ^ B ^ Cin;\n    assign Cout = (A & B) | (B & Cin) | (A & Cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    wire [8:0] c;\n    assign c[0] = Cin;\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : fa_gen\n            full_adder u_fa (\n                .A    (X[i]),\n                .B    (Y[i]),\n                .Cin  (c[i]),\n                .Sum  (Sum[i]),\n                .Cout (c[i+1])\n            );\n        end\n    endgenerate\n    assign Cout = c[8];\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] X,\n    input  [31:0] Y,\n    output [31:0] Sum,\n    output        Carry_out\n);\n    wire c1, c2, c3;\n\n    adder_8bit u_adder0 (\n        .X   (X[7:0]),\n        .Y   (Y[7:0]),\n        .Cin (1'b0),\n        .Sum (Sum[7:0]),\n        .Cout(c1)\n    );\n\n    adder_8bit u_adder1 (\n        .X   (X[15:8]),\n        .Y   (Y[15:8]),\n        .Cin (c1),\n        .Sum (Sum[15:8]),\n        .Cout(c2)\n    );\n\n    adder_8bit u_adder2 (\n        .X   (X[23:16]),\n        .Y   (Y[23:16]),\n        .Cin (c2),\n        .Sum (Sum[23:16]),\n        .Cout(c3)\n    );\n\n    adder_8bit u_adder3 (\n        .X   (X[31:24]),\n        .Y   (Y[31:24]),\n        .Cin (c3),\n        .Sum (Sum[31:24]),\n        .Cout(Carry_out)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         Cin,\n    output [31:0] Sum,\n    output        Cout\n);\n    wire c1, c2, c3;\n\n    adder_8bit adder0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n\n    adder_8bit adder1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n\n    adder_8bit adder2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n\n    adder_8bit adder3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module alu_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input  [1:0]  op,\n    output [31:0] result,\n    output        carry_out\n);\n\nwire [31:0] add_result, sub_result, and_result;\nwire        add_carry, sub_carry;\n\nadder_32bit u_adder (\n    .A(A),\n    .B(B),\n    .result(add_result),\n    .carry_out(add_carry)\n);\n\nsubtractor_32bit u_subtractor (\n    .A(A),\n    .B(B),\n    .result(sub_result),\n    .carry_out(sub_carry)\n);\n\nand_32bit u_and (\n    .A(A),\n    .B(B),\n    .result(and_result)\n);\n\nassign result = (op == 2'b00) ? add_result :\n                (op == 2'b01) ? sub_result :\n                (op == 2'b10) ? and_result : 32'd0;\n\nassign carry_out = (op == 2'b00) ? add_carry :\n                   (op == 2'b01) ? sub_carry :\n                   1'b0;\n\nendmodule\n\n\nmodule adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\nassign {carry_out, result} = A + B;\nendmodule\n\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\nassign {carry_out, result} = A + (~B) + 1;\nendmodule\n\n\nmodule and_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result\n);\nassign result = A & B;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux_path0 (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n  always @(posedge clk)\n    out <= in;\nendmodule\n\nmodule mux_path1 (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n  always @(posedge clk)\n    out <= in;\nendmodule\n\nmodule mux_path2 (\n    input clk,\n    input [7:0] in,\n    output reg [7:0] out\n);\n  always @(posedge clk)\n    out <= in;\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output reg [7:0] data_out\n);\n  wire [7:0] out0;\n  wire [7:0] out1;\n  wire [7:0] out2;\n  \n  mux_path0 u_mux0 (\n      .clk(clk),\n      .in(d0),\n      .out(out0)\n  );\n  \n  mux_path1 u_mux1 (\n      .clk(clk),\n      .in(d1),\n      .out(out1)\n  );\n  \n  mux_path2 u_mux2 (\n      .clk(clk),\n      .in(d2),\n      .out(out2)\n  );\n  \n  always @(*) begin\n    case (sel)\n      3'b000: data_out = out0;\n      3'b001: data_out = out1;\n      3'b010: data_out = out2;\n      default: data_out = 8'd0;\n    endcase\n  end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold0 (\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (load)\n            q <= d;\n    end\nendmodule\n\nmodule hold1 (\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (load)\n            q <= d;\n    end\nendmodule\n\nmodule hold2 (\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (load)\n            q <= d;\n    end\nendmodule\n\nmodule hold3 (\n    input clk,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (load)\n            q <= d;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n    wire en0, en1, en2, en3;\n    assign en0 = (sel == 2'b00);\n    assign en1 = (sel == 2'b01);\n    assign en2 = (sel == 2'b10);\n    assign en3 = (sel == 2'b11);\n\n    wire [7:0] hold0_q, hold1_q, hold2_q, hold3_q;\n\n    hold0 u_hold0 (\n        .clk(clk),\n        .load(en0),\n        .d(in0),\n        .q(hold0_q)\n    );\n\n    hold1 u_hold1 (\n        .clk(clk),\n        .load(en1),\n        .d(in1),\n        .q(hold1_q)\n    );\n\n    hold2 u_hold2 (\n        .clk(clk),\n        .load(en2),\n        .d(in2),\n        .q(hold2_q)\n    );\n\n    hold3 u_hold3 (\n        .clk(clk),\n        .load(en3),\n        .d(in3),\n        .q(hold3_q)\n    );\n\n    assign out = (sel == 2'b00) ? hold0_q :\n                 (sel == 2'b01) ? hold1_q :\n                 (sel == 2'b10) ? hold2_q : hold3_q;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n    wire [15:0] count;\n    wire reset = 1'b0;\n\n    pwm_counter u_pwm_counter (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(count)\n    );\n\n    pwm_signal u_pwm_signal (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n    always @(posedge clk) begin\n        if (reset)\n            count <= 16'd0;\n        else if (count == freq - 1)\n            count <= 16'd0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle) / 100)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n  wire [7:0] adjusted_duty;\n\n  duty_ctrl u_duty_ctrl (\n    .clk(clk),\n    .duty_cycle(duty_cycle),\n    .adjusted_duty(adjusted_duty)\n  );\n\n  pulse_gen u_pulse_gen (\n    .clk(clk),\n    .duty_cycle(adjusted_duty),\n    .pwm_out(pwm_out)\n  );\n\nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n  always @(posedge clk) begin\n    adjusted_duty <= duty_cycle;\n  end\n\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n\n  reg [7:0] counter;\n\n  always @(posedge clk) begin\n    counter <= counter + 1'b1;\n    if (counter < duty_cycle)\n      pwm_out <= 1'b1;\n    else\n      pwm_out <= 1'b0;\n  end\n\nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input  wire [31:0] a,\n    input  wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n    \n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n    \n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n    \n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n    \n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bit_reverse (\n    input  [7:0] din,\n    output [7:0] dout\n);\n    assign dout[7] = din[0];\n    assign dout[6] = din[1];\n    assign dout[5] = din[2];\n    assign dout[4] = din[3];\n    assign dout[3] = din[4];\n    assign dout[2] = din[5];\n    assign dout[1] = din[6];\n    assign dout[0] = din[7];\nendmodule\n\nmodule bitwise_reverse8 (\n    input  [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] intermediate;\n    \n    bit_reverse br1 (\n        .din(din),\n        .dout(intermediate)\n    );\n    \n    bit_reverse br2 (\n        .din(intermediate),\n        .dout(dout)\n    );\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n\n    wire [7:0] adder_result;\n\n    my_adder8 U1 (\n        .a(a),\n        .b(b),\n        .sum(adder_result)\n    );\n\n    always @(*) begin\n        if (ctrl)\n            sum = adder_result;\n        else\n            sum = 8'b0;\n    end\n\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    wire pwm25;\n    wire pwm50;\n    wire pwm75;\n\n    pwm_module_25 u_pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm25)\n    );\n\n    pwm_module_50 u_pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm50)\n    );\n\n    pwm_module_75 u_pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm75)\n    );\n\n    assign PWM_25 = pwm25;\n    assign PWM_50 = pwm50;\n    assign PWM_75 = pwm75;\nendmodule\n\nmodule pwm_module_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter PERIOD = 100;\n    parameter THRESH = 25;\n    reg [6:0] counter;\n    \n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter < THRESH)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n                \n            if (counter == PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule pwm_module_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter PERIOD = 100;\n    parameter THRESH = 50;\n    reg [6:0] counter;\n    \n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter < THRESH)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n                \n            if (counter == PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n        end\n    end\nendmodule\n\nmodule pwm_module_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    parameter PERIOD = 100;\n    parameter THRESH = 75;\n    reg [6:0] counter;\n    \n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n            PWM_out <= 0;\n        end else begin\n            if (counter < THRESH)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n                \n            if (counter == PERIOD - 1)\n                counter <= 0;\n            else\n                counter <= counter + 1;\n        end\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_duty_25 u_pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_25)\n    );\n\n    pwm_duty_50 u_pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_50)\n    );\n\n    pwm_duty_75 u_pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_75)\n    );\nendmodule\n\nmodule pwm_duty_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 25) / 100;\n    reg [31:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM <= 0;\n        end\n        else begin\n            if (counter < PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n                \n            if (counter < THRESHOLD)\n                PWM <= 1;\n            else\n                PWM <= 0;\n        end\n    end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 50) / 100;\n    reg [31:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM <= 0;\n        end\n        else begin\n            if (counter < PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n                \n            if (counter < THRESHOLD)\n                PWM <= 1;\n            else\n                PWM <= 0;\n        end\n    end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM\n);\n    parameter PERIOD = 100;\n    localparam THRESHOLD = (PERIOD * 75) / 100;\n    reg [31:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            PWM <= 0;\n        end\n        else begin\n            if (counter < PERIOD - 1)\n                counter <= counter + 1;\n            else\n                counter <= 0;\n                \n            if (counter < THRESHOLD)\n                PWM <= 1;\n            else\n                PWM <= 0;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller #(\n    parameter DUTY_CYCLE = 50,    // Duty cycle in percentage\n    parameter MAX_COUNT  = 255,   // Maximum count value for the counter\n    parameter WIDTH      = 8      // Bit-width of the counter\n)(\n    input  clk,\n    input  rst_n,\n    output pwm_out\n);\n\nwire [WIDTH-1:0] count;\nwire cmp_out;\n\ncounter #(\n    .MAX_COUNT(MAX_COUNT),\n    .WIDTH(WIDTH)\n) u_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .count(count)\n);\n\nlocalparam THRESHOLD = (DUTY_CYCLE * MAX_COUNT) / 100;\n\ncomparator #(\n    .THRESHOLD(THRESHOLD),\n    .WIDTH(WIDTH)\n) u_comparator (\n    .count(count),\n    .pwm_out(cmp_out)\n);\n\nassign pwm_out = cmp_out;\n\nendmodule\n\nmodule counter #(\n    parameter MAX_COUNT = 255,\n    parameter WIDTH = 8\n)(\n    input clk,\n    input rst_n,\n    output reg [WIDTH-1:0] count\n);\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        count <= 0;\n    else if (count == MAX_COUNT)\n        count <= 0;\n    else \n        count <= count + 1;\nend\n\nendmodule\n\nmodule comparator #(\n    parameter THRESHOLD = 128,\n    parameter WIDTH = 8\n)(\n    input [WIDTH-1:0] count,\n    output pwm_out\n);\n\nassign pwm_out = (count < THRESHOLD);\n\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input  [31:0] a,\n    input  [31:0] b,\n    input         multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output        zero\n);\n\n    wire [63:0] signed_product;\n    wire [63:0] unsigned_product;\n    wire [63:0] result;\n\n    mult_signed u_mult_signed(\n        .a(a),\n        .b(b),\n        .y(signed_product)\n    );\n\n    mult_unsigned u_mult_unsigned(\n        .a(a),\n        .b(b),\n        .y(unsigned_product)\n    );\n\n    assign result = (multc == 1'b0) ? signed_product : unsigned_product;\n    assign y      = result;\n    assign msb    = result[63:32];\n    assign lsb    = result[31:0];\n    assign zero   = (result == 64'b0);\n\nendmodule\n\nmodule mult_signed(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] y\n);\n    assign y = $signed(a) * $signed(b);\nendmodule\n\nmodule mult_unsigned(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": ""}
{"task_id": "stagepipe5_v_52", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    add add_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_result)\n    );\n\n    subtract subtract_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_result)\n    );\n\n    bitwise_and and_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .and_out(and_result)\n    );\n\n    bitwise_or or_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .or_out(or_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else begin\n            case (op_code)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= and_result;\n                2'b11: result <= or_result;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule add(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtract(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule bitwise_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "module comparator_4bit(a, b, eq, gt, lt);\n    input  [3:0] a, b;\n    output       eq, gt, lt;\n    reg          eq_reg, gt_reg, lt_reg;\n    \n    assign eq = eq_reg;\n    assign gt = gt_reg;\n    assign lt = lt_reg;\n    \n    always @(*) begin\n        if (a > b) begin\n            gt_reg = 1'b1;\n            lt_reg = 1'b0;\n            eq_reg = 1'b0;\n        end else if (a < b) begin\n            gt_reg = 1'b0;\n            lt_reg = 1'b1;\n            eq_reg = 1'b0;\n        end else begin\n            gt_reg = 1'b0;\n            lt_reg = 1'b0;\n            eq_reg = 1'b1;\n        end\n    end\nendmodule\n\nmodule comparator_16bit(a, b, eq, gt, lt);\n    input  [15:0] a, b;\n    output        eq, gt, lt;\n    \n    wire eq4, gt4, lt4;\n    wire eq3, gt3, lt3;\n    wire eq2, gt2, lt2;\n    wire eq1, gt1, lt1;\n    \n    comparator_4bit slice4 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .eq(eq4),\n        .gt(gt4),\n        .lt(lt4)\n    );\n    \n    comparator_4bit slice3 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .eq(eq3),\n        .gt(gt3),\n        .lt(lt3)\n    );\n    \n    comparator_4bit slice2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .eq(eq2),\n        .gt(gt2),\n        .lt(lt2)\n    );\n    \n    comparator_4bit slice1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .eq(eq1),\n        .gt(gt1),\n        .lt(lt1)\n    );\n    \n    assign eq = eq4 & eq3 & eq2 & eq1;\n    assign gt = gt4 | (eq4 & gt3) | (eq4 & eq3 & gt2) | (eq4 & eq3 & eq2 & gt1);\n    assign lt = lt4 | (eq4 & lt3) | (eq4 & eq3 & lt2) | (eq4 & eq3 & eq2 & lt1);\n    \nendmodule"}
{"task_id": "adder_32bit_v_54", "response": ""}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire q0, q1, q2;\n    \n    my_tff u0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(q0)\n    );\n    \n    my_tff u1 (\n        .clk(clk),\n        .reset(reset),\n        .t(q0),\n        .q(q1)\n    );\n    \n    my_tff u2 (\n        .clk(clk),\n        .reset(reset),\n        .t(q0 & q1),\n        .q(q2)\n    );\n    \n    assign count = {q2, q1, q0};\n    \nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module counter_init(\n    input wire reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule counter_increment(\n    input wire [3:0] count,\n    output wire [3:0] next_count\n);\n    assign next_count = count + 4'b0001;\nendmodule\n\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    reg [3:0] count;\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n    \n    counter_init init_inst (\n        .reset(reset),\n        .init_val(init_val)\n    );\n    \n    counter_increment inc_inst (\n        .count(count),\n        .next_count(inc_val)\n    );\n    \n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n    \n    assign out = count;\n\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\nwire [15:0] next_count;\n\nu_counter_logic u_counter_logic_inst (\n    .up_down(up_down),\n    .count(count),\n    .next_count(next_count)\n);\n\nu_counter_register u_counter_register_inst (\n    .clk(clk),\n    .reset(reset),\n    .next_count(next_count),\n    .count(count)\n);\n\nendmodule\n\nmodule u_counter_logic (\n    input wire up_down,\n    input wire [15:0] count,\n    output reg [15:0] next_count\n);\n\nalways @(*) begin\n    if (up_down)\n        next_count = count + 16'd1;\n    else\n        next_count = count - 16'd1;\nend\n\nendmodule\n\nmodule u_counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] count\n);\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 16'd0;\n    else\n        count <= next_count;\nend\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter_init(\n    input wire reset,\n    output wire [7:0] init_state\n);\n    assign init_state = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition(\n    input wire [7:0] current_state,\n    output wire [7:0] next_state\n);\n    assign next_state = (current_state == 8'b10000000) ? 8'b00000001 : (current_state << 1);\nendmodule\n\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] out\n);\n    wire [7:0] init_state;\n    wire [7:0] next_state;\n\n    ring_counter_init init_inst (\n        .reset(reset),\n        .init_state(init_state)\n    );\n\n    ring_counter_transition trans_inst (\n        .current_state(out),\n        .next_state(next_state)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            out <= init_state;\n        else\n            out <= next_state;\n    end\nendmodule"}
{"task_id": "counter_12", "response": "module counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      count <= 4'b0000;\n    else if (valid_count) begin\n      if (count == 4'd11)\n        count <= 4'b0000;\n      else\n        count <= count + 1;\n    end\n  end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] in,\n    output reg [3:0] out\n);\n  always @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n      out <= 4'b0000;\n    else if (valid_count)\n      out <= in;\n  end\nendmodule\n\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n  wire [3:0] count;\n  \n  counter_logic u_counter_logic (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .count(count)\n  );\n  \n  output_register u_output_register (\n    .rst_n(rst_n),\n    .clk(clk),\n    .valid_count(valid_count),\n    .in(count),\n    .out(out)\n  );\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    clk_div_2 u_clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_50)\n    );\n\n    clk_div_10 u_clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_10)\n    );\n\n    clk_div_100 u_clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(CLK_1)\n    );\n\nendmodule\n\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_out <= 1'b0;\n        else\n            CLK_out <= ~CLK_out;\n    end\nendmodule\n\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 3'd0;\n            CLK_out <= 1'b0;\n        end\n        else begin\n            if (counter == 3'd4) begin\n                counter <= 3'd0;\n                CLK_out <= ~CLK_out;\n            end\n            else\n                counter <= counter + 1'b1;\n        end\n    end\nendmodule\n\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] counter;\n    \n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 7'd0;\n            CLK_out <= 1'b0;\n        end\n        else begin\n            if (counter == 7'd49) begin\n                counter <= 7'd0;\n                CLK_out <= ~CLK_out;\n            end\n            else\n                counter <= counter + 1'b1;\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": "module pos_edge_counter #(\n    parameter NUM_DIV = 5\n) (\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam WIDTH = $clog2(NUM_DIV);\n    reg [WIDTH-1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count   <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count == NUM_DIV - 1) begin\n                count   <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter #(\n    parameter NUM_DIV = 5\n) (\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam WIDTH = $clog2(NUM_DIV);\n    reg [WIDTH-1:0] count;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count   <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count == NUM_DIV - 1) begin\n                count   <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule freq_divbyodd #(\n    parameter NUM_DIV = 5\n) (\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    wire clk_div1;\n    wire clk_div2;\n\n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n\n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n\n    assign clk_div = clk_div1 | clk_div2;\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 4;\n    wire tick;\n    \n    u_counter #(.NUM_DIV(NUM_DIV)) u_counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n    \n    u_clk_divider u_clk_divider_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n    \nendmodule\n\nmodule u_counter #(parameter NUM_DIV = 4)(\n    input clk,\n    input rst_n,\n    output reg tick\n);\n    reg [3:0] count;\n    localparam MAX_COUNT = (NUM_DIV/2) - 1;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'd0;\n            tick  <= 1'b0;\n        end else begin\n            if(count == MAX_COUNT) begin\n                count <= 4'd0;\n                tick  <= 1'b1;\n            end else begin\n                count <= count + 4'd1;\n                tick  <= 1'b0;\n            end\n        end\n    end\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n        else\n            clk_div <= clk_div;\n    end\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n  assign result = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] in_data,\n    output reg [31:0] current_value\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      current_value <= 32'b0;\n    else\n      current_value <= current_value + in_data;\n  end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n  wire [63:0] mult_result;\n\n  multiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n  );\n\n  accumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .in_data(mult_result[31:0]),\n    .current_value(c)\n  );\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n    wire load1, load2;\n    wire [7:0] instr1, instr2;\n\n    assign load1 = (fetch == 2'b01);\n    assign load2 = (fetch == 2'b10);\n\n    ins_p1 u_ins_p1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .d(data),\n        .q(instr1)\n    );\n\n    ins_p2 u_ins_p2 (\n        .clk(clk),\n        .rst(rst),\n        .load(load2),\n        .d(data),\n        .q(instr2)\n    );\n\n    assign ins = instr1[7:5];\n    assign ad1 = instr1[4:0];\n    assign ad2 = instr2;\n    \nendmodule\n\nmodule ins_p1 (\n    input clk,\n    input rst,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            q <= 8'b0;\n        else if (load)\n            q <= d;\n        else\n            q <= q;\n    end\nendmodule\n\nmodule ins_p2 (\n    input clk,\n    input rst,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            q <= "}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n\n    assign enable = (freq != 8'd0) ? 1'b1 : 1'b0;\n\n    counter u_counter (\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n\n    wave_generator u_wave_generator (\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count >= (freq - 1))\n                count <= 8'd0;\n            else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    always @(posedge clk) begin\n        if (count == (freq - 1))\n            wave_out <= ~wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": ""}
{"task_id": "shift8", "response": "module my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0;\n    wire [7:0] q1;\n    wire [7:0] q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1;\n\n    my_dff u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q)\n    );\n    \nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe(\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c,\n  output reg [15:0] b_out\n);\n  always @(posedge clk) begin\n    if (rst) begin\n      c <= 32'b0;\n      b_out <= 16'b0;\n    end else begin\n      c <= c + a * b;\n      b_out <= b;\n    end\n  end\nendmodule\n\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n  wire [15:0] b1, b2,"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "`timescale 1ns / 1ps\n\nmodule div_32bit(\n    input  wire [31:0] A,     \n    input  wire [15:0] B,     \n    output wire [31:0] result,  \n    output wire [31:0] odd      \n);\n\n    wire [31:0] dividend_prepared;\n    wire [31:0] divisor_prepared;\n\n    prep_dividend u_prep_dividend (\n        .A(A),\n        .B(B),\n        .dividend(dividend_prepared),\n        .divisor(divisor_prepared)\n    );\n\n    div_operation u_div_operation (\n        .dividend(dividend_prepared),\n        .divisor(divisor_prepared),\n        .quotient(result),\n        .remainder(odd)\n    );\n\nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] dividend,\n    output wire"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n);\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    div_ctrl control_unit (\n        .A(A),\n        .B(B),\n        .result(quotient),\n        .odd(remainder)\n    );\n\n    assign result = quotient;\n    assign odd    = remainder;\n    \nendmodule\n\nmodule div_ctrl (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output reg  [15:0] result,\n    output reg  [15:0] odd\n);\n    reg [15:0] rem;\n    reg [15:0] temp_result;\n    reg [15:0] dividend;\n    integer i;\n    \n    always @(*) begin\n        dividend    = A;\n        rem         = 16'd0;\n        temp_result = 16'd0;\n        for(i = 15; i >= 0; i = i - 1) begin\n            rem = {rem[14:0], dividend[i]};\n            if(rem >= {8'b0, B}) begin\n                rem = rem - {8'b0, B};\n                temp_result[i] = 1'b1;\n            end\n            else begin\n                temp_result[i] = 1'b0;\n            end\n        end\n        result = temp_result;\n        odd    = rem;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n    wire c1, c2, c3, c4, c5, c6, c7;\n    \n    full_adder fa0(.a(A[0]), .b(B[0]), .cin(cin), .sum(sum[0]), .cout(c1));\n    full_adder fa1(.a(A[1]), .b(B[1]), .cin(c1),  .sum(sum[1]), .cout(c2));\n    full_adder fa2(.a(A[2]), .b(B[2]), .cin(c2),  .sum(sum[2]), .cout(c3));\n    full_adder fa3(.a(A[3]), .b(B[3]), .cin(c3),  .sum(sum[3]), .cout(c4));\n    full_adder fa4(.a(A[4]), .b(B[4]), .cin(c4),  .sum(sum[4]), .cout(c5));\n    full_adder fa5(.a(A[5]), .b(B[5]), .cin(c5),  .sum(sum[5]), .cout(c6));\n    full_adder fa6(.a(A[6]), .b(B[6]), .cin(c6),  .sum(sum[6]), .cout(c7));\n    full_adder fa7(.a(A[7]), .b(B[7]), .cin(c7),  .sum(sum[7]), .cout(cout));\nendmodule\n\nmodule sub_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n    wire [7:0] B_comp;\n    wire cout;\n    \n    assign B_comp = ~B;\n    \n    adder_8bit adder_inst(\n        .A(A),\n        .B(B_comp),\n        .cin(1'b1),\n        .sum(D),\n        .cout(cout)\n    );\n    \n    assign B_out = ~cout;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_16bit(A, B, borrow_in, Diff, borrow_out);\n  input [15:0] A, B;\n  input        borrow_in;\n  output [15:0] Diff;\n  output       borrow_out;\n  \n  wire [16:0] result;\n  assign result = {1'b0, A} - {1'b0, B} - borrow_in;\n  assign Diff = result[15:0];\n  assign borrow_out = result[16];\nendmodule\n\nmodule sub_32bit(A, B, Diff, B_out);\n  input  [31:0] A, B;\n  output [31:0] Diff;\n  output        B_out;\n  \n  wire        borrow_mid;\n  wire [15:0] Diff_low;\n  wire [15:0] Diff_high;\n  \n  sub_16bit s1 (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .borrow_in(1'b0),\n    .Diff(Diff_low),\n    .borrow_out(borrow_mid)\n  );\n  \n  sub_16bit s2 (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .borrow_in(borrow_mid),\n    .Diff(Diff_high),\n    .borrow_out(B_out)\n  );\n  \n  assign Diff = {Diff_high, Diff_low};\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        borrow_in,\n    output [7:0] D,\n    output       borrow_out\n);\n    assign D = A - B - borrow_in;\n    assign borrow_out = (A < (B + borrow_in));\nendmodule\n\nmodule sub_16bit(\n    input  [15:0] A,\n    input  [15:0] B,\n    input         borrow_in,\n    output [15:0] D,\n    output        borrow_out\n);\n    wire borrow_mid;\n    \n    sub_8bit u0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .borrow_in(borrow_in),\n        .D(D[7:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_8bit u1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .borrow_in(borrow_mid),\n        .D(D[15:8]),\n        .borrow_out(borrow_out)\n    );\nendmodule\n\nmodule sub_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         borrow_in,\n    output [31:0] D,\n    output        borrow_out\n);\n    wire borrow_mid;\n    \n    sub_16bit u0 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(borrow_in),\n        .D(D[15:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_16bit u1 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_mid),\n        .D(D[31:16]),\n        .borrow_out(borrow_out)\n    );\nendmodule\n\nmodule sub_64bit(\n    input  [63:0] A,\n    input  [63:0] B,\n    output [63:0] D,\n    output        B_out\n);\n    wire borrow_mid;\n    \n    sub_32bit u0 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .borrow_in(1'b0),\n        .D(D[31:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_32bit u1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .borrow_in(borrow_mid),\n        .D(D[63:32]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    assign diff   = A - B;\n    assign borrow = (A < B);\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater,\n    output        A_equal,\n    output        A_less\n);\n    wire [31:0] diff;\n    wire        borrow;\n    \n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n    \n    assign A_equal   = (diff == 32'd0);\n    assign A_less    = borrow;\n    assign A_greater = (~borrow) & (diff != 32'd0);\nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module rca_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule csa_slice_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       cout0, cout1;\n\n    rca_4bit u_rca0(\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .sum(sum0),\n        .cout(cout0)\n    );\n\n    rca_4bit u_rca1(\n        .a(a),\n        .b(b),\n        .cin(1'b1),\n        .sum(sum1),\n        .cout(cout1)\n    );\n\n    assign sum  = (cin == 1'b0) ? sum0 : sum1;\n    assign cout = (cin == 1'b0) ? cout0 : cout1;\nendmodule\n\nmodule adder_16bit_csa(\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n    wire c4, c8, c12;\n\n    rca_4bit u_rca0(\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c4)\n    );\n\n    csa_slice_4bit u_csa1(\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c4),\n        .sum(sum[7:4]),\n        .cout(c8)\n    );\n\n    csa_slice_4bit u_csa2(\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c8),\n        .sum(sum[11:8]),\n        .cout(c12)\n    );\n\n    csa_slice_4bit u_csa3(\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c12),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry_inter;\n\n    adder_8bit add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry_inter)\n    );\n\n    adder_8bit add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry_inter),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] a, b,\n    input        cin,\n    output [7:0] sum,\n    output       cout\n);\n    wire [6:0] carry;\n\n    full_adder FA0(\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(carry[0])\n    );\n\n    full_adder FA1(\n        .a(a[1]),\n        .b(b[1]),\n        .cin(carry[0]),\n        .sum(sum[1]),\n        .cout(carry[1])\n    );\n\n    full_adder FA2(\n        .a(a[2]),\n        .b(b[2]),\n        .cin(carry[1]),\n        .sum(sum[2]),\n        .cout(carry[2])\n    );\n\n    full_adder FA3(\n        .a(a[3]),\n        .b(b[3]),\n        .cin(carry[2]),\n        .sum(sum[3]),\n        .cout(carry[3])\n    );\n\n    full_adder FA4(\n        .a(a[4]),\n        .b(b[4]),\n        .cin(carry[3]),\n        .sum(sum[4]),\n        .cout(carry[4])\n    );\n\n    full_adder FA5(\n        .a(a[5]),\n        .b(b[5]),\n        .cin(carry[4]),\n        .sum(sum[5]),\n        .cout(carry[5])\n    );\n\n    full_adder FA6(\n        .a(a[6]),\n        .b(b[6]),\n        .cin(carry[5]),\n        .sum(sum[6]),\n        .cout(carry[6])\n    );\n\n    full_adder FA7(\n        .a(a[7]),\n        .b(b[7]),\n        .cin(carry[6]),\n        .sum(sum[7]),\n        .cout(cout)\n    );\n    \nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module u_adder(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] sum\n);\n    assign sum = op1 + op2;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] diff\n);\n    assign diff = op1 - op2;\nendmodule\n\nmodule as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n\n    u_adder u_add(\n        .op1(op1),\n        .op2(op2),\n        .sum(add_result)\n    );\n\n    u_subtractor u_sub(\n        .op1(op1),\n        .op2(op2),\n        .diff(sub_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else\n            result <= (mode == 1'b0) ? add_result : sub_result;\n    end\nendmodule"}
{"task_id": "pe_v_1", "response": "module divider (\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] quotient\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      quotient <= 32'b0;\n    else\n      quotient <= (b != 0) ? (a / b) : 32'b0;\n  end\nendmodule\n\nmodule subtractor (\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] subtrahend,\n    output reg [31:0] difference\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      difference <= 32'b0;\n    else\n      difference <= dividend - subtrahend;\n  end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n  wire [31:0] div_q;\n  \n  divider u_divider (\n      .clk(clk),\n      .rst(rst),\n      .a(x),\n      .b(y),\n      .quotient(div_q)\n  );\n  \n  subtractor u_subtractor (\n      .clk(clk),\n      .rst(rst),\n      .dividend(div_q),\n      .subtrahend(z),\n      .difference(difference)\n  );\n  \n  assign quotient = div_q;\n  \nendmodule"}
{"task_id": "pe_v_2", "response": "module u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n\nmodule alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n    wire [31:0] add_res;\n    wire [31:0] sub_res;\n    wire [31:0] and_res;\n    wire [31:0] or_res;\n\n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .sum(add_res)\n    );\n\n    u_subtractor u_subtractor_inst (\n        .a(a),\n        .b(b),\n        .diff(sub_res)\n    );\n\n    u_and u_and_inst (\n        .a(a),\n        .b(b),\n        .and_out(and_res)\n    );\n\n    u_or u_or_inst (\n        .a(a),\n        .b(b),\n        .or_out(or_res)\n    );\n\n    always @(posedge clk) begin\n        case(op_sel)\n            2'b00: result <= add_res;\n            2'b01: result <= sub_res;\n            2'b10: result <= and_res;\n            2'b11: result <= or_res;\n            default: result <= 32'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "pe_v_3", "response": "module u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n  assign result = a + b;\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n  assign result = a & b;\nendmodule\n\nmodule alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n  wire [31:0] add_result;\n  wire [31:0] and_result;\n  \n  u_adder u_adder_inst (\n    .a(a),\n    .b(b),\n    .result(add_result)\n  );\n  \n  u_bitwise_and u_bitwise_and_inst (\n    .a(a),\n    .b(b),\n    .result(and_result)\n  );\n  \n  always @(posedge clk) begin\n    result <= (op_sel == 1'b0) ? add_result : and_result;\n  end\nendmodule"}
{"task_id": "pe_v_4", "response": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    \n    u_adder adder_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n    \n    u_subtractor subtractor_inst (\n        .clk(clk),\n        .rst(rst),\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'd0;\n        else begin\n            if (mode == 1'b0)\n                result <= add_result;\n            else\n                result <= sub_result;\n        end\n    end\nendmodule\n\nmodule u_adder(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'd0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 16'd0;\n        else\n            result <= a - b;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = ((~a) & b) | (((~a) | b) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire b0, b1, b2, b3, b4, b5, b6;\n\n    full_subtractor FS0(\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(b0)\n    );\n\n    full_subtractor FS1(\n        .a(a[1]),\n        .b(b[1]),\n        .bin(b0),\n        .diff(diff[1]),\n        .bout(b1)\n    );\n\n    full_subtractor FS2(\n        .a(a[2]),\n        .b(b[2]),\n        .bin(b1),\n        .diff(diff[2]),\n        .bout(b2)\n    );\n\n    full_subtractor FS3(\n        .a(a[3]),\n        .b(b[3]),\n        .bin(b2),\n        .diff(diff[3]),\n        .bout(b3)\n    );\n\n    full_subtractor FS4(\n        .a(a[4]),\n        .b(b[4]),\n        .bin(b3),\n        .diff(diff[4]),\n        .bout(b4)\n    );\n\n    full_subtractor FS5(\n        .a(a[5]),\n        .b(b[5]),\n        .bin(b4),\n        .diff(diff[5]),\n        .bout(b5)\n    );\n\n    full_subtractor FS6(\n        .a(a[6]),\n        .b(b["}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~a | b) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire [8:0] borrow;\n    assign borrow[0] = bin;\n\n    subtractor_1bit S0 (.a(a[0]), .b(b[0]), .bin(borrow[0]), .diff(diff[0]), .bout(borrow[1]));\n    subtractor_1bit S1 (.a(a[1]), .b(b[1]), .bin(borrow[1]), .diff(diff[1]), .bout(borrow[2]));\n    subtractor_1bit S2 (.a(a[2]), .b(b[2]), .bin(borrow[2]), .diff(diff[2]), .bout(borrow[3]));\n    subtractor_1bit S3 (.a(a[3]), .b(b[3]), .bin(borrow[3]), .diff(diff[3]), .bout(borrow[4]));\n    subtractor_1bit S4 (.a(a[4]), .b(b[4]), .bin(borrow[4]), .diff(diff[4]), .bout(borrow[5]));\n    subtractor_1bit S5 (.a(a[5]), .b(b[5]), .bin(borrow[5]), .diff(diff[5]), .bout(borrow[6]));\n    subtractor_1bit S6 (.a(a[6]), .b(b[6]), .bin(borrow[6]), .diff(diff[6]), .bout(borrow[7]));\n    subtractor_1bit S7 (.a(a[7]), .b(b[7]), .bin(borrow[7]), .diff(diff[7]), .bout(borrow[8]));\n\n    assign bout = borrow[8];\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b ^ bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a, \n    input  [7:0] b,\n    input  bin,\n    output [7:0] diff,\n    output bout\n);\n    wire c0, c1, c2, c3, c4, c5, c6;\n\n    full_subtractor FS0(.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(c0));\n    full_subtractor FS1(.a(a[1]), .b(b[1]), .bin(c0),  .diff(diff[1]), .bout(c1));\n    full_subtractor FS2(.a(a[2]), .b(b[2]), .bin(c1),  .diff(diff[2]), .bout(c2));\n    full_subtractor FS3(.a(a[3]), .b(b[3]), .bin(c2),  .diff(diff[3]), .bout(c3));\n    full_subtractor FS4(.a(a[4]), .b(b[4]), .bin(c3),  .diff(diff[4]), .bout(c4));\n    full_subtractor FS5(.a(a[5]), .b(b[5]), .bin(c4),  .diff(diff[5]), .bout(c5));\n    full_subtractor FS6(.a(a[6]), .b(b[6]), .bin(c5),  .diff(diff[6]), .bout(c6));\n    full_subtractor FS7(.a(a[7]), .b(b[7]), .bin(c6),  .diff(diff[7]), .bout(bout));\n    \nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [7:0] product\n);\n\n  wire [7:0] pp0, pp1, pp2, pp3;\n\n  assign pp0 = b[0] ? {4'b0000, a}  : 8'b00000000;\n  assign pp1 = b[1] ? {3'b000, a, 1'b0} : 8'b00000000;\n  assign pp2 = b[2] ? {2'b00, a, 2'b00} : 8'b00000000;\n  assign pp3 = b[3] ? {1'b0, a, 3'b000} : 8'b00000000;\n\n  assign product = pp0 + pp1 + pp2 + pp3;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": "module toggle_logic(\n    input wire control_signal,\n    output wire toggle\n);\n    assign toggle = control_signal;\nendmodule\n\nmodule counter_logic(\n    input wire [31:0] current_count,\n    input wire toggle,\n    output wire [31:0] next_count\n);\n    assign next_count = toggle ? (current_count + 32'd1) : 32'd0;\nendmodule\n\nmodule counter_register(\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] current_count\n);\n    always @(posedge clk) begin\n        if (!control_signal)\n            current_count <= 32'd0;\n        else\n            current_count <= next_count;\n    end\nendmodule\n\nmodule binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n    wire toggle;\n    wire [31:0] next_count;\n    wire [31:0] current_count;\n\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    counter_logic u_counter_logic (\n        .current_count(current_count),\n        .toggle(toggle),\n        .next_count(next_count)\n    );\n\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .next_count(next_count),\n        .current_count(current_count)\n    );\n\n    assign count = current_count;\nendmodule"}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    \n    adder u_adder (\n        .a(a),\n        .b(b),\n        .result(add_result)\n    );\n    \n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .result(sub_result)\n    );\n    \n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .result(and_result)\n    );\n    \n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .result(or_result)\n    );\n    \n    reg [31:0] alu_result;\n    always @(*) begin\n        case (op_code)\n            2'b00: alu_result = add_result;\n            2'b01: alu_result = sub_result;\n            2'b10: alu_result = and_result;\n            2'b11: alu_result = or_result;\n            default: alu_result = 32'b0;\n        endcase\n    end\n    \n    assign result = alu_result;\n    assign zero = (alu_result == 32'b0);\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input  wire [2:0] op_code,\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    adder       u_adder     ( .operand_a(operand_a), .operand_b(operand_b), .sum(add_result) );\n    subtractor  u_subtractor( .operand_a(operand_a), .operand_b(operand_b), .difference(sub_result) );\n    and_bit     u_and_bit   ( .operand_a(operand_a), .operand_b(operand_b), .and_out(and_result) );\n    or_bit      u_or_bit    ( .operand_a(operand_a), .operand_b(operand_b), .or_out(or_result) );\n    xor_bit     u_xor_bit   ( .operand_a(operand_a), .operand_b(operand_b), .xor_out(xor_result) );\n\n    reg [31:0] result_reg;\n    assign result = result_reg;\n\n    always @(*) begin\n        case (op_code)\n            3'b000: result_reg = add_result;\n            3'b001: result_reg = sub_result;\n            3'b010: result_reg = and_result;\n            3'b011: result_reg = or_result;\n            3'b100: result_reg = xor_result;\n            default: result_reg = 32'b0;\n        endcase\n    end\n\n    assign zero = (result_reg == 32'b0);\n\nendmodule\n\nmodule adder (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] sum\n);\n    assign sum = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] difference\n);\n    assign difference = operand_a - operand_b;\nendmodule\n\nmodule and_bit (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] and_out\n);\n    assign and_out = operand_a & operand_b;\nendmodule\n\nmodule or_bit (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] or_out\n);\n    assign or_out = operand_a | operand_b;\nendmodule\n\nmodule xor_bit (\n    input  wire [31:0] operand_a,\n    input  wire [31:0] operand_b,\n    output wire [31:0] xor_out\n);\n    assign xor_out = operand_a ^ operand_b;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] bw_result;\n\n    adder u_adder (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(add_result)\n    );\n\n    subtractor u_subtractor (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(sub_result)\n    );\n\n    bitwise_operator u_bitwise_operator (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .op(op_code[0]),\n        .result(bw_result)\n    );\n\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result <= add_result;\n            2'b01: result <= sub_result;\n            2'b10: result <= bw_result;\n            2'b11: result <= bw_result;\n            default: result <= 32'b0;\n        endcase\n    end\n\nendmodule\n\nmodule adder (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule bitwise_operator (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    input wire op,  // 0: AND, 1: OR\n    output wire [31:0] result\n);\n    assign result = (op == 1'b0) ? (operand_a & operand_b) : (operand_a | operand_b);\nendmodule"}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] X,\n    input        Y_bit,\n    output [15:0] partial\n);\n    assign partial = Y_bit ? ({8'b0, X} << SHIFT) : 16'b0;\nendmodule\n\nmodule mult_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n\n    gen_product #(0) gp0 (.X(X), .Y_bit(Y[0]), .partial(pp0));\n    gen_product #(1) gp1 (.X(X), .Y_bit(Y[1]), .partial(pp1));\n    gen_product #(2) gp2 (.X(X), .Y_bit(Y[2]), .partial(pp2));\n    gen_product #(3) gp3 (.X(X), .Y_bit(Y[3]), .partial(pp3));\n    gen_product #(4) gp4 (.X(X), .Y_bit(Y[4]), .partial(pp4));\n    gen_product #(5) gp5 (.X(X), .Y_bit(Y[5]), .partial(pp5));\n    gen_product #(6) gp6 (.X(X), .Y_bit(Y[6]), .partial(pp6));\n    gen_product #(7) gp7 (.X(X), .Y_bit(Y[7]), .partial(pp7));\n\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n    input  [7:0] X;\n    input  [7:0] Y;\n    output [15:0] P;\n    \n    wire [15:0] acc0, acc1, acc2, acc3, acc4, acc5, acc6, acc7, acc8;\n    \n    assign acc0 = 16'b0;\n    \n    add_shift #(.SHIFT(0)) AS0 (\n        .acc_in(acc0),\n        .X(X),\n        .Y_bit(Y[0]),\n        .acc_out(acc1)\n    );\n    \n    add_shift #(.SHIFT(1)) AS1 (\n        .acc_in(acc1),\n        .X(X),\n        .Y_bit(Y[1]),\n        .acc_out(acc2)\n    );\n    \n    add_shift #(.SHIFT(2)) AS2 (\n        .acc_in(acc2),\n        .X(X),\n        .Y_bit(Y[2]),\n        .acc_out(acc3)\n    );\n    \n    add_shift #(.SHIFT(3)) AS3 (\n        .acc_in(acc3),\n        .X(X),\n        .Y_bit(Y[3]),\n        .acc_out(acc4)\n    );\n    \n    add_shift #(.SHIFT(4)) AS4 (\n        .acc_in(acc4),\n        .X(X),\n        .Y_bit(Y[4]),\n        .acc_out(acc5)\n    );\n    \n    add_shift #(.SHIFT(5)) AS5 (\n        .acc_in(acc5),\n        .X(X),\n        .Y_bit(Y[5]),\n        .acc_out(acc6)\n    );\n    \n    add_shift #(.SHIFT(6)) AS6 (\n        .acc_in(acc6),\n        .X(X),\n        .Y_bit(Y[6]),\n        .acc_out(acc7)\n    );\n    \n    add_shift #(.SHIFT(7)) AS7 (\n        .acc_in(acc7),\n        .X(X),\n        .Y_bit(Y[7]),\n        .acc_out(acc8)\n    );\n    \n    assign P = acc8;\nendmodule\n\nmodule add_shift #(parameter SHIFT = 0)(\n    input  [15:0] acc_in,\n    input  [7:0]  X,\n    input         Y_bit,\n    output [15:0] acc_out\n);\n    wire [15:0] shifted_X;\n    assign shifted_X = ({8'b0, X}) << SHIFT;\n    assign acc_out = Y_bit ? (acc_in + shifted_X) : acc_in;\nendmodule"}
{"task_id": "sub_8bit_v_16", "response": ""}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n\nwire [3:0] sum;\nwire [3:0] diff;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder u_adder(\n    .a(operand_a),\n    .b(operand_b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor(\n    .a(operand_a),\n    .b(operand_b),\n    .diff(diff)\n);\n\nand_logical u_and(\n    .a(operand_a),\n    .b(operand_b),\n    .and_out(and_result)\n);\n\nor_logical u_or(\n    .a(operand_a),\n    .b(operand_b),\n    .or_out(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_code)\n        2'b00: result <= sum;\n        2'b01: result <= diff;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\nassign and_out = a & b;\nendmodule\n\nmodule or_logical(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\nassign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\nwire [3:0] add_res;\nwire [3:0] sub_res;\nwire [3:0] and_res;\nwire [3:0] or_res;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_res)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .diff(sub_res)\n);\n\nand_module u_and (\n    .a(a),\n    .b(b),\n    .and_out(and_res)\n);\n\nor_module u_or (\n    .a(a),\n    .b(b),\n    .or_out(or_res)\n);\n\nalways @(*) begin\n    case(op)\n        2'b00: result = add_res;\n        2'b01: result = sub_res;\n        2'b10: result = and_res;\n        2'b11: result = or_res;\n        default: result = 4'b0000;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_out\n);\nassign and_out = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_out\n);\nassign or_out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": ""}
{"task_id": "stagepipe3_v_21", "response": "module add_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule sub_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule mul_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule div_module(\n    input [7:0] a,\n    input [7:0] b,\n    output [15:0] quotient,\n    output valid\n);\n    assign quotient = (b == 8'd0) ? 16'd0 : (a / b);\n    assign valid = (b == 8'd0) ? 1'b0 : 1'b1;\nendmodule\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\n\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] mul_result;\n    wire [15:0] div_result;\n    wire div_valid;\n\n    add_module u_add (\n        .a(data_a),\n        .b(data_b),\n        .sum(add_result)\n    );\n\n    sub_module u_sub (\n        .a(data_a),\n        .b(data_b),\n        .diff(sub_result)\n    );\n\n    mul_module u_mul (\n        .a(data_a),\n        .b(data_b),\n        .product(mul_result)\n    );\n\n    div_module u_div (\n        .a(data_a),\n        .b(data_b),\n        .quotient(div_result),\n        .valid(div_valid)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 16'd0;\n            valid  <= 1'b0;\n        end else begin\n            case(opcode)\n                2'b00: begin\n                    result <= add_result;\n                    valid  <= 1'b1;\n                end\n                2'b01: begin\n                    result <= sub_result;\n                    valid  <= 1'b1;\n                end\n                2'b10: begin\n                    result <= mul_result;\n                    valid  <= 1'b1;\n                end\n                2'b11: begin\n                    result <= div_result;\n                    valid  <= div_valid;\n                end\n                default: begin\n                    result <= 16'd0;\n                    valid  <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare(input a, input b, output gt, output lt, output eq);\n    assign gt = a & ~b;\n    assign lt = ~a & b;\n    assign eq = ~(a ^ b);\nendmodule\n\nmodule magnitude_comparator(A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt;\n    output lt;\n    output eq;\n\n    wire gt3, lt3, eq3;\n    wire gt2, lt2, eq2;\n    wire gt1, lt1, eq1;\n    wire gt0, lt0, eq0;\n\n    bit_compare bc3 (.a(A[3]), .b(B[3]), .gt(gt3), .lt(lt3), .eq(eq3));\n    bit_compare bc2 (.a(A[2]), .b(B[2]), .gt(gt2), .lt(lt2), .eq(eq2));\n    bit_compare bc1 (.a(A[1]), .b(B[1]), .gt(gt1), .lt(lt1), .eq(eq1));\n    bit_compare bc0 (.a(A[0]), .b(B[0]), .gt(gt0), .lt(lt0), .eq(eq0));\n\n    assign gt = gt3 | (eq3 & gt2) | (eq3 & eq2 & gt1) | (eq3 & eq2 & eq1 & gt0);\n    assign lt = lt3 | (eq3 & lt2) | (eq3 & eq2 & lt1) | (eq3 & eq2 & eq1 & lt0);\n    assign eq = eq3 & eq2 & eq1 & eq0;\n    \nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": ""}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module compare_temp (\n    input [7:0] temp_sensor,\n    output temp_alarm\n);\n    parameter THRESHOLD = 8'd100;\n    assign temp_alarm = (temp_sensor > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic (\n    input in1,\n    input in2,\n    output out\n);\n    assign out = in1 | in2;\nendmodule\n\nmodule alarm_system (\n    input  [7:0] temp_sensor,\n    input        smoke_sensor,\n    output       alarm_out\n);\n    wire temp_alarm;\n\n    compare_temp comp_temp_inst (\n        .temp_sensor(temp_sensor),\n        .temp_alarm(temp_alarm)\n    );\n\n    or_logic or_gate_inst (\n        .in1(temp_alarm),\n        .in2(smoke_sensor),\n        .out(alarm_out)\n    );\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": ""}
{"task_id": "sub_16bit_v_27", "response": ""}
{"task_id": "sub_16bit_v_28", "response": "module parity_16bit(X, Y, P);\n  input  [7:0] X;\n  input  [7:0] Y;\n  output       P;\n  \n  wire parX;\n  wire parY;\n  \n  parity_8bit gen1 (\n    .A(X),\n    .P(parX)\n  );\n  \n  parity_8bit gen2 (\n    .A(Y),\n    .P(parY)\n  );\n  \n  assign P = parX ^ parY;\nendmodule\n\nmodule parity_8bit(A, P);\n  input  [7:0] A;\n  output       P;\n  \n  assign P = A[0] ^ A[1] ^ A[2] ^ A[3] ^ A[4] ^ A[5] ^ A[6] ^ A[7];\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": "module cla4(\n    input  [3:0] A,\n    input  [3:0] B,\n    input        C_in,\n    output [3:0] S,\n    output       C_out\n);\n    wire [3:0] p, g;\n    wire       c1, c2, c3;\n\n    assign p = A ^ B;\n    assign g = A & B;\n\n    assign c1 = g[0] | (p[0] & C_in);\n    assign c2 = g[1] | (p[1] & g[0]) | (p[1] & p[0] & C_in);\n    assign c3 = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & C_in);\n    assign C_out = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & C_in);\n\n    assign S[0] = p[0] ^ C_in;\n    assign S[1] = p[1] ^ c1;\n    assign S[2] = p[2] ^ c2;\n    assign S[3] = p[3] ^ c3;\nendmodule\n\nmodule add_16bit(\n    input  [15:0] A,\n    input  [15:0] B,\n    output [15:0] S,\n    output        C_out\n);\n    wire c1, c2, c3;\n\n    cla4 cla0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .C_in(1'b0),\n        .S(S[3:0]),\n        .C_out(c1)\n    );\n\n    cla4 cla1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .C"}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0 (.a(a0), .b(b0), .sum(sum0));\n    adder_unit au1 (.a(a1), .b(b1), .sum(sum1));\n    adder_unit au2 (.a(a2), .b(b2), .sum(sum2));\n    adder_unit au3 (.a(a3), .b(b3), .sum(sum3));\nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n\n    multiplier mult0 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .prod(p0)\n    );\n    \n    multiplier mult1 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .prod(p1)\n    );\n    \n    multiplier mult2 (\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .prod(p2)\n    );\n    \n    multiplier mult3 (\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .prod(p3)\n    );\n\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] prod\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            prod <= 16'd0;\n        else\n            prod <= a * b;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module left_rotate(\n  input [3:0] data,\n  output [3:0] data_out\n);\n  assign data_out = {data[2:0], data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] data_out\n);\n  assign data_out = {data[0], data[3:1]};\nendmodule\n\nmodule cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n  wire [3:0] left_result;\n  wire [3:0] right_result;\n\n  left_rotate lr(\n    .data(in_data),\n    .data_out(left_result)\n  );\n\n  right_rotate rr(\n    .data(in_data),\n    .data_out(right_result)\n  );\n\n  assign out_data = en ? (rot_dir ? left_result : right_result) : in_data;\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 8'd1;\n      else\n        count <= count - 8'd1;\n    end\n  end\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": ""}
{"task_id": "systolic1x2_v_35", "response": "module shift_register(\n    input clk,\n    input rst,\n    input load,\n    input shift,\n    input [7:0] data,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 8'b0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= {1'b0, out[7:1]};\n        else\n            out <= out;\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .out(out0)\n    );\n\n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .out(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input  A,\n    input  B,\n    input  Cin,\n    output Sum,\n    output Cout\n);\n    assign Sum  = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] X,\n    input  [7:0] Y,\n    input        Cin,\n    output [7:0] Sum,\n    output       Cout\n);\n    wire [8:0] carry;\n    assign carry[0] = Cin;\n    \n    genvar i;\n    generate\n        for(i = 0; i < 8; i = i + 1) begin: full_adder_loop\n            full_adder fa (\n                .A(X[i]),\n                .B(Y[i]),\n                .Cin(carry[i]),\n                .Sum(Sum[i]),\n                .Cout(carry[i+1])\n            );\n        end\n    endgenerate\n    \n    assign Cout = carry[8];\nendmodule\n\nmodule adder_32bit(\n    input  [31:0] X,      // First 32-bit input operand\n    input  [31:0] Y,      // Second 32-bit input operand\n    output [31:0] Sum,    // 32-bit output sum\n    output        Carry_out // Carry output\n);\n    wire c0, c1, c2;\n    \n    adder_8bit u0 (\n        .X   (X[7:0]),\n        .Y   (Y[7:0]),\n        .Cin (1'b0),\n        .Sum (Sum[7:0]),\n        .Cout(c0)\n    );\n    \n    adder_8bit u1 (\n        .X   (X[15:8]),\n        .Y   (Y[15:8]),\n        .Cin (c0),\n        .Sum (Sum[15:8]),\n        .Cout(c1)\n    );\n    \n    adder_8bit u2 (\n        .X   (X[23:16]),\n        .Y   (Y[23:16]),\n        .Cin (c1),\n        .Sum (Sum[23:16]),\n        .Cout(c2)\n    );\n    \n    adder_8bit u3 (\n        .X   (X[31:24]),\n        .Y   (Y[31:24]),\n        .Cin (c2),\n        .Sum (Sum[31:24]),\n        .Cout(Carry_out)\n    );\n    \nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n    wire c1, c2, c3;\n    \n    adder_8bit add0(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n    \n    adder_8bit add1(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n    \n    adder_8bit add2(\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n    \n    adder_8bit add3(\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\n    \nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module adder_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\n    assign {carry_out, result} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result,\n    output        carry_out\n);\n    assign {carry_out, result} = A + (~B) + 1;\nendmodule\n\nmodule and_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule\n\nmodule alu_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input  [1:0]  op,\n    output [31:0] result,\n    output        carry_out\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire        add_carry;\n    wire        sub_carry;\n\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .result(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .result(sub_result),\n        .carry_out(sub_carry)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    assign result = (op == 2'b00) ? add_result :\n                    (op == 2'b01) ? sub_result :\n                    (op == 2'b10) ? and_result : 32'b0;\n\n    assign carry_out = (op == 2'b00) ? add_carry :\n                       (op == 2'b01) ? sub_carry : 1'b0;\n                       \nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux_path0(\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\nendmodule\n\nmodule mux_path1(\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\nendmodule\n\nmodule mux_path2(\n    input clk,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(posedge clk) begin\n        data_out <= data_in;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output reg [7:0] data_out\n);\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n    \n    mux_path0 u_mux0 (\n        .clk(clk),\n        .data_in(d0),\n        .data_out(mux0_out)\n    );\n    \n    mux_path1 u_mux1 (\n        .clk(clk),\n        .data_in(d1),\n        .data_out(mux1_out)\n    );\n    \n    mux_path2 u_mux2 (\n        .clk(clk),\n        .data_in(d2),\n        .data_out(mux2_out)\n    );\n    \n    always @(*) begin\n        case (sel)\n            3'b000: data_out = mux0_out;\n            3'b001: data_out = mux1_out;\n            3'b010: data_out = mux2_out;\n            default: data_out = 8'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] hold0_out;\n    wire [7:0] hold1_out;\n    wire [7:0] hold2_out;\n    wire [7:0] hold3_out;\n\n    hold0 u_hold0 (\n        .clk(clk),\n        .sel(sel),\n        .in(in0),\n        .out(hold0_out)\n    );\n\n    hold1 u_hold1 (\n        .clk(clk),\n        .sel(sel),\n        .in(in1),\n        .out(hold1_out)\n    );\n\n    hold2 u_hold2 (\n        .clk(clk),\n        .sel(sel),\n        .in(in2),\n        .out(hold2_out)\n    );\n\n    hold3 u_hold3 (\n        .clk(clk),\n        .sel(sel),\n        .in(in3),\n        .out(hold3_out)\n    );\n\n    assign out = (sel == 2'b00) ? hold0_out :\n                 (sel == 2'b01) ? hold1_out :\n                 (sel == 2'b10) ? hold2_out : hold3_out;\n\nendmodule\n\n\nmodule hold0 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'b00)\n            out <= in;\n    end\nendmodule\n\n\nmodule hold1 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'b01)\n            out <= in;\n    end\nendmodule\n\n\nmodule hold2 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'b10)\n            out <= in;\n    end\nendmodule\n\n\nmodule hold3 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if (sel == 2'b11)\n            out <= in;\n    end\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n    always @(posedge clk) begin\n        if (reset)\n            count <= 16'd0;\n        else if (count == (freq - 1))\n            count <= 16'd0;\n        else\n            count <= count + 16'd1;\n    end\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n    wire [15:0] threshold;\n    assign threshold = (freq * duty_cycle) / 100;\n    \n    always @(posedge clk) begin\n        if (count < threshold)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule\n\nmodule pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n    wire [15:0] count;\n    wire reset;\n    assign reset = 1'b0;\n    \n    pwm_counter pc_inst (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(count)\n    );\n    \n    pwm_signal ps_inst (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    wire [7:0] adjusted_duty;\n    \n    duty_ctrl u_duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n    \n    pulse_gen u_pulse_gen (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule\n\nmodule duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    reg [7:0] counter;\n    \n    always @(posedge clk) begin\n        if (counter == 8'hFF)\n            counter <= 8'h00;\n        else\n            counter <= counter + 1;\n    end\n    \n    assign pwm_out = (counter < duty_cycle) ? 1'b1 : 1'b0;\n    \nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": ""}
{"task_id": "shift8_v_45", "response": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] inter;\n\n    bit_reverse br1 (\n        .din(din),\n        .dout(inter)\n    );\n\n    bit_reverse br2 (\n        .din(inter),\n        .dout(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule"}
{"task_id": "shift8_v_46", "response": "module my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] add_result;\n\n    my_adder8 u_my_adder8 (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    always @(*) begin\n        if (ctrl)\n            sum = add_result;\n        else\n            sum = 8'b0;\n    end\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_module_25 u_pwm25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_25)\n    );\n\n    pwm_module_50 u_pwm50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_50)\n    );\n\n    pwm_module_75 u_pwm75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_75)\n    );\nendmodule\n\nmodule pwm_module_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM\n);\n    reg [7:0] counter;\n    parameter THRESHOLD = 8'd64; // 25% of 256\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            PWM <= 1'b0;\n        end else begin\n            if (counter == 8'd255)\n                counter <= 8'd0;\n            else\n                counter <= counter + 1;\n            PWM <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_module_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM\n);\n    reg [7:0] counter;\n    parameter THRESHOLD = 8'd128; // 50% of 256\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            PWM <= 1'b0;\n        end else begin\n            if (counter == 8'd255)\n                counter <= 8'd0;\n            else\n                counter <= counter + 1;\n            PWM <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule\n\nmodule pwm_module_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM\n);\n    reg [7:0] counter;\n    parameter THRESHOLD = 8'd192; // 75% of 256\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 8'd0;\n            PWM <= 1'b0;\n        end else begin\n            if (counter == 8'd255)\n                counter <= 8'd0;\n            else\n                counter <= counter + 1;\n            PWM <= (counter < THRESHOLD) ? 1'b1 : 1'b0;\n        end\n    end\nendmodule"}
{"task_id": "freq_div_v_48", "response": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n  wire pwm25;\n  wire pwm50;\n  wire pwm75;\n  \n  pwm_duty_25 u_pwm_duty_25 (\n    .CLK(CLK_in),\n    .RST(RST),\n    .PWM(pwm25)\n  );\n  \n  pwm_duty_50 u_pwm_duty_50 (\n    .CLK(CLK_in),\n    .RST(RST),\n    .PWM(pwm50)\n  );\n  \n  pwm_duty_75 u_pwm_duty_75 (\n    .CLK(CLK_in),\n    .RST(RST),\n    .PWM(pwm75)\n  );\n  \n  assign PWM_25 = pwm25;\n  assign PWM_50 = pwm50;\n  assign PWM_75 = pwm75;\n  \nendmodule\n\nmodule pwm_duty_25 (\n    input CLK,\n    input RST,\n    output reg PWM\n);\n  parameter PERIOD = 100;\n  localparam THRESHOLD = (PERIOD * 25) / 100;\n  reg [6:0] counter;\n  \n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      counter <= 0;\n      PWM <= 0;\n    end else begin\n      if (counter == PERIOD - 1)\n        counter <= 0;\n      else\n        counter <= counter + 1;\n        \n      if (counter < THRESHOLD)\n        PWM <= 1;\n      else\n        PWM <= 0;\n    end\n  end\nendmodule\n\nmodule pwm_duty_50 (\n    input CLK,\n    input RST,\n    output reg PWM\n);\n  parameter PERIOD = 100;\n  localparam THRESHOLD = (PERIOD * 50) / 100;\n  reg [6:0] counter;\n  \n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      counter <= 0;\n      PWM <= 0;\n    end else begin\n      if (counter == PERIOD - 1)\n        counter <= 0;\n      else\n        counter <= counter + 1;\n        \n      if (counter < THRESHOLD)\n        PWM <= 1;\n      else\n        PWM <= 0;\n    end\n  end\nendmodule\n\nmodule pwm_duty_75 (\n    input CLK,\n    input RST,\n    output reg PWM\n);\n  parameter PERIOD = 100;\n  localparam THRESHOLD = (PERIOD * 75) / 100;\n  reg [6:0] counter;\n  \n  always @(posedge CLK or posedge RST) begin\n    if (RST) begin\n      counter <= 0;\n      PWM <= 0;\n    end else begin\n      if (counter == PERIOD - 1)\n        counter <= 0;\n      else\n        counter <= counter + 1;\n        \n      if (counter < THRESHOLD)\n        PWM <= 1;\n      else\n        PWM <= 0;\n    end\n  end\nendmodule"}
{"task_id": "freq_divbyodd_v_49", "response": ""}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n    wire [63:0] signed_result;\n    wire [63:0] unsigned_result;\n    \n    mult_signed u_mult_signed (\n        .a(a),\n        .b(b),\n        .y(signed_result)\n    );\n    \n    mult_unsigned u_mult_unsigned (\n        .a(a),\n        .b(b),\n        .y(unsigned_result)\n    );\n    \n    wire [63:0] product;\n    assign product = (multc) ? unsigned_result : signed_result;\n    \n    assign y = product;\n    assign msb = product[63:32];\n    assign lsb = product[31:0];\n    assign zero = (product == 64'b0);\n    \nendmodule\n\nmodule mult_signed(\n    input signed [31:0] a,\n    input signed [31:0] b,\n    output signed [63:0] y\n);\n    assign y = a * b;\nendmodule\n\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] y\n);\n    assign y = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n    output      [3:0]   count_out,\n    output              overflow\n);\n    wire [3:0] internal_count;\n    \n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(internal_count)\n    );\n    \n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .count(internal_count),\n        .overflow(overflow)\n    );\n    \n    assign count_out = internal_count;\nendmodule\n\nmodule count_control (\n    input         clk,\n    input         rst,\n    input         en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'b0000;\n        else if (en)\n            count <= count + 1'b1;\n    end\nendmodule\n\nmodule overflow_detection (\n    input         clk,\n    input         rst,\n    input  [3:0]  count,\n    output reg    overflow\n);\n    reg [3:0] prev_count;\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'b0000;\n            overflow   <= 1'b0;\n        end else begin\n            if ((prev_count == 4'b1111) && (count == 4'b0000))\n                overflow <= 1'b1;\n            else\n                overflow <= 1'b0;\n            prev_count <= count;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module add(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] out\n);\n    assign out = operand_a + operand_b;\nendmodule\n\nmodule subtract(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] out\n);\n    assign out = operand_a - operand_b;\nendmodule\n\nmodule bitwise_and(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] out\n);\n    assign out = operand_a & operand_b;\nendmodule\n\nmodule bitwise_or(\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output [31:0] out\n);\n    assign out = operand_a | operand_b;\nendmodule\n\nmodule simple_alu(\n    input         clk,\n    input         rst,\n    input  [1:0]  op_code,\n    input  [31:0] operand_a,\n    input  [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    add u_add (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .out(add_result)\n    );\n\n    subtract u_subtract (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .out(sub_result)\n    );\n\n    bitwise_and u_bitwise_and (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .out(and_result)\n    );\n\n    bitwise_or u_bitwise_or (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .out(or_result)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else begin\n            case(op_code)\n                2'b00: result <= add_result;\n                2'b01: result <= sub_result;\n                2'b10: result <= and_result;\n                2'b11: result <= or_result;\n                default: result <= 32'b0;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": "module comparator_4bit(a, b, eq, gt, lt);\n  input [3:0] a, b;\n  output eq, gt, lt;\n\n  assign eq = (a == b);\n  assign gt = (a > b);\n  assign lt = (a < b);\nendmodule\n\nmodule comparator_16bit(a, b, eq, gt, lt);\n  input  [15:0] a, b;\n  output        eq, gt, lt;\n  \n  wire eq_slice1, eq_slice2, eq_slice3, eq_slice4;\n  wire gt_slice1, gt_slice2, gt_slice3, gt_slice4;\n  wire lt_slice1, lt_slice2, lt_slice3, lt_slice4;\n  \n  comparator_4bit comp_slice1 (\n    .a(a[15:12]),\n    .b(b[15:12]),\n    .eq(eq_slice1),\n    .gt(gt_slice1),\n    .lt(lt_slice1)\n  );\n  \n  comparator_4bit comp_slice2 (\n    .a(a[11:8]),\n    .b(b[11:8]),\n    .eq(eq_slice2),\n    .gt(gt_slice2),\n    .lt(lt_slice2)\n  );\n  \n  comparator_4bit comp_slice3 (\n    .a(a[7:4]),\n    .b(b[7:4]),\n    .eq(eq_slice3),\n    .gt(gt_slice3),\n    .lt(lt_slice3)\n  );\n  \n  comparator_4bit comp_slice4 (\n    .a(a[3:0]),\n    .b(b[3:0]),\n    .eq(eq_slice4),\n    .gt(gt_slice4),\n    .lt(lt_slice4)\n  );\n  \n  assign eq = eq_slice1 & eq_slice2 & eq_slice3 & eq_slice4;\n  \n  assign gt = gt_slice1 |\n              (eq_slice1 & gt_slice2) |\n              (eq_slice1 & eq_slice2 & gt_slice3) |\n              (eq_slice1 & eq_slice"}
{"task_id": "adder_32bit_v_54", "response": ""}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\n    my_tff tff0 (\n        .clk(clk),\n        .reset(reset),\n        .t(1'b1),\n        .q(count[0])\n    );\n\n    my_tff tff1 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0]),\n        .q(count[1])\n    );\n\n    my_tff tff2 (\n        .clk(clk),\n        .reset(reset),\n        .t(count[0] & count[1]),\n        .q(count[2])\n    );\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module counter_init(\n    output [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule counter_increment(\n    input  [3:0] in,\n    output [3:0] out\n);\n    assign out = in + 1;\nendmodule\n\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n    reg  [3:0] count;\n\n    counter_init init_inst (\n        .init_val(init_val)\n    );\n\n    counter_increment inc_inst (\n        .in(count),\n        .out(inc_val)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n\n    assign out = count;\nendmodule"}
{"task_id": "up_down_counter", "response": ""}
{"task_id": "ring_counter", "response": "module ring_counter_init (\n    input  wire reset,\n    output wire [7:0] init_out\n);\n    assign init_out = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition (\n    input  wire [7:0] state,\n    output wire [7:0] next_state\n);\n    assign next_state = (state == 8'b10000000) ? 8'b00000001 : (state << 1);\nendmodule\n\nmodule ring_counter (\n    input  wire clk,\n    input  wire reset,\n    output wire [7:0] out\n);\n    wire [7:0] init_val;\n    wire [7:0] next_val;\n    reg  [7:0] state;\n    \n    ring_counter_init init_inst (\n        .reset(reset),\n        .init_out(init_val)\n    );\n    \n    ring_counter_transition transition_inst (\n        .state(state),\n        .next_state(next_val)\n    );\n    \n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            state <= init_val;\n        else\n            state <= next_val;\n    end\n    \n    assign out = state;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_wire;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count_wire)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .data_in(count_wire),\n        .out(out)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 4'b0001;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] data_in,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= data_in;\n    end\nendmodule"}
{"task_id": "JC_counter", "response": ""}
{"task_id": "freq_div", "response": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n    wire clk_div2_out;\n    wire clk_div10_out;\n    wire clk_div100_out;\n    \n    clk_div_2 u_clk_div_2 (\n        .CLK"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd #(\n    parameter NUM_DIV = 5\n)(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n\nwire clk_div1;\nwire clk_div2;\n\npos_edge_counter #(\n    .NUM_DIV(NUM_DIV)\n) u_pos_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div1)\n);\n\nneg_edge_counter #(\n    .NUM_DIV(NUM_DIV)\n) u_neg_counter (\n    .clk(clk),\n    .rst_n(rst_n),\n    .clk_div(clk_div2)\n);\n\nassign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\n\nmodule pos_edge_counter #(\n    parameter NUM_DIV = 5,\n    parameter CNT_WIDTH = $clog2(NUM_DIV)\n)(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nreg [CNT_WIDTH-1:0] counter;\n\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n        clk_div <= 0;\n    end else if (counter == NUM_DIV - 1) begin\n        counter <= 0;\n        clk_div <= ~clk_div;\n    end else begin\n        counter <= counter + 1;\n    end\nend\n\nendmodule\n\n\nmodule neg_edge_counter #(\n    parameter NUM_DIV = 5,\n    parameter CNT_WIDTH = $clog2(NUM_DIV)\n)(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n\nreg [CNT_WIDTH-1:0] counter;\n\nalways @(negedge clk or negedge rst_n) begin\n    if (!rst_n) begin\n        counter <= 0;\n"}
{"task_id": "freq_divbyeven", "response": ""}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier (\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\nmodule accumulator (\n    input clk,\n    input rst,\n    input [31:0] in,\n    output reg [31:0] acc\n);\n    always @(posedge clk) begin\n        if (rst)\n            acc <= 32'd0;\n        else\n            acc <= acc + in;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mul_result;\n    \n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .result(mul_result)\n    );\n    \n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .in(mul_result[31:0]),\n        .acc(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": ""}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n  wire [7:0] count;\n  wire enable;\n\n  assign enable = 1'b1;\n\n  counter u_counter (\n    .clk(clk),\n    .enable(enable),\n    .freq(freq),\n    .count(count)\n  );\n\n  wave_generator u_wave_generator (\n    .clk(clk),\n    .count(count),\n    .freq(freq),\n    .wave_out(wave_out)\n  );\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n  always @(posedge clk) begin\n    if (enable) begin\n      if (count >= (freq - 1))\n        count <= 8'd0;\n      else\n        count <= count + 1;\n    end\n  end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n  always @(posedge clk) begin\n    if (count == (freq - 1))\n      wave_out <= ~wave_out;\n  end\n\nendmodule"}
{"task_id": "signal_generator", "response": ""}
{"task_id": "shift8", "response": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n\nwire [7:0] q0;\nwire [7:0] q1;\nwire [7:0] q2;\n\nmy_dff8 u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff8 u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff8 u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q2)\n);\n\nalways @(*) begin\n    case(sel)\n        2'b00: q = d;\n        2'b01: q = q0;\n        2'b10: q = q1;\n        2'b11: q = q2;\n        default: q = d;\n    endcase\nend\n\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\nwire q0, q1;\n\nmy_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q)\n);\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n  \n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  \n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  \n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      b1 <= 16'd0;\n    else\n      b1 <= b0;\n  end\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe (\n  input        clk,\n  input        rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  wire [31:0] prod;\n  assign prod = a * b;\n  \n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'd0;\n    else\n      c <= c + prod;\n  end\nendmodule\n\nmodule systolic1x4(\n  input         clk,\n  input         rst,\n  input  [15:0] a0,\n  input  [15:0] a1,\n  input  [15:0] a2,\n  input  [15:0] a3,\n  input  [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\n  reg [15:0] b_reg1, b_reg2, b_reg3;\n\n  always @(posedge clk) begin\n    if (rst) begin\n      b_reg1 <= 16'd0;\n      b_reg2 <= 16'd0;\n      b_reg3 <= 16'd0;\n    end else begin\n      b_reg1 <= b0;\n      b_reg2 <= b_reg1;\n      b_reg3 <= b_reg2;\n    end\n  end\n\n  pe pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b_reg1),\n    .c(c1)\n  );\n\n  pe pe2 (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b_reg2),\n    .c(c2)\n  );\n\n  pe pe3 (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b_reg3),\n    .c(c3)\n  );\n  \nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module prep_dividend(\n    input  [31:0] A,\n    input  [15:0] B,\n    output [31:0] prep_A,\n    output [31:0] prep_B\n);\n    assign prep_A = A;\n    assign prep_B = {16'd0, B};\nendmodule\n\nmodule div_operation(\n    input  [31:0] dividend,\n    input  [31:0] divisor,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n    integer i;\n    reg [32:0] rem;\n    always @(*) begin\n        rem = 33'd0;\n"}
{"task_id": "div_16bit", "response": ""}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [6:0] carry;\n\n    full_adder FA0 (.a(A[0]), .b(B[0]), .cin(Cin),    .sum(Sum[0]), .cout(carry[0]));\n    full_adder FA1 (.a(A[1]), .b(B[1]), .cin(carry[0]), .sum(Sum[1]), .cout(carry[1]));\n    full_adder FA2 (.a(A[2]), .b(B[2]), .cin(carry[1]), .sum(Sum[2]), .cout(carry[2]));\n    full_adder FA3 (.a(A[3]), .b(B[3]), .cin(carry[2]), .sum(Sum[3]), .cout(carry[3]));\n    full_adder FA4 (.a(A[4]), .b(B[4]), .cin(carry[3]), .sum(Sum[4]), .cout(carry[4]));\n    full_adder FA5 (.a(A[5]), .b(B[5]), .cin(carry[4]), .sum(Sum[5]), .cout(carry[5]));\n    full_adder FA6 (.a(A[6]), .b(B[6]), .cin(carry[5]), .sum(Sum[6]), .cout(carry[6]));\n    full_adder FA7 (.a(A[7]), .b(B[7]), .cin(carry[6]), .sum(Sum[7]), .cout(Cout));\nendmodule\n\nmodule sub_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n    wire Cout;\n\n    adder_8bit adder_inst (\n        .A(A),\n        .B(~B),\n        .Cin(1'b1),\n        .Sum(D),\n        .Cout(Cout)\n    );\n\n    assign B_out = ~Cout;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_16bit(A, B, bin, Diff, bout);\n  input [15:0] A, B;\n  input bin;\n  output [15:0] Diff;\n  output bout;\n  \n  wire [16:0] tmp;\n  \n  assign tmp = {1'b0, A} - {1'b0, B} - bin;\n  assign Diff = tmp[15:0];\n  assign bout = tmp[16];\nendmodule\n\nmodule sub_32bit(A, B, Diff, B_out);\n  input [31:0] A, B;\n  output [31:0] Diff;\n  output B_out;\n  \n  wire borrow;\n  \n  sub_16bit s1 (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .bin(1'b0),\n    .Diff(Diff[15:0]),\n    .bout(borrow)\n  );\n  \n  sub_16bit s2 (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .bin(borrow),\n    .Diff(Diff[31:16]),\n    .bout(B_out)\n  );\nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_64bit(A, B, D, B_out);\n    input  [63:0] A;\n    input  [63:0] B;\n    output [63:0] D;\n    output        B_out;\n\n    wire b0;\n\n    sub_32bit u_sub32_low (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .bin(1'b0),\n        .D(D[31:0]),\n        .bout(b0)\n    );\n\n    sub_32bit u_sub32_high (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .bin(b0),\n        .D(D[63:32]),\n        .bout(B_out"}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    assign diff  = A - B;\n    assign borrow = (A < B);\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,   // First 32-bit input operand\n    input  [31:0] B,   // Second 32-bit input operand\n    output        A_greater,\n    output        A_equal,\n    output        A_less\n);\n    wire [31:0] diff;\n    wire        borrow;\n    \n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n    \n    assign A_less    = borrow;\n    assign A_equal   = ~borrow & (diff == 32'b0);\n    assign A_greater = ~borrow & (diff != 32'b0);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module ripple_carry_adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule\n\nmodule csa_slice(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       cout0, cout1;\n\n    ripple_carry_adder_4bit rca0 (\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        .sum(sum0),\n        .cout(cout0)\n    );\n\n    ripple_carry_adder_4bit rca1 (\n        .a(a),\n        .b(b),\n        .cin(1'b1),\n        .sum(sum1),\n        .cout(cout1)\n    );\n\n    assign sum  = cin ? sum1 : sum0;\n    assign cout = cin ? cout1 : cout0;\nendmodule\n\nmodule adder_16bit_csa(\n    input  [15:0] a,\n    input  [15:0] b,\n    input         cin,\n    output [15:0] sum,\n    output        cout\n);\n    wire c4, c8, c12;\n\n    ripple_carry_adder_4bit u0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(c4)\n    );\n\n    csa_slice u1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(c4),\n        .sum(sum[7:4]),\n        .cout(c8)\n    );\n\n    csa_slice u2 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .cin(c8),\n        .sum(sum[11:8]),\n        .cout(c12)\n    );\n\n    csa_slice u3 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .cin(c12),\n        .sum(sum[15:12]),\n        .cout(cout)\n    );\nendmodule"}
{"task_id": "adder_16bit", "response": "module adder_8bit (\n    input  wire [7:0] a,\n    input  wire [7:0] b,\n    input  wire       Cin,\n    output wire [7:0] y,\n    output wire       Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input  wire [15:0] a,\n    input  wire [15:0] b,\n    input  wire       Cin,\n    output wire [15:0] y,\n    output wire       Co\n);\n    wire carry;\n\n    adder_8bit add8_inst1 (\n        .a   (a[7:0]),\n        .b   (b[7:0]),\n        .Cin (Cin),\n        .y   (y[7:0]),\n        .Co  (carry)\n    );\n\n    adder_8bit add8_inst2 (\n        .a   (a[15:8]),\n        .b   (b[15:8]),\n        .Cin (carry),\n        .y   (y[15:8]),\n        .Co  (Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n    wire c0, c1, c2, c3, c4, c5, c6;\n    \n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c0),  .sum(sum[1]), .cout(c1));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c1),  .sum(sum[2]), .cout(c2));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c2),  .sum(sum[3]), .cout(c3));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c3),  .sum(sum[4]), .cout(c4));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c4),  .sum(sum[5]), .cout(c5));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c5),  .sum(sum[6]), .cout(c6));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c6),  .sum(sum[7]), .cout(cout));\nendmodule"}
{"task_id": "multi_16bit", "response": ""}
{"task_id": "pe_v_0", "response": "module as_module(\n    input         clk,\n    input         rst,\n    input         mode,\n    input  [31:0] op1,\n    input  [31:0] op2,\n    output reg [31:0] result\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    \n    u_adder u_adder_inst (\n        .a(op1),\n        .b(op2),\n        .sum(add_result)\n    );\n    \n    u_subtractor u_subtractor_inst (\n        .a(op1),\n        .b(op2),\n        .diff(sub_result)\n    );\n    \n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else\n            result <= (mode) ? sub_result : add_result;\n    end\nendmodule\n\nmodule u_adder(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input  [31:0] a,\n    input  [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule"}
{"task_id": "pe_v_1", "response": "module u_divider(\n    input clk,\n    input rst,\n    input [31:0] dividend,\n    input [31:0] divisor,\n    output reg [31:0] quotient\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            quotient <= 32'd0;\n        else\n            quotient <= dividend / divisor;\n    end\nendmodule\n\nmodule u_subtractor(\n    input clk,\n    input rst,\n    input [31:0] minuend,\n    input [31:0] subtrahend,\n    output reg [31:0] difference\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            difference <= 32'd0;\n        else\n            difference <= minuend - subtrahend;\n    end\nendmodule\n\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n    wire [31:0] div_quotient;\n\n    u_divider divider_inst (\n        .clk(clk),\n        .rst(rst),\n        .dividend(x),\n        .divisor(y),\n        .quotient(div_quotient)\n    );\n\n    u_subtractor subtractor_inst (\n        .clk(clk),\n        .rst(rst),\n        .minuend(div_quotient),\n        .subtrahend(z),\n        .difference(difference)\n    );\n\n    assign quotient = div_quotient;\nendmodule"}
{"task_id": "pe_v_2", "response": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    u_adder uAdder (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    u_subtractor uSubtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n\n    u_and uAnd (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n\n    u_or uOr (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n\n    always @(posedge clk) begin\n        case(op_sel)\n            2'b00: result <= add_result;\n            2'b01: result <= sub_result;\n            2'b10: result <= and_result;\n            2'b11: result <= or_result;\n            default: result <= 32'b0;\n        endcase\n    end\n\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule u_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule u_or(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "pe_v_3", "response": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] and_result;\n\nu_adder u_adder_inst (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\nu_bitwise_and u_bitwise_and_inst (\n    .a(a),\n    .b(b),\n    .out(and_result)\n);\n\nalways @(posedge clk) begin\n    if (op_sel == 1'b0)\n        result <= add_result;\n    else\n        result <= and_result;\nend\n\nendmodule\n\nmodule u_adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\nassign sum = a + b;\n\nendmodule\n\nmodule u_bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n\nassign out = a & b;\n\nendmodule"}
{"task_id": "pe_v_4", "response": "module u_adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule u_subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    wire [15:0] adder_result;\n    wire [15:0] subtractor_result;\n\n    u_adder u_adder_inst (\n        .a(a),\n        .b(b),\n        .result(adder_result)\n    );\n\n    u_subtractor u_subtractor_inst (\n        .a(a),\n        .b(b),\n        .result(subtractor_result)\n    );\n\n    always @(posedge clk) begin\n        if (rst)\n            result <= 16'b0;\n        else\n            result <= (mode == 1'b0) ? adder_result : subtractor_result;\n    end\nendmodule"}
{"task_id": "adder_8bit_v_5", "response": ""}
{"task_id": "adder_8bit_v_6", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & b) | ((~a | b) & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout\n);\n    wire borrow0, borrow1, borrow2, borrow3, borrow4, borrow5, borrow6;\n\n    full_subtractor FS0 (\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow0)\n    );\n    \n    full_subtractor FS1 (\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow0),\n        .diff(diff[1]),\n        .bout(borrow1)\n    );\n    \n    full_subtractor FS2 (\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow1),\n        .diff(diff[2]),\n        .bout(borrow2)\n    );\n    \n    full_subtractor FS3 (\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow2),\n        .diff(diff[3]),\n        .bout(borrow3)\n    );\n    \n    full_subtractor FS4 (\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow3),\n        .diff(diff[4]),\n        .bout(borrow4)\n    );\n    \n    full_subtractor FS5 (\n        .a(a[5]),\n        .b(b[5]),\n        .bin(borrow4),\n        .diff(diff[5]),\n        .bout(borrow5)\n    );\n    \n    full_subtractor FS6 (\n        .a(a[6]),\n        .b(b[6]),\n        .bin(borrow5),\n        .diff(diff[6]),\n        .bout(borrow6)\n    );\n    \n    full_subtractor FS7 (\n        .a(a[7]),\n        .b(b[7]),\n        .bin(borrow6),\n        .diff(diff[7]),\n        .bout(bout)\n    );\nendmodule"}
{"task_id": "adder_8bit_v_7", "response": "module subtractor_1bit(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a,\n    input  [7:0] b,\n    input       bin,\n    output [7:0] diff,\n    output      bout\n);\n    wire [6:0] borrow;\n\n    subtractor_1bit s0(\n        .a(a[0]),\n        .b(b[0]),\n        .bin(bin),\n        .diff(diff[0]),\n        .bout(borrow[0])\n    );\n\n    subtractor_1bit s1(\n        .a(a[1]),\n        .b(b[1]),\n        .bin(borrow[0]),\n        .diff(diff[1]),\n        .bout(borrow[1])\n    );\n\n    subtractor_1bit s2(\n        .a(a[2]),\n        .b(b[2]),\n        .bin(borrow[1]),\n        .diff(diff[2]),\n        .bout(borrow[2])\n    );\n\n    subtractor_1bit s3(\n        .a(a[3]),\n        .b(b[3]),\n        .bin(borrow[2]),\n        .diff(diff[3]),\n        .bout(borrow[3])\n    );\n\n    subtractor_1bit s4(\n        .a(a[4]),\n        .b(b[4]),\n        .bin(borrow[3]),\n        .diff(diff[4]),\n        .bout(borrow[4])\n    );\n\n    subtractor_1bit s5(\n        .a(a[5]),\n        .b(b[5]),\n        .bin(borrow[4]),\n        .diff(diff[5]),\n        .bout(borrow[5])\n    );\n\n    subtractor_1bit s6(\n        .a(a[6]),\n        .b(b[6]),\n        .bin(borrow[5]),\n        .diff(diff[6]),\n        .bout(borrow[6])\n    );\n\n    subtractor_1bit s7(\n        .a(a[7]),\n        .b(b[7]),\n        .bin(borrow[6]),\n        .diff(diff[7]),\n        .bout(bout)\n    );\nendmodule"}
{"task_id": "adder_8bit_v_8", "response": "module full_subtractor(\n    input a,\n    input b,\n    input bin,\n    output diff,\n    output bout\n);\n    assign diff = a ^ b ^ bin;\n    assign bout = (~a & (b | bin)) | (b & bin);\nendmodule\n\nmodule subtractor_8bit(\n    input  [7:0] a, b,\n    input        bin,\n    output [7:0] diff,\n    output       bout\n);\n    wire borrow0, borrow1, borrow2, borrow3, borrow4, borrow5, borrow6;\n    \n    full_subtractor FS0 ( .a(a[0]), .b(b[0]), .bin(bin),    .diff(diff[0]), .bout(borrow0) );\n    full_subtractor FS1 ( .a(a[1]), .b(b[1]), .bin(borrow0), .diff(diff[1]), .bout(borrow1) );\n    full_subtractor FS2 ( .a(a[2]), .b(b[2]), .bin(borrow1), .diff(diff[2]), .bout(borrow2) );\n    full_subtractor FS3 ( .a(a[3]), .b(b[3]), .bin(borrow2), .diff(diff[3]), .bout(borrow3) );\n    full_subtractor FS4 ( .a(a[4]), .b(b[4]), .bin(borrow3), .diff(diff[4]), .bout(borrow4) );\n    full_subtractor FS5 ( .a(a[5]), .b(b[5]), .bin(borrow4), .diff(diff[5]), .bout(borrow5) );\n    full_subtractor FS6 ( .a(a[6]), .b(b[6]), .bin(borrow5), .diff(diff[6]), .bout(borrow6) );\n    full_subtractor FS7 ( .a(a[7]), .b(b[7]), .bin(borrow6), .diff(diff[7]), .bout(bout) );\n    \nendmodule"}
{"task_id": "adder_8bit_v_9", "response": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product\n);\n\nwire [7:0] part0, part1, part2, part3;\n\nassign part0 = b[0] ? {4'b0000, a}       : 8'b0;\nassign part1 = b[1] ? {3'b000,  a, 1'b0}   : 8'b0;\nassign part2 = b[2] ? {2'b00,   a, 2'b00}   : 8'b0;\nassign part3 = b[3] ? {1'b0,    a, 3'b000}   : 8'b0;\n\nassign product = part0 + part1 + part2 + part3;\n\nendmodule"}
{"task_id": "up_down_counter_v_10", "response": ""}
{"task_id": "up_down_counter_v_11", "response": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] add_out;\n    wire [31:0] sub_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(add_out)\n    );\n\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .diff(sub_out)\n    );\n\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_out(and_out)\n    );\n\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_out(or_out)\n    );\n\n    assign result = (op_code == 2'b00) ? add_out :\n                    (op_code == 2'b01) ? sub_out :\n                    (op_code == 2'b10) ? and_out : or_out;\n\n    assign zero = (result == 32'b0) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule"}
{"task_id": "up_down_counter_v_12", "response": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n    wire [31:0] xor_result;\n\n    adder u_adder (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .sum(add_result)\n    );\n\n    subtractor u_subtractor (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .diff(sub_result)\n    );\n\n    and_bit u_and_bit (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .and_out(and_result)\n    );\n\n    or_bit u_or_bit (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .or_out(or_result)\n    );\n\n    xor_bit u_xor_bit (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .xor_out(xor_result)\n    );\n\n    assign result = (op_code == 3'b000) ? add_result :\n                    (op_code == 3'b001) ? sub_result :\n                    (op_code == 3'b010) ? and_result :\n                    (op_code == 3'b011) ? or_result  :\n                    (op_code == 3'b100) ? xor_result : 32'b0;\n\n    assign zero = (result == 32'b0);\nendmodule\n\nmodule adder (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] sum\n);\n    assign sum = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] diff\n);\n    assign diff = operand_a - operand_b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] and_out\n);\n    assign and_out = operand_a & operand_b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] or_out\n);\n    assign or_out = operand_a | operand_b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] xor_out\n);\n    assign xor_out = operand_a ^ operand_b;\nendmodule"}
{"task_id": "up_down_counter_v_13", "response": ""}
{"task_id": "sub_8bit_v_14", "response": "module gen_product #(parameter SHIFT = 0) (\n    input  [7:0] x,\n    input        y,\n    output [15:0] pp\n);\n    assign pp = y ? ({8'b0, x} << SHIFT) : 16'd0;\nendmodule\n\nmodule mult_8bit (\n    input  [7:0] X,\n    input  [7:0] Y,\n    output [15:0] P\n);\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;\n    \n    gen_product #(.SHIFT(0)) gp0 (.x(X), .y(Y[0]), .pp(pp0));\n    gen_product #(.SHIFT(1)) gp1 (.x(X), .y(Y[1]), .pp(pp1));\n    gen_product #(.SHIFT(2)) gp2 (.x(X), .y(Y[2]), .pp(pp2));\n    gen_product #(.SHIFT(3)) gp3 (.x(X), .y(Y[3]), .pp(pp3));\n    gen_product #(.SHIFT(4)) gp4 (.x(X), .y(Y[4]), .pp(pp4));\n    gen_product #(.SHIFT(5)) gp5 (.x(X), .y(Y[5]), .pp(pp5));\n    gen_product #(.SHIFT(6)) gp6 (.x(X), .y(Y[6]), .pp(pp6));\n    gen_product #(.SHIFT(7)) gp7 (.x(X), .y(Y[7]), .pp(pp7));\n    \n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n    \nendmodule"}
{"task_id": "sub_8bit_v_15", "response": "module mult_8bit(X, Y, P);\n  input  [7:0] X;\n  input  [7:0] Y;\n  output [15:0] P;\n  \n  wire [15:0] accum0, accum1, accum2, accum3, accum4, accum5, accum6, accum7, accum8;\n  \n  assign accum0 = 16'd0;\n  \n  add_shift #(0) AS0 (.X(X), .Y_bit(Y[0]), .accumulator_in(accum0), .accumulator_out(accum1));\n  add_shift #(1) AS1 (.X(X), .Y_bit(Y[1]), .accumulator_in(accum1), .accumulator_out(accum2));\n  add_shift #(2) AS2 (.X(X), .Y_bit(Y[2]), .accumulator_in(accum2), .accumulator_out(accum3));\n  add_shift #(3) AS3 (.X(X), .Y_bit(Y[3]), .accumulator_in(accum3), .accumulator_out(accum4));\n  add_shift #(4) AS4 (.X(X), .Y_bit(Y[4]), .accumulator_in(accum4), .accumulator_out(accum5));\n  add_shift #(5) AS5 (.X(X), .Y_bit(Y[5]), .accumulator_in(accum5), .accumulator_out(accum6));\n  add_shift #(6) AS6 (.X(X), .Y_bit(Y[6]), .accumulator_in(accum6), .accumulator_out(accum7));\n  add_shift #(7) AS7 (.X(X), .Y_bit(Y[7]), .accumulator_in(accum7), .accumulator_out(accum8));\n  \n  assign P = accum8;\n  \nendmodule\n\nmodule add_shift #(parameter SHIFT = 0)\n(\n  input  [7:0] X,\n  input        Y_bit,\n  input  [15:0] accumulator_in,\n  output [15:0] accumulator_out\n);\n  \n  wire [15:0] shifted_X;\n  assign shifted_X = {8'd0, X} << SHIFT;\n  assign accumulator_out = accumulator_in + (Y_bit ? shifted_X : 16'd0);\n  \nendmodule"}
{"task_id": "sub_8bit_v_16", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign"}
{"task_id": "sub_8bit_v_17", "response": ""}
{"task_id": "stagepipe3_v_18", "response": "module simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\n    wire [3:0] add_out;\n    wire [3:0] sub_out;\n    wire [3:0] and_out;\n    wire [3:0] or_out;\n\n    adder4bit u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_out)\n    );\n\n    subtractor4bit u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(sub_out)\n    );\n\n    and4bit u_and (\n        .a(operand_a),\n        .b(operand_b),\n        .out(and_out)\n    );\n\n    or4bit u_or (\n        .a(operand_a),\n        .b(operand_b),\n        .out(or_out)\n    );\n\n    always @(posedge clk) begin\n        case (op_code)\n            2'b00: result <= add_out;\n            2'b01: result <= sub_out;\n            2'b10: result <= and_out;\n            2'b11: result <= or_out;\n            default: result <= 4'b0;\n        endcase\n    end\nendmodule\n\nmodule adder4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or4bit(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "stagepipe3_v_19", "response": "module adder(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\n\n    wire [3:0] add_result;\n    wire [3:0] sub_result;\n    wire [3:0] and_result;\n    wire [3:0] or_result;\n\n    adder u_adder(\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    subtractor u_subtractor(\n        .a(a),\n        .b(b),\n        .diff(sub_result)\n    );\n\n    and_module u_and(\n        .a(a),\n        .b(b),\n        .and_result(and_result)\n    );\n\n    or_module u_or(\n        .a(a),\n        .b(b),\n        .or_result(or_result)\n    );\n\n    always @(*) begin\n        case(op)\n            2'b00: result = add_result;\n            2'b01: result = sub_result;\n            2'b10: result = and_result;\n            2'b11: result = or_result;\n            default: result = 4'b0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": "stagepipe3_v_20", "response": ""}
{"task_id": "stagepipe3_v_21", "response": "module add_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule sub_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] diff\n);\n    assign diff = {8'b0, a} - {8'b0, b};\nendmodule\n\nmodule mul_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [15:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule div_module(\n    input  [7:0] a,\n    input  [7:0] b,\n    output reg [15:0] quotient,\n    output reg valid\n);\n    always @(*) begin\n        if (b == 8'b0) begin\n            quotient = 16'b0;\n            valid    = 1'b0;\n        end else begin\n            quotient = a / b;\n            valid    = 1'b1;\n        end\n    end\nendmodule\n\nmodule arithmetic_unit(\n    input         clk,\n    input         rst,\n    input  [1:0]  opcode,\n    input  [7:0]  data_a,\n    input  [7:0]  data_b,\n    output reg [15:0] result,\n    output reg    valid\n);\n\n    wire [15:0] add_out;\n    wire [15:0] sub_out;\n    wire [15:0] mul_out;\n    wire [15:0] div_out;\n    wire        div_valid;\n    \n    add_module u_add (\n        .a   (data_a),\n        .b   (data_b),\n        .sum (add_out)\n    );\n    \n    sub_module u_sub (\n        .a    (data_a),\n        .b    (data_b),\n        .diff (sub_out)\n    );\n    \n    mul_module u_mul (\n        .a       (data_a),\n        .b       (data_b),\n        .product (mul_out)\n    );\n    \n    div_module u_div (\n        .a        (data_a),\n        .b        (data_b),\n        .quotient (div_out),\n        .valid    (div_valid)\n    );\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            result <= 16'b0;\n            valid  <= 1'b0;\n        end else begin\n            case (opcode)\n                2'b00: begin\n                    result <= add_out;\n                    valid  <= 1'b1;\n                end\n                2'b01: begin\n                    result <= sub_out;\n                    valid  <= 1'b1;\n                end\n                2'b10: begin\n                    result <= mul_out;\n                    valid  <= 1'b1;\n                end\n                2'b11: begin\n                    result <= div_out;\n                    valid  <= div_valid;\n                end\n                default: begin\n                    result <= 16'b0;\n                    valid  <= 1'b0;\n                end\n            endcase\n       "}
{"task_id": "barrel_shifter_v_22", "response": "module bit_compare(\n    input a,\n    input b,\n    input eq_in,\n    output gt,\n    output lt,\n    output eq_out\n);\n    assign gt = eq_in & (a & ~b);\n    assign lt = eq_in & (~a & b);\n    assign eq_out = eq_in & ~(a ^ b);\nendmodule\n\nmodule magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt;\n    output lt;\n    output eq;\n    \n    wire eq3, eq2, eq1;\n    wire gt3, gt2, gt1, gt0;\n    wire lt3, lt2, lt1, lt0;\n    \n    bit_compare bc0 (\n        .a(A[3]),\n        .b(B[3]),\n        .eq_in(1'b1),\n        .gt(gt3),\n        .lt(lt3),\n        .eq_out(eq3)\n    );\n    \n    bit_compare bc1 (\n        .a(A[2]),\n        .b(B[2]),\n        .eq_in(eq3),\n        .gt(gt2),\n        .lt(lt2),\n        .eq_out(eq2)\n    );\n    \n    bit_compare bc2 (\n        .a(A[1]),\n        .b(B[1]),\n        .eq_in(eq2),\n        .gt(gt1),\n        .lt(lt1),\n        .eq_out(eq1)\n    );\n    \n    bit_compare bc3 (\n        .a(A[0]),\n        .b(B[0]),\n        .eq_in(eq1),\n        .gt(gt0),\n        .lt(lt0),\n        .eq_out(eq)\n    );\n    \n    assign gt = gt3 | gt2 | gt1 | gt0;\n    assign lt = lt3 | lt2 | lt1 | lt0;\n    \nendmodule"}
{"task_id": "barrel_shifter_v_23", "response": "module simple_alu(a, b, op, result, carry_borrow);\n  input  [3:0] a;\n  input  [3:0] b;\n  input  [1:0] op;\n  output reg [3:0] result;\n  output reg carry_borrow;\n\n  wire [3:0] and_res;\n  wire [3:0] or_res;\n  wire [3:0] add_res;\n  wire       add_carry;\n  wire [3:0] sub_res;\n  wire       sub_borrow;\n\n  bitwise_and u_and (\n    .a(a),\n    .b(b),\n    .result(and_res)\n  );\n\n  bitwise_or u_or (\n    .a(a),\n    .b(b),\n    .result(or_res)\n  );\n\n  adder_4bit u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_res),\n    .carry(add_carry)\n  );\n\n  subtractor_4bit u_sub (\n    .a(a),\n    .b(b),\n    .diff(sub_res),\n    .borrow(sub_borrow)\n  );\n\n  always @(*) begin\n    case(op)\n      2'b00: begin\n        result = and_res;\n        carry_borrow = 1'b0;\n      end\n      2'b01: begin\n        result = or_res;\n        carry_borrow = 1'b0;\n      end\n      2'b10: begin\n        result = add_res;\n        carry_borrow = add_carry;\n      end\n      2'b11: begin\n        result = sub_res;\n        carry_borrow = sub_borrow;\n      end\n      default: begin\n        result = 4'd0;\n        carry_borrow = 1'b0;\n      end\n    endcase\n  end\n\nendmodule\n\nmodule bitwise_and(a, b, result);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] result;\n  assign result = a & b;\nendmodule\n\nmodule bitwise_or(a, b, result);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] result;\n  assign result = a | b;\nendmodule\n\nmodule adder_4bit(a, b, sum, carry);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] sum;\n  output       carry;\n  wire   [4:0] temp;\n  assign temp = a + b;\n  assign sum = temp[3:0];\n  assign carry = temp[4];\nendmodule\n\nmodule subtractor_4bit(a, b, diff, borrow);\n  input  [3:0] a;\n  input  [3:0] b;\n  output [3:0] diff;\n  output       borrow;\n  assign diff = a - b;\n  assign borrow = (a < b) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "barrel_shifter_v_24", "response": ""}
{"task_id": "barrel_shifter_v_25", "response": "module compare_temp (temp_sensor, compare_out);\n  input [7:0] temp_sensor;\n  output compare_out;\n  parameter THRESHOLD = 8'd100;\n  \n  assign compare_out = (temp_sensor > THRESHOLD);\nendmodule\n\nmodule or_logic (a, b, alarm);\n  input a, b;\n  output alarm;\n  \n  assign alarm = a | b;\nendmodule\n\nmodule alarm_system (temp_sensor, smoke_sensor, alarm_out);\n  input [7:0] temp_sensor;\n  input smoke_sensor;\n  output alarm_out;\n  \n  wire temp_flag;\n  \n  compare_temp comp_temp (\n    .temp_sensor(temp_sensor),\n    .compare_out(temp_flag)\n  );\n  \n  or_logic or_gate (\n    .a(temp_flag),\n    .b(smoke_sensor),\n    .alarm(alarm_out)\n  );\nendmodule"}
{"task_id": "sub_16bit_v_26", "response": "module cla_4bit(A, B, cin, S, cout);\n    input  [3:0] A, B;\n    input        cin;\n    output [3:0] S;\n    output       cout;\n    \n    wire [3:0] p, g;\n    wire       c1, c2, c3;\n    \n    assign p = A ^ B;\n    assign g = A & B;\n    \n    assign c1    = g[0] | (p[0] & cin);\n    assign c2    = g[1] | (p[1] & g[0]) | (p[1] & p[0] & cin);\n    assign c3    = g[2] | (p[2] & g[1]) | (p[2] & p[1] & g[0]) | (p[2] & p[1] & p[0] & cin);\n    assign cout  = g[3] | (p[3] & g[2]) | (p[3] & p[2] & g[1]) | (p[3] & p[2] & p[1] & g[0]) | (p[3] & p[2] & p[1] & p[0] & cin);\n    \n    assign S[0] = p[0] ^ cin;\n    assign S[1] = p[1] ^ c1;\n    assign S[2] = p[2] ^ c2;\n    assign S[3] = p[3] ^ c3;\nendmodule\n\nmodule add_16bit(A, B, S, C_out);\n    input  [16:1] A, B;\n    output [16:1] S;\n    output        C_out;\n    \n    wire c1, c2, c3;\n    \n    cla_4bit adder0(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .cin(1'b0),\n        .S(S[4:1]),\n        .cout(c1)\n    );\n    \n    cla_4bit adder1(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .cin(c1),\n        .S(S[8:5]),\n        .cout(c2)\n    );\n    \n    cla_4bit adder2(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .cin(c2),\n        .S(S[12:9]),\n        .cout(c3)\n    );\n    \n    cla_4bit adder3(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .cin(c3),\n        .S(S[16:13]),\n        .cout(C_out)\n    );\nendmodule"}
{"task_id": "sub_16bit_v_27", "response": ""}
{"task_id": "sub_16bit_v_28", "response": "module parity_8bit(input [7:0] data, output parity);\n    assign parity = ^data;\nendmodule\n\nmodule parity_16bit(input [7:0] X, input [7:0] Y, output P);\n    wire p1, p2;\n\n    parity_8bit u_gen1 (.data(X), .parity(p1));\n    parity_8bit u_gen2 (.data(Y), .parity(p2));\n\n    assign P = p1 ^ p2;\nendmodule"}
{"task_id": "sub_16bit_v_29", "response": ""}
{"task_id": "systolic1x4_v_30", "response": "module adder_unit(\n    input  [7:0] a,\n    input  [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule parallel_adder1x4(\n    input  [7:0] a0,\n    input  [7:0] a1,\n    input  [7:0] a2,\n    input  [7:0] a3,\n    input  [7:0] b0,\n    input  [7:0] b1,\n    input  [7:0] b2,\n    input  [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    adder_unit au0(\n        .a(a0),\n        .b(b0),\n        .sum(sum0)\n    );\n    \n    adder_unit au1(\n        .a(a1),\n        .b(b1),\n        .sum(sum1)\n    );\n    \n    adder_unit au2(\n        .a(a2),\n        .b(b2),\n        .sum(sum2)\n    );\n    \n    adder_unit au3(\n        .a(a3),\n        .b(b3),\n        .sum(sum3)\n    );\n    \nendmodule"}
{"task_id": "systolic1x4_v_31", "response": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n\n    multiplier_unit mult0(\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y0),\n        .out(p0)\n    );\n\n    multiplier_unit mult1(\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y0),\n        .out(p1)\n    );\n\n    multiplier_unit mult2(\n        .clk(clk),\n        .rst(rst),\n        .a(x0),\n        .b(y1),\n        .out(p2)\n    );\n\n    multiplier_unit mult3(\n        .clk(clk),\n        .rst(rst),\n        .a(x1),\n        .b(y1),\n        .out(p3)\n    );\n\nendmodule\n\nmodule multiplier_unit(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 16'd0;\n        else\n            out <= a * b;\n    end\nendmodule"}
{"task_id": "systolic1x4_v_32", "response": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n\n  wire [3:0] left_data;\n  wire [3:0] right_data;\n\n  left_rotate u_left_rotate(\n    .data(in_data),\n    .rotated(left_data)\n  );\n\n  right_rotate u_right_rotate(\n    .data(in_data),\n    .rotated(right_data)\n  );\n\n  assign out_data = en ? (rot_dir ? left_data : right_data) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  output [3:0] rotated\n);\n\n  assign rotated = {data[2:0], data[3]};\n\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] rotated\n);\n\n  assign rotated = {data[0], data[3:1]};\n\nendmodule"}
{"task_id": "systolic1x2_v_33", "response": "module Counter(\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk) begin\n    if (rst)\n      count <= 8'd0;\n    else if (enable) begin\n      if (mode == 1'b0)\n        count <= count + 8'd1;\n      else\n        count <= count - 8'd1;\n    end\n  end\nendmodule\n\nmodule dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(count)\n  );\nendmodule"}
{"task_id": "systolic1x2_v_34", "response": "module latch (\n    input reset,\n    input load,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge load or posedge reset) begin\n        if (reset)\n            q <= 8'd0;\n        else\n            q <= d;\n    end\nendmodule\n\nmodule dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    latch latch0_inst (\n        .reset(reset),\n        .load(load0),\n        .d(d0),\n        .q(q0)\n    );\n\n    latch latch1_inst (\n        .reset(reset),\n        .load(load1),\n        .d(d1),\n        .q(q1)\n    );\nendmodule"}
{"task_id": "systolic1x2_v_35", "response": "module shift_register (\n    input  clk,\n    input  rst,\n    input  load,\n    input  shift,\n    input  [7:0] data,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        if (rst)\n            q <= 8'b0;\n        else if (load)\n            q <= data;\n        else if (shift)\n            q <= {1'b0, q[7:1]};\n    end\nendmodule\n\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    shift_register sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .shift(shift0),\n        .data(data0),\n        .q(out0)\n    );\n    \n    shift_register sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .shift(shift1),\n        .data(data1),\n        .q(out1)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_36", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (a & cin) | (b & cin);\nendmodule\n\nmodule adder_8bit(\n    input [7:0] X,\n    input [7:0] Y,\n    input carry_in,\n    output [7:0] Sum,\n    output carry_out\n);\n    wire [8:0] carry;\n    assign carry[0] = carry_in;\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin: FA\n            full_adder fa_inst (\n                .a(X[i]),\n                .b(Y[i]),\n                .cin(carry[i]),\n                .sum(Sum[i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n    assign carry_out = carry[8];\nendmodule\n\nmodule adder_32bit(\n    input [31:0] X,\n    input [31:0] Y,\n    output [31:0] Sum,\n    output Carry_out\n);\n    wire carry0, carry1, carry2;\n    \n    adder_8bit adder0 (\n        .X(X[7:0]),\n        .Y(Y[7:0]),\n        .carry_in(1'b0),\n        .Sum(Sum[7:0]),\n        .carry_out(carry0)\n    );\n    \n    adder_8bit adder1 (\n        .X(X[15:8]),\n        .Y(Y[15:8]),\n        .carry_in(carry0),\n        .Sum(Sum[15:8]),\n        .carry_out(carry1)\n    );\n    \n    adder_8bit adder2 (\n        .X(X[23:16]),\n        .Y(Y[23:16]),\n        .carry_in(carry1),\n        .Sum(Sum[23:16]),\n        .carry_out(carry2)\n    );\n    \n    adder_8bit adder3 (\n        .X(X[31:24]),\n        .Y(Y[31:24]),\n        .carry_in(carry2),\n        .Sum(Sum[31:24]),\n        .carry_out(Carry_out)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_37", "response": "module adder_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    input Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    assign {Cout, Sum} = A + B + Cin;\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n    wire c1, c2, c3;\n    \n    adder_8bit adder0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(Cin),\n        .Sum(Sum[7:0]),\n        .Cout(c1)\n    );\n    \n    adder_8bit adder1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .Sum(Sum[15:8]),\n        .Cout(c2)\n    );\n    \n    adder_8bit adder2 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .Sum(Sum[23:16]),\n        .Cout(c3)\n    );\n    \n    adder_8bit adder3 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .Sum(Sum[31:24]),\n        .Cout(Cout)\n    );\nendmodule"}
{"task_id": "comparator_32bit_v_38", "response": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow\n);\n    assign diff = A - B;\n    assign borrow = (A < B) ? 1'b1 : 1'b0;\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] result\n);\n    assign result = A & B;\nendmodule\n\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n    wire [31:0] add_result;\n    wire        add_carry;\n\n    wire [31:0] sub_result;\n    wire        sub_borrow;\n\n    wire [31:0] and_result;\n\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .sum(add_result),\n        .carry_out(add_carry)\n    );\n\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(sub_result),\n        .borrow(sub_borrow)\n    );\n\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .result(and_result)\n    );\n\n    reg [31:0] result_reg;\n    reg        carry_reg;\n\n    always @(*) begin\n        case (op)\n            2'b00: begin\n                result_reg = add_result;\n                carry_reg = add_carry;\n            end\n            2'b01: begin\n                result_reg = sub_result;\n                carry_reg = sub_borrow;\n            end\n            2'b10: begin\n                result_reg = and_result;\n                carry_reg = 1'b0;\n            end\n            default: begin\n                result_reg = 32'b0;\n                carry_reg = 1'b0;\n            end\n        endcase\n    end\n\n    assign result = result_reg;\n    assign carry_out = carry_reg;\nendmodule"}
{"task_id": "instr_reg_v_39", "response": "module mux_path (\n    input clk,\n    input [7:0] din,\n    output reg [7:0] dout\n);\n    always @(posedge clk) begin\n        dout <= din;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output reg [7:0] data_out\n);\n    wire [7:0] mux0_out;\n    wire [7:0] mux1_out;\n    wire [7:0] mux2_out;\n\n    mux_path mux0 (\n        .clk(clk),\n        .din(d0),\n        .dout(mux0_out)\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .din(d1),\n        .dout(mux1_out)\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .din(d2),\n        .dout(mux2_out)\n    );\n\n    always @(*) begin\n        case(sel)\n            3'b000: data_out = mux0_out;\n            3'b001: data_out = mux1_out;\n            3'b010: data_out = mux2_out;\n            default: data_out = 8'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "instr_reg_v_40", "response": "module hold0 (\n    input clk,\n    input enable,\n    input [7:0] in,\n    output reg [7:0] data\n);\n    always @(posedge clk) begin\n        if (enable)\n            data <= in;\n    end\nendmodule\n\nmodule hold1 (\n    input clk,\n    input enable,\n    input [7:0] in,\n    output reg [7:0] data\n);\n    always @(posedge clk) begin\n        if (enable)\n            data <= in;\n    end\nendmodule\n\nmodule hold2 (\n    input clk,\n    input enable,\n    input [7:0] in,\n    output reg [7:0] data\n);\n    always @(posedge clk) begin\n        if (enable)\n            data <= in;\n    end\nendmodule\n\nmodule hold3 (\n    input clk,\n    input enable,\n    input [7:0] in,\n    output reg [7:0] data\n);\n    always @(posedge clk) begin\n        if (enable)\n            data <= in;\n    end\nendmodule\n\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n    wire load0, load1, load2, load3;\n    wire [7:0] data0, data1, data2, data3;\n\n    assign load0 = (sel == 2'b00);\n    assign load1 = (sel == 2'b01);\n    assign load2 = (sel == 2'b10);\n    assign load3 = (sel == 2'b11);\n\n    hold0 u_hold0 (\n        .clk(clk),\n        .enable(load0),\n        .in(in0),\n        .data(data0)\n    );\n\n    hold1 u_hold1 (\n        .clk(clk),\n        .enable(load1),\n        .in(in1),\n        .data(data1)\n    );\n\n    hold2 u_hold2 (\n        .clk(clk),\n        .enable(load2),\n        .in(in2),\n        .data(data2)\n    );\n\n    hold3 u_hold3 (\n        .clk(clk),\n        .enable(load3),\n        .in(in3),\n        .data(data3)\n    );\n\n    assign out = (sel == 2'b00) ? data0 :\n                 (sel == 2'b01) ? data1 :\n                 (sel == 2'b10) ? data2 :\n                 (sel == 2'b11) ? data3 : 8'b0;\nendmodule"}
{"task_id": "square_wave_v_41", "response": "module pwm_generator(\n    input         clk,\n    input  [7:0]  duty_cycle,\n    input  [7:0]  freq,\n    output        pwm_out\n);\n    wire [15:0] count;\n    wire        reset;\n    \n    assign reset = 1'b0;\n    \n    pwm_counter pc_inst (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(count)\n    );\n    \n    pwm_signal ps_inst (\n        .clk(clk),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\nendmodule\n\nmodule pwm_counter(\n    input         clk,\n    input         reset,\n    input  [7:0]  freq,\n    output reg [15:0] count\n);\n    always @(posedge clk) begin\n        if (reset)\n            count <= 16'd0;\n        else if (count >= (freq - 1))\n            count <= 16'd0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule pwm_signal(\n    input         clk,\n    input  [15:0] count,\n    input  [7:0]  duty_cycle,\n    input  [7:0]  freq,\n    output reg    pwm_out\n);\n    wire [15:0] threshold;\n    assign threshold = (freq * duty_cycle) / 100;\n    \n    always @(posedge clk) begin\n        if (count < threshold)\n            pwm_out <= 1'b1;\n        else\n            pwm_out <= 1'b0;\n    end\nendmodule"}
{"task_id": "square_wave_v_42", "response": "module duty_ctrl(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle;\n    end\nendmodule\n\nmodule pulse_gen(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n    reg [7:0] counter;\n    \n    always @(posedge clk) begin\n        if(counter < 8'd255)\n            counter <= counter + 1;\n        else\n            counter <= 0;\n        \n        pwm_out <= (counter < duty_cycle) ? 1'b1 : 1'b0;\n    end\nendmodule\n\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    wire [7:0] adjusted_duty;\n    \n    duty_ctrl dut_ctrl_inst (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n    \n    pulse_gen pulse_gen_inst (\n        .clk(clk),\n        .duty_cycle(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule"}
{"task_id": "adder_16bit_v_43", "response": "module comparator_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n    assign equal = (a == b);\nendmodule\n\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n    wire eq0, eq1, eq2, eq3;\n\n    comparator_8bit comp8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(eq0)\n    );\n\n    comparator_8bit comp8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(eq1)\n    );\n\n    comparator_8bit comp8_inst3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(eq2)\n    );\n\n    comparator_8bit comp8_inst4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(eq3)\n    );\n\n    assign equal = eq0 & eq1 & eq2 & eq3;\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [15:0] product\n);\n    assign product = a * b;\nendmodule\n\nmodule multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n    wire [15:0] p0, p1, p2, p3;\n    wire [31:0] pp0, pp1, pp2, pp3;\n\n    mult8 mult8_inst1 (\n        .a(x[7:0]),\n        .b(y[7:0]),\n        .product(p0)\n    );\n    \n    mult8 mult8_inst2 (\n        .a(x[7:0]),\n        .b(y[15:8]),\n        .product(p1)\n    );\n    \n    mult8 mult8_inst3 (\n        .a(x[15:8]),\n        .b(y[7:0]),\n        .product(p2)\n    );\n    \n    mult8 mult8_inst4 (\n        .a(x[15:8]),\n        .b(y[15:8]),\n        .product(p3)\n    );\n\n    assign pp0 = {16'b0, p0};\n    assign pp1 = {8'b0, p1, 8'b0};\n    assign pp2 = {8'b0, p2, 8'b0};\n    assign pp3 = {p3, 16'b0};\n\n    assign prod = pp0 + pp1 + pp2 + pp3;\nendmodule"}
{"task_id": "shift8_v_45", "response": "module bit_reverse (\n    input [7:0] din,\n    output [7:0] dout\n);\n    assign dout = {din[0], din[1], din[2], din[3], din[4], din[5], din[6], din[7]};\nendmodule\n\nmodule bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] stage1;\n    \n    bit_reverse br1 (\n        .din(din),\n        .dout(stage1)\n    );\n    \n    bit_reverse br2 (\n        .din(stage1),\n        .dout(dout)\n    );\nendmodule"}
{"task_id": "shift8_v_46", "response": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] add_result;\n\n    my_adder8 u_my_adder8 (\n        .a(a),\n        .b(b),\n        .sum(add_result)\n    );\n\n    always @(*) begin\n        if (ctrl)\n            sum = add_result;\n        else\n            sum = 8'b0;\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b;\nendmodule"}
{"task_id": "freq_div_v_47", "response": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n    pwm_module_25 u_pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM(PWM_25)\n    );\n    \n    pwm_module_50 u_pwm_module_50 (\n        .CLK_in"}
{"task_id": "freq_div_v_48", "response": ""}
{"task_id": "freq_divbyodd_v_49", "response": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    parameter DUTY_CYCLE   = 50;\n    parameter MAX_COUNT    = 255;\n    parameter COUNTER_WIDTH = 8;\n\n    wire [COUNTER_WIDTH-1:0] count;\n\n    counter #(\n        .MAX_COUNT(MAX_COUNT),\n        .COUNTER_WIDTH(COUNTER_WIDTH)\n    ) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count)\n    );\n\n    comparator #(\n        .DUTY_CYCLE(DUTY_CYCLE),\n        .MAX_COUNT(MAX_COUNT),\n        .COUNTER_WIDTH(COUNTER_WIDTH)\n    ) u_comparator (\n        .count(count),\n        .pwm_out(pwm_out)\n    );\n    \nendmodule\n\nmodule counter #(\n    parameter MAX_COUNT = 255,\n    parameter COUNTER_WIDTH = 8\n)(\n    input clk,\n    input rst_n,\n    output reg [COUNTER_WIDTH-1:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 0;\n        else if (count >= MAX_COUNT)\n            count <= 0;\n        else\n            count <= count + 1;\n    end\nendmodule\n\nmodule comparator #(\n    parameter DUTY_CYCLE = 50,\n    parameter MAX_COUNT  = 255,\n    parameter COUNTER_WIDTH = 8\n)(\n    input [COUNTER_WIDTH-1:0] count,\n    output pwm_out\n);\n    localparam integer THRESHOLD = (DUTY_CYCLE * (MAX_COUNT + 1)) / 100;\n    assign pwm_out = (count < THRESHOLD) ? 1'b1 : 1'b0;\nendmodule"}
{"task_id": "alu_v_50", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\n  wire [63:0] signed_result;\n  wire [63:0] unsigned_result;\n\n  mult_signed u_mult_signed (\n    .a(a),\n    .b(b),\n    .result(signed_result)\n  );\n\n  mult_unsigned u_mult_unsigned (\n    .a(a),\n    .b(b),\n    .result(unsigned_result)\n  );\n\n  wire [63:0] product;\n  assign product = (multc == 1'b0) ? signed_result : unsigned_result;\n  assign y = product;\n  assign msb = product[63:32];\n  assign lsb = product[31:0];\n  assign zero = (product == 64'b0) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule mult_signed(\n    input [31:0] a,\n    input [31:0] b,\n    output signed [63:0] result\n);\n  assign result = $signed(a) * $signed(b);\nendmodule\n\nmodule mult_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n  assign result = a * b;\nendmodule"}
{"task_id": "accu_v_51", "response": "module binary_up_counter (\n    input         clk,\n    input         rst,\n    input         en,\n    output [3:0]  count_out,\n    output        overflow\n);\n    wire [3:0] count_internal;\n\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count_internal)\n    );\n\n    overflow_detection u_overflow_detection (\n        .clk(clk),\n        .rst(rst),\n        .count(count_internal),\n        .overflow(overflow)\n    );\n\n    assign count_out = count_internal;\nendmodule\n\nmodule count_control (\n    input         clk,\n    input         rst,\n    input         en,\n    output reg [3:0] count\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            count <= 4'd0;\n        else if (en)\n            count <= count + 4'd1;\n        else\n            count <= count;\n    end\nendmodule\n\nmodule overflow_detection (\n    input         clk,\n    input         rst,\n    input  [3:0]  count,\n    output reg    overflow\n);\n    reg [3:0] prev_count;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            prev_count <= 4'd0;\n            overflow   <= 1'b0;\n        end else begin\n            overflow   <= ((prev_count == 4'd15) && (count == 4'd0)) ? 1'b1 : 1'b0;\n            prev_count <= count;\n        end\n    end\nendmodule"}
{"task_id": "stagepipe5_v_52", "response": "module simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n    wire [31:0] add_out;\n    wire [31:0] subtract_out;\n    wire [31:0] and_out;\n    wire [31:0] or_out;\n\n    adder add_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(add_out)\n    );\n\n    subtracter subtract_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .diff(subtract_out)\n    );\n\n    and_gate and_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .out(and_out)\n    );\n\n    or_gate or_inst (\n        .a(operand_a),\n        .b(operand_b),\n        .out(or_out)\n    );\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'd0;\n        else begin\n            case (op_code)\n                2'b00: result <= add_out;\n                2'b01: result <= subtract_out;\n                2'b10: result <= and_out;\n                2'b11: result <= or_out;\n                default: result <= 32'd0;\n            endcase\n        end\n    end\nendmodule\n\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtracter(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] out\n);\n    assign out = a | b;\nendmodule"}
{"task_id": "adder_16bit_csa_v_53", "response": ""}
{"task_id": "adder_32bit_v_54", "response": "module subtractor_8bit(A, B, Bin, D, Bout);\n  input  [7:0] A, B;\n  input        Bin;\n  output [7:0] D;\n  output       Bout;\n  \n  wire [8:0] diff;\n  assign diff = {1'b0, A} - {1'b0, B} - Bin;\n  assign D    = diff[7:0];\n  assign Bout = diff[8];\nendmodule\n\nmodule subtractor_32bit(A, B, Bin, D, Bout);\n  input  [32:1] A, B;\n  input         Bin;\n  output [32:1] D;\n  output        Bout;\n  \n  wire b1, b2, b3;\n  \n  subtractor_8bit SUB1(\n    .A(A[8:1]),\n    .B(B[8:1]),\n    .Bin(Bin),\n    .D(D[8:1]),\n    .Bout(b1)\n  );\n  \n  subtractor_8bit SUB2(\n    .A(A[16:9]),\n    .B(B[16:9]),\n    .Bin(b1),\n    .D(D[16:9]),\n    .Bout(b2)\n  );\n  \n  subtractor_8bit SUB3(\n    .A(A[24:17]),\n    .B(B[24:17]),\n    .Bin(b2),\n    .D(D[24:17]),\n    .Bout(b3)\n  );\n  \n  subtractor_8bit SUB4(\n    .A(A[32:25]),\n    .B(B[32:25]),\n    .Bin(b3),\n    .D(D[32:25]),\n    .Bout(Bout)\n  );\n  \nendmodule"}
{"task_id": "shift_reg_v_55", "response": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n\n  wire t0, t1, t2;\n\n  assign t0 = 1'b1;\n  assign t1 = count[0];\n  assign t2 = count[0] & count[1];\n\n  my_tff u0 (\n    .clk(clk),\n    .reset(reset),\n    .t(t0),\n    .q(count[0])\n  );\n\n  my_tff u1 (\n    .clk(clk),\n    .reset(reset),\n    .t(t1),\n    .q(count[1])\n  );\n\n  my_tff u2 (\n    .clk(clk),\n    .reset(reset),\n    .t(t2),\n    .q(count[2])\n  );\n\nendmodule"}
{"task_id": "ring_counter_v_56", "response": "module binary_up_counter (\n    input  wire       clk,\n    input  wire       reset,\n    output wire [3:0] out\n);\n    reg [3:0] count;\n    wire [3:0] init_val;\n    wire [3:0] inc_val;\n\n    init_module u_init (\n        .reset(reset),\n        .init_val(init_val)\n    );\n\n    increment_module u_inc (\n        .in(count),\n        .out(inc_val)\n    );\n\n    always @(posedge clk) begin\n        if (reset)\n            count <= init_val;\n        else\n            count <= inc_val;\n    end\n\n    assign out = count;\nendmodule\n\nmodule init_module (\n    input  wire       reset,\n    output wire [3:0] init_val\n);\n    assign init_val = 4'b0000;\nendmodule\n\nmodule increment_module (\n    input  wire [3:0] in,\n    output wire [3:0] out\n);\n    assign out = in + 4'b0001;\nendmodule"}
{"task_id": "up_down_counter", "response": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n  wire [15:0] next;\n  wire [15:0] current;\n\n  counter_logic u_counter_logic (\n    .current(current),\n    .up_down(up_down),\n    .next(next)\n  );\n\n  counter_register u_counter_register (\n    .clk(clk),\n    .reset(reset),\n    .next(next),\n    .current(current)\n  );\n\n  assign count = current;\n\nendmodule\n\n\nmodule counter_logic (\n    input wire [15:0] current,\n    input wire up_down,\n    output wire [15:0] next\n);\n\n  assign next = up_down ? (current + 16'd1) : (current - 16'd1);\n\nendmodule\n\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next,\n    output reg [15:0] current\n);\n\n  always @(posedge clk) begin\n    if (reset)\n      current <= 16'd0;\n    else\n      current <= next;\n  end\n\nendmodule"}
{"task_id": "ring_counter", "response": "module ring_counter_init (\n    input wire reset,\n    output wire [7:0] init_state\n);\n    assign init_state = 8'b00000001;\nendmodule\n\nmodule ring_counter_transition (\n    input wire [7:0] current_state,\n    output wire [7:0] next_state\n);\n    assign next_state = (current_state == 8'b10000000) ? 8'b00000001 : (current_state << 1);\nendmodule\n\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n    reg [7:0] state;\n    wire [7:0] init_state;\n    wire [7:0] next_state;\n    \n    ring_counter_init init_inst (\n        .reset(reset),\n        .init_state(init_state)\n    );\n    \n    ring_counter_transition trans_inst (\n        .current_state(state),\n        .next_state(next_state)\n    );\n    \n    always @(posedge clk) begin\n        if (reset)\n            state <= init_state;\n        else\n            state <= next_state;\n    end\n    \n    assign out = state;\nendmodule"}
{"task_id": "counter_12", "response": "module counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n    wire [3:0] count_val;\n\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count(count_val)\n    );\n\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .data(count_val),\n        .out(out)\n    );\n    \nendmodule\n\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            count <= 4'b0000;\n        else if (valid_count) begin\n            if (count == 4'd11)\n                count <= 4'b0000;\n            else\n                count <= count + 4'b0001;\n        end\n    end\nendmodule\n\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] data,\n    output reg [3:0] out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            out <= 4'b0000;\n        else if (valid_count)\n            out <= data;\n    end\nendmodule"}
{"task_id": "JC_counter", "response": "module JC_counter(\n    input         clk,\n    input         rst_n,\n    output [63:0] Q\n);\n    wire [63:0] next_state;\n\n    JC_logic logic_inst (\n        .current_state(Q),\n        .next_state(next_state)\n    );\n\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .next_state(next_state),\n        .q(Q)\n    );\n    \nendmodule\n\nmodule JC_register(\n    input         clk,\n    input         rst_n,\n    input  [63:0] next_state,\n    output reg [63:0] q\n);\n    always @(posedge clk or negedge rst_n)\n        if (!rst_n)\n            q <= 64'd0;\n        else\n            q <= next_state;\nendmodule\n\nmodule JC_logic(\n    input  [63:0] current_state,\n    output [63:0] next_state\n);\n    assign next_state = {~current_state[0], current_state[63:1]};\nendmodule"}
{"task_id": "freq_div", "response": "module clk_div_2(\n    input CLK_in,\n    input RST,\n    output reg CLK_div\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST)\n            CLK_div <= 1'b0;\n        else\n            CLK_div <= ~CLK_div;\n    end\nendmodule\n\nmodule clk_div_10(\n    input CLK_in,\n    input RST,\n    output reg CLK_div\n);\n    reg [2:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count   <= 3'd0;\n            CLK_div <= 1'b0;\n        end else begin\n            if (count == 3'd4) begin\n                count   <= 3'd0;\n                CLK_div <= ~CLK_div;\n            end else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_100(\n    input CLK_in,\n    input RST,\n    output reg CLK_div\n);\n    reg [5:0] count;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            count   <= 6'd0;\n            CLK_div <= 1'b0;\n        end else begin\n            if (count == 6'd49) begin\n                count   <= 6'd0;\n                CLK_div <= ~CLK_div;\n            end else\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    clk_div_2 U_clk_div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_div(CLK_50)\n    );\n\n    clk_div_10 U_clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_div(CLK_10)\n    );\n\n    clk_div_100 U_clk_div_100 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_div(CLK_1)\n    );\n\nendmodule"}
{"task_id": "freq_divbyfrac", "response": ""}
{"task_id": "freq_divbyodd", "response": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 5;\n    \n    wire clk_div1;\n    wire clk_div2;\n    \n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div1)\n    );\n    \n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .clk_div(clk_div2)\n    );\n    \n    assign clk_div = clk_div1 | clk_div2;\n    \nendmodule\n\n\nmodule pos_edge_counter #(\n    parameter NUM_DIV = 5\n)(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam CNT_WIDTH = $clog2(NUM_DIV);\n    reg [CNT_WIDTH-1:0] count;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count   <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count == NUM_DIV - 1) begin\n                count   <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\n\nmodule neg_edge_counter #(\n    parameter NUM_DIV = 5\n)(\n    input clk,\n    input rst_n,\n    output reg clk_div\n);\n    localparam CNT_WIDTH = $clog2(NUM_DIV);\n    reg [CNT_WIDTH-1:0] count;\n    \n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count   <= 0;\n            clk_div <= 0;\n        end else begin\n            if (count == NUM_DIV - 1) begin\n                count   <= 0;\n                clk_div <= ~clk_div;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule"}
{"task_id": "freq_divbyeven", "response": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    parameter NUM_DIV = 10;\n    \n    wire tick;\n    \n    u_counter #(.NUM_DIV(NUM_DIV)) counter_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick)\n    );\n    \n    u_clk_divider clk_divider_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .tick(tick),\n        .clk_div(clk_div)\n    );\n    \nendmodule\n\nmodule u_counter #(\n    parameter NUM_DIV = 10\n)(\n    input clk,\n    input rst_n,\n    output reg tick\n);\n    localparam CNT_MAX = (NUM_DIV / 2) - 1;\n    reg [3:0] count;\n    \n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 4'd0;\n            tick  <= 1'b0;\n        end\n        else if (count == CNT_MAX) begin\n            count <= 4'd0;\n            tick  <= 1'b1;\n        end\n        else begin\n            count <= count + 1;\n            tick  <= 1'b0;\n        end\n    end\nendmodule\n\nmodule u_clk_divider(\n    input clk,\n    input rst_n,\n    input tick,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n)\n            clk_div <= 1'b0;\n        else if (tick)\n            clk_div <= ~clk_div;\n    end\nendmodule"}
{"task_id": "alu", "response": ""}
{"task_id": "pe", "response": "module multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] p\n);\n    assign p = a * b;\nendmodule\n\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] d,\n    output reg [31:0] out\n);\n    always @(posedge clk) begin\n        if (rst)\n            out <= 32'd0;\n        else\n            out <= out + d;\n    end\nendmodule\n\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n    wire [63:0] mult_result;\n\n    multiplier u_multiplier (\n        .a(a),\n        .b(b),\n        .p(mult_result)\n    );\n\n    accumulator u_accumulator (\n        .clk(clk),\n        .rst(rst),\n        .d(mult_result[31:0]),\n        .out(c)\n    );\nendmodule"}
{"task_id": "instr_reg", "response": "module instr_reg_sub (\n    input clk,\n    input rst,\n    input en,\n    input [7:0] data,\n    output reg [7:0] q\n);\n  always @(posedge clk or negedge rst) begin\n    if (!rst)\n      q <= 8'b0;\n    else if (en)\n      q <= data;\n  end\nendmodule\n\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n  wire [7:0] ins_p1;\n  wire ["}
{"task_id": "square_wave", "response": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n    wire [7:0] count;\n    wire enable;\n    \n    assign enable = (freq != 8'd0);\n    \n    counter counter_inst(\n        .clk(clk),\n        .enable(enable),\n        .freq(freq),\n        .count(count)\n    );\n    \n    wave_generator wave_generator_inst(\n        .clk(clk),\n        .count(count),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n    initial count = 8'd0;\n    \n    always @(posedge clk) begin\n        if (enable) begin\n            if (freq != 8'd0 && count == freq - 1)\n                count <= 8'd0;\n            else if (freq != 8'd0)\n                count <= count + 1;\n        end\n    end\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n    initial wave_out = 1'b0;\n    \n    always @(posedge clk) begin\n        if (freq != 8'd0 && count == freq - 1)\n            wave_out <= ~wave_out;\n    end\nendmodule"}
{"task_id": "signal_generator", "response": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\nwire [1:0] state;\n\nstate_control state_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .wave(wave),\n    .state(state)\n);\n\nwave_generation wave_inst (\n    .clk(clk),\n    .rst_n(rst_n),\n    .state(state),\n    .wave(wave)\n);\n\nendmodule\n\nmodule state_control (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [1:0] state\n);\nalways @(posedge clk or negedge rst_n) begin\n    if (!rst_n)\n        state <= 2'b00;\n    else if (wave == 5'd31)\n        state <= 2'b01;\n    else if (wave == 5'd0)\n        state <= 2'b00;\n    else\n        state <= state;\nend\nendmodule\n\nmodule wave_generation (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\nalways @(posedge clk or negedge rst_n) begin"}
{"task_id": "shift8", "response": "module my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d;\n    end\nendmodule\n\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    my_dff8 u0 (\n        .clk(clk),\n        .d(d),\n        .q(q0)\n    );\n\n    my_dff8 u1 (\n        .clk(clk),\n        .d(q0),\n        .q(q1)\n    );\n\n    my_dff8 u2 (\n        .clk(clk),\n        .d(q1),\n        .q(q2)\n    );\n\n    always @(*) begin\n        case (sel)\n            2'b00: q = d;\n            2'b01: q = q0;\n            2'b10: q = q1;\n            2'b11: q = q2;\n            default: q = 8'b0;\n        endcase\n    end\nendmodule"}
{"task_id": "shift_reg", "response": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n\nwire q0, q1;\n\nmy_dff u0 (\n    .clk(clk),\n    .d(d),\n    .q(q0)\n);\n\nmy_dff u1 (\n    .clk(clk),\n    .d(q0),\n    .q(q1)\n);\n\nmy_dff u2 (\n    .clk(clk),\n    .d(q1),\n    .q(q)\n);\n\nendmodule"}
{"task_id": "barrel_shifter", "response": ""}
{"task_id": "systolic1x2", "response": "module pe (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk) begin\n    if (rst)\n      c <= 32'b0;\n    else\n      c <= c + a * b;\n  end\nendmodule\n\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  always @(posedge clk) begin\n    if (rst)\n      b1 <= 16'b0;\n    else\n      b1 <= b0;\n  end\nendmodule"}
{"task_id": "stagepipe5", "response": ""}
{"task_id": "systolic1x4", "response": "module pe(\n  input         clk,\n  input         rst,\n  input  [15:0] a,\n  input  [15:0] b,\n  output reg [31:0] c\n);\n  always @(posedge clk or posedge rst) begin\n    if(rst)\n      c <= 32'd0;\n    else\n      c <= c + (a * b);\n  end\nendmodule\n\nmodule systolic1x4(\n  input         clk,\n  input         rst,\n  input  [15:0] a0,\n  input  [15:0] a1,\n  input  [15:0] a2,\n  input  [15:0] a3,\n  input  [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3\n);\n\n  reg [15:0] b1_reg, b2_reg, b3_reg;\n  wire [15:0] b1, b2, b3;\n\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      b1_reg <= 16'd0;\n      b2_reg <= 16'd0;\n      b3_reg <= 16'd0;\n    end else begin\n      b1_reg <= b0;\n      b2_reg <= b1_reg;\n      b3_reg <= b2_reg;\n    end\n  end\n\n  assign b1 = b1_reg;\n  assign b2 = b2_reg;\n  assign b3 = b3_reg;\n\n  pe pe0_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n\n  pe pe1_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n\n  pe pe2_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a2),\n    .b(b2),\n    .c(c2)\n  );\n\n  pe pe3_inst (\n    .clk(clk),\n    .rst(rst),\n    .a(a3),\n    .b(b3),\n    .c(c3)\n  );\n\nendmodule"}
{"task_id": "stagepipe3", "response": ""}
{"task_id": "accu", "response": ""}
{"task_id": "radix2_div", "response": ""}
{"task_id": "div_32bit", "response": "module div_32bit(\n    input  wire [31:0] A,   // 32-bit dividend\n    input  wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd     // 32-bit remainder\n);\n\n    wire [31:0] prepared_dividend;\n    wire [31:0] prepared_divisor;\n    wire [31:0] quotient;\n    wire [31:0] remainder;\n\n    prep_dividend u_prep_dividend (\n        .A(A),\n        .B(B),\n        .prepared_dividend(prepared_dividend),\n        .prepared_divisor(prepared_divisor)\n    );\n\n    div_operation u_div_operation (\n        .dividend(prepared_dividend),\n        .divisor(prepared_divisor),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd    = remainder;\n\nendmodule\n\nmodule prep_dividend(\n    input  wire [31:0] A,\n    input  wire [15:0] B,\n    output wire [31:0] prepared_dividend,\n    output wire [31:0] prepared_divisor\n);\n    assign prepared_dividend = A;\n    assign prepared_divisor  = {16'd0, B};\nendmodule\n\nmodule div_operation(\n    input  wire [31:0] dividend,\n    input  wire [31:0] divisor,\n    output reg  [31:0] quotient,\n    output reg  [31:0] remainder\n);\n    integer i;\n    reg [31:0] temp_remainder;\n\n    always @(*) begin\n        temp_remainder = 32'd0;\n        quotient = 32'd0;\n        for (i = 31; i >= 0; i = i - 1) begin\n            temp_remainder = (temp_remainder << 1) | dividend[i];\n            if (temp_remainder >= divisor) begin\n                temp_remainder = temp_remainder - divisor;\n                quotient[i] = 1'b1;\n            end else begin\n                quotient[i] = 1'b0;\n            end\n        end\n        remainder = temp_remainder;\n    end\n\nendmodule"}
{"task_id": "div_16bit", "response": "module div_16bit (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output wire [15:0] result,\n    output wire [15:0] odd\n);\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    div_ctrl control_unit (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    assign result = quotient;\n    assign odd    = remainder;\nendmodule\n\nmodule div_ctrl (\n    input  wire [15:0] A,\n    input  wire [7:0]  B,\n    output reg  [15:0] quotient,\n    output reg  [15:0] remainder\n);\n    integer i;\n    reg [15:0] rem;\n    reg [15:0] quot;\n\n    always @(*) begin\n        rem  = 16'd0;\n        quot = 16'd0;\n        for (i = 15; i >= 0; i = i - 1) begin\n            rem = {rem[14:0], A[i]};\n            if (rem >= {8'd0, B}) begin\n                rem = rem - {8'd0, B};\n                quot[i] = 1'b1;\n            end else begin\n                quot[i] = 1'b0;\n            end\n        end\n        quotient  = quot;\n        remainder = rem;\n    end\nendmodule"}
{"task_id": "sub_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | ((a ^ b) & cin);\nendmodule\n\nmodule adder_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input  Cin,\n    output [7:0] Sum,\n    output Cout\n);\n    wire [8:0] carry;\n    assign carry[0] = Cin;\n    \n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : full_adders\n            full_adder fa (\n                .a(A[i]),\n                .b(B[i]),\n                .cin(carry[i]),\n                .sum(Sum[i]),\n                .cout(carry[i+1])\n            );\n        end\n    endgenerate\n    \n    assign Cout = carry[8];\nendmodule\n\nmodule sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    output [7:0] D,\n    output B_out\n);\n    wire [7:0] B_inv;\n    wire cout;\n    \n    assign B_inv = ~B;\n    \n    adder_8bit adder_inst (\n        .A(A),\n        .B(B_inv),\n        .Cin(1'b1),\n        .Sum(D),\n        .Cout(cout)\n    );\n    \n    assign B_out = ~cout;\nendmodule"}
{"task_id": "sub_32bit", "response": "module sub_32bit(A, B, Diff, B_out);\n  input  [31:0] A, B;\n  output [31:0] Diff;\n  output        B_out;\n  \n  wire borrow_low;\n  \n  sub_16 subtractor_low (\n    .A(A[15:0]),\n    .B(B[15:0]),\n    .borrow_in(1'b0),\n    .Diff(Diff[15:0]),\n    .borrow_out(borrow_low)\n  );\n  \n  sub_16 subtractor_high (\n    .A(A[31:16]),\n    .B(B[31:16]),\n    .borrow_in(borrow_low),\n    .Diff(Diff[31:16]),\n    .borrow_out(B_out)\n  );\n\nendmodule\n\nmodule sub_16(A, B, borrow_in, Diff, borrow_out);\n  input  [15:0] A, B;\n  input         borrow_in;\n  output [15:0] Diff;\n  output        borrow_out;\n  \n  wire [16:0] result;\n  \n  assign result = {1'b0, A} - {1'b0, B} - borrow_in;\n  assign Diff = result[15:0];\n  assign borrow_out = result[16];\n  \nendmodule"}
{"task_id": "sub_64bit", "response": "module sub_8bit(\n    input  [7:0] A,\n    input  [7:0] B,\n    input        borrow_in,\n    output [7:0] D,\n    output       borrow_out\n);\n    assign {borrow_out, D} = {1'b0, A} - {1'b0, B} - borrow_in;\nendmodule\n\nmodule sub_16bit(\n    input  [15:0] A,\n    input  [15:0] B,\n    input         borrow_in,\n    output [15:0] D,\n    output        borrow_out\n);\n    wire borrow_mid;\n    \n    sub_8bit u0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .borrow_in(borrow_in),\n        .D(D[7:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_8bit u1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .borrow_in(borrow_mid),\n        .D(D[15:8]),\n        .borrow_out(borrow_out)\n    );\nendmodule\n\nmodule sub_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    input         borrow_in,\n    output [31:0] D,\n    output        borrow_out\n);\n    wire borrow_mid;\n    \n    sub_16bit u0 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .borrow_in(borrow_in),\n        .D(D[15:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_16bit u1 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .borrow_in(borrow_mid),\n        .D(D[31:16]),\n        .borrow_out(borrow_out)\n    );\nendmodule\n\nmodule sub_64bit(\n    input  [63:0] A,\n    input  [63:0] B,\n    output [63:0] D,\n    output        B_out\n);\n    wire borrow_mid;\n    \n    sub_32bit u0 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .borrow_in(1'b0),\n        .D(D[31:0]),\n        .borrow_out(borrow_mid)\n    );\n    \n    sub_32bit u1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .borrow_in(borrow_mid),\n        .D(D[63:32]),\n        .borrow_out(B_out)\n    );\nendmodule"}
{"task_id": "sub_16bit", "response": ""}
{"task_id": "comparator_32bit", "response": "module subtractor_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output [31:0] diff,\n    output        borrow\n);\n    assign diff = A - B;\n    assign borrow = (A < B);\nendmodule\n\nmodule comparator_32bit(\n    input  [31:0] A,\n    input  [31:0] B,\n    output        A_greater,\n    output        A_equal,\n    output        A_less\n);\n    wire [31:0] diff;\n    wire borrow;\n    \n    subtractor_32bit sub_inst(\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow(borrow)\n    );\n    \n    assign A_less    = borrow;\n    assign A_equal   = ~borrow && (diff == 32'd0);\n    assign A_greater = ~borrow && (diff != 32'd0);\n    \nendmodule"}
{"task_id": "adder_32bit", "response": ""}
{"task_id": "adder_16bit_csa", "response": "module full_adder(\n    input  a,\n    input  b,\n    input  cin,\n    output sum,\n    output cout\n);\n    assign sum  = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule\n\nmodule ripple_carry_adder_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire c1, c2, c3;\n    \n    full_adder fa0 (\n        .a(a[0]),\n        .b(b[0]),\n        .cin(cin),\n        .sum(sum[0]),\n        .cout(c1)\n    );\n    \n    full_adder fa1 (\n        .a(a[1]),\n        .b(b[1]),\n        .cin(c1),\n        .sum(sum[1]),\n        .cout(c2)\n    );\n    \n    full_adder fa2 (\n        .a(a[2]),\n        .b(b[2]),\n        .cin(c2),\n        .sum(sum[2]),\n        .cout(c3)\n    );\n    \n    full_adder fa3 (\n        .a(a[3]),\n        .b(b[3]),\n        .cin(c3),\n        .sum(sum[3]),\n        .cout(cout)\n    );\nendmodule\n\nmodule csa_slice_4bit(\n    input  [3:0] a,\n    input  [3:0] b,\n    input        cin,\n    output [3:0] sum,\n    output       cout\n);\n    wire [3:0] sum0, sum1;\n    wire       cout0, cout1;\n    \n    // Compute with carry-in 0\n    ripple_carry_adder_4bit rca0 (\n        .a(a),\n        .b(b),\n        .cin(1'b0),\n        ."}
{"task_id": "adder_16bit", "response": "module add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    wire carry;\n\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(carry)\n    );\n\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(carry),\n        .y(y[15:8]),\n        .Co(Co)\n    );\nendmodule"}
{"task_id": "adder_8bit", "response": "module full_adder(\n    input a,\n    input b,\n    input cin,\n    output sum,\n    output cout\n);\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (cin & (a ^ b));\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a, b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n\n    wire c0, c1, c2, c3, c4, c5, c6;\n\n    full_adder FA0(.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c0));\n    full_adder FA1(.a(a[1]), .b(b[1]), .cin(c0), .sum(sum[1]), .cout(c1));\n    full_adder FA2(.a(a[2]), .b(b[2]), .cin(c1), .sum(sum[2]), .cout(c2));\n    full_adder FA3(.a(a[3]), .b(b[3]), .cin(c2), .sum(sum[3]), .cout(c3));\n    full_adder FA4(.a(a[4]), .b(b[4]), .cin(c3), .sum(sum[4]), .cout(c4));\n    full_adder FA5(.a(a[5]), .b(b[5]), .cin(c4), .sum(sum[5]), .cout(c5));\n    full_adder FA6(.a(a[6]), .b(b[6]), .cin(c5), .sum(sum[6]), .cout(c6));\n    full_adder FA7(.a(a[7]), .b(b[7]), .cin(c6), .sum(sum[7]), .cout(cout));\n\nendmodule"}
{"task_id": "multi_16bit", "response": ""}
