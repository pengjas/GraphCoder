{"task_id": "pe_v_0", "response": "wire [31:0] add_result;\n    wire [31:0] sub_result;\n\n    // Adder Submodule\n    assign add_result = op1 + op2;\n\n    // Subtractor Submodule\n    assign sub_result = op1 - op2;\n\n    // Output the result based on the mode\n    assign result = mode ? sub_result : add_result;\n\nendmodule"}
{"task_id": "pe", "response": "// Multiplier submodule\n    wire [63:0] mult_result;\n    assign mult_result = a * b;\n\n    // Accumulator submodule\n    reg [31:0] current_value;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= mult_result[31:0] + current_value;\n        end\n    end\n\n    // Output\n    assign c = current_value;\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8_inst1 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst2 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst3 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst4 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule\n\nendmodule"}
{"task_id": "pe", "response": "module multiplier (\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    reg [63:0] product_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            product_reg <= 64'b0;\n        else\n            product_reg <= a * b;\n    end\n\n    assign product = product_reg;\nendmodule\n\nmodule accumulator (\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            current_value <= 32'b0;\n        else\n            current_value <= current_value + new_value;\n    end\nendmodule\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8_inst1 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst2 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst3 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst4 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule\n\nendmodule"}
{"task_id": "barrel_shifter_v_22", "response": "input [3:0] A;\ninput [3:0] B;\noutput gt;\noutput lt;\noutput eq;\n\nwire gt_temp;\nwire lt_temp;\nwire eq_temp;\n\n// Compare the most significant bit\nassign gt_temp = (A[3] > B[3]) ? 1'b1 : 1'b0;\nassign lt_temp = (A[3] < B[3]) ? 1'b1 : 1'b0;\nassign eq_temp = (A[3] == B[3]) ? 1'b1 : 1'b0;\n\n// Compare the next significant bit\nassign gt_temp = gt_temp | ((A[2] > B[2]) & eq_temp);\nassign lt_temp = lt_temp | ((A[2] < B[2]) & eq_temp);\nassign eq_temp = eq_temp | ((A[2] == B[2]) & eq_temp);\n\n// Compare the next significant bit\nassign gt_temp = gt_temp | ((A[1] > B[1]) & eq_temp);\nassign lt_temp = lt_temp | ((A[1] < B[1]) & eq_temp);\nassign eq_temp = eq_temp | ((A[1] == B[1]) & eq_temp);\n\n// Compare the least significant bit\nassign gt_temp = gt_temp | ((A[0] > B[0]) & eq_temp);\nassign lt_temp = lt_temp | ((A[0] < B[0]) & eq_temp);\nassign eq_temp = eq_temp | ((A[0] == B[0]) & eq_temp);\n\nassign gt = gt_temp;\nassign lt = lt_temp;\nassign eq = eq_temp;\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module adder_submodule(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 32'b0;\n        end else if (mode) begin\n            result <= op1 - op2;\n        end else begin\n            result <= op1 + op2;\n        end\n    end\nendmodule\n\nmodule subtractor_submodule(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 32'b0;\n        end else if (mode) begin\n            result <= op1 - op2;\n        end else begin\n            result <= op1 + op2;\n        end\n    end\nendmodule\n\nadder_submodule u_adder (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .op1(op1),\n    .op2(op2),\n    .result(result)\n);\n\nsubtractor_submodule u_subtractor (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .op1(op1),\n    .op2(op2),\n    .result(result)\n);\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8_inst1 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst2 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst3 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst4 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule\n\nendmodule"}
{"task_id": "pe", "response": "module multiplier (\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] product\n);\n    reg [63:0] product_reg;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            product_reg <= 64'b0;\n        end else begin\n            product_reg <= a * b;\n        end\n    end\n\n    assign product = product_reg;\nendmodule\n\nmodule accumulator (\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 32'b0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule\n\nendmodule"}
{"task_id": "pe_v_0", "response": "wire [31:0] add_result;\n    wire [31:0] sub_result;\n\n    // Adder Submodule\n    assign add_result = op1 + op2;\n\n    // Subtractor Submodule\n    assign sub_result = op1 - op2;\n\n    // Output the result based on the mode\n    assign result = mode ? sub_result : add_result;\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8_inst1 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst2 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst3 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst4 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule\n\nendmodule"}
{"task_id": "pe", "response": "module multiplier (\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output reg [63:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 64'b0;\n        end else begin\n            result <= a * b;\n        end\n    end\nendmodule\n\nmodule accumulator (\n    input clk,\n    input rst,\n    input [63:0] result,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 32'b0;\n        end else begin\n            current_value <= current_value + result[31:0];\n        end\n    end\nendmodule\n\nendmodule"}
{"task_id": "adder_16bit_v_44", "response": "module mult8_inst1 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst2 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst3 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\nmodule mult8_inst4 (\n    input wire [7:0] x,\n    input wire [7:0] y,\n    output wire [15:0] prod\n);\n    assign prod = x * y;\nendmodule\n\nendmodule"}
{"task_id": "pe_v_0", "response": "module adder_submodule(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else if (mode)\n            result <= op1 - op2;\n        else\n            result <= op1 + op2;\n    end\nendmodule\n\nmodule subtractor_submodule(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 32'b0;\n        else if (mode)\n            result <= op1 - op2;\n        else\n            result <= op1 + op2;\n    end\nendmodule\n\nadder_submodule u_adder (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .op1(op1),\n    .op2(op2),\n    .result(result)\n);\n\nsubtractor_submodule u_subtractor (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .op1(op1),\n    .op2(op2),\n    .result(result)\n);\n\nendmodule"}
