{"task_id": 21, "response": "module serial_to_parallel (\n    input clk,\n    input rst,\n    input serial_in,\n    output [7:0] parallel_out\n);\n    reg [7:0] shift_reg;\n    reg [7:0] buffer_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            shift_reg <= 8'b0;\n            buffer_reg <= 8'b0;\n        end else begin\n            if (load) begin\n                buffer_reg <= shift_reg;\n            end\n            shift_reg <= serial_in;\n        end\n    end\n\n    assign parallel_out = load ? buffer_reg : 8'b0;\n\nendmodule"}
{"task_id": 21, "response": "module serial_to_parallel (\n    input clk,\n    input rst,\n    input serial_in,\n    input load,\n    output [7:0] parallel_out\n);\n\n    // Submodule for serial-to-parallel converter\n    reg [7:0] shift_reg;\n    reg [7:0] parallel_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            shift_reg <= 8'b000000;\n            parallel_reg <= 8'b000000;\n        end else begin\n            shift_reg <= serial_in;\n            parallel_reg <= shift_reg;\n        end\n    end\n\n    assign parallel_out = parallel_reg;\n\nendmodule"}
{"task_id": 21, "response": "module serial_to_parallel (\n    input clk,\n    input rst,\n    input serial_in,\n    output [7:0] parallel_out\n);\n    reg [7:0] shift_reg;\n    reg [7:0] buffer_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            shift_reg <= 8'b0;\n            buffer_reg <= 8'b0;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load) begin\n            shift_reg <= serial_in;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (load) begin\n            buffer_reg <= shift_reg;\n        end\n    end\n    end\n\n    assign parallel_out = buffer_reg;\n\nendmodule"}
{"task_id": 22, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] num_data,\n    input [7:0] ctrl_data,\n    output [15:0] num_out,\n    output [7:0] ctrl_out\n);\n\n    // Submodules\n    wire [15:0] num_out_mux;\n    wire [7:0] ctrl_out_mux;\n\n    // Instantiate submodules\n    num_mux num_mux_inst (.clk(clk), .rst(rst), .sel(sel), .num_data(num_data), .num_out(num_out_mux));\n    ctrl_mux ctrl_mux_inst (.clk(clk), .rst(rst), .sel(sel), .ctrl_data(ctrl_data), .ctrl_out(ctrl_out_mux));\n\n    // Output assignments\n    assign num_out = num_out_mux;\n    assign ctrl_out = ctrl_out_mux;\n\nendmodule\n\n// Submodule for routing numerical data\nmodule num_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] num_data,\n    output reg [15:0] num_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            num_out <= 0;\n        end else begin\n            case (sel)\n                2'b00: num_out <= num_data;\n                2'b01: num_out <= 0;\n                default: num_out <= num_out; // Maintain current value\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for routing control data\nmodule ctrl_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] ctrl_data,\n    output reg [7:0] ctrl_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ctrl_out <= 0;\n        end else begin\n            case (sel)\n                2'b00: ctrl_out <= ctrl_data;\n                2'b01: ctrl_out <= 0;\n                default: ctrl_out <= ctrl_out; // Maintain current value\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 22, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] num_data,\n    input [7:0] ctrl_data,\n    output [15:0] num_out,\n    output [7:0] ctrl_out\n);\n\n    // Submodule instances\n    wire [15:0] num_out_mux;\n    wire [7:0] ctrl_out_mux;\n\n    // Submodule instantiations\n    num_mux num_mux_inst (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[0]),\n        .num_data(num_data),\n        .num_out(num_out_mux)\n    );\n\n    ctrl_mux ctrl_mux_inst (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[1]),\n        .ctrl_data(ctrl_data),\n        .ctrl_out(ctrl_out_mux)\n    );\n\n    // Output assignments\n    assign num_out = num_out_mux;\n    assign ctrl_out = ctrl_out_mux;\n\nendmodule\n\n// Submodule implementation\nmodule num_mux (\n    input clk,\n    input rst,\n    input sel,\n    input [15:0] num_data,\n    output reg [15:0] num_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            num_out <= 0;\n        end else if (sel) begin\n            num_out <= num_data;\n        end\n    end\n\nendmodule\n\nmodule ctrl_mux (\n    input clk,\n    input rst,\n    input sel,\n    input [7:0] ctrl_data,\n    output reg [7:0] ctrl_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ctrl_out <= 0;\n        end else if (sel) begin\n            ctrl_out <= ctrl_data;\n        end\n    end\n\nendmodule"}
{"task_id": 22, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] num_data,\n    input [7:0] ctrl_data,\n    output [15:0] num_out,\n    output [7:0] ctrl_out\n);\n\n    // Submodule instances\n    wire [15:0] num_out_mux;\n    wire [7:0] ctrl_out_mux;\n\n    // Data multiplexer\n    num_mux_subnum num_mux (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[0]),\n        .num_data(num_data),\n        .num_out(num_out_mux)\n    );\n\n    // Control multiplexer\n    ctrl_mux_subnum ctrl_mux (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[1]),\n        .ctrl_data(ctrl_data),\n        .ctrl_out(ctrl_out_mux)\n    );\n\n    // Output assignments\n    assign num_out = num_out_mux;\n    assign ctrl_out = ctrl_out_mux;\n\nendmodule\n\n// Submodule for data multiplexer\nmodule num_mux_subnum (\n    input clk,\n    input rst,\n    input sel,\n    input [15:0] num_data,\n    output reg [15:0] num_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            num_out <= 0;\n        end else if (sel) begin\n            num_out <= num_data;\n        end\n    end\n\nendmodule\n\n// Submodule for control data multiplexer\nmodule ctrl_mux_subnum (\n    input clk,\n    input rst,\n    input sel,\n    input [7:0] ctrl_data,\n    output reg [7:0] ctrl_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ctrl_out <= 0;\n        end else if (sel) begin\n            ctrl_out <= ctrl_data;\n        end\n    end\n\nendmodule"}
{"task_id": 23, "response": "module clock_divider (\n    input clk,\n    input rst,\n    input [1:0] div_select,\n    output clk_out\n);\n\n    wire clk_div2, clk_div4, clk_div8;\n\n    // Submodule for dividing clock by 2\n    assign clk_div2 = clk; // Direct assignment\n\n    // Submodule for dividing clock by 4\n    assign clk_div4 = clk / 2; // Direct assignment\n    // Submodule for dividing clock by 8\n    assign clk_div8 = clk_div2 / 2; // Direct assignment\n\n    // Active submodule based on div_select input\n    assign clk_out = (div_select == 2'b00) ? clk_div2 :\n                       (div_select == 2'b01) ? clk_div4 : clk_div8;\n\nendmodule"}
{"task_id": 23, "response": "module clock_divider (\n    input clk,\n    input rst,\n    input [1:0] div_select,\n    output clk_out\n);\n\n    wire clk2, clk4, clk8;\n\n    // Submodule for dividing clock by 2\n    assign clk2 = clk;\n\n    // Submodule for dividing clock by 4\n    assign clk4 = clk;\n\n    // Submodule for dividing clock by 8\n    assign clk8 = clk;\n\nendmodule"}
{"task_id": 14, "response": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input sensor_main,\n    input sensor_side,\n    output [1:0] light_main,\n    output [1:0] light_side\n);\n\n    // Submodule for main road traffic light\n    wire [1:0] main_light;\n    main_road_ctrl main_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sensor_main(sensor_main),\n        .main_light(main_light)\n    );\n\n    // Submodule for side road traffic light\n    wire [1:0] side_light;\n    side_road_ctrl side_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sensor_side(sensor_side),\n        .side_light(side_light)\n    );\n\n    // Output signals\n    assign light_main = main_light;\n    assign light_side = side_light;\n\nendmodule\n\n// Submodule for main road traffic light\nmodule main_road_ctrl (\n    input clk,\n    input rst,\n    input sensor_main,\n    output reg [1:0] main_light\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            main_light <= 2'b00; // Set to red\n        end else begin\n            if (sensor_main) begin\n                main_light <= 2'b01; // Set to green\n            end else begin\n                main_light <= 2'b10; // Set to yellow\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for side road traffic light\nmodule side_road_ctrl (\n    input clk,\n    input rst,\n    input sensor_side,\n    output reg [1:0] side_light\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            side_light <= 2'b00; // Set to red\n        end else begin\n            if (sensor_side) begin\n                side_light <= 2'b01; // Set to green\n            end else begin\n                side_light <= 2'b10; // Set to yellow\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 7, "response": "module arithmetic_unit (\n    input clk,\n    input rst,\n    input [0:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output [15:0] result\n);\n\n    wire [15:0] add_result, mult_result;\n\n    // Addition submodule\n    wire [15:0] add_out;\n    wire [15:0] add_out;\n\n    // Multiplication submodule\n    wire [15:0] mult_out;\n    wire [15:0] mult_out_2;\n\n    // Addition submodule\n    wire [15:0] add_out_3;\n    wire [15:0] add_out_4;\n\n    // Instantiate submodules\n    adder_module adder (\n        .clk(clk),\n        .rst(rst),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(add_out)\n    );\n\n    multiplier_module mult (\n        .clk(clk),\n        .rst(rst),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(mult_out)\n    );\n\n    // Select output based on control signal\n    assign add_out = (ctrl == 2'b00) ? add_out_3 : add_out_4;\n    assign mult_out = (ctrl == 2'b00) ? mult_out_2 : mult_out;\n\n    // Output result\n    assign result = (ctrl == 2'b00) ? add_out : mult_out;\n\nendmodule\n\n// Addition submodule\nmodule adder_module (\n    input clk,\n    input rst,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= operand1 + operand2;\n        end\n    end\n\nendmodule\n\n// Multiplication submodule\nmodule multiplier_module (\n    input clk,\n    input rst,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= operand1 * operand2;\n        end\n    end\n\nendmodule"}
{"task_id": 23, "response": "module clock_divider (\n    input clk,\n    input rst,\n    input [1:0] div_select,\n    output clk_out\n);\n\n    wire clk1, clk2, clk4, clk8;\n\n    // Submodule for dividing by 2\n    assign clk1 = clk;\n\n    // Submodule for dividing by 4\n    assign clk2 = clk;\n    assign clk2 = clk;\n    assign clk2 = clk;\n    // Submodule for dividing by 8\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk4 = clk;\n    assign clk_out = clk"}
{"task_id": 7, "response": "module arithmetic_unit (\n    input clk,\n    input rst,\n    input [0:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output [15:0] result\n);\n\n    wire [15:0] adder_result, multiplier_result;\n\n    adder_module adder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(adder_result)\n    );\n\n    multiplier_module multiplier (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(multiplier_result)\n    );\n\n    assign result = (ctrl == 2'b00) ? adder_result : multiplier_result;\n\nendmodule\n\nmodule adder_module (\n    input clk,\n    input rst,\n    input [0:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 16'd0;\n        end else begin\n            result <= operand1 + operand2;\n        end\n    end\n\nendmodule\n\nmodule multiplier_module (\n    input clk,\n    input rst,\n    input [0:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [15:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 16'd0;\n        end else begin\n            result <= operand1 * operand2;\n        end\n    end\n\nendmodule"}
{"task_id": 14, "response": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input sensor_main,\n    input sensor_side,\n    output [1:0] light_main,\n    output [1:0] light_side\n);\n\n    // Submodules for main and side roads\n    main_road_ctrl main_road_ctrl0 (\n        .clk(clk),\n        .rst(rst),\n        .sensor_main(sensor_main),\n        .light_main(light_main)\n    );\n\n    side_road_ctrl side_road_ctrl0 (\n        .clk(clk),\n        .rst(rst),\n        .sensor_side(sensor_side),\n        .light_side(light_side)\n    );\n\nendmodule\n\n// Submodule for main road traffic light controller\nmodule main_road_ctrl (\n    input clk,\n    input rst,\n    input sensor_main,\n    output reg [1:0] light_main\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_main <= 2'b00; // Red light\n        end else begin\n            if (sensor_main) begin\n                light_main <= 2'b01; // Green light\n            end else begin\n                light_main <= 2'b10; // Yellow light\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for side road traffic light controller\nmodule side_road_ctrl (\n    input clk,\n    input rst,\n    input sensor_side,\n    output reg [1:0] light_side\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_side <= 2'b00; // Red light\n        end else begin\n            if (sensor_side) begin\n                light_side <= 2'b01; // Green light\n            end else begin\n                light_side <= 2'b10; // Yellow light\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 0, "response": "module clock_divider (\n    input clk_high,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodule 1: Divide by 2\n    wire clk_div2;\n    divider_by_2 divider1 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div2)\n    );\n\n    // Submodule 2: Divide by 4\n    wire clk_div4;\n    divider_by_4 divider2 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div4)\n    );\n\n    // Submodule 3: Divide by 8\n    wire clk_div8;\n    divider_by_8 divider3 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div8)\n    );\n\n    // Output clocks\n    assign clk_out1 = clk_div2;\n    assign clk_out2 = clk_div4;\n    assign clk_out3 = clk_div8;\n\nendmodule\n\n// Submodule to divide clock by 2\nmodule divider_by_2 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            count <= 3'b000;\n            clk_out <= 1'b0;\n        end else begin\n            if (count == 3'b100) begin\n                count <= 3'b000;\n                clk_out <= ~clk_out;\n            end else begin\n                count <= count + 1'b1;\n                clk_out <= clk_out;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule to divide clock by 4\nmodule divider_by_4 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            count <= 3'b000;\n            clk_out <= 1'b0;\n        end else begin\n            if (count == 3'b100) begin\n                count <= 3'b000;\n                clk_out <= ~clk_out;\n            end else begin\n                count <= count + 1'b1;\n                clk_out <= clk_out;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule to divide clock by 8\nmodule divider_by_8 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    reg [2:0] count;\n\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            count <= 3'b000;\n            clk_out <= 1'b0;\n        end else begin\n            if (count == 3'b100) begin\n                count <= 3'b000;\n                clk_out <= ~clk_out;\n            end else begin\n                count <= count + 1'b1;\n                clk_out <= clk_out;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 7, "response": "module arithmetic_unit (\n    input clk,\n    input rst,\n    input [0:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output [15:0] result\n);\n\n    wire [15:0] add_result, mult_result;\n\n    // Addition submodule\n    wire [15:0] add_out;\n    assign add_out = operand1 + operand2;\n\n    // Multiplication submodule\n    wire [15:0] mult_out;\n    wire [15:0] mult_operand1 = operand1;\n    wire [15:0] mult_operand2 = operand2;\n\n    // Addition submodule\n    wire [15:0] add_operand1 = operand1;\n    wire [15:0] add_operand2 = operand2;\n\n    // Instantiate submodules based on control signal\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            if (ctrl == 2'b00) begin\n                // Multiplication submodule\n                mult_out = mult_operand1 * mult_operand2;\n            end else begin\n                // Addition submodule\n                add_out = add_operand1 + add_operand2;\n            end\n        end\n    end\n\n    // Output result\n    assign result = (ctrl == 2'b00) ? mult_out : add_out;\n\nendmodule"}
{"task_id": 24, "response": "module bit_manip_unit (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [8:0] result_add,\n    output [7:0] result_and,\n    output [7:0] result_xor\n);\n\n    // Submodules\n    adder adder_submodule (\n        input clk,\n        input rst,\n        input [7:0] data1,\n        input [7:0] data2,\n        output [8:0] result\n    );\n\n    and_gate and_gate_submodule (\n        input clk,\n        input rst,\n        input [7:0] data1,\n        input [7:0] data2,\n        output [7:0] result\n    );\n\n    xor_gate xor_gate_submodule (\n        input clk,\n        input rst,\n        input [7:0] data1,\n        input [7:0] data2,\n        output [7:0] result\n    );\n\n    // Output assignments\n    assign result_add = adder_submodule.result;\n    assign result_and = and_gate_submodule.result;\n    assign result_xor = xor_gate_submodule.result;\n\nendmodule\n\n// Submodule for addition\nmodule adder (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [8:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= data1 + data2;\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise AND\nmodule and_gate (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= data1 & data2;\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise XOR\nmodule xor_gate (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= data1 ^ data2;\n        end\n    end\n\nendmodule"}
{"task_id": 14, "response": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input sensor_main,\n    input sensor_side,\n    output [1:0] light_main,\n    output [1:0] light_side\n);\n\n    // Submodule for main road traffic light\n    wire [1:0] light_main_int;\n    main_road_ctrl main_road_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sensor_state(sensor_main),\n        .light_out(light_main_int)\n    );\n\n    // Submodule for side road traffic light\n    wire [1:0] light_side_int;\n    side_road_ctrl side_road_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .sensor_state(sensor_side),\n        .light_out(light_side_int)\n    );\n\n    // Output signals\n    assign light_main = light_main_int;\n    assign light_side = light_side_int;\n\nendmodule\n\n// Submodule for main road traffic light\nmodule main_road_ctrl (\n    input clk,\n    input rst,\n    input sensor_state,\n    output reg [1:0] light_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_out <= 2'b00; // Reset to red\n        end else begin\n            if (sensor_state) begin\n                light_out <= 2'b01; // Green\n            end else begin\n                light_out <= 2'b10; // Yellow\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for side road traffic light\nmodule side_road_ctrl (\n    input clk,\n    input rst,\n    input sensor_state,\n    output reg [1:0] light_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_out <= 2'b00; // Reset to red\n        end else begin\n            if (sensor_state) begin\n                light_out <= 2'b01; // Green\n            end else begin\n                light_out <= 2'b10; // Yellow\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 0, "response": "module clock_divider (\n    input clk_high,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodule for dividing clock by 2\n    wire clk_div2;\n    divider_2 divider_2 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div2)\n    );\n\n    // Submodule for dividing clock by 4\n    wire clk_div4;\n    divider_4 divider_4 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div4)\n    );\n\n    // Submodule for dividing clock by 8\n    wire clk_div8;\n    divider_8 divider_8 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div8)\n    );\n\n    // Assign output clocks\n    assign clk_out1 = clk_div2;\n    assign clk_out2 = clk_div4;\n    assign clk_out3 = clk_div8;\n\nendmodule\n\n// Submodule for dividing clock by 2\nmodule divider_2 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 1'b0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\n// Submodule for dividing clock by 4\nmodule divider_4 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 1'b0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\n// Submodule for dividing clock by 8\nmodule divider_8 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 1'b0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule"}
{"task_id": 8, "response": "module multi_mux (\n    input [1:0] sel,\n    input [7:0] data0,\n    input [15:0] data1,\n    input [3:0] data2,\n    output [15:0] out\n);\n\n    wire [15:0] out0, out1, out2;\n\n    // Submodules\n    mux_sub mux0 (\n        .sel(sel),\n        .data0(data0),\n        .out(out0)\n    );\n\n    mux_sub mux1 (\n        .sel(sel),\n        .data1(data1),\n        .out(out1)\n    );\n\n    mux_sub mux2 (\n        .sel(sel),\n        .data2(data2),\n        .out(out2)\n    );\n\n    // Output\n    assign out = (sel == 2'b00) ? out0 :\n                  (sel == 2'b01) ? out1 :\n                  (sel == 2'b10) ? out2 : 16'b0;\n\nendmodule\n\n// Submodule for multiplexer\nmodule mux_sub (\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            2'b00: out = data;\n            2'b01: out = 16'h0000;\n            2'b10: out = 16'h0000;\n            default: out = 16'h0000;\n        endcase\n    end\n\nendmodule"}
{"task_id": 8, "response": "module multi_mux (\n    input [1:0] sel,\n    input [7:0] data0,\n    input [15:0] data1,\n    input [3:0] data2,\n    output [15:0] out\n);\n\n    wire [15:0] out0, out1, out2;\n\n    // Submodule 1: Selector\n    assign out = (sel == 2'b00) ? data0 :\n                    (sel == 2'b01) ? data1 :\n                    (sel == 2'b10) ? data2 :\n                    16'h000;\n\n    // Submodule 2: Multiplexer\n    assign out0 = (sel == 2'b00) ? data0 : 16'h000;\n    assign out1 = (sel == 2'b01) ? data1 : 16'h000;\n    assign out2 = (sel == 2'b10) ? data2 : 16'h000;\n\nendmodule\n```"}
{"task_id": 24, "response": "module bit_manip_unit (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [8:0] result_add,\n    output [7:0] result_and,\n    output [7:0] result_xor\n);\n\n    wire [8:0] add_out, and_out, xor_out;\n\n    // Submodule for addition\n    adder adder_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .result(add_out)\n    );\n\n    // Submodule for bitwise AND\n    and_gate and_gate_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .result(and_out)\n    );\n\n    // Submodule for bitwise XOR\n    xor_gate xor_gate_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .result(xor_out)\n    );\n\n    // Output selection\n    assign result_add = (op_sel == 2'b000) ? add_out : 9'd0;\n    assign result_and = (op_sel == 2'b01) ? and_out : 8'd0;\n    assign result_xor = (op_sel == 2'b10) ? xor_out : 8'd0;\n\nendmodule\n\n// Submodule for addition\nmodule adder (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [8:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 9'd0; // Reset output\n        end else begin\n            result <= data1 + data2; // Addition operation\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise AND\nmodule and_gate (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset output\n        end else begin\n            result <= data1 & data2; // Bitwise AND operation\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise XOR\nmodule xor_gate (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset output\n        end else begin\n            result <= data1 ^^ data2; // Bitwise XOR operation\n        end\n    end\nend\n\nendmodule"}
{"task_id": 0, "response": "module clock_divider (\n    input clk_high,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodules\n    wire clk_div2, clk_div4, clk_div8;\n\n    // Divide by 2\n    divider_2 div2 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div2)\n    );\n\n    // Divide by 4\n    divider_4 div4 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div4)\n    );\n\n    // Divide by 8\n    divider_8 div8 (\n        .clk_high(clk_high),\n        .rst(rst),\n        .clk_out(clk_div8)\n    );\n\n    // Output clocks\n    assign clk_out1 = clk_div2;\n    assign clk_out2 = clk_div4;\n    assign clk_out3 = clk_div8;\n\nendmodule\n\n// Submodule to divide clock frequency by 2\nmodule divider_2 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count < 2) begin\n                count <= count + 1;\n                clk_out <= 0;\n            end else begin\n                count <= 0;\n                clk_out <= 1;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule to divide clock frequency by 4\nmodule divider_4 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count < 4) begin\n                count <= count + 1;\n                clk_out <= 0;\n            end else begin\n                count <= 0;\n                clk_out <= 1;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule to divide clock frequency by 8\nmodule divider_8 (\n    input clk_high,\n    input rst,\n    output reg clk_out\n);\n\n    reg [2:0] count;\n\n    always @(posedge clk_high or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n            clk_out <= 0;\n        end else begin\n            if (count < 8) begin\n                count <= count + 1;\n                clk_out <= 0;\n            end else begin\n                count <= 0;\n                clk_out <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 15, "response": "module auth_control (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output auth_success,\n    output auth_fail\n);\n\n    // Submodule for password authentication\n    wire auth_success_pw, auth_fail_pw;\n    wire [15:0] user_data_pw;\n\n    assign user_data_pw = user_data;\n\n    // Password authentication\n    password_auth pass_auth (\n        .clk(clk),\n        .rst(rst),\n        .auth_signal(auth_signal),\n        .user_data(user_data_pw),\n        .auth_success(auth_success),\n        .auth_fail(auth_fail)\n    );\n\n    // Biometric authentication\n    biometric_auth biom_auth (\n        .clk(clk),\n        .rst(rst),\n        .auth_signal(auth_signal),\n        .user_data(user_data_pw),\n        .auth_success(auth_success_pw),\n        .auth_fail(auth_fail_pw)\n    );\n\n    // Output assignments\n    assign auth_success = auth_success_pw;\n    assign auth_fail = auth_fail_pw;\n\nendmodule\n\n// Submodule for password authentication\nmodule password_auth (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output reg auth_success,\n    output reg auth_fail\n);\n\n    // Local signals\n    reg [15:0] password;\n\n    // Password authentication logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            auth_success <= 1'b0;\n            auth_fail <= 1'b0;\n        end else begin\n            if (auth_signal == 2'b01) begin\n                if (user_data == password) begin\n                    auth_success <= 1'b1;\n                    auth_fail <= 1'b0;\n                end else begin\n                    auth_success <= 1'b0;\n                    auth_fail <= 1'b1;\n                end\n            end else begin\n                auth_success <= 1'b0;\n                auth_fail <= 1'b0;\n            end\n        end\n    end\n\n    // Password\n    initial begin\n        password <= 16'h000; // Default password: 000\n    end\n\nendmodule\n\n// Submodule for biometric authentication\nmodule biometric_auth (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output reg auth_success,\n    output reg auth_fail\n);\n\n    // Local signals\n    reg [15:0] biometric_data;\n\n\n    // Biometric authentication logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            auth_success <= 1'b0;\n            auth_fail <= 1'b0;\n        end else begin\n            if (auth_signal == 2'b10) begin\n                if (user_data < biometric_data) begin\n                    auth_success <= 1'b1;\n                    auth_fail <= 1'b0;\n                end else begin\n                    auth_success <= 1'b0;\n                    auth_fail <= 1'b1;\n                end\n            end else begin\n                auth_success <= 1'b0;\n                auth_fail <= 1'b0;\n            end\n        end\n    end\n\n    // Biometric data\n    initial begin\n        biometric_data <= 6'h00; // Default biometric data: 00000\n    end\n\nendmodule"}
{"task_id": 8, "response": "module multi_mux (\n    input [1:0] sel,\n    input [7:0] data0,\n    input [15:0] data1,\n    input [3:0] data2,\n    output [15:0] out\n);\n\n    // Submodule outputs\n    wire [15:0] out0, out1, out2;\n\n    // Submodule instances\n    multi_mux_sub1 multi_mux1 (.sel(sel),\n        .data0(data0),\n        .data1(data1),\n        .data2(data2),\n        .out(out0));\n\n    multi_mux_sub2 multi_mux2 (.sel(sel),\n                                  .data0(data0),\n                                  .data1(data1),\n                                  .data2(data2),\n                                  .out(out1));\n\n    // Output logic\n    assign out = (sel == 2'b00) ? out0 :\n                   (sel == 2'b01) ? out1 :\n                   (sel == 2'b10) ? out2 : 16'h0;\n\nendmodule\n\n// Submodule 1\nmodule multi_mux_sub1 (\n    input [1:0] sel,\n    input [7:0] data0,\n    input [15:0] data1,\n    input [3:0] data2,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            2'b00: out = data0;\n            2'b01: out = data1;\n            2'b10: out = {data2, data1};\n            default: out = 16'h0;\n        endcase\n    end\n\nendmodule\n\n// Submodule 2\nmodule multi_mux_sub2 (\n    input [1:0] sel,\n    input [7:0] data0,\n    input [15:0] data1,\n    input [3:0] data2,\n    output reg [15:0] out\n);\n\n    always @(*) begin\n        case (sel)\n            2'b00: out = {data2, data1};\n            2'b01: out = data1;\n            2'b10: out = data0;\n            default: out = 16'h0;\n        endcase\n    end\n\nendmodule"}
{"task_id": 9, "response": "module signal_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] sig1,\n    input [7:0] sig2,\n    input [7:0] sig3,\n    output [7:0] out_sig\n);\n\n    wire [7:0] mux_s1, mux_s2, mux_s3;\n\n    // Submodule 1\n    assign mux_s1 = (sel == 2'b00) ? sig1 : 8'd0;\n\n    // Submodule 2\n    assign mux_s2 = (sel == 2'b01) ? sig2 : 8'd0;\n\n    // Submodule 3\n    assign mux_s3 = (sel == 2'b10) ? sig3 : 8'd0;\n\n    // Output signal\n    assign out_sig = (sel == 2'b00) ? mux_s1 :\n                     (sel == 2'b01) ? mux_s2 :\n                     (sel == 2'b10) ? mux_s3 : 8'd0;\n\nendmodule"}
{"task_id": 24, "response": "module bit_manip_unit (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [8:0] result_add,\n    output [7:0] result_and,\n    output [7:0] result_xor\n);\n\n    // Submodules\n    wire [8:0] add_result;\n    wire [7:0] and_result;\n    wire [7:0] xor_result;\n\n    // Addition submodule\n    adder adder_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .result(add_result)\n    );\n\n    // AND submodule\n    and_gate and_gate_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .result(and_result)\n    );\n\n    // XOR submodule\n    xor_gate xor_gate_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .result(xor_result)\n    );\n\n    // Output assignments\n    assign result_add = add_result;\n    assign result_and = and_result;\n    assign result_xor = xor_result;\n\nendmodule\n\n// Submodule for addition\nmodule adder (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [8:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= data1 + data2;\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise AND\nmodule and_gate (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= data1 & data2;\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise XOR\nmodule xor_gate (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n        end else begin\n            result <= data1 ^ data2;\n        end\n    end\n\nendmodule"}
{"task_id": 9, "response": "module signal_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] sig1,\n    input [7:0] sig2,\n    input [7:0] sig3,\n    output [7:0] out_sig\n);\n\n    wire [7:0] mux_s1, mux_s2, mux_s3;\n\n    // Submodule 1\n    assign mux_s1 = (sel == 2'b00) ? sig1 : 8'd0;\n\n    // Submodule 2\n    assign mux_s2 = (sel == 2'b01) ? sig2 : 8'd0;\n\n    // Submodule 3\n    assign mux_s3 = (sel == 2'b10) ? sig3 : 8'd0;\n\n    // Output signal\n    assign out_sig = (sel == 2'b00) ? mux_s1 :\n                     (sel == 2'b01) ? mux_s2 :\n                     (sel == 2'b10) ? mux_s3 : 8'd0;\n\nendmodule"}
{"task_id": 1, "response": "module alarm_system (\n    input clk,\n    input rst,\n    input [3:0] zone_signal,\n    input [7:0] trigger,\n    output [1:0] alarm_type,\n    output [1:0] zone_id,\n    output [7:0] details\n);\n\n    wire [1:0] alarm1_type, zone1_id, alarm2_type, zone2_id;\n    wire [7:0] alarm1_details, alarm2_details;\n\n    zone_handler zone_handler1 (\n        .clk(clk),\n        .rst(rst),\n        .zone_signal(zone_signal),\n        .trigger(trigger),\n        .alarm_type(alarm1_type),\n        .zone_id(zone1_id),\n        .details(alarm1_details)\n    );\n\n    zone_handler zone_handler2 (\n        .clk(clk),\n        .rst(rst),\n        .zone_signal(zone_signal),\n        .trigger(trigger),\n        .alarm_type(alarm2_type),\n        .zone_id(zone2_id),\n        .details(alarm2_details)\n    );\n\n    assign alarm_type = (zone_signal == 4'b0001) ? alarm1_type :\n                      (zone_signal == 4'b0100) ? alarm2_type : 2'b00;\n    assign zone_id = (zone_signal == 4'b0001) ? zone1_id :\n                     (zone_signal == 4'b0100) ? zone2_id : 2'b00;\n    assign details = (zone_signal == 4'b0001) ? alarm1_details :\n                    (zone_signal == 4'b0010) ? alarm2_details : 8'b00000000;\n\nendmodule\n\nmodule zone_handler (\n    input clk,\n    input rst,\n    input [3:0] zone_signal,\n    input [7:0] trigger,\n    output reg [1:0] alarm_type,\n    output reg [1:0] zone_id,\n    output reg [7:0] details\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            alarm_type <= 2'b0;\n            zone_id <= 2'b0;\n            details <= 8'b0;\n        end else begin\n            alarm_type <= (zone_signal == 4'b0001) ? 2'b1 :\n                 (zone_signal == 4'b0010) ? 2'b2 : 2'b0;\n            zone_id <= (zone_signal == 4'b0010) ? 2'b1 : 2'b0;\n            details <= (zone_signal == 4'b0001) ? trigger : 8'b00000000;\n        end\n    end\n\nendmodule"}
{"task_id": 25, "response": "module clock_divider (\n    input clk_high_freq,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodule 1: Divide by 2\n    reg [3:0] clk_out1_reg;\n    always @(posedge) begin\n        if (rst == 1'b0) begin\n            clk_out1_reg <= clk_high_freq / 2;\n        end\n    end\n\n    // Submodule 2: Divide by 4\n    reg [3:0] clk_out2_reg;\n    always @(posedge) begin\n        if (rst == 1'b0) begin\n            clk_out2_reg <= 4'b0;\n        end else begin\n            clk_out2_reg <= clk_out1_reg / 4;\n        end\n    end\n\n    // Submodule 3: Divide by 8\n    reg [3:0] clk_out3_reg;\n    always @(posedge) begin\n        if (rst == 1'b0) begin\n            clk_out3_reg <= 8'b0;\n        end\n        else begin\n            clk_out3_reg <= clk_out2_reg / 8;\n        end\n    end\n\n    // Outputs\n    assign clk_out1 = clk_out1_reg;\n    assign clk_out2 = clk_out2_reg;\n    assign clk_out3 = clk_out3_reg;\n\nendmodule"}
{"task_id": 9, "response": "module signal_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] sig1,\n    input [7:0] sig2,\n    input [7:0] sig3,\n    output [7:0] out_sig\n);\n\n    wire [7:0] mux_s1, mux_s2, mux_s3;\n\n    // Submodule 1\n    assign mux_s1 = (sel == 2'b00) ? sig1 : 8'd0;\n\n    // Submodule 2\n    assign mux_s2 = (sel == 2'b01) ? sig2 : 8'd0;\n\n    // Submodule 3\n    assign mux_s3 = (sel == 2'b10) ? sig3 : 8'd0;\n\n    // Output signal\n    assign out_sig = (sel == 2'b00) ? mux_s1 :\n                   (sel == 2'b01) ? mux_s2 :\n                   (sel == 2'b10) ? mux_s3 : 8'd0;\n\nendmodule"}
{"task_id": 15, "response": "module auth_control (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output auth_success,\n    output auth_fail\n);\n\n    // Submodule outputs\n    wire [0:1] pwd_auth_success, bm_auth_success;\n    wire [0:1] pwd_auth_fail, bm_auth_fail;\n\n    // Submodules\n    password_auth pwd_auth (\n        .clk(clk),\n        .rst(rst),\n        .auth_signal(auth_signal),\n        .user_data(user_data),\n        .auth_success(pwd_auth_success),\n        .auth_fail(pwd_auth_fail)\n    );\n\n    biometric_auth bm_auth (\n        .clk(clk),\n        .rst(rst),\n        .auth_signal(auth_signal),\n        .user_data(user_data),\n        .auth_success(bm_auth_success),\n        .auth_fail(bm_auth_fail)\n    );\n\n    // Output assignments\n    assign auth_success = (auth_signal == 2'b01) ? pwd_auth_success : bm_auth_success;\n    assign auth_fail = (auth_signal == 2'b01) ? pwd_auth_fail : bm_auth_fail;\n\nendmodule\n\n// Submodule for password authentication\nmodule password_auth (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output reg [0:1] auth_success,\n    output reg [0:1] auth_fail\n);\n\n    // Local signals\n    reg [0:1] auth_result;\n\n    // Password authentication logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            auth_success <= 2'b00;\n            auth_fail <= 2'b00;\n        end else begin\n            if (auth_signal == 2'b01) begin\n                if (user_data == 16'h1234) begin\n                    auth_success <= 2'b01;\n                    auth_fail <= 2'b00;\n                end else begin\n                    auth_success <= 2'b00;\n                    auth_fail <= 2'b01;\n                end\n            end else begin\n                auth_success <= 2'b00;\n                auth_fail <= 2'b00;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for biometric authentication\nmodule biometric_auth (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output reg [0:1] auth_success,\n    output reg [0:1] auth_fail\n);\n\n    // Local signals\n    reg [0:1] auth_result;\n\n    // Biometric authentication logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            auth_success <= 2'b00;\n            auth_fail <= 2'b00;\n        end else begin\n            if (auth_signal == 2'b10) begin\n                if (user_data > 16'h1234) begin\n                    auth_success <= 2'b01;\n                    auth_fail <= 2'b00;\n                end else begin\n                    auth_success <= 2'b00;\n                    auth_fail <= 2'b01;\n                end\n            end else begin\n                auth_success <= 2'b00;\n                auth_fail <= 2'b00;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 15, "response": "module auth_control (\n    input clk,\n    input rst,\n    input [1:0] auth_signal,\n    input [15:0] user_data,\n    output auth_success,\n    output auth_fail\n);\n\n    // Submodule for password authentication\n    wire [15:0] password_data;\n    assign password_data = user_data;\n\n    wire password_auth_success;\n    assign password_auth_success = password_auth_success;\n\n    // Submodule for biometric authentication\n    wire [15:0] biometric_data;\n    assign biometric_data = user_data;\n    wire biometric_auth_success;\n    assign biometric_auth_success = biometric_auth_success;\n\n    // Output signals\n    wire [1:0] auth_success_select;\n    assign auth_success_select = (auth_signal == 2'b01) ? password_auth_success : biometric_auth_success;\n\n    // Output assignments\n    assign auth_success = auth_success_select[0];\n    assign auth_fail = auth_success_select[1];\n\nendmodule"}
{"task_id": 25, "response": "module clock_divider (\n    input clk_high_freq,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodule outputs\n    wire clk_out1_sub, clk_out2_sub, clk_out3_sub;\n\n    // Submodule instantiations\n    div2 div2_inst (\n        .clk_in(clk_high_freq),\n        .rst(rst),\n        .clk_out(clk_out1_sub)\n    );\n\n    div4 div4_inst (\n        .clk_in(clk_high_freq),\n        .rst(rst),\n        .clk_out(clk_out2_sub)\n    );\n\n    div8 div8_inst (\n        .clk_in(clk_high_freq),\n        .rst(rst),\n        .clk_out(clk_out3_sub)\n    );\n\n    // Output assignments\n    assign clk_out1 = clk_out1_sub;\n    assign clk_out2 = clk_out2_sub;\n    assign clk_out3 = clk_out3_sub;\n\nendmodule\n\n// Submodule implementation\nmodule div2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_in or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= clk_in / 2;\n        end\n    end\n\nendmodule\n\nmodule div4 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_in or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= clk_in / 4;\n        end\n    end\n\nendmodule\n\nmodule div8 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_in or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= clk_in / 8;\n        end\n    end\n\nendmodule"}
{"task_id": 10, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [7:0] output_a,\n    output [7:0] output_b\n);\n\n    wire [7:0] mux_path_a, mux_path_b;\n\n    // Submodule for data routing\n    data_mux_path mux_path_a (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data_a),\n        .output(mux_path_a)\n    );\n\n    data_mux_path mux_path_b (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data_b),\n        .output(mux_path_b)\n    );\n\n    // Output selection logic\n    assign output_a = (sel == 2'b00) ? mux_path_a : mux_path_b;\n    assign output_b = (sel == 2'b00) ? mux_path_b : mux_path_a;\n\nendmodule\n\n// Submodule for data routing\nmodule data_mux_path (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0;\n        end else begin\n            output <= data_in[7:0];\n        end\n    end\n\nendmodule"}
{"task_id": 1, "response": "module alarm_system (\n    input clk,\n    input rst,\n    input [3:0] zone_signal,\n    input [7:0] trigger,\n    output [1:0] alarm_type,\n    output [1:0] zone_id,\n    output [7:0] details\n);\n\n    wire [1:0] alarm1_type, zone1_id, alarm2_type, zone2_id;\n    wire [7:0] alarm1_details, alarm2_details;\n\n    zone_handler zone_handler1 (\n        .clk(clk),\n        .rst(rst),\n        .zone_signal(zone_signal),\n        .trigger(trigger),\n        .alarm_type(alarm1_type),\n        .zone_id(zone1_id),\n        .details(alarm1_details)\n    );\n\n    zone_handler zone_handler2 (\n        .clk(clk),\n        .rst(rst),\n        .zone_signal(zone_signal),\n        .trigger(trigger),\n        .alarm_type(alarm2_type),\n        .zone_id(zone2_id),\n        .details(alarm2_details)\n    );\n\n    assign alarm_type = (zone_signal == 4'b0001) ? alarm1_type :\n                       (zone_signal == 4'b0100) ? alarm2_type : 2'b00;\n    assign zone_id = (zone_signal == 4'b0001) ? zone1_id :\n                      (zone_signal == 4'b0100) ? zone2_id : 2'b00;\n    assign details = (zone_signal == 4'b0001) ? alarm1_details :\n                     (zone_signal == 4'b0010) ? alarm2_details : 8'b0000000;\n\nendmodule\n\n// Submodule for handling alarms from different zones\nmodule zone_handler (\n    input clk,\n    input rst,\n    input [3:0] zone_signal,\n    input [7:0] trigger,\n    output reg [1:0] alarm_type,\n    output reg [1:0] zone_id,\n    output reg [7:0] details\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            alarm_type <= 2'b00;\n            zone_id <= 2'b00;\n            details <= 8'b0000000;\n        end else begin\n            case (zone_signal)\n                4'b0001: begin // Alarm from zone 1\n                    alarm_type <= 2'b01;\n                    zone_id <= 2'b01;\n                    details <= {3'b000, trigger};\n                end\n                4'b0010: begin // Alarm from zone 2\n                    alarm_type <= 2'b10;\n                    zone_id <= 2'b10;\n                    details <= {3'b000, trigger};\n                end\n                default: begin\n                    alarm_type <= 2'b00;\n                    zone_id <= 2'b00;\n                    details <= 8'b0000000;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 10, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [7:0] output_a,\n    output [7:0] output_b\n);\n\n    wire [7:0] mux_path_a, mux_path_b;\n\n    // Submodule for data multiplexing\n    data_mux_path mux_path_a (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data_a),\n        .output(mux_path_a)\n    );\n\n    data_mux_path mux_path_b (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data_b),\n        .output(mux_path_b)\n    );\n\n    // Output selection logic\n    assign output_a = (sel == 2'b00) ? mux_path_a : mux_path_b;\n    assign output_b = (sel == 2'b00) ? mux_path_b : mux_path_a;\n\nendmodule\n\n// Submodule for data multiplexing\nmodule data_mux_path (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0; // Reset output\n        end else begin\n            output <= data_in[7:0]; // Output lower 8 bits\n        end\n    end\n\nendmodule"}
{"task_id": 16, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    input [7:0] d4,\n    output reg [7:0] dout\n);\n\n    wire [7:0] mux_out1, mux_out2, mux_out3, mux_out4;\n\n    // Submodule 1: Data source 1\n    data_source data_src1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d1),\n        .data_out(mux_out1)\n    );\n\n    // Submodule 2: Data source 2\n    data_source data_src2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d2),\n        .data_out(mux_out2)\n    );\n\n    // Submodule 3: Data source 3\n    data_source data_src3 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d3),\n        .data_out(mux_out3)\n    );\n\n    // Submodule 4: Data source 4\n    data_source data_src4 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d4),\n        .data_out(mux_out4)\n    );\n\n    // Multiplexer\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            dout <= 8'd0;\n        end else begin\n            case (sel)\n                2'b00: dout <= mux_out1;\n                2'b01: dout <= mux_out2;\n                2'b10: dout <= mux_out3;\n                2'b11: dout <= mux_out4;\n                default: dout <= 8'd0;\n            endcase\n        end\n    end\n\nendmodule\n\n// Data source submodule\nmodule data_source (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0;\n        end else begin\n            data_out <= data_in;\n        end\n    end\n\nendmodule"}
{"task_id": 25, "response": "module clock_divider (\n    input clk_high_freq,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodule outputs\n    wire clk_out1_sub, clk_out2_sub, clk_out3_sub;\n\n    // Submodule instantiations\n    submodule_div2 submodule_div2 (.clk_high_freq(clk_high_freq), .rst(rst), .clk_out(clk_out1_sub));\n    submodule_div4 submodule_div4 (.clk_high_freq(clk_high_freq), .rst(rst), .clk_out(clk_out2_sub));\n    submodule_div8 submodule_div8 (.clk_high_freq(clk_high_freq), .rst(rst), .clk_out(clk_out3_sub));\n\n    // Output assignments\n    assign clk_out1 = clk_out1_sub;\n    assign clk_out2 = clk_out2_sub;\n    assign clk_out3 = clk_out3_sub;\n\nendmodule\n\n// Submodule implementation\nmodule submodule_div2 (\n    input clk_high_freq,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_high_freq or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 1'b0;\n        end else begin\n            clk_out <= clk_out + 1'b1;\n        end\n    end\n\nendmodule\n\nmodule submodule_div4 (\n    input clk_high_freq,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_high_freq or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 1'b0;\n        end else begin\n            clk_out <= clk_out + 2'b11;\n        end\n    end\n\nendmodule\n\nmodule submodule_div8 (\n    input clk_high_freq,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk_high_freq or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 1'b0;\n        end else begin\n            clk_out <= clk_out + 4'b1111;\n        end\n    end\n\nendmodule"}
{"task_id": 16, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    input [7:0] d4,\n    output reg [7:0] dout\n);\n\n    reg [7:0] d1_reg, d2_reg, d3_reg, d4_reg;\n\n    always @(posedge clk) begin\n        if (~rst) begin\n            d1_reg <= d1;\n            d2_reg <= d2;\n            d3_reg <= d3;\n            d4_reg <= d4;\n        end\n    end\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            dout <= d1_reg;\n        end else if (sel == 2'b01) begin\n            dout <= d2_reg;\n        end else if (sel == 2'b10) begin\n            dout <= d3_reg;\n        end else begin\n            dout <= d4_reg;\n        end\n    end\n\nendmodule"}
{"task_id": 1, "response": "module alarm_system (\n    input clk,\n    input rst,\n    input [3:0] zone_signal,\n    input [7:0] trigger,\n    output [1:0] alarm_type,\n    output [1:0] zone_id,\n    output [7:0] details\n);\n\n    wire [1:0] alarm1_type, zone1_id, alarm2_type, zone2_id;\n    wire [7:0] alarm1_details, alarm2_details;\n\n    zone_handler zone_handler1 (\n        .clk(clk),\n        .rst(rst),\n        .zone_signal(zone_signal),\n        .trigger(trigger),\n        .alarm_type(alarm1_type),\n        .zone_id(zone1_id),\n        .details(alarm1_details)\n    );\n\n    zone_handler zone_handler2 (\n        .clk(clk),\n        .rst(rst),\n        .zone_signal(zone_signal),\n        .trigger(trigger),\n        .alarm_type(alarm2_type),\n        .zone_id(zone2_id),\n        .details(alarm2_details)\n    );\n\n    assign alarm_type = (zone_signal == 4'b0001) ? alarm1_type :\n                       (zone_signal == 4'b0100) ? alarm2_type : 2'b00;\n    assign zone_id = (zone_signal == 4'b0001) ? zone1_id :\n                       (zone_signal == 4'b0100) ? zone2_id : 2'b00;\n    assign details = (zone_signal == 4'b0001) ? alarm1_details :\n                      (zone_signal == 4'b0010) ? alarm2_details : 8'b00000000;\n\nendmodule\n\nmodule zone_handler (\n    input clk,\n    input rst,\n    input [3:0] zone_signal,\n    input [7:0] trigger,\n    output reg [1:0] alarm_type,\n    output reg [1:0] zone_id,\n    output reg [7:0] details\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            alarm_type <= 2'b0;\n            zone_id <= 2'b0;\n            details <= 8'b000000000;\n        end else begin\n            if (zone_signal == 4'b0001) begin\n                alarm_type <= 2'b01;\n                zone_id <= 2'b01;\n                details <= 8'b0000000;\n            end else if (zone_signal == 4'b0010) begin\n                alarm_type <= 2'b02;\n                zone_id <= 2'b02;\n                details <= 8'b0000000;\n            end else begin\n                alarm_type <= 2'b00;\n                zone_id <= 2'b00;\n                details <= 8'b0000000;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 10, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [7:0] output_a,\n    output [7:0] output_b\n);\n\n    wire [7:0] mux_path_a, mux_path_b;\n\n    // Submodule for data multiplexing\n    data_mux_a data_mux_a (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data_a),\n        .output(mux_path_a)\n    );\n\n    data_mux_b data_mux_b (\n        .clk(clk),\n        .rst(rst),\n        .data_in(data_b),\n        .output(mux_path_b)\n    );\n\n    // Submodule for data routing\n    data_router data_router_a (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(mux_path_a),\n        .output(output_a)\n    );\n\n    data_router data_router_b (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(mux_path_b),\n        .output(output_b)\n    );\n\nendmodule\n\n// Submodule for data multiplexing\nmodule data_mux_a (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0;\n        end else begin\n            output <= data_in[7:0];\n        end\n    end\n\nendmodule\n\n// Submodule for data multiplexing\nmodule data_mux_b (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0;\n        end else begin\n            output <= data_in[15:8];\n        end\n    end\n\nendmodule\n\n// Submodule for data routing\nmodule data_router (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] output\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output <= 8'd0;\n        end else begin\n            case (sel)\n                2'b00: output <= data_in;\n                2'b01: output <= data_in;\n                default: output <= 8'd0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 16, "response": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    input [7:0] d4,\n    output reg [7:0] dout\n);\n\n    reg [7:0] d1_out, d2_out, d3_out, d4_out;\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            d1_out <= d1;\n            d2_out <= d2;\n            d3_out <= d3;\n            d4_out <= d4;\n        end else if (sel == 2'b01) begin\n            d1_out <= d1;\n            d2_out <= d2;\n            d3_out <= d3;\n            d4_out <= d4;\n        end else if (sel == 2'b10) begin\n            d1_out <= d1;\n            d2_out <= d2;\n            d3_out <= d3;\n            d4_out <= d4;\n        end else begin\n            d1_out <= d1;\n            d2_out <= d2;\n            d3_out <= d3;\n            d4_out <= d4;\n        end\n    end\n\n    assign dout = (sel == 2'b00) ? d1_out :\n                  (sel == 2'b01) ? d2_out :\n                  (sel == 2'b10) ? d3_out : d4_out;\n\nendmodule"}
{"task_id": 11, "response": "module dual_mode_counter (\n    input clk,\n    input rst,\n    input mode,\n    input enable,\n    output reg [7:0] count\n);\n\n    wire [7:0] up_count, down_count;\n\n    // Submodule for up-counting\n    up_counter up_count_sub (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .count(up_count)\n    );\n\n    // Submodule for down-counting\n    down_counter down_count_sub (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .count(down_count)\n    );\n\n    // Output logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n        end else if (enable) begin\n            if (mode == 1'b0) begin\n                count <= up_count;\n            end else if (mode == 1'b1) begin\n                count <= down_count;\n            end else begin\n                count <= count;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 26, "response": "module data_router (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] chan1,\n    output reg [7:0] chan2,\n    output reg [7:0] chan3\n);\n\n    wire [7:0] chan1_out, chan2_out, chan3_out;\n\n    // Channel 1 routing\n    channel1_module channel1_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data(data),\n        .ch_out(chan1_out)\n    );\n\n    // Channel 2 routing\n    channel2_module channel2_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data(data),\n        .ch_out(chan2_out)\n    );\n\n    // Channel 3 routing\n    channel3_module channel3_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data(data),\n        .ch_out(chan3_out)\n    );\n\n    // Output assignments\n    assign chan1 = chan1_out;\n    assign chan2 = chan2_out;\n    assign chan3 = chan3_out;\n\nendmodule\n\n// Channel 1 routing module\nmodule channel1_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] ch_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ch_out <= 8'd0;\n        end else begin\n            case (ctrl)\n                2'b00: ch_out <= data;\n                2'b01: ch_out <= data;\n                2'b10: ch_out <= data;\n                default: ch_out <= ch_out;\n            endcase\n        end\n    end\n\nendmodule\n\n// Channel 2 routing module\nmodule channel2_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] ch_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ch_out <= 8'd0;\n        end else begin\n            case (ctrl)\n                2'b00: ch_out <= data;\n                2'b01: ch_out <= data;\n                2'b10: ch_out <= data;\n                default: ch_out <= ch_out;\n            endcase\n        end\n    end\n\nendmodule\n\n// Channel 3 routing module\nmodule channel3_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] ch_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ch_out <= 8'd0;\n        end else begin\n            case (ctrl)\n                2'b00: ch_out <= data;\n                2'b01: ch_out <= data;\n                2'b10: ch_out <= data;\n                default: ch_out <= ch_out;\n            endcase\n        end\n    end\n    end\nend\nendmodule"}
{"task_id": 2, "response": "module traffic_light_ctrl (\n    input clk,\n    input rst,\n    input ped_request,\n    input [5:0] timer,\n    output [1:0] main_light,\n    output [1:0] side_light,\n    output walk_sign\n);\n\n    // Submodules\n    wire [1:0] main_light_sub;\n    wire [1:0] side_light_sub;\n    wire ped_walk_sub;\n\n    // Main Road Traffic Light Controller\n    main_road_traffic_light main_road_light_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .timer(timer),\n        .ped_request(ped_request),\n        .main_light_out(main_light_sub),\n        .side_light_out(side_light_sub),\n        .ped_walk_out(ped_walk_sub)\n    );\n\n    // Side Road Traffic Light Controller\n    side_road_traffic_light side_road_light_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .timer(timer),\n        .ped_request(ped_request),\n        .main_light_in(main_light_sub),\n        .side_light_out(side_light_sub),\n        .ped_walk_out(ped_walk_sub)\n    );\n\n    // Pedestrian Traffic Light Controller\n    pedestrian_traffic_light pedestrian_light_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .ped_request(ped_request),\n        .main_light_in(main_light_sub),\n        .side_light_in(side_light_sub),\n        .ped_walk_out(ped_walk_sub)\n    );\n\n    // Output assignments\n    assign main_light = main_light_sub;\n    assign side_light = side_light_sub;\n    assign walk_sign = ped_walk_sub;\n\nendmodule\n\n// Submodule for Main Road Traffic Light Controller\nmodule main_road_traffic_light (\n    input clk,\n    input rst,\n    input [5:0] timer,\n    input ped_request,\n    output reg [1:0] main_light_out,\n    output reg [1:0] side_light_out,\n    output reg ped_walk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            main_light_out <= 2'b00;\n            side_light_out <= 2'b00;\n            ped_walk_out <= 1'b0;\n        end else begin\n            if (ped_request) begin\n                main_light_out <= 2'b00;\n                side_light_out <= 2'b00;\n                ped_walk_out <= 1'b1;\n            end else begin\n                if (timer >= 6) begin\n                    main_light_out <= 2'b01;\n                    side_light_out <= 2'b01;\n                    ped_walk_out <= 1'b0;\n                end else begin\n                    main_light_out <= 2'b00;\n                    side_light_out <= 2'b00;\n                    ped_walk_out <= 1'b0;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for Side Road Traffic Light Controller\nmodule side_road_traffic_light (\n    input clk,\n    input rst,\n    input [5:0] timer,\n    input ped_request,\n    input [1:0] main_light_in,\n    input [1:0] side_light_in,\n    output reg [1:0] main_light_out,\n    output reg [1:0] side_light_out,\n    output reg ped_walk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            main_light_out <= 2'b00;\n            side_light_out <= 2'b00;\n            ped_walk_out <= 1'b0"}
{"task_id": 11, "response": "module dual_mode_counter (\n    input clk,\n    input rst,\n    input mode,\n    input enable,\n    output reg [7:0] count\n);\n\n    wire [7:0] up_count_out, down_count_out;\n\n    // Submodule for up-counting\n    up_counter up_count (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .count(up_count_out)\n    );\n\n    // Submodule for down-counting\n    down_counter down_count (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .count(down_count_out)\n    );\n\n    // Output logic\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 8'd0;\n        end else if (enable) begin\n            if (mode == 1'b0) begin\n                count <= up_count_out;\n            end else if (mode == 1'b1) begin\n                count <= down_count_out;\n            end else begin\n                count <= count;\n            end\n        end\n    end\n\n    // Submodule outputs\n    assign up_count_out = enable ? (mode == 1'b0 ? (count + 8'd1) : count);\n    assign down_count_out = enable ? (mode == 1'b1 ? (count - 8'd1) : count);\n\nendmodule\n\n// Submodule for up-counting\nmodule up_counter (\n    input clk,\n    input rst,\n    input enable,\n    output reg [7:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 8'd0;\n        end else if (enable) begin\n            count <= count + 8'd1;\n        end\n    end\n\nendmodule\n\n// Submodule for down-counting\nmodule down_counter (\n    input clk,\n    input rst,\n    input enable,\n    output reg [7:0] count\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 8'd0;\n        end else if (enable) begin\n            count <= count - 8'd1;\n        end\n    end\n\nendmodule"}
{"task_id": 17, "response": "module dual_mode_timer (\n    input clk,\n    input rst,\n    input mode,\n    input start,\n    input [15:0] set_time,\n    output [15:0] current_time,\n    output done\n);\n\n    // Submodule for countdown timer\n    wire [15:0] countdown_time;\n    countdown_timer countdown (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .set_time(set_time),\n        .current_time(countdown_time),\n        .done(countdown_timer_done)\n    );\n\n    // Submodule for stopwatch timer\n    wire [15:0] stopwatch_time;\n    stopwatch_timer stopwatch (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .set_time(set_time),\n        .current_time(stopwatch_time),\n        .done(stopwatch_timer_done)\n    );\n\n    // Outputs\n    assign current_time = (mode == 0) ? countdown_time : stopwatch_time;\n    assign done = (mode == 0) ? countdown_timer_done : stopwatch_timer_done;\n\nendmodule\n\n// Submodule for countdown timer\nmodule countdown_timer (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] set_time,\n    output reg [15:0] current_time,\n    output reg done\n);\n\n    reg [15:0] count;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= set_time;\n            current_time <= set_time;\n            done <= 0;\n        end else if (start) begin\n            count <= 0;\n            current_time <= 0;\n            done <= 0;\n        end else begin\n            if (count > 0) begin\n                count <= count - 1;\n                current_time <= count;\n                done <= 0;\n            end else begin\n                current_time <= set_time;\n                done <= 1;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for stopwatch timer\nmodule stopwatch_timer (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] set_time,\n    output reg [15:0] current_time,\n    output reg done\n);\n\n    reg [15:0] count;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n            current_time <= 0;\n            done <= 0;\n        end else if (start) begin\n            count <= set_time;\n            current_time <= count;\n            done <= 0;\n        end else begin\n            if (count > 0) begin\n                count <= count + 1;\n                current_time <= count;\n                done <= 0;\n            end else begin\n                current_time <= set_time;\n                done <= 1;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 11, "response": "module dual_mode_counter (\n    input clk,\n    input rst,\n    input mode,\n    input enable,\n    output reg [7:0] count\n);\n\n    wire [7:0] up_count, down_count;\n\n    // Submodule for up-counting\n    up_counter up_cnt (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .count(up_count)\n    );\n\n    // Submodule for down-counting\n    down_counter down_cnt (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .count(down_count)\n    );\n\n    // Output logic\n    always @ (posedge clk or negedge rst) begin\n        if (~rst) begin\n            if (enable) begin\n                if (mode == 2'b00) begin\n                    count <= up_count;\n                end else begin\n                    count <= down_count;\n                end\n            end else begin\n                count <= 0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 26, "response": "module data_router (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] chan1,\n    output reg [7:0] chan2,\n    output reg [7:0] chan3\n);\n\n    wire [7:0] channel1_data, channel2_data, channel3_data;\n\n    // Submodule for routing data to channel 1\n    channel1_router channel1_module (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ctrl(ctrl),\n        .channel_data(channel1_data)\n    );\n\n    // Submodule for routing data to channel 2\n    channel2_router channel2_module (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ctrl(ctrl),\n        .channel_data(channel2_data)\n    );\n\n    // Submodule for routing data to channel 3\n    channel3_router channel3_module (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .ctrl(ctrl),\n        .channel_data(channel3_data)\n    );\n\n    // Assign data to output channels\n    assign chan1 = channel1_data;\n    assign chan2 = channel2_data;\n    assign chan3 = channel3_data;\n\nendmodule\n\n// Submodule for routing data to channel 1\nmodule channel1_router (\n    input clk,\n    input rst,\n    input [7:0] data,\n    input [1:0] ctrl,\n    output reg [7:0] channel_data\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            channel_data <= 8'd0; // Reset channel data\n        end else begin\n            if (ctrl == 2'b00) begin\n                channel_data <= data; // Route data to channel 1\n            end else begin\n                channel_data <= channel_data; // Maintain previous channel data\n            end\n        end\n    end\n\nendmodule\n\n\n// Submodule for routing data to channel 2\nmodule channel2_router (\n    input clk,\n    input rst,\n    input [7:0] data,\n    input [1:0] ctrl,\n    output reg [7:0] channel_data\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            channel_data <= 8'd0; // Reset channel data\n        end else begin\n            if (ctrl == 2'b01) begin\n                channel_data <= data; // Route data to channel 2\n            end else begin\n                channel_data <= channel_data; // Maintain previous channel data\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for routing data to channel 3\nmodule channel3_router (\n    input clk,\n    input rst,\n    input [7:0] data,\n    input [1:0] ctrl,\n    output reg [7:0] channel_data\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            channel_data <= 8'd0; // Reset channel data\n        end else begin\n            if (ctrl == 2'b10) begin\n                channel_data <= data; // Route data to channel 3\n            end else begin\n                channel_data <= channel_data; // Maintain previous channel data\n            end\n        end\n    end\nend\nend\nendmodule"}
{"task_id": 12, "response": "module digital_watch (\n    input clk,\n    input rst,\n    input inc_min,\n    output reg [4:0] hours,\n    output reg [5:0] minutes\n);\n\n    reg [4:0] hour_count;\n    reg [5:0] min_count;\n\n    // Hour submodule\n    wire [4:0] hour_out;\n    hour_count hour_sub (\n        .clk(clk),\n        .rst(rst),\n        .inc(inc_min),\n        .hour_out(hour_out)\n    );\n\n    // Minute submodule\n    wire [5:0] min_out;\n    min_count min_sub (\n        .clk(clk),\n        .rst(rst),\n        .inc(inc_min),\n        .min_out(min_out)\n    );\n\n    // Connect the outputs\n    assign hours = hour_out;\n    assign minutes = min_out;\n\nendmodule"}
{"task_id": 17, "response": "module dual_mode_timer (\n    input clk,\n    input rst,\n    input mode,\n    input start,\n    input [15:0] set_time,\n    output [15:0] current_time,\n    output done\n);\n\n    // Submodule for countdown timer\n    wire [15:0] countdown_timer_out;\n    countdown_timer countdown_timer1 (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .set_time(set_time),\n        .current_time(countdown_timer_out),\n        .done(done)\n    );\n\n    // Submodule for stopwatch timer\n    wire [15:0] stopwatch_timer_out;\n    stopwatch_timer stopwatch_timer1 (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .set_time(set_time),\n        .current_time(stopwatch_timer_out),\n        .done(done)\n    );\n\n    // Output logic\n    reg [15:0] current_time_reg;\n    reg done_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            current_time_reg <= 0;\n            done_reg <= 0;\n        end else begin\n            if (mode == 0) begin\n                current_time_reg <= countdown_timer_out;\n                done_reg <= (countdown_timer_out == 0);\n            end else begin\n                current_time_reg <= stopwatch_timer_out;\n                done_reg <= (stopwatch_timer_out == set_time);\n            end\n        end\n    end\n\n    assign current_time = current_time_reg;\n    assign done = done_reg;\n\nendmodule"}
{"task_id": 2, "response": "module traffic_light_ctrl (\n    input clk,\n    input rst,\n    input ped_request,\n    input [5:0] timer,\n    output reg [1:0] main_light,\n    output reg [1:0] side_light,\n    output reg walk_sign\n);\n\n    // Submodules\n    wire [1:0] main_light_sub;\n    wire [1:0] side_light_sub;\n    wire [1:0] pedestrian_sub;\n\n    // Main Road Traffic Lights\n    main_road_traffic main_road_traffic (\n        .clk(clk),\n        .rst(rst),\n        .timer(timer),\n        .ped_request(ped_request),\n        .main_light(main_light_sub),\n        .side_light(side_light_sub),\n        .pedestrian(pedestrian_sub)\n    );\n\n    // Side Road Traffic Lights\n    side_road_traffic side_road_traffic (\n        .clk(clk),\n        .rst(rst),\n        .timer(timer),\n        .ped_request(ped_request),\n        .main_light(main_light_sub),\n        .side_light(side_light_sub),\n        .pedestrian(pedestrian_sub)\n    );\n\n    // Pedestrian Signal\n    pedestrian_signal pedestrian_signal (\n        .clk(clk),\n        .rst(rst),\n        .timer(timer),\n        .ped_request(ped_request),\n        .main_light(main_light_sub),\n        .side_light(side_light_sub),\n        .pedestrian(pedestrian_sub)\n    );\n\n    // Outputs\n    assign main_light = main_light_sub;\n    assign side_light = side_light_sub;\n    assign walk_sign = pedestrian_sub;\n\nendmodule\n\n// Submodules\n\n// Main Road Traffic Lights\nmodule main_road_traffic (\n    input clk,\n    input rst,\n    input [5:0] timer,\n    input ped_request,\n    output reg [1:0] main_light,\n    output reg [1:0] side_light,\n    output reg [1:0] pedestrian\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            main_light <= 2'b00;\n            side_light <= 2'b00;\n            pedestrian <= 2'b00;\n        end else begin\n            if (ped_request) begin\n                main_light <= 2'b10;\n                side_light <= 2'b10;\n                pedestrian <= 2'b10;\n            end else begin\n                if (timer >= 6) begin\n                    main_light <= 2'b01;\n                    side_light <= 2'b01;\n                    pedestrian <= 2'b01;\n                end else begin\n                    main_light <= 2'b00;\n                    side_light <= 2'b00;\n                    pedestrian <= 2'b00;\n                end\n            end\n        end\n    end\n\nendmodule\n\n// Side Road Traffic Lights\nmodule side_road_traffic (\n    input clk,\n    input rst,\n    input [5:0] timer,\n    input ped_request,\n    input [1:0] main_light,\n    input [1:0] side_light,\n    output reg [1:0] pedestrian\n);\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            if (ped_request) begin\n                pedestrian <= 2'b10;\n            if (main_light == 2'b01)\n            else if (side_light == 2'b001)\n            else if (main_light == 2'b10 && side_light == 2'b01)\n            else pedestrian <= 2'b00;\n        end\n    end\n\nendmodule\n\n// Pedestrian Signal\nmodule"}
{"task_id": 26, "response": "module data_router (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] chan1,\n    output reg [7:0] chan2,\n    output reg [7:0] chan3\n);\n\n    wire [7:0] chan1_out, chan2_out, chan3_out;\n\n    // Submodule for routing data to channel 1\n    channel1_module channel1_inst (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data(data),\n        .chout(chan1_out)\n    );\n\n    // Submodule for routing data to channel 2\n    channel2_module channel2_inst (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data(data),\n        .chout(chan2_out)\n    );\n\n    // Submodule for routing data to channel 3\n    channel3_module channel3_inst (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data(data),\n        .chout(chan3_out)\n    );\n\n    // Assign outputs to output ports\n    assign chan1 = chan1_out;\n    assign chan2 = chan2_out;\n    assign chan3 = chan3_out;\n\nendmodule\n\n// Submodule for routing data to channel 1\nmodule channel1_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] chout\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            chout <= 8'd0;\n        end else begin\n            if (ctrl == 2'b00) begin\n                chout <= data;\n            end else begin\n                chout <= chout;\n            end\n        end\n    end\n\nendmodule\n\n\n// Submodule for routing data to channel 2\nmodule channel2_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] chout\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            chout <= 8'd0;\n        end else begin\n            if (ctrl == 2'b01) begin\n                chout <= data;\n            end else begin\n                chout <= chout;\n            end\n        end\n    end\n\nendmodule\n\n\n// Submodule for routing data to channel 3\nmodule channel3_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [7:0] data,\n    output reg [7:0] chout\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            chout <= 8'd0;\n        end else begin\n            if (ctrl == 2'b10) begin\n                chout <= data;\n            end else begin\n                chout <= chout;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 12, "response": "module digital_watch (\n    input clk,\n    input rst,\n    input inc_min,\n    output reg [4:0] hours,\n    output reg [5:0] minutes\n);\n\n    reg [4:0] hour;\n    reg [5:0] min;\n\n    // Hour submodule\n    wire [4:0] next_hour;\n    wire [5:0] next_min;\n    hour_count hour_sub (\n        .clk(clk),\n        .rst(rst),\n        .inc_min(inc_min),\n        .next_hour(next_hour),\n        .next_min(next_min)\n    );\n    );\n\n    // Minute submodule\n    wire [5:0] next_minute;\n    wire [4:0] next_hour;\n    min_count min_sub (\n        .clk(clk),\n        .rst(rst),\n        .inc_min(inc_min),\n        .next_minute(next_minute),\n        .next_hour(next_hour)\n    );\n\n    // Output assignments\n    assign hours = hour;\n    assign minutes = min;\n\nendmodule\n\n// Hour count submodule\nmodule hour_count (\n    input clk,\n    input rst,\n    input inc_min,\n    output reg [4:0] next_hour,\n    output reg [5:0] next_min\n);\n\n    reg [4:0] hour;\n    reg [5:0] min;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            hour <= 0;\n            min <= 0;\n        end else begin\n            if (inc_min) begin\n                min <= min + 1;\n                if (min == 60) begin\n                    min <= 0;\n                    hour <= hour + 1;\n                end\n            end\n        end\n    end\n\n    assign next_hour = hour;\n    assign next_min = min;\n\nendmodule\n\n// Minute count submodule\nmodule min_count (\n    input clk,\n    input rst,\n    input inc_min,\n    output reg [5:0] next_minute,\n    output reg [4:0] next_hour\n);\n\n    reg [5:0] min;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            min <= 0;\n        end else begin\n            if (inc_min) begin\n                min <= min + 1;\n                if (min == 60) begin\n                    min <= 0;\n                    next_hour <= next_hour + 1;\n                end\n            end\n        end\n    end\n\n    assign next_minute = min;\n\nendmodule"}
{"task_id": 17, "response": "module dual_mode_timer (\n    input clk,\n    input rst,\n    input mode,\n    input start,\n    input [15:0] set_time,\n    output [15:0] current_time,\n    output done\n);\n\n    // Submodule for countdown timer\n    wire [15:0] countdown_time;\n    countdown_timer countdown_timer (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .set_time(set_time),\n        .current_time(countdown_time),\n        .done(countdown_timer_done)\n    );\n\n    // Submodule for stopwatch timer\n    wire [15:0] stopwatch_time;\n    stopwatch_timer stopwatch_timer (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .set_time(set_time),\n        .current_time(stopwatch_time),\n        .done(stopwatch_timer_done)\n    );\n\n    // Output logic\n    reg [15:0] current_time_reg;\n    reg done_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            current_time_reg <= 0;\n            done_reg <= 0;\n        end else begin\n            if (mode == 0) begin\n                current_time_reg <= countdown_time;\n                done_reg <= countdown_timer_done;\n            end else begin\n                current_time_reg <= stopwatch_time;\n                done_reg <= stopwatch_timer_done;\n            end\n        end\n    end\n\n    assign current_time = current_time_reg;\n    assign done = done_reg;\n\nendmodule"}
{"task_id": 12, "response": "module digital_watch (\n    input clk,\n    input rst,\n    input inc_min,\n    output reg [4:0] hours,\n    output reg [5:0] minutes\n);\n\n    reg [4:0] hour_count;\n    reg [5:0] min_count;\n\n    // Hour submodule\n    wire [4:0] hour_out;\n    hour_count hour_sub (\n        .clk(clk),\n        .rst(rst),\n        .inc(inc_min),\n        .hour_out(hour_out)\n    );\n\n    // Minute submodule\n    wire [5:0] min_out;\n    min_count min_sub (\n        .clk(clk),\n        .rst(rst),\n        .inc(inc_min),\n        .min_out(min_out)\n    );\n\n    // Connect outputs\n    assign hours = hour_out;\n    assign minutes = min_out;\n\nendmodule"}
{"task_id": 27, "response": "module data_multiplexer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] out1,\n    output [3:0] out2\n);\n\n    // Submodule for data routing\n    wire [7:0] mux_p1, mux_p2;\n\n    // Data routing submodule for data1\n    data_router data_router1 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(data1),\n        .data_out(mux_p1)\n    );\n\n    // Data routing submodule for data2\n    data_router data_router2 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(data2),\n        .data_out(mux_p2)\n    );\n\n    // Output assignment\n    assign out1 = mux_p1;\n    assign out2 = mux_p2[3:0];\n\nendmodule\n\n// Submodule for data routing\nmodule data_router (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            case (sel)\n                2'b01: data_out <= data_in; // Route data1\n                2'b10: data_out <= data_in; // Route data2\n                default: data_out <= data_out; // Retain previous value\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 13, "response": "module mux4way (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    input [7:0] src3,\n    input [7:0] src4,\n    output [7:0] out\n);\n\n    wire [7:0] out1, out2, out3, out4;\n\n    // Submodule 1: Select src1\n    assign out1 = (sel == 2'b00) ? src1 : 8'd0;\n\n    // Submodule 2: Select src2\n    assign out2 = (sel == 2'b01) ? src2 : 8'd0;\n\n    // Submodule 3: Select src3\n    assign out3 = (sel == 2'b10) ? src3 : 8'd0;\n\n    // Submodule 4: Select src4\n    assign out4 = (sel == 2'b11) ? src4 : 8'd0;\n\n    // Output selection\n    assign out = (sel == 2'b00) ? out1 :\n                  (sel == 2'b01) ? out2 :\n                  (sel == 2'b10) ? out3 :\n                  (sel == 2'b11) ? out4 : 8'd0;\n\nendmodule"}
{"task_id": 18, "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output [7:0] out_data\n);\n\n    wire [7:0] mux1_out, mux2_out, mux3_out;\n\n    // Submodules\n    data_mux_sub mux1 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data1),\n        .out_data(mux1_out)\n    );\n\n    data_mux_sub mux2 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data2),\n        .out_data(mux2_out)\n    );\n\n    data_mux_sub mux3 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data3),\n        .out_data(mux3_out)\n    );\n\n    // Output assignment\n    assign out_data = (sel == 2'b00) ? mux1_out :\n                       (sel == 2'b01) ? mux2_out : mux3_out;\n\nendmodule\n\n// Submodule for data multiplexer\nmodule data_mux_sub (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: out_data <= data_in;\n            2'b01: out_data <= data_in;\n            default: out_data <= data_in;\n        endcase\n    end\n\nendmodule"}
{"task_id": 2, "response": "module traffic_light_ctrl (\n    input clk,\n    input rst,\n    input ped_request,\n    input [5:0] timer,\n    output reg [1:0] main_light,\n    output reg [1:0] side_light,\n    output reg walk_sign\n);\n\n    // Submodule for main road traffic lights\n    wire [1:0] red_light, green_light, yellow_light;\n    main_road_light main_road (.clk(clk), .rst(rst), .timer(timer), .red_light(red_light), .green_light(green_light), .yellow_light(yellow_light));\n\n    // Submodule for side road traffic lights\n    wire [1:0] red_side_light, green_side_light, yellow_side_light;\n    side_road_light side_road (.clk(clk), .rst(rst), .timer(timer), .red_side_light(red_side_light), .green_side_light(green_side_light), .yellow_side_light(yellow_side_light));\n\n    // Submodule for pedestrian crossing signal\n    wire ped_walk;\n    pedestrian_crossing pedestrian (.clk(clk), .rst(rst), .ped_request(ped_request), .ped_walk(ped_walk));\n\n    // Output assignments\n    assign main_light = ped_request ? yellow_light : (timer == 6'd00 ? red_light : green_light);\n    assign side_light = ped_request ? yellow_side_light : (timer == 6'd00 ? red_side_light : green_side_light);\n    assign walk_sign = ped_request ? ped_walk : 1'b0;\n\nendmodule\n\n// Submodule for main road traffic lights\nmodule main_road_light (\n    input clk,\n    input rst,\n    input [5:0] timer,\n    output reg [1:0] red_light,\n    output reg [1:0] green_light,\n    output reg [1:0] yellow_light\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            red_light <= 2'b00;\n            green_light <= 2'b00;\n            yellow_light <= 2'b00;\n        end else begin\n            case (timer)\n                6'd00: begin\n                    red_light <= 2'b00;\n                    green_light <= 2'b00;\n                    yellow_light <= 2'b00;\n                end\n                6'd01: begin\n                    red_light <= 2'b01;\n                    green_light <= 2'b00;\n                    yellow_light <= 2'b00;\n                end\n                6'd02: begin\n                    red_light <= 2'b00;\n                    green_light <= 2'b01;\n                    yellow_light <= 2'b00;\n                end\n                6'd03: begin\n                    red_light <= 2'b00;\n                    green_light <= 2'b00;\n                    yellow_light <= 2'b01;\n                end\n                default: begin\n                    red_light <= 2'b00;\n                    green_light <= 2'b00;\n                    yellow_light <= 2'b00;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for side road traffic lights\nmodule side_road_light (\n    input clk,\n    input rst,\n    input [5:0] timer,\n    output reg [1:0] red_side_light,\n    output reg [1:0] green_side_light,\n    output reg [1:0] yellow_side_light\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            red_side_light <= 2'b00;\n            green_side_light <= 2'b00;\n            yellow_side_light <= 2'b00;\n        end\n    end\n\n    assign"}
{"task_id": 27, "response": "module data_multiplexer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] out1,\n    output [3:0] out2\n);\n\n    reg [7:0] out1_reg;\n    reg [3:0] out2_reg;\n\n    // Submodule for data routing\n    wire [7:0] mux_p1_out;\n    wire [3:0] mux_p2_out;\n\n    // Instantiate submodules\n    data_router mux_p1 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(data1),\n        .out(mux_p1_out)\n    );\n\n    data_router mux_p2 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(data2),\n        .out(mux_p2_out)\n    );\n\n    // Output assignment\n    always @(posedge clk) begin\n        if (rst) begin\n            out1_reg <= 8'd0;\n            out2_reg <= 4'd0;\n        end else begin\n            out1_reg <= mux_p1_out;\n            out2_reg <= mux_p2_out;\n        end\n    end\n\n    assign out1 = out1_reg;\n    assign out2 = out2_reg;\n\nendmodule\n\n// Submodule for data routing\nmodule data_router (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            out <= 8'd0;\n        end else begin\n            case (sel)\n                2'b01: out <= data_in;\n                2'b10: out <= out;\n                default: out <= out;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 27, "response": "module data_multiplexer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] out1,\n    output [3:0] out2\n);\n\n    reg [7:0] out1_reg;\n    reg [3:0] out2_reg;\n\n    // Submodule for data routing\n    wire [7:0] mux_p1_out;\n    wire [3:0] mux_p2_out;\n\n    // Instantiate submodules\n    data_multiplexer_p1 mux_p1 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(data1),\n        .out(mux_p1_out)\n    );\n\n    data_multiplexer_p2 mux_p2 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data_in(data2),\n        .out(mux_p2_out)\n    );\n\n    // Output assignment\n    always @(posedge clk) begin\n        if (!rst) begin\n            out1_reg <= 8'd0;\n            out2_reg <= 4'd0;\n        end else begin\n            out1_reg <= mux_p1_out;\n            out2_reg <= mux_p2_out;\n        end\n    end\n\n    assign out1 = out1_reg;\n    assign out2 = out2_reg;\n\nendmodule\n\n// Submodule for data routing\nmodule data_multiplexer_p1 (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out\n);\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            out <= 8'd0;\n        end else begin\n            case (sel)\n                2'b01: out <= data_in;\n                2'b10: out <= out;\n                default: out <= out;\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for data routing\nmodule data_multiplexer_p2 (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [3:0] out\n);\n\n    always @(posedge clk) begin\n        if (!rst) begin\n            out <= 4'd0;\n        end else begin\n            case (sel)\n                2'b01: out <= data_in;\n                2'b10: out <= out;\n                default: out <= out;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 13, "response": "module mux4way (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    input [7:0] src3,\n    input [7:0] src4,\n    output [7:0] out\n);\n\n    wire [7:0] src1_out, src2_out, src3_out, src4_out;\n\n    // Submodule for each source\n    submodule src1_sm (\n        input clk,\n        input rst,\n        input [7:0] src_in,\n        output reg [7:0] src_out\n    );\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                src_out <= 8'd0;\n            end else begin\n                src_out <= src_in;\n            end\n        end\n    endmodule\n\n    submodule src2_sm (\n        input clk,\n        input rst,\n        input [7:0] src_in,\n        output reg [7:0] src_out\n    );\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                src_out <= 8'd0;\n            end else begin\n                src_out <= src_in;\n            end\n        end\n    endmodule\n\n    submodule src3_sm (\n        input clk,\n        input rst,\n        input [7:0] src_in,\n        output reg [7:0] src_out\n    );\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                src_out <= 8'd0;\n            end else begin\n                src_out <= src_in;\n            end\n        end\n    endmodule\n\n    submodule src4_sm (\n        input clk,\n        input rst,\n        input [7:0] src_in,\n        output reg [7:0] src_out\n    );\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                src_out <= 8'd0;\n            end else begin\n                src_out <= src_in;\n            end\n        end\n    endmodule\n\n    // Submodule for each output\n    submodule out_sm (\n        input clk,\n        input rst,\n        input [7:0] src_in,\n        output reg [7:0] out_out\n    );\n        always @(posedge clk or negedge rst) begin\n            if (!rst) begin\n                out_out <= 8'd0;\n            end else begin\n                out_out <= src_in;\n            end\n        end\n    endmodule\n\n    // Instantiate submodules\n    src1_sm src1 (\n        .clk(clk),\n        .rst(rst),\n        .src_in(src1),\n        .src_out(src1_out)\n    );\n    src2_sm src2 (\n        .clk(clk),\n        .rst(rst),\n        .src_in(src2),\n        .src_out(src2_out)\n    );\n    );\n    );\n    src3_sm src3 (\n        .clk(clk),\n        .rst(rst),\n        .src_in(src3),\n        .src_out(src3_out)\n    );\n    src4_sm src4 (\n        .clk(clk),\n        .rst(rst),\n        .src_in(src4),\n        .src_out(src4_out)\n    );\n\n    // Connect submodules to outputs\n    out_sm out1 (\n        .clk(clk),\n        .rst(rst),\n        .src_in(src1_out),\n        .src_out(out[0])\n    );\n    out_sm out2 (\n        .clk(clk),\n        .rst(rst),\n        .src_in(src2_out),\n        .src_out(out[1])\n    );\n    out_sm out3 (\n        .clk(clk),\n        .rst(rst"}
{"task_id": 18, "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output [7:0] out_data\n);\n\n    // Submodules\n    wire [7:0] mux1_out, mux2_out, mux3_out;\n\n    // First submodule\n    mux1 mux1_inst (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data1),\n        .out_data(mux1_out)\n    );\n\n    // Second submodule\n    mux2 mux2_inst (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data2),\n        .out_data(mux2_out)\n    );\n\n    // Third submodule\n    mux3 mux3_inst (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data3),\n        .out_data(mux3_out)\n    );\n\n    // Output\n    assign out_data = (sel == 2'b00) ? mux1_out :\n                     (sel == 2'b01) ? mux2_out : mux3_out;\n\nendmodule\n\n// Submodule for multiplexing\nmodule mux1 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: out_data <= data_in;\n            2'b01: out_data <= 8'h00;\n            default: out_data <= 8'hFF;\n        endcase\n    end\n\nendmodule\n\nmodule mux2 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: out_data <= data_in;\n            2'b01: out_data <= 8'h00;\n            default: out_data <= 8'hFF;\n        endcase\n    end\n\nendmodule\n\nmodule mux3 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        case (sel)\n            2'b00: out_data <= data_in;\n            2'b01: out_data <= 8'h00;\n            default: out_data <= 8'hFF;\n        endcase\n    end\n\nendmodule"}
{"task_id": 3, "response": "module configurable_timer (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] duration,\n    output timeout\n);\n\n    // Submodule outputs\n    wire [5:0] counter_out;\n    wire timeout_out;\n\n    // Counter submodule\n    counter counter counter_inst (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .duration(duration),\n        .count_out(counter_out),\n        .timeout_out(timeout_out)\n    );\n\n    // Comparator submodule\n    comparator comparator_inst (\n        .clk(clk),\n        .rst(rst),\n        .duration(duration),\n        .counter_out(counter_out),\n        .timeout_out(timeout_out)\n    );\n\n    // Control logic submodule\n    control_logic control_logic_inst (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .timeout_out(timeout_out),\n        .enable_counter(counter_out),\n        .enable_comparator(timeout_out)\n    );\n\nendmodule\n\n// Counter submodule\nmodule counter (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] duration,\n    output reg [5:0] count_out,\n    output reg timeout_out\n);\n\n    reg [5:0] count_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count_reg <= 6'd0;\n            timeout_out <= 1'b0;\n        end else if (start) begin\n            count_reg <= duration;\n            timeout_out <= 1'b0;\n        end else begin\n            if (count_reg > 6'd0) begin\n                count_reg <= count_reg - 6'd1;\n                timeout_out <= 1'b1;\n            end else begin\n                count_reg <= count_reg;\n                timeout_out <= 1'b0;\n            end\n        end\n    end\n\n    assign count_out = count_reg;\n\nendmodule\n\n// Comparator submodule\nmodule comparator (\n    input clk,\n    input rst,\n    input [15:0] duration,\n    input [5:0] counter_out,\n    output reg timeout_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            timeout_out <= 1'b0;\n        end else begin\n            if (counter_out == duration) begin\n                timeout_out <= 1'b1;\n            end else begin\n                timeout_out <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\n\n// Control logic submodule\nmodule control_logic (\n    input clk,\n    input rst,\n    input start,\n    input timeout_out,\n    output reg enable_counter,\n    output reg enable_comparator\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            enable_counter <= 1'b0;\n            enable_comparator <= 1'b0;\n        end else begin\n            if (start) begin\n                enable_counter <= 1'b1;\n                enable_comparator <= 1'b0;\n            end else if (timeout_out) begin\n                enable_counter <= 1'b0;\n                enable_comparator <= 1'b1;\n            end else begin\n                enable_counter <= 1'b0;\n                enable_comparator <= 1'b0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 28, "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data0,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] out\n);\n\n    wire [7:0] sub0_out, sub1_out, sub2_out, sub3_out;\n\n    // Submodule 0\n    data_selector sub0 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data0),\n        .channel_code(8'b00),\n        .data_out(sub0_out)\n    );\n\n    // Submodule 1\n    data_selector sub1 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data1),\n        .channel_code(8'b01),\n        .data_out(sub1_out)\n    );\n\n    // Submodule 2\n    data_selector sub2 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data2),\n        .channel_code(8'b02),\n        .data_out(sub2_out)\n    );\n\n    // Submodule 3\n    data_selector sub3 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data3),\n        .channel_code(8'b03),\n        .data_out(sub3_out)\n    );\n\n    // Output assignment\n    assign out = (sel == 8'b00) ? sub0_out :\n                  (sel == 8'b01) ? sub1_out :\n                  (sel == 8'b02) ? sub2_out :\n                  (sel == 8'b03) ? sub3_out :\n                  8'b00; // Default case\n\nendmodule\n\n// Submodule for data selection based on channel code\nmodule data_selector (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    input [6:0] channel_code,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk) begin\n        if (sel == channel_code) begin\n            data_out <= data_in;\n        end else begin\n            data_out <= 8'b00; // Default case\n        end\n    end\n\nendmodule"}
{"task_id": 13, "response": "module mux4way (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    input [7:0] src3,\n    input [7:0] src4,\n    output [7:0] out\n);\n\n    wire [7:0] out1, out2, out3, out4;\n\n    // Submodule for each source\n    submodule src1_sub (\n        input [7:0] in,\n        output reg [7:0] out\n    );\n        always @(posedge clk) begin\n            if (~rst) begin\n                out <= 8'd0; // Reset output\n            end else begin\n                out <= in; // Pass input to output\n            end\n        end\n    endmodule\n\n    submodule src2_sub (\n        input [7:0] in,\n        output reg [7:0] out\n    );\n        always @(posedge clk) begin\n            if (~rst) begin\n                out <= 8'd0; // Reset output\n            end else begin\n                out <= in; // Pass input to output\n            end\n        end\n    endmodule\n\n    submodule src3_sub (\n        input [7:0] in,\n        output reg [7:0] out\n    );\n        always @(posedge clk) begin\n            if (~rst) begin\n                out <= 8'd0; // Reset output\n            end else begin\n                out <= in; // Pass input to output\n            end\n        end\n    endmodule\n\n    submodule src4_sub (\n        input [7:0] in,\n        output reg [7:0] out\n    );\n        always @(posedge clk) begin\n            if (~rst) begin\n                out <= 8'd0; // Reset output\n            end else begin\n                out <= in; // Pass input to output\n            end\n        end\n    endmodule\n\n    // Instantiate outputs based on sel signal\n    assign out1 = (sel == 2'b00) src1_sub(src1) : (src2_sub(src2) : (src3_sub(src3) : (src4_sub(src4));\n    assign out2 = (sel == 2'b01) ? src1_sub(src1) : (sel == 2'b10) ? src2_sub(src2) : (sel == 2'b11) ? src3_sub(src3) : src4_sub(src4);\n\nendmodule"}
{"task_id": 18, "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output [7:0] out_data\n);\n\n    wire [7:0] mux1_out, mux2_out, mux3_out;\n\n    // Submodule for data multiplexer\n    data_mux_1 mux1 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data1),\n        .out_data(mux1_out)\n    );\n\n    data_mux_2 mux2 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data2),\n        .out_data(mux2_out)\n    );\n\n    data_mux_3 mux3 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data3),\n        .out_data(mux3_out)\n    );\n\n    // Output selection based on control signal\n    assign out_data = (sel == 2'b00) ? mux1_out :\n                       (sel == 2'b01) ? mux2_out : mux3_out;\n\nendmodule\n\n// Submodule for data multiplexer\nmodule data_mux_1 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b00) begin\n            out_data <= data_in;\n        end\n    end\n\nendmodule\n\nmodule data_mux_2 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b01) begin\n            out_data <= data_in;\n        end\n    end\n\nendmodule\n\nmodule data_mux_3 (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data_in,\n    output reg [7:0] out_data\n);\n\n    always @(posedge clk) begin\n        if (sel == 2'b10) begin\n            out_data <= data_in;\n        end\n    end\n\nendmodule"}
{"task_id": 3, "response": "module configurable_timer (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] duration,\n    output timeout\n);\n\n    // Submodule outputs\n    wire [15:0] counter_out;\n    wire timeout_out;\n\n    // Counter submodule\n    counter counter counter_inst (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .duration(duration),\n        .count_out(counter_out),\n        .timeout_out(timeout_out)\n    );\n\n    // Comparator submodule\n    comparator comparator_inst (\n        .clk(clk),\n        .rst(rst),\n        .duration(duration),\n        .count_out(counter_out),\n        .timeout_out(timeout_out)\n    );\n\n    // Control logic submodule\n    control_logic control_logic_inst (\n        .clk(clk),\n        .rst(rst),\n        .start(start),\n        .timeout_out(timeout_out),\n        .enable_out(timeout)\n    );\n\nendmodule\n\n// Counter submodule\nmodule counter (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] duration,\n    output reg [15:0] count_out,\n    output reg timeout_out\n);\n\n    reg [15:0] count;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            count <= 0;\n            timeout_out <= 0;\n        end else if (start) begin\n            count <= duration;\n            timeout_out <= 0;\n        end else begin\n            if (count > 0) begin\n                count <= count - 1;\n                timeout_out <= 0;\n            end else begin\n                timeout_out <= 1;\n            end\n        end\n    end\n\n    assign count_out = count;\n\nendmodule\n\n// Comparator submodule\nmodule comparator (\n    input clk,\n    input rst,\n    input [15:0] duration,\n    input [15:0] count_out,\n    output reg timeout_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            timeout_out <= 0;\n        end else if (count_out == duration) begin\n            timeout_out <= 1;\n        end else begin\n            timeout_out <= 0;\n        end\n    end\n\nendmodule\n\n// Control logic submodule\nmodule control_logic (\n    input clk,\n    input rst,\n    input start,\n    input timeout_out,\n    output reg enable_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            enable_out <= 0;\n        end else if (start) begin\n            enable_out <= 1;\n        end else if (timeout_out) begin\n            enable_out <= 0;\n        end else begin\n            enable_out <= 0;\n        end\n    end\n\nendmodule"}
{"task_id": 28, "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data0,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] out\n);\n\n    wire [7:0] data0_out, data1_out, data2_out, data3_out;\n\n    // Submodule for data selection\n    data_selector data_sel0 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data0),\n        .data_out(data0_out),\n        .channel_code(0)\n    );\n\n    data_selector data_sel1 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data1),\n        .data_out(data1_out),\n        .channel_code(1)\n    );\n\n    data_selector data_sel2 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data2),\n        .data_out(data2_out),\n        .channel_code(2)\n    );\n\n    data_selector data_sel3 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data3),\n        .data_out(data3_out),\n        .channel_code(3)\n    );\n\n    // Output selection logic\n    always @(posedge clk) begin\n        if (sel == 0) begin\n            out <= data0_out;\n        end else if (sel == 1) begin\n            out <= data1_out;\n        end else if (sel == 2) begin\n            out <= data2_out;\n        end else if (sel == 3) begin\n            out <= data3_out;\n        end\n    end\n\nendmodule"}
{"task_id": 3, "response": "module configurable_timer (\n    input clk,\n    input rst,\n    input start,\n    input [15:0] duration,\n    output timeout\n);\n\n    // Submodule outputs\n    wire [5:0] counter_out;\n    wire timeout_out;\n\n    // Counter submodule\n    reg [5:0] counter;\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            counter <= 0;\n        end else if (start == 1) begin\n            counter <= counter + 1;\n        end\n        end\n    end\n\n    assign counter_out = counter;\n\n    // Comparator submodule\n    reg [5:0] comparator;\n    always @(posedge clk) begin\n        if (counter == duration) begin\n            comparator <= 1;\n        end else begin\n            comparator <= 0;\n        end\n    end\n\n    // Control logic submodule\n    reg enable_counter;\n    reg enable_comparator;\n    always @(posedge clk) begin\n        if (rst == 0) begin\n            enable_counter <= 0;\n            enable_comparator <= 0;\n        end else begin\n            enable_counter <= start;\n            enable_comparator <= comparator;\n        end\n    end\n\n    // Output assignments\n    assign timeout = timeout_out;\n\nendmodule"}
{"task_id": 19, "response": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output [7:0] out1,\n    output [7:0] out2\n);\n\n    wire [7:0] out1_sub1, out2_sub1, out1_sub2, out2_sub2;\n\n    // Submodule 1\n    data_selector_submodule submodule1 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[0]),\n        .d_in(d1),\n        .d_out(out1_sub1)\n    );\n\n    // Submodule 2\n    data_selector_submodule submodule2 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[1]),\n        .d_in(d2),\n        .d_out(out2_sub2)\n    );\n\n    // Submodule 3\n    data_selector_submodule submodule3 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel[2]),\n        .d_in(d3),\n        .d_out(out1_sub2)\n    );\n\n    // Output assignments\n    assign out1 = sel[0] ? out1_sub1 : out1_sub2;\n    assign out2 = sel[0] ? out2_sub1 : out2_sub2;\n\nendmodule\n\n// Submodule implementation\nmodule data_selector_submodule (\n    input clk,\n    input rst,\n    input sel,\n    input [7:0] d_in,\n    output reg [7:0] d_out\n);\n\n    always @(posedge clk or neg rst) begin\n        if (!rst) begin\n            d_out <= 8'b0;\n        end else begin\n            if (sel) begin\n                d_out <= d_in;\n            end else begin\n                d_out <= 8'b0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 28, "response": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] data0,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] out\n);\n\n    wire [7:0] data0_out, data1_out, data2_out, data3_out;\n\n    // Submodules\n    data_selector data_sel0 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data0),\n        .data_out(data0_out),\n        .channel_code(8'b00)\n    );\n\n    data_selector data_sel1 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data1),\n        .data_out(data1_out),\n        .channel_code(8'b01)\n    );\n\n    data_selector data_sel2 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data2),\n        .data_out(data2_out),\n        .channel_code(8'b02)\n    );\n\n    data_selector data_sel3 (\n        .clk(clk),\n        .sel(sel),\n        .data_in(data3),\n        .data_out(data3_out),\n        .channel_code(8'b03)\n    );\n\n    // Output selection\n    always @(posedge clk) begin\n        if (sel == 8'b00) begin\n            out <= data0_out;\n        end else if (sel == 8'b01) begin\n            out <= data1_out;\n        end else if (sel == 8'b02) begin\n            out <= data2_out;\n        end else if (sel == 8'b03) begin\n            out <= data3_out;\n        end\n    end\n\nendmodule"}
{"task_id": 19, "response": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output [7:0] out1,\n    output [7:0] out2\n);\n\n    wire [7:0] out1_submodule, out2_submodule;\n\n    // Submodule 1\n    wire [7:0] d1_processed;\n    assign d1_processed = (sel == 2'b01) ? d1 : 8'd0;\n    data_processor dp1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d1_processed),\n        .data_out(out1_submodule)\n    );\n\n    // Submodule 2\n    wire [7:0] d2_processed;\n    assign d2_processed = (sel == 2'b10) ? d2 : 8'd0;\n    data_processor dp2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d2_processed),\n        .data_out(out2_submodule)\n    );\n\n    // Submodule 3\n    wire [7:0] d3_processed;\n    assign d3_processed = (sel == 2'b11) ? d3 : 8'd0;\n    data_processor dp3 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(d3_processed),\n        .data_out(out1_submodule)\n    );\n\n    // Output\n    assign out1 = out1_submodule;\n    assign out2 = out2_submodule;\n\nendmodule\n\n// Submodule to process data based on the selector signal\nmodule data_processor (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            data_out <= data_in; // Process data\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "module mem_interface (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    input [15:0] data_in,\n    output [15:0] data_out,\n    output valid_out\n);\n\n    // Submodule for reading memory\n    wire [15:0] read_data;\n    mem_read mem_read_inst (\n        .clk(clk),\n        .rst(rst),\n        .read_write(read_write),\n        .address(address),\n        .data_out(read_data)\n    );\n\n    // Submodule for writing memory\n    mem_write mem_write_inst (\n        .clk(clk),\n        .rst(rst),\n        .read_write(read_write),\n        .address(address),\n        .data_in(data_in)\n    );\n\n    // Output signals\n    assign data_out = read_write == 2'b01 ? read_data : 16'h000;\n    assign valid_out = read_write == 2'b01;\n\nendmodule\n\n// Submodule for reading memory\nmodule mem_read (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'h000;\n        end else if (read_write == 2'b01) begin\n            data_out <= address; // Dummy read operation\n        end\n    end\n\nendmodule\n\n// Submodule for writing memory\nmodule mem_write (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    input [15:0] data_in\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            // No write operation\n        end else if (read_write == 2'b10) begin\n            // Dummy write operation\n        end\n    end\n\nendmodule"}
{"task_id": 4, "response": "module data_router (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] to_mem,\n    output reg [15:0] to_reg,\n    output reg [15:0] to_ext\n);\n\n    wire [15:0] mem_data, reg_data, ext_data;\n\n    // Memory module\n    memory_module mem_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .payload(payload),\n        .data_out(mem_data)\n    );\n\n    // Register module\n    register_module reg_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .payload(payload),\n        .data_out(reg_data)\n    );\n\n    // External module\n    external_module ext_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .payload(payload),\n        .data_out(ext_data)\n    );\n\n    // Output logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            to_mem <= 16'd0;\n            to_reg <= 16'd0;\n            to_ext <= 16'd0;\n        end else begin\n            case (ctrl)\n                2'b00: to_mem <= mem_data;\n                2'b01: to_reg <= reg_data;\n                2'b10: to_ext <= ext_data;\n                default: begin\n                    to_mem <= 16'd0;\n                    to_reg <= 16'd0;\n                    to_ext <= 16'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Memory module\nmodule memory_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] data_out\n);\n\n    reg [15:0] mem_data;\n\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            mem_data <= 16'd0;\n        end else begin\n            case (ctrl)\n                2'b00: mem_data <= payload;\n                default: mem_data <= mem_data;\n            endcase\n        end\n    end\n\n    assign data_out = mem_data;\n\nendmodule\n\n// Register module\nmodule register_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] data_out\n);\n\n    reg [15:0] reg_data;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_data <= 16'd0;\n        end else begin\n            case (ctrl)\n                2'b00: reg_data <= payload;\n                default: reg_data <= reg_data;\n            endcase\n        end\n    end\n\n    assign data_out = reg_data;\n\nendmodule\n\n// External module\nmodule external_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] data_out\n);\n);\n\n    reg [15:0] ext_data;\n\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ext_data <= 6'd0;\n        end\n    end else begin\n            case (ctrl)\n                2'b00: ext_data <= payload;\n                default: ext_data <= ext_data;\n            endcase\n        end\n    end\n\n    assign data_out = ext_data;\n\nendmodule"}
{"task_id": 19, "response": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output [7:0] out1,\n    output [7:0] out2\n);\n\n    // Submodule for processing data\n    wire [7:0] data_out1, data_out2;\n\n    // Submodule for processing data\n    submodule_1 submodule1 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .d_in(d1),\n        .d_out(data_out1)\n    );\n\n    submodule_2 submodule2 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .d_in(d2),\n        .d_out(data_out2)\n    );\n\n    // Submodule for processing data\n    submodule_3 submodule3 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .d_in(d3),\n        .d_out(data_out1)\n    );\n\n    // Output assignments\n    assign out1 = (sel == 2'b01) ? data_out1 : 8'd0;\n    assign out2 = (sel == 2'b10) ? data_out2 : 8'd0;\n\nendmodule\n\n// Submodule for processing data\nmodule submodule_1 (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d_in,\n    output reg [7:0] d_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            d_out <= 8'd0;\n        end else begin\n            if (sel == 2'b01) begin\n                d_out <= d_in;\n            end else begin\n                d_out <= 8'd0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for processing data\nmodule submodule_2 (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d_in,\n    output reg [7:0] d_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            d_out <= 8'd0;\n        end else begin\n            if (sel == 2'b10) begin\n                d_out <= d_in;\n            end else begin\n                d_out <= 8'd0;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for processing data\nmodule submodule_3 (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] d_in,\n    output reg [7:0] d_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            d_out <= 8'd0;\n        end else begin\n            if (sel == 2'b11) begin\n                d_out <= d_in;\n            end\n            end else begin\n                d_out <= 8'd0;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "module mem_interface (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    input [15:0] data_in,\n    output [15:0] data_out,\n    output valid_out\n);\n\n    wire read_trigger, write_trigger;\n    reg [15:0] mem_data;\n\n    // Read submodule\n    mem_read mem_read_inst (\n        .clk(clk),\n        .rst(rst),\n        .read_write(read_write),\n        .address(address),\n        .data_out(data_out),\n        .valid_out(valid_out),\n        .mem_data(mem_data),\n        .read_trigger(read_trigger)\n    );\n\n    // Write submodule\n    mem_write mem_write_inst (\n        .clk(clk),\n        .rst(rst),\n        .read_write(read_write),\n        .address(address),\n        .data_in(data_in),\n        .mem_data(mem_data),\n        .write_trigger(write_trigger)\n    );\n\nendmodule\n\n// Memory read submodule\nmodule mem_read (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    output reg [15:0] data_out,\n    output reg valid_out,\n    output reg [15:0] mem_data,\n    output reg read_trigger\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0;\n            valid_out <= 1'b0;\n            mem_data <= 16'd0;\n            read_trigger <= 1'b0;\n        end else begin\n            if (read_write == 2'b01) begin\n                data_out <= mem_data;\n                valid_out <= 1'b1;\n                mem_data <= 16'd0;\n                read_trigger <= 1'b1;\n            end else begin\n                data_out <= 16'd0;\n                valid_out <= 1'b0;\n                mem_data <= 16'd0;\n                read_trigger <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n\n// Memory write submodule\nmodule mem_write (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    input [15:0] data_in,\n    output reg [15:0] mem_data,\n    input write_trigger\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            mem_data <= 16'd0;\n        end else begin\n            if (write_trigger) begin\n                mem_data <= data_in;\n            end\n        end\n    end\n\nendmodule"}
{"task_id": 4, "response": "module data_router (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] to_mem,\n    output reg [15:0] to_reg,\n    output reg [15:0] to_ext\n);\n\n    // Submodules\n    wire [15:0] mem_data, reg_data, ext_data;\n    mem_module mem_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .payload(payload),\n        .data_out(mem_data)\n    );\n    reg_module reg_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .payload(payload),\n        .data_out(reg_data)\n    );\n    ext_module ext_module (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .payload(payload),\n        .data_out(ext_data)\n    );\n\n    // Output selection\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            to_mem <= 16'h0000;\n            to_reg <= 16'h0000;\n            to_ext <= 16'h0000;\n        end else begin\n            case (ctrl)\n                2'b00: to_mem <= mem_data;\n                2'b01: to_reg <= reg_data;\n                2'b10: to_ext <= ext_data;\n                default: begin\n                    to_mem <= to_mem;\n                    to_reg <= to_reg;\n                    to_ext <= to_ext;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Memory module\nmodule mem_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'h000;\n        end else begin\n            case (ctrl)\n                2'b00: data_out <= payload;\n                2'b01: data_out <= data_out;\n                default: data_out <= data_out;\n            endcase\n        end\n    end\n\nendmodule\n\n\n// Register module\nmodule reg_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'h000;\n        end else begin\n            case (ctrl)\n                2'b00: data_out <= payload;\n                2'b01: data_out <= data_out;\n                default: data_out <= data_out;\n            endcase\n        end\n    end\n\n\nendmodule\n\n// External module\nmodule ext_module (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'h00000;\n        end else begin\n            case (ctrl)\n                2'b00: data_out <= payload;\n                2'b01: data_out <= data_out;\n                default: data_out <= data_out;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 20, "response": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input [1:0] sensor_input,\n    output [2:0] main_road_light,\n    output [2:0] side_road_light\n);\n\n    // Submodule outputs\n    wire [2:0] main_road_light_out;\n    wire [2:0] side_road_light_out;\n\n    // Submodule instances\n    traffic_light_controller_sub main_road (\n        .clk(clk),\n        .rst(rst),\n        .sensor_input(sensor_input),\n        .light_out(main_road_light_out)\n    );\n\n    traffic_light_controller_sub side_road (\n        .clk(clk),\n        .rst(rst),\n        .sensor_input(sensor_input),\n        .light_out(side_road_light_out)\n    );\n\n    // Output assignments\n    assign main_road_light = main_road_light_out;\n    assign side_road_light = side_road_light_out;\n\nendmodule\n\n// Submodule implementation\nmodule traffic_light_controller_sub (\n    input clk,\n    input rst,\n    input [1:0] sensor_input,\n    output reg [2:0] light_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_out <= 3'b100; // Red\n        end else begin\n            case (sensor_input)\n                2'b00: light_out <= 3'b001; // Green\n                2'b01: light_out <= 3'b010; // Yellow\n                default: light_out <= 3'b100; // Red\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "module mem_interface (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    input [15:0] data_in,\n    output [15:0] data_out,\n    output valid_out\n);\n\n    wire read_trigger, write_trigger;\n    wire [15:0] read_data;\n\n    mem_read mem_read_inst (\n        .clk(clk),\n        .rst(rst),\n        .read_write(read_write),\n        .address(address),\n        .data_out(read_data),\n        .trigger(read_trigger)\n    );\n\n    mem_write mem_write_inst (\n        .clk(clk),\n        .rst(rst),\n        .read_write(read_write),\n        .address(address),\n        .data_in(data_in),\n        .trigger(write_trigger)\n    );\n\n    assign read_trigger = (read_write == 2'b01);\n    assign write_trigger = (read_write == 2'b10);\n\n    assign data_out = (read_write == 2'b01) ? read_data : 16'h000;\n    assign valid_out = (read_write == 2'b01) ? 1'b1 : 1'b0;\n\nendmodule\n\nmodule mem_read (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    output reg [15:0] data_out,\n    output reg trigger\n);\n\n    reg [15:0] mem [0:1535];\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'h000;\n            trigger <= 1'b0;\n        end else if (read_write == 2'b01) begin\n            data_out <= mem[address];\n            trigger <= 1'b1;\n        end\n    end\n\nendmodule\n\nmodule mem_write (\n    input clk,\n    input rst,\n    input [1:0] read_write,\n    input [9:0] address,\n    input [15:0] data_in,\n    input trigger\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n        end else if (read_write == 2'b10) begin\n            mem[address] <= data_in;\n        end\n    end\n\nendmodule"}
{"task_id": 20, "response": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input [1:0] sensor_input,\n    output [2:0] main_road_light,\n    output [2:0] side_road_light\n);\n\n    // Submodule outputs\n    wire [2:0] main_road_light_out;\n    wire [2:0] side_road_light_out;\n\n    // Submodule instances\n    traffic_light_controller_sub main_road (\n        .clk(clk),\n        .rst(rst),\n        .sensor_input(sensor_input),\n        .light_out(main_road_light)\n    );\n\n    traffic_light_controller_sub side_road (\n        .clk(clk),\n        .rst(rst),\n        .sensor_input(sensor_input),\n        .light_out(side_road_light)\n    );\n\nendmodule\n\n// Submodule implementation\nmodule traffic_light_controller_sub (\n    input clk,\n    input rst,\n    input [1:0] sensor_input,\n    output reg [2:0] light_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_out <= 3'b100;  // Red\n        end else begin\n            case (sensor_input)\n                2'b00: light_out <= 3'b001;  // Green\n                2'b01: light_out <= 3'b010;  // Yellow\n                default: light_out <= 3'b100;  // Red\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 4, "response": "module data_router (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] payload,\n    output reg [15:0] to_mem,\n    output reg [15:0] to_reg,\n    output reg [15:0] to_ext\n);\n\n    wire [15:0] mem_out, reg_out, ext_out;\n\n    // Submodules\n    memory_module mem_module (\n        .clk(clk),\n        .rst(rst),\n        .payload(payload),\n        .out(mem_out)\n    );\n\n    register_module reg_module (\n        .clk(clk),\n        .rst(rst),\n        .payload(payload),\n        .out(reg_out)\n    );\n\n    external_module ext_module (\n        .clk(clk),\n        .rst(rst),\n        .payload(payload),\n        .out(ext_out)\n    );\n\n    // Output selection\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            to_mem <= 16'h000;\n            to_reg <= 16'h000;\n            to_ext <= 16'h000;\n        end else begin\n            case (ctrl)\n                2'b00: to_mem <= mem_out;\n                2'b01: to_reg <= reg_out;\n                2'b10: to_ext <= ext_out;\n                default: begin\n                    to_mem <= 16'h000;\n                    to_reg <= 16'h000;\n                    to_ext <= 16'h000;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Memory module\nmodule memory_module (\n    input clk,\n    input rst,\n    input [15:0] payload,\n    output reg [15:0] out\n);\n\n    reg [15:0] mem;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            mem <= 16'h000;\n        end else begin\n            mem <= payload;\n            out <= mem;\n        end\n    end\n\nendmodule\n\n// Register module\nmodule register_module (\n    input clk,\n    input rst,\n    input [15:0] payload,\n    output reg [15:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 16'h000;\n        end else begin\n            out <= payload;\n        end\n    end\n\nendmodule\n\n// External module\nmodule external_module (\n    input clk,\n    input rst,\n    input [15:0] payload,\n    output reg [15:0] out\n);\n\n    reg [15:0] ext;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ext <= 16'h0000;\n        end else begin\n            ext <= payload;\n            out <= ext;\n        end\n    end\n\nendmodule"}
{"task_id": 20, "response": "module traffic_light_controller (\n    input clk,\n    input rst,\n    input [1:0] sensor_input,\n    output [2:0] main_road_light,\n    output [2:0] side_road_light\n);\n\n    // Submodule outputs\n    wire [2:0] main_road_light_out;\n    wire [2:0] side_road_light_out;\n\n    // Submodules\n    traffic_light_controller main_road (\n        .clk(clk),\n        .rst(rst),\n        .sensor_input(sensor_input),\n        .light_out(main_road_light_out)\n    );\n\n    traffic_light_controller side_road (\n        .clk(clk),\n        .rst(rst),\n        .sensor_input(sensor_input),\n        .light_out(side_road_light_out)\n    );\n\n    // Output assignments\n    assign main_road_light = main_road_light_out;\n    assign side_road_light = side_road_light_out;\n\nendmodule\n\n// Traffic Light Controller Submodule\nmodule traffic_light_controller (\n    input clk,\n    input rst,\n    input [1:0] sensor_input,\n    output reg [2:0] light_out\n);\n\n    // Local signals\n    reg [2:0] light_green;\n    reg [2:0] light_yellow;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            light_green <= 3'b000;\n            light_yellow <= 3'b000;\n        end else begin\n            case (sensor_input)\n                3'b00: begin // Low traffic\n                    light_green <= 3'b010;\n                    light_yellow <= 3'b000;\n                end\n                3'b01: begin // Medium traffic\n                    light_green <= 3'b001;\n                    light_yellow <= 3'b010;\n                end\n                3'b10: begin // High traffic\n                    light_green <= 3'b000;\n                    light_yellow <= 3'b001;\n                end\n                default: begin\n                    light_green <= 3'b000;\n                    light_yellow <= 3'b000;\n                end\n            endcase\n        end\n    end\n\n    assign light_out = (sensor_input == 3'b00) ? light_green : light_yellow;\n\nendmodule"}
{"task_id": 5, "response": "module data_comparator (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output eq_flag,\n    output gt_flag\n);\n\n    wire eq_flag, gt_flag;\n\n    // Submodule for equality check\n    wire eq_check;\n\n    // Submodule for greater than check\n    wire gt_check;\n\n    // Submodule for greater than check\n    wire gt_check_2;\n\n    // Instantiate submodules\n    equality_check eq_check_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .eq_flag(eq_flag)\n    );\n\n    greater_than_check gt_check_inst (\n        .clk(clk),\n        .rst(rst),\n        .data1(data1),\n        .data2(data2),\n        .gt_flag(gt_flag)\n    );\n\n    // Connect submodules based on select signal\n    assign eq_check = (sel == 2'b01) ? eq_flag : 1'b0;\n    assign gt_check = (sel == 2'b10) ? gt_flag : 1'b0;\n\nendmodule\n\n// Submodule for equality check\nmodule equality_check (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg eq_flag\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            eq_flag <= 1'b0;\n        end else begin\n            eq_flag <= (data1 == data2);\n        end\n    end\n\nendmodule\n\n// Submodule for greater than check\nmodule greater_than_check (\n    input clk,\n    input rst,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg gt_flag\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            gt_flag <= 1'b0;\n        end else begin\n            gt_flag <= (data1 > data2);\n        end\n    end\n\nendmodule"}
{"task_id": 5, "response": "module data_comparator (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output eq_flag,\n    output gt_flag\n);\n\n    wire eq_flag, gt_flag;\n\n    // Submodule for equality check\n    wire eq_check;\n\n    // Submodule for greater than check\n    wire gt_check;\n\n    // Submodule for greater than check\n    wire gt_check2;\n\n    // Submodule for greater than check\n    wire gt_check3;\n\n    // Submodule for equality check\n    wire eq_check2;\n\n    // Submodule for greater than check\n    wire gt_check4;\n\n    // Submodule for greater than check\n    wire gt_check5;\n\n    // Submodule for greater than check\n    wire gt_check6;\n\n    // Submodule for greater than check\n    wire gt_check7;\n\n    // Submodule for greater than check\n    wire gt_check8;\n\n    // Submodule for greater than check\n    wire gt_check9;\n\n    // Submodule for greater than check\n    wire gt_check10;\n\n    // Submodule for greater than check\n    wire gt_check11;\n\n    // Submodule for greater than check\n    wire gt_check12;\n\n    // Submodule for greater than check\n    wire gt_check13;\n\n    // Submodule for greater than check\n    wire gt_check14;\n\n    // Submodule for greater than check\n    wire gt_check15;\n\n    // Submodule for greater than check\n    wire gt_check16;\n\n    // Submodule for greater than check\n    wire gt_check17;\n\n    // Submodule for greater than check\n    wire gt_check18;\n\n    // Submodule for greater than check\n    wire gt_check19;\n\n    // Submodule for greater than check\n    wire gt_check20;\n\n    // Submodule for greater than check\n    wire gt_check21;\n\n    // Submodule for greater than check\n    wire gt_check22;\n\n    // Submodule for greater than check\n    wire gt_check23;\n\n    // Submodule for greater than check\n    wire gt_check24;\n\n    // Submodule for greater than check\n    wire gt_check25;\n\n    // Submodule for greater than check\n    wire gt_check26;\n\n    // Submodule for greater than check\n    wire gt_check27;\n\n    // Submodule for greater than check\n    wire gt_check28;\n\n    // Submodule for greater than check\n    wire gt_check29;\n\n\n    // Submodule for greater than check\n    wire gt_check30;\n\n    // Submodule for greater than check\n    wire gt_check31;\n\n    // Submodule for greater than check\n    wire gt_check32;\n\n    // Submodule for greater than check\n    wire gt_check33;\n\n    // Submodule for greater than check\n    wire gt_check34;\n\n    // Submodule for greater than check\n    wire gt_check35;\n\n    // Submodule for greater than check\n    wire gt_check36;\n\n    // Submodule for greater than check\n    wire gt_check37;\n\n    // Submodule for greater than check\n    wire gt_check38;\n\n    // Submodule for greater than check\n    wire gt_check39;\n\n    // Submodule for greater than check\n    wire gt_check40;\n\n    // Submodule for greater than check\n    wire gt_check41;\n\n    // Submodule for greater than check\n    wire gt_check42;\n\n    // Submodule for greater than check\n    greater_than_check (\n        input clk,\n        input rst,\n        input [1:0] sel,\n        input [7:0] data1,\n        input [7:0] data2,\n        output reg_flag,\n        output gt_flag\n    );"}
{"task_id": 5, "response": "module data_comparator (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output eq_flag,\n    output gt_flag\n);\n\n    wire eq_flag, gt_flag;\n\n    // Submodule for equality check\n    wire eq_check;\n\n    // Submodule for greater than check\n    wire gt_check;\n\n    // Submodule for greater than check\n    wire gt_check_2;\n\n    // Submodule for equality check\n    assign eq_check = (data1 == data2);\n\n    // Submodule for greater than check\n    assign gt_check = (data1 > data2);\n\n    // Submodule for greater than check\n    assign gt_check_2 = (data1 > data2);\n\n    // Output flags\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            eq_flag <= 1'b0;\n            gt_flag <= 1'b0;\n        end else begin\n            case (sel)\n                2'b01: begin\n                    eq_flag <= eq_check;\n                    gt_flag <= 1'b0;\n                end\n                2'b10: begin\n                    eq_flag <= 1'b0;\n                    gt_flag <= gt_check;\n                end\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 6, "response": "module clock_divider (\n    input clk,\n    input rst,\n    output clk_out1,\n    output clk_out2,\n    output clk_out3\n);\n\n    // Submodule 1: Divide by 2\n    wire clk_div2;\n    divider_by_2 div2 (.clk(clk), .rst(rst), .clk_out(clk_div2));\n\n    // Submodule 2: Divide by 4\n    wire clk_div4;\n    divider_by_4 div4 (.clk(clk), .rst(rst), .clk_out(clk_div4));\n\n    // Submodule 3: Divide by 8\n    wire clk_div8;\n    divider_by_8 div8 (.clk(clk), .rst(rst), .clk_out(clk_div8));\n\nendmodule\n\n// Submodule to divide the clock by 2\nmodule divider_by_2 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else if (clk) begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\n// Submodule to divide the clock by 4\nmodule divider_by_4 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else if (clk) begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\n// Submodule to divide the clock by 8\nmodule divider_by_8 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else if (clk) begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule"}
{"task_id": 6, "response": "module clock_divider (\n    input clk,\n    input rst,\n    output clk_out1,\n\n    output clk_out2,\n\n    output clk_out3\n);\n\n    // Submodule 1: Divide by 2\n    wire clk_div2;\n    divider div2 (\n        .clk(clk),\n        .rst(rst),\n        .clk_out(clk_div2)\n    );\n\n    // Submodule 2: Divide by 4\n    wire clk_div4;\n    divider div4 (\n        .clk(clk_div2),\n        .rst(rst),\n        .clk_out(clk_div4)\n    );\n\n    // Submodule 3: Divide by 8\n    wire clk_div8;\n    divider div8 (\n        .clk(clk_div4),\n        .rst(rst),\n        .clk_out(clk_div8)\n    );\n\n    // Output assignment\n    assign clk_out1 = clk_div2;\n    assign clk_out2 = clk_div4;\n    assign clk_out3 = clk_div8;\n\nendmodule\n\n// Submodule for dividing clock by 2\nmodule divider (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge) begin\n        if (rst == 0) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\n// Submodule for dividing clock by 4\nmodule divider (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge) begin\n        if (rst == 0) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\n// Submodule for dividing clock by 8\nmodule divider (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge) begin\n        if (rst == 0) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule"}
{"task_id": 6, "response": "module clock_divider (\n    input clk,\n    input rst,\n    output clk_out1,\n\n    output clk_out2,\n\n    output clk_out3\n);\n\n    // Submodule 1: Divide by 2\n    wire clk_div2;\n    divider_by_2 div2 (.clk(clk), .rst(rst), .clk_out(clk_div2));\n\n    // Submodule 2: Divide by 4\n    wire clk_div4;\n    divider_by_4 div4 (.clk(clk), .rst(rst), .clk_out(clk_div4));\n\n    // Submodule 3: Divide by 8\n    wire clk_div8;\n    divider_by_8 div8 (.clk(clk), .rst(rst), .clk_out(clk_div8));\n\nendmodule\n\nmodule divider_by_2 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else if (clk) begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\nmodule divider_by_4 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else if (clk) begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule\n\nmodule divider_by_8 (\n    input clk,\n    input rst,\n    output reg clk_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            clk_out <= 0;\n        end else if (clk) begin\n            clk_out <= ~clk_out;\n        end\n    end\n\nendmodule"}
