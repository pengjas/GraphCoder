[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'op_code', 'type': 'input port'}, {'id': 2, 'content': 'func3', 'type': 'input port'}, {'id': 3, 'content': 'func7', 'type': 'input port'}, {'id': 4, 'content': 'alu_op', 'type': 'output port'}, {'id': 5, 'content': 'logic_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 3, 5], [5, 5, 5, 4]]\n, Design a Verilog module named \"alu_control_unit\" for a RISC-V ALU that takes an instruction and decodes it to generate control signals for an Arithmetic Logic Unit (ALU). The module should handle a subset of RISC-V instructions that includes add, subtract, and bitwise AND.\n\nModule name:\n    alu_control_unit\n\nInput ports:\n    clk: Clock input for synchronization.\n    op_code [6:0]: 7-bit operation code from the instruction.\n    func3 [2:0]: 3-bit function field from the instruction.\n    func7 [6:0]: 7-bit function field for extended instruction decoding.\n\nOutput ports:\n    alu_op [3:0]: Control signals for the ALU operation.\n\nImplementation:\n    The alu_control_unit module decodes the instruction based on the op_code, func3, and func7 values.\n    This decoding process involves a sub-module \"decode_logic\" which takes the instruction fields as inputs and produces the appropriate ALU operation signal.\n    The output \"alu_op\" is set by the decode_logic submodule based on the input instruction fields.\n    The module should support a reset condition that sets the ALU operation to a default state.\nGive me the complete code."}, {"from": "gpt", "value": "module alu_control_unit (\n    input clk,\n    input [6:0] op_code,\n    input [2:0] func3,\n    input [6:0] func7,\n    output [3:0] alu_op\n);\n\n    wire [3:0] decoded_op;\n\n    decode_logic logic_unit (\n        .op_code(op_code),\n        .func3(func3),\n        .func7(func7),\n        .alu_op(decoded_op)\n    );\n\n    assign alu_op = decoded_op;\n\nendmodule\n\nmodule decode_logic (\n    input [6:0] op_code,\n    input [2:0] func3,\n    input [6:0] func7,\n    output reg [3:0] alu_op\n);\n\n    always @(*) begin\n        case (op_code)\n            7'b0110011: begin // R-type\n                case (func3)\n                    3'b000: alu_op <= (func7 == 7'b0000000) ? 4'b0000 : // ADD\n                                       (func7 == 7'b0100000) ? 4'b0001 : // SUB\n                                       4'b1111; // Undefined\n                    3'b111: alu_op <= 4'b0010; // AND\n                    default: alu_op <= 4'b1111; // Undefined\n                endcase\n            end\n            default: alu_op <= 4'b1111; // Undefined\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'funct7', 'type': 'output port'}, {'id': 9, 'content': 'opcode_extractor', 'type': 'submodule'}, {'id': 10, 'content': 'rd_extractor', 'type': 'submodule'}, {'id': 11, 'content': 'funct3_extractor', 'type': 'submodule'}, {'id': 12, 'content': 'rs1_extractor', 'type': 'submodule'}, {'id': 13, 'content': 'rs2_extractor', 'type': 'submodule'}, {'id': 14, 'content': 'funct7_extractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 2, 1, 0, 9, 10, 11, 12, 13, 14], [9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 14, 3, 4, 5, 6, 7, 8]]\n, Design a Verilog module for a RISC-V instruction decoder that extracts and decodes the opcode, function codes, and register addresses from a 32-bit instruction input. The module uses submodules to handle specific parts of the decoding.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    instr [31:0]: 32-bit input representing the full instruction.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode extracted from the instruction.\n    rd [4:0]: 5-bit destination register address.\n    funct3 [2:0]: 3-bit function code part of the instruction.\n    rs1 [4:0]: 5-bit first source register address.\n    rs2 [4:0]: 5-bit second source register address.\n    funct7 [6:0]: 7-bit function code for certain instructions.\n\nImplementation:\n    The instruction_decoder module instantiates several submodules each responsible for extracting specific parts of the instruction based on the bit positions defined by the RISC-V standard.\n    Outputs are updated on the positive edge of the clock and reset to zero when rst is asserted.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7\n);\n\n    // Submodules for extracting instruction fields\n    bit_extractor opcode_extractor (\n        .clk(clk),\n        .rst(rst),\n        .data(instr[6:0]),\n        .out(opcode)\n    );\n\n    bit_extractor rd_extractor (\n        .clk(clk),\n        .rst(rst),\n        .data(instr[11:7]),\n        .out(rd)\n    );\n\n    bit_extractor funct3_extractor (\n        .clk(clk),\n        .rst(rst),\n        .data(instr[14:12]),\n        .out(funct3)\n    );\n\n    bit_extractor rs1_extractor (\n        .clk(clk),\n        .rst(rst),\n        .data(instr[19:15]),\n        .out(rs1)\n    );\n\n    bit_extractor rs2_extractor (\n        .clk(clk),\n        .rst(rst),\n        .data(instr[24:20]),\n        .out(rs2)\n    );\n\n    bit_extractor funct7_extractor (\n        .clk(clk),\n        .rst(rst),\n        .data(instr[31:25]),\n        .out(funct7)\n    );\n\nendmodule\n\n// Submodule for extracting bits\nmodule bit_extractor (\n    input clk,\n    input rst,\n    input [6:0] data,\n    output reg [6:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 7'd0;\n        end else begin\n            out <= data;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}, {'id': 9, 'content': 'op_dec', 'type': 'submodule'}, {'id': 10, 'content': 'reg_dec', 'type': 'submodule'}, {'id': 11, 'content': 'imm_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 9, 10, 2, 10, 10, 11], [9, 10, 11, 3, 4, 5, 6, 7, 8]]\n, Design a RISC-V instruction decoder module that takes a 32-bit instruction and decodes it into various functional fields. This module should utilize submodules to decode specific parts of the instruction such as the opcode, register addresses, and immediate values.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    instruction [31:0]: The 32-bit instruction to be decoded.\n\nOutput ports:\n    opcode [6:0]: Extracted opcode of the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function field for additional operation specification.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address.\n    imm [11:0]: Immediate value for operations requiring constants.\n\nImplementation:\n    The instruction decoder uses several submodules, each responsible for extracting specific parts of the instruction. The opcode, rd, funct3, rs1, rs2, and imm values are extracted based on the current instruction format.\n    The module operates synchronously with the clock signal, updating output values on the rising edge.\n    The outputs are derived from the appropriate bits of the instruction and are determined conditionally based on the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [11:0] imm\n);\n\n    // Submodule for opcode extraction\n    wire [6:0] opcode_extracted;\n    opcode_decoder op_dec (\n        .instruction(instruction),\n        .opcode(opcode_extracted)\n    );\n\n    // Submodule for register addresses extraction\n    wire [4:0] rd_extracted, rs1_extracted, rs2_extracted;\n    reg_address_decoder reg_dec (\n        .instruction(instruction),\n        .rd(rd_extracted),\n        .rs1(rs1_extracted),\n        .rs2(rs2_extracted)\n    );\n\n    // Submodule for immediate value extraction\n    wire [11:0] imm_extracted;\n    immediate_decoder imm_dec (\n        .instruction(instruction),\n        .imm(imm_extracted)\n    );\n\n    // Output assignments\n    assign opcode = opcode_extracted;\n    assign rd = rd_extracted;\n    assign funct3 = instruction[14:12];\n    assign rs1 = rs1_extracted;\n    assign rs2 = rs2_extracted;\n    assign imm = imm_extracted;\n\nendmodule\n\n// Submodule for opcode extraction\nmodule opcode_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\n// Submodule for register addresses extraction\nmodule reg_address_decoder (\n    input [31:0] instruction,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\nendmodule\n\n// Submodule for immediate value extraction\nmodule immediate_decoder (\n    input [31:0] instruction,\n    output [11:0] imm\n);\n    assign imm = instruction[31:20];\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'opcode', 'type': 'input port'}, {'id': 1, 'content': 'RegWrite', 'type': 'output port'}, {'id': 2, 'content': 'ALUSrc', 'type': 'output port'}, {'id': 3, 'content': 'MemToReg', 'type': 'output port'}, {'id': 4, 'content': 'MemWrite', 'type': 'output port'}, {'id': 5, 'content': 'Branch', 'type': 'output port'}, {'id': 6, 'content': 'rtc', 'type': 'submodule'}, {'id': 7, 'content': 'itc', 'type': 'submodule'}, {'id': 8, 'content': 'stc', 'type': 'submodule'}, {'id': 9, 'content': 'btc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 7, 6, 7, 6, 7, 8, 9], [6, 7, 8, 9, 1, 1, 2, 2, 3, 4, 5]]\n, Design a Verilog module for a RISC-V single-cycle control unit that decodes the instruction type and controls the signals accordingly for different types of operations (R-type, I-type, S-type, B-type). It utilizes submodules to decode and manage control signals for each type.\n\nModule name:\n    control_unit\n\nInput ports:\n    opcode [6:0]: 7-bit opcode input which determines the type of the instruction.\n    \nOutput ports:\n    RegWrite: Signal to indicate if a register should be written.\n    ALUSrc: Signal to determine the source of the second operand for the ALU.\n    MemToReg: Signal to control if the data should come from memory to register.\n    MemWrite: Signal to control writing to memory.\n    Branch: Signal to control branching.\n\nImplementation:\n    Based on the opcode input, various control signals are set in the corresponding submodule.\n    The main control unit decides which submodule to activate based on the leading bits of the opcode.\n    Each submodule is responsible for handling the control logic for each type of operation.\n    The outputs are set based on active submodule outputs.\nGive me the complete code."}, {"from": "gpt", "value": "module control_unit (\n    input [6:0] opcode,\n    output RegWrite,\n    output ALUSrc,\n    output MemToReg,\n    output MemWrite,\n    output Branch\n);\n\n    wire r_type, i_type, s_type, b_type;\n\n    // Opcode decoding for instruction types\n    assign r_type = (opcode == 7'b0110011);\n    assign i_type = (opcode == 7'b0010011 || opcode == 7'b0000011);\n    assign s_type = (opcode == 7'b0100011);\n    assign b_type = (opcode == 7'b1100011);\n\n    // Submodules for each instruction type control logic\n    r_type_control rtc(.enable(r_type), .RegWrite(RegWrite), .ALUSrc(ALUSrc));\n    i_type_control itc(.enable(i_type), .RegWrite(RegWrite), .ALUSrc(ALUSrc), .MemToReg(MemToReg));\n    s_type_control stc(.enable(s_type), .MemWrite(MemWrite));\n    b_type_control btc(.enable(b_type), .Branch(Branch));\n\nendmodule\n\n// Submodule for R-type instructions\nmodule r_type_control(input enable, output RegWrite, output ALUSrc);\n    assign RegWrite = enable;\n    assign ALUSrc = 0;\nendmodule\n\n// Submodule for I-type instructions\nmodule i_type_control(input enable, output RegWrite, output ALUSrc, output MemToReg);\n    assign RegWrite = enable;\n    assign ALUSrc = 1;\n    assign MemToReg = enable;\nendmodule\n\n// Submodule for S-type instructions\nmodule s_type_control(input enable, output MemWrite);\n    assign MemWrite = enable;\nendmodule\n\n// Submodule for B-type instructions\nmodule b_type_control(input enable, output Branch);\n    assign Branch = enable;\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'csr_cmd', 'type': 'input port'}, {'id': 3, 'content': 'csr_addr', 'type': 'input port'}, {'id': 4, 'content': 'write_data', 'type': 'input port'}, {'id': 5, 'content': 'read_data', 'type': 'output port'}, {'id': 6, 'content': 'csr_busy', 'type': 'output port'}, {'id': 7, 'content': 'read_unit', 'type': 'submodule'}, {'id': 8, 'content': 'write_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 1, 0, 3, 0, 4, 2, 1, 7, 2], [7, 7, 7, 7, 8, 8, 8, 8, 8, 5, 6]]\n, A RISC-V Control Status Register (CSR) module for handling CSR access instructions. It supports read and write operations to model simple CSR functionality based on specific control signals.\n\nModule name:\n    csr_module\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the CSR.\n    csr_cmd [1:0]: Command indicating CSR operation (00 for no operation, 01 for read, 10 for write).\n    csr_addr [11:0]: 12-bit CSR address.\n    write_data [31:0]: 32-bit data for CSR write operation.\n\nOutput ports:\n    read_data [31:0]: 32-bit output data from CSR read operation.\n    csr_busy: High when a CSR operation is being processed.\n\nImplementation:\n    The CSR module is implemented using a read submodule and a write submodule.\n    During write operations indicated by csr_cmd, data is written to the CSR address specified.\n    During read operations, data from the specified CSR address is output.\n    The csr_busy signal indicates whether a CSR operation is in progress.\nGive me the complete code."}, {"from": "gpt", "value": "module csr_module (\n    input clk,\n    input rst,\n    input [1:0] csr_cmd,\n    input [11:0] csr_addr,\n    input [31:0] write_data,\n    output [31:0] read_data,\n    output csr_busy\n);\n\n    // Submodule connections\n    wire [31:0] internal_data;\n    reg csr_busy_reg;\n\n    csr_read read_unit (\n        .clk(clk),\n        .rst(rst),\n        .csr_addr(csr_addr),\n        .csr_cmd(csr_cmd),\n        .read_data(read_data),\n        .data(internal_data)\n    );\n\n    csr_write write_unit (\n        .clk(clk),\n        .rst(rst),\n        .csr_addr(csr_addr),\n        .write_data(write_data),\n        .csr_cmd(csr_cmd),\n        .data(internal_data)\n    );\n\n    // Busy signal logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            csr_busy_reg <= 1'b0;\n        end else begin\n            csr_busy_reg <= (csr_cmd != 2'b00);\n        end\n    end\n\n    assign csr_busy = csr_busy_reg;\n\nendmodule\n\nmodule csr_read (\n    input clk,\n    input rst,\n    input [11:0] csr_addr,\n    input [1:0] csr_cmd,\n    output [31:0] read_data,\n    input [31:0] data\n);\n\n    reg [31:0] csr_mem[0:4095]; // Simulated CSR memory space\n\n    assign read_data = (csr_cmd == 2'b01) ? csr_mem[csr_addr] : 32'd0;\n\nendmodule\n\nmodule csr_write (\n    input clk,\n    input rst,\n    input [11:0] csr_addr,\n    input [31:0] write_data,\n    input [1:0] csr_cmd,\n    inout [31:0] data\n);\n\n    reg [31:0] csr_mem[0:4095]; // Simulated CSR memory space\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            csr_mem[csr_addr] <= 32'd0;\n        end else if (csr_cmd == 2'b10) begin\n            csr_mem[csr_addr] <= write_data;\n        end\n    end\n\n    assign data = csr_mem[csr_addr];\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'instruction', 'type': 'input port'}, {'id': 4, 'content': 'new_pc', 'type': 'output port'}, {'id': 5, 'content': 'link_address', 'type': 'output port'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'update', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 6, 2, 0, 7, 7], [6, 7, 7, 7, 7, 4, 5]]\n, A module named \"jump_control\" designed to decode and execute the JAL (Jump and Link) RISC-V instruction, controlling program flow based on input conditions. It reads the current instruction, extracts the jump offset, updates the program counter (PC), and stores the return address.\n\nModule name:\n    jump_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the state.\n    enable: Enable signal to initiate the jump calculation.\n    instruction [31:0]: Full 32-bit instruction containing opcode and jump offset.\n\nOutput ports:\n    new_pc [31:0]: The new program counter value after the jump.\n    link_address [31:0]: The address to return to after the function call.\n\nImplementation:\n    The module uses an \"offset_decoder\" submodule to decode the 20-bit offset from the instruction and compute the effective jump target. Another submodule, \"pc_updater\", computes the new program counter based on the jump target.\n    On the rising edge of the clock, if the reset is low, it initializes all outputs to zero. If enabled and the opcode matches the JAL instruction (opcode 0x6F), it activates the submodules to compute the new PC and the link address (current PC + 4).\nGive me the complete code."}, {"from": "gpt", "value": "module jump_control (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] instruction,\n    output [31:0] new_pc,\n    output [31:0] link_address\n);\n\n    wire [31:0] jump_target, current_pc;\n    wire [19:0] offset;\n\n    assign offset = instruction[31:12]; // Extract 20-bit offset from instruction\n\n    offset_decoder decode (\n        .offset(offset),\n        .jump_target(jump_target)\n    );\n\n    pc_updater update (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .jump_target(jump_target),\n        .new_pc(new_pc),\n        .link_address(link_address),\n        .current_pc(current_pc)\n    );\n\n    // Assign the current PC for testing purposes or from another module\n    assign current_pc = 32'd100; // Example starting PC for functionality\n\nendmodule\n\n// Submodule for decoding the jump offset\nmodule offset_decoder (\n    input [19:0] offset,\n    output [31:0] jump_target\n);\n\n    assign jump_target = {offset, 12'b0}; // Shift offset to form the full address\n\nendmodule\n\n// Submodule for updating the program counter\nmodule pc_updater (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] jump_target,\n    output reg [31:0] new_pc,\n    output reg [31:0] link_address,\n    input [31:0] current_pc\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            new_pc <= 32'd0;\n            link_address <= 32'd0;\n        end else if (enable) begin\n            new_pc <= jump_target;\n            link_address <= current_pc + 4;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'input port'}, {'id': 2, 'content': 'immediate', 'type': 'output port'}, {'id': 3, 'content': 'i_type_extract', 'type': 'submodule'}, {'id': 4, 'content': 's_type_extract', 'type': 'submodule'}, {'id': 5, 'content': 'b_type_extract', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 5, 1, 3, 4], [3, 4, 5, 2, 2, 2, 2]]\n, Design a RISC-V Immediate Generation Module that extracts immediate values from different RISC-V instruction formats (I-Type, S-Type, and B-Type). The module should receive the instruction as input and output the appropriate immediate value, depending on the instruction type determined by the opcode. \n\nModule name:\n    imm_gen\n\nInput ports:\n    instr [31:0]: 32-bit input instruction from which the immediate value will be extracted.\n    opcode [6:0]: Opcode to determine the instruction format.\n\nOutput ports:\n    immediate [31:0]: The 32-bit immediate value extracted and sign-extended from the input instruction.\n\nImplementation:\n    The immediate generation module uses a submodule for each instruction type to extract and sign-extend the immediate value.\n    The top module decodes the opcode and directs the instruction to the appropriate submodule.\n    The immediate output depends on the submodule that processes the instruction based on the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module imm_gen (\n    input [31:0] instr,\n    input [6:0] opcode,\n    output [31:0] immediate\n);\n\n    // Wires for submodule outputs\n    wire [31:0] imm_i_type, imm_s_type, imm_b_type;\n\n    // Submodules for each instruction type\n    i_type_imm_extractor i_type_extract (\n        .instr(instr),\n        .imm_out(imm_i_type)\n    );\n\n    s_type_imm_extractor s_type_extract (\n        .instr(instr),\n        .imm_out(imm_s_type)\n    );\n\n    b_type_imm_extractor b_type_extract (\n        .instr(instr),\n        .imm_out(imm_b_type)\n    );\n\n    // Immediate output selection based on opcode\n    assign immediate = (opcode == 7'b0010011) ? imm_i_type :   // Opcode for I-Type\n                       (opcode == 7'b0100011) ? imm_s_type :   // Opcode for S-Type\n                       (opcode == 7'b1100011) ? imm_b_type :   // Opcode for B-Type\n                       32'b0;                                   // Default case\n\nendmodule\n\n// I-Type immediate extractor submodule\nmodule i_type_imm_extractor (\n    input [31:0] instr,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{instr[31]}}, instr[31:20]}; // Sign-extend the immediate\nendmodule\n\n// S-Type immediate extractor submodule\nmodule s_type_imm_extractor (\n    input [31:0] instr,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{instr[31]}}, instr[31:25], instr[11:7]}; // Sign-extend the immediate\nendmodule\n\n// B-Type immediate extractor submodule\nmodule b_type_imm_extractor (\n    input [31:0] instr,\n    output [31:0] imm_out\n);\n    assign imm_out = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}; // Sign-extend the immediate\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'inst_type', 'type': 'input port'}, {'id': 2, 'content': 'immediate', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0], [2]]\n, Design a RISC-V immediate value decoder submodule for a Verilog CPU implementation. This module should extract immediate values from an incoming 32-bit instruction, decode it according to the type of the instruction (I, S, B, U, J), and output the appropriate signed immediate value.\n\nModule name:\n    immediate_decoder\n\nInput ports:\n    instruction [31:0]: 32-bit input representing the entire CPU instruction.\n    inst_type [2:0]: Input signal indicating the type of instruction (0 for I-type, 1 for S-type, 2 for B-type, 3 for U-type, 4 for J-type).\n\nOutput ports:\n    immediate [31:0]: 32-bit output representing the decoded signed immediate value.\n\nImplementation:\n    The immediate_decoder module is implemented with internal logic to decode the immediate value based on the instruction type. It uses bit slicing and concatenation to extract and assemble the immediate value accordingly.\n    The output immediate is sign-extended to 32 bits and calculated conditionally based on the value of inst_type.\nGive me the complete code."}, {"from": "gpt", "value": "module immediate_decoder (\n    input [31:0] instruction,\n    input [2:0] inst_type,\n    output reg [31:0] immediate\n);\n\n    always @(*) begin\n        case (inst_type)\n            3'b000: immediate = {{21{instruction[31]}}, instruction[30:20]}; // I-type\n            3'b001: immediate = {{21{instruction[31]}}, instruction[30:25], instruction[11:7]}; // S-type\n            3'b010: immediate = {{20{instruction[31]}}, instruction[7], instruction[30:25], instruction[11:8], 1'b0}; // B-type\n            3'b011: immediate = {instruction[31:12], 12'b0}; // U-type\n            3'b100: immediate = {{12{instruction[31]}}, instruction[19:12], instruction[20], instruction[30:21], 1'b0}; // J-type\n            default: immediate = 32'b0; // Default case for safety\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'funct3', 'type': 'output port'}, {'id': 5, 'content': 'funct7', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'rs1', 'type': 'output port'}, {'id': 8, 'content': 'rs2', 'type': 'output port'}, {'id': 9, 'content': 'imm', 'type': 'output port'}, {'id': 10, 'content': 'control_signals', 'type': 'output port'}, {'id': 11, 'content': 'td', 'type': 'submodule'}, {'id': 12, 'content': 'csg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 11, 11, 11, 11, 11, 11, 11, 11, 12], [11, 12, 3, 4, 5, 6, 7, 8, 9, 10]]\n, A RISC-V instruction decoder module that interprets a 32-bit instruction and outputs relevant control signals for different stages of an instruction processing pipeline. This module should include a submodule to decode the instruction type (R-type, I-type, S-type, etc.) and another submodule to generate specific control signals based on the instruction type.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    instruction [31:0]: Full 32-bit instruction to be decoded.\n\nOutput ports:\n    opcode [6:0]: Opcode field of the instruction.\n    funct3 [2:0]: Function field, used in some formats.\n    funct7 [6:0]: Function field, used in R-type instructions.\n    rd [4:0]: Destination register.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    imm [31:0]: Immediate value, extracted and sign-extended.\n    control_signals [5:0]: Control signals for the pipeline stages.\n\nImplementation:\n    The instruction decoder is implemented using two submodules: type_decoder and control_signal_generator.\n    The type_decoder extracts fields like opcode, funct3, funct7, rs1, rs2, rd, and also processes immediate values.\n    The control_signal_generator submodule uses the opcode and funct fields to output control signals for further pipeline processing.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [31:0] imm,\n    output [5:0] control_signals\n);\n\n    wire [31:0] imm_gen_out;\n\n    type_decoder td(\n        .instruction(instruction),\n        .opcode(opcode),\n        .funct3(funct3),\n        .funct7(funct7),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .imm(imm_gen_out)\n    );\n\n    control_signal_generator csg(\n        .opcode(opcode),\n        .funct3(funct3),\n        .control_out(control_signals)\n    );\n\n    assign imm = imm_gen_out;\n\nendmodule\n\nmodule type_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output reg [31:0] imm\n);\n\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign funct7 = instruction[31:25];\n\n    always @(*) begin\n        case(opcode)\n            7'b0010011: imm = {{20{instruction[31]}}, instruction[31:20]}; // I-type\n            default: imm = 32'd0;\n        endcase\n    end\n\nendmodule\n\nmodule control_signal_generator (\n    input [6:0] opcode,\n    input [2:0] funct3,\n    output reg [5:0] control_out\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0110011: control_out = 6'b000001; // R-type\n            7'b0010011: control_out = 6'b000010; // I-type\n            default: control_out = 6'b000000;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'inst', 'type': 'input port'}, {'id': 3, 'content': 'shift_type', 'type': 'output port'}, {'id': 4, 'content': 'shift_dist', 'type': 'output port'}, {'id': 5, 'content': 'left_shift_decoder', 'type': 'submodule'}, {'id': 6, 'content': 'right_shift_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 2, 1, 0, 6, 5, 6], [5, 5, 5, 6, 6, 6, 3, 4, 4]]\n, Design a RISC-V Shift Register Decoder module that separates an instruction into opcode and operand parts, aimed to decode shift operations. The module identifies if the operation is a logical left or right shift, and outputs the operation details, including shift direction and distance.\n\nModule name:\n    shift_decoder\n\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Active low reset signal for initialization.\n    inst [15:0]: 16-bit instruction input where [15:12] indicates the operation and [11:0] are operands.\n\nOutput ports:\n    shift_type: Indicates the type of shift (0 for left, 1 for right).\n    shift_dist [5:0]: Indicates the distance to shift, taken from the lower 6 bits of the operand.\n\nImplementation:\n    Based on the opcode, the decoder module directs the instruction to one of two submodules to handle either left or right shifts.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Depending on the opcode:\n    If opcode is 4'h0, the left shift is decoded.\n    If opcode is 4'h1, the right shift is decoded.\n    If neither opcode matches, outputs remain unchanged.\n    The outputs shift_type and shift_dist are generated based on the active submodule's outputs.\nGive me the complete code."}, {"from": "gpt", "value": "module shift_decoder (\n    input clk,\n    input rst,\n    input [15:0] inst,\n    output shift_type,\n    output [5:0] shift_dist\n);\n\n    wire [3:0] opcode = inst[15:12];\n    wire [11:0] operand = inst[11:0];\n\n    // Submodule wires\n    wire left_shift_active, right_shift_active;\n    wire [5:0] left_shift_dist, right_shift_dist;\n\n    decode_left_shift left_shift_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .operand(operand),\n        .active(left_shift_active),\n        .shift_dist(left_shift_dist)\n    );\n\n    decode_right_shift right_shift_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .operand(operand),\n        .active(right_shift_active),\n        .shift_dist(right_shift_dist)\n    );\n\n    assign shift_type = right_shift_active;\n    assign shift_dist = (left_shift_active ? left_shift_dist : right_shift_dist);\n\nendmodule\n\nmodule decode_left_shift (\n    input clk,\n    input rst,\n    input [3:0] opcode,\n    input [11:0] operand,\n    output reg active,\n    output reg [5:0] shift_dist\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            active <= 0;\n            shift_dist <= 0;\n        end else if (opcode == 4'h0) begin\n            active <= 1;\n            shift_dist <= operand[5:0];\n        end else begin\n            active <= 0;\n            shift_dist <= shift_dist;\n        end\n    end\n\nendmodule\n\nmodule decode_right_shift (\n    input clk,\n    input rst,\n    input [3:0] opcode,\n    input [11:0] operand,\n    output reg active,\n    output reg [5:0] shift_dist\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            active <= 0;\n            shift_dist <= 0;\n        end else if (opcode == 4'h1) begin\n            active <= 1;\n            shift_dist <= operand[5:0];\n        end else begin\n            active <= 0;\n            shift_dist <= shift_dist;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'instr', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'output port'}, {'id': 3, 'content': 'rs1', 'type': 'output port'}, {'id': 4, 'content': 'rs2', 'type': 'output port'}, {'id': 5, 'content': 'rd', 'type': 'output port'}, {'id': 6, 'content': 'funct3', 'type': 'output port'}, {'id': 7, 'content': 'funct7', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 1, 1, 1, 1], [2, 3, 4, 5, 6, 7, 8]]\n, Design a RISC-V instruction decoder module that takes a 32-bit encoded instruction and decodes it into various control signals for a processor's control unit. This module should support decoding of basic RISC-V instructions including register-register arithmetic, immediate arithmetic, and load/store operations.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    instr [31:0]: 32-bit input representing the full instruction code.\n\nOutput ports:\n    opcode [6:0]: Opcode field of the instruction.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function3 field, used in arithmetic and memory access.\n    funct7 [6:0]: Function7 field, used in arithmetic.\n    imm [11:0]: Immediate value for immediate operations.\n\nImplementation:\n    The instruction decoder module reads the instruction from the input and breaks it down into several fields which are commonly used in the control logic of RISC-V CPUs. Each field is directly mapped from specific bit positions of the 32-bit instruction. This module does not implement any logic operations but simply partitions the instruction into relevant fields.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output reg [11:0] imm\n);\n\n    // Decode each field from the instruction\n    assign opcode = instr[6:0];\n    assign rd = instr[11:7];\n    assign funct3 = instr[14:12];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign funct7 = instr[31:25];\n\n    always @(posedge clk) begin\n        // Decode immediate value based on opcode\n        case (opcode)\n            7'b0010011, // I-Type\n            7'b0000011: // Load-type\n                imm <= instr[31:20];\n            7'b0100011: // S-Type\n                imm <= {instr[31:25], instr[11:7]};\n            default:\n                imm <= 12'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch_op', 'type': 'input port'}, {'id': 3, 'content': 'cond_flag', 'type': 'input port'}, {'id': 4, 'content': 'current_pc', 'type': 'input port'}, {'id': 5, 'content': 'next_pc', 'type': 'output port'}, {'id': 6, 'content': 'logic_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 4], [6, 6, 5]]\n, Design a Verilog module called `branch_controller` to handle branch operations in a CPU based on RISC-V ISA. This module should decode and execute branch instructions based on condition flags and update the program counter accordingly.\n\nModule name:\n    branch_controller\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    branch_op [2:0]: Control signal specifying the type of branch operation (e.g., BEQ, BNE, etc.).\n    cond_flag: Condition flag from ALU or comparator indicating the result of the previous comparison.\n    current_pc [31:0]: Current program counter value.\n\nOutput ports:\n    next_pc [31:0]: Updated program counter value based on the branch decision.\n\nImplementation:\n    The branch_controller uses one submodule `branch_logic` to decide whether to take the branch based on the branch operation and condition flag.\n    If a branch is taken, next_pc is updated to `current_pc + 4` (branch target address assuming a fixed branch length of 4 bytes).\n    Otherwise, the next_pc is set to `current_pc + 4`, advancing to the next sequential instruction.\n    Supports basic branch types like BEQ (branch if equal) and BNE (branch if not equal).\nGive me the complete code."}, {"from": "gpt", "value": "module branch_controller(\n    input clk,\n    input rst,\n    input [2:0] branch_op,\n    input cond_flag,\n    input [31:0] current_pc,\n    output reg [31:0] next_pc\n);\n\n    wire take_branch;\n\n    branch_logic logic_unit (\n        .branch_op(branch_op),\n        .cond_flag(cond_flag),\n        .take_branch(take_branch)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            next_pc <= 32'b0;\n        end else begin\n            if (take_branch) begin\n                next_pc <= current_pc + 32'd4;  // Branch taken\n            end else begin\n                next_pc <= current_pc + 32'd4;  // Branch not taken or sequential instruction\n            end\n        end\n    end\n\nendmodule\n\nmodule branch_logic(\n    input [2:0] branch_op,\n    input cond_flag,\n    output reg take_branch\n);\n\n    always @* begin\n        case (branch_op)\n            3'b000: take_branch = cond_flag; // BEQ\n            3'b001: take_branch = !cond_flag; // BNE\n            default: take_branch = 0; // No branch\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'func7', 'type': 'input port'}, {'id': 1, 'content': 'func3', 'type': 'input port'}, {'id': 2, 'content': 'alu_op', 'type': 'output port'}, {'id': 3, 'content': 'shift_type', 'type': 'output port'}, {'id': 4, 'content': 'arith_dec', 'type': 'submodule'}, {'id': 5, 'content': 'logic_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 5, 0, 1, 5], [4, 4, 5, 2, 2, 2, 3, 3]]\n, Create a Verilog module named \"riscv_alu_control\" that decodes the function code from a RISC-V instruction and generates appropriate control signals for the Arithmetic Logic Unit (ALU). This module is to be used in a hierarchical design, with submodules handling different sets of operations (arithmetic, logical).\n\nModule name:\n    riscv_alu_control\n\nInput ports:\n    func7 [6:0]: 7-bit function code defining the type of operation (from RISC-V instruction set).\n    func3 [2:0]: 3-bit function code further specifying the operation.\n\nOutput ports:\n    alu_op [3:0]: 4-bit ALU operation code, determining which operation to perform.\n    shift_type [1:0]: 2-bit code indicating the type of shift operation (if applicable).\n\nImplementation:\n    The module includes two submodules:\n    - \"alu_arith_decoder\" decodes arithmetic operations based on the func7 and func3 fields.\n    - \"alu_logic_decoder\" decodes logical operations including shifts based on the func3 field alone.\n    Each submodule outputs a partial ALU operation code.\n    The top module, \"riscv_alu_control\", combines these partial codes into the final \"alu_op\" and \"shift_type\" based on priority and type of operation specified in the func3 and func7 fields.\nGive me the complete code."}, {"from": "gpt", "value": "module riscv_alu_control (\n    input [6:0] func7,\n    input [2:0] func3,\n    output [3:0] alu_op,\n    output [1:0] shift_type\n);\n\n    wire [3:0] arith_op, logic_op;\n    wire [1:0] logic_shift_type;\n\n    alu_arith_decoder arith_dec (\n        .func7(func7),\n        .func3(func3),\n        .arith_op(arith_op)\n    );\n\n    alu_logic_decoder logic_dec (\n        .func3(func3),\n        .logic_op(logic_op),\n        .shift_type(logic_shift_type)\n    );\n\n    // Priority encoding logic for ALU operation\n    assign alu_op = (func7[5] == 1'b1) ? arith_op : logic_op;\n    assign shift_type = (func3[2:1] == 2'b01) ? logic_shift_type : 2'b00;\n\nendmodule\n\nmodule alu_arith_decoder (\n    input [6:0] func7,\n    input [2:0] func3,\n    output reg [3:0] arith_op\n);\n\n    always @(*) begin\n        case ({func7, func3})\n            10'b0000000_000: arith_op = 4'b0000; // ADD\n            10'b0100000_000: arith_op = 4'b0001; // SUB\n            10'b0000000_111: arith_op = 4'b0010; // AND\n            default: arith_op = 4'b1111; // INVALID OPERATION\n        endcase\n    end\n\nendmodule\n\nmodule alu_logic_decoder (\n    input [2:0] func3,\n    output reg [3:0] logic_op,\n    output reg [1:0] shift_type\n);\n\n    always @(*) begin\n        case (func3)\n            3'b000: begin logic_op = 4'b0011; shift_type = 2'b01; end // SLL\n            3'b100: begin logic_op = 4'b0100; shift_type = 2'b10; end // SRL\n            3'b101: begin logic_op = 4'b0101; shift_type = 2'b11; end // SRA\n            default: begin logic_op = 4'b1111; shift_type = 2'b00; end // INVALID OPERATION\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'input port'}, {'id': 2, 'content': 'compare_result', 'type': 'input port'}, {'id': 3, 'content': 'branch_taken', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[], []]\n, Create a Verilog module for a RISC-V branching condition checker, specifically designed to compute the branch result based on the opcode and compare bits from the instruction set. The module should take input of the current instruction opcode and comparison results, and output whether a branch should be taken or not.\n\nModule name:\n    branch_condition_checker\n\nInput ports:\n    clk: Clock signal for synchronization.\n    opcode [6:0]: 7-bit input representing the opcode of the instruction.\n    compare_result: Input signal indicating the result of the comparison (1 if true, 0 if false).\n\nOutput ports:\n    branch_taken: Output signal (1 if branch is to be taken, 0 otherwise).\n\nImplementation:\n    The branch_condition_checker module uses internal logic to decide the branch outcome based on different opcode values and the compare_result.\n    On the rising edge of the clock (clk), if the opcode corresponds to a branching opcode and the compare_result is true, the output branch_taken is set to 1.\n    Otherwise, the branch_taken is set to 0.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_condition_checker (\n    input clk,\n    input [6:0] opcode,\n    input compare_result,\n    output reg branch_taken\n);\n\n    // Define branching opcodes\n    localparam BRANCH_EQ = 7'b1100011; // Example opcode for branch if equal\n\n    always @(posedge clk) begin\n        if (opcode == BRANCH_EQ && compare_result == 1'b1) begin\n            branch_taken <= 1'b1;\n        end else begin\n            branch_taken <= 1'b0;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'is_R_type', 'type': 'output port'}, {'id': 4, 'content': 'is_I_type', 'type': 'output port'}, {'id': 5, 'content': 'is_S_type', 'type': 'output port'}, {'id': 6, 'content': 'is_B_type', 'type': 'output port'}, {'id': 7, 'content': 'is_U_type', 'type': 'output port'}, {'id': 8, 'content': 'is_J_type', 'type': 'output port'}, {'id': 9, 'content': 'r_type_decoder', 'type': 'submodule'}, {'id': 10, 'content': 'i_type_decoder', 'type': 'submodule'}, {'id': 11, 'content': 's_type_decoder', 'type': 'submodule'}, {'id': 12, 'content': 'b_type_decoder', 'type': 'submodule'}, {'id': 13, 'content': 'u_type_decoder', 'type': 'submodule'}, {'id': 14, 'content': 'j_type_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2, 9, 10, 11, 12, 13, 14], [9, 10, 11, 12, 13, 14, 3, 4, 5, 6, 7, 8]]\n, An instruction register module called \"opcode_decoder\" designed to decode the opcode from a given 32-bit instruction and categorize it as R-type, I-type, S-type, B-type, U-type, or J-type based on RISC-V architecture specifics. It uses submodule decoders to handle each instruction type detection.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active low.\n    instruction [31:0]: 32-bit instruction input from which the opcode will be decoded.\n\nOutput ports:\n    is_R_type: Output signal indicating if the instruction is R-type.\n    is_I_type: Output signal indicating if the instruction is I-type.\n    is_S_type: Output signal indicating if the instruction is S-type.\n    is_B_type: Output signal indicating if the instruction is B-type.\n    is_U_type: Output signal indicating if the instruction is U-type.\n    is_J_type: Output signal indicating if the instruction is J-type.\n\nImplementation:\n    The opcode_decoder module will instantiate several submodules, each designed to detect a specific type of instruction based on the opcode field. The detection is carried out by comparing opcode bits extracted from the 32-bit instruction.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output is_R_type,\n    output is_I_type,\n    output is_S_type,\n    output is_B_type,\n    output is_U_type,\n    output is_J_type\n);\n\n    wire [6:0] opcode;\n    assign opcode = instruction[6:0];\n\n    type_decoder r_type_decoder (\n        .opcode(opcode),\n        .is_type(is_R_type),\n        .type_code(7'b0110011)\n    );\n\n    type_decoder i_type_decoder (\n        .opcode(opcode),\n        .is_type(is_I_type),\n        .type_code(7'b0010011)\n    );\n\n    type_decoder s_type_decoder (\n        .opcode(opcode),\n        .is_type(is_S_type),\n        .type_code(7'b0100011)\n    );\n\n    type_decoder b_type_decoder (\n        .opcode(opcode),\n        .is_type(is_B_type),\n        .type_code(7'b1100011)\n    );\n\n    type_decoder u_type_decoder (\n        .opcode(opcode),\n        .is_type(is_U_type),\n        .type_code(7'b0110111)\n    );\n\n    type_decoder j_type_decoder (\n        .opcode(opcode),\n        .is_type(is_J_type),\n        .type_code(7'b1101111)\n    );\n\nendmodule\n\nmodule type_decoder (\n    input [6:0] opcode,\n    output reg is_type,\n    input [6:0] type_code\n);\n\n    always @* begin\n        if(opcode == type_code) \n            is_type = 1;\n        else\n            is_type = 0;\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'inst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'output port'}, {'id': 3, 'content': 'rs1', 'type': 'output port'}, {'id': 4, 'content': 'rs2', 'type': 'output port'}, {'id': 5, 'content': 'rd', 'type': 'output port'}, {'id': 6, 'content': 'imm', 'type': 'output port'}, {'id': 7, 'content': 'op_dec', 'type': 'submodule'}, {'id': 8, 'content': 'reg_dec', 'type': 'submodule'}, {'id': 9, 'content': 'imm_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 7, 8, 8, 8, 9], [7, 8, 9, 2, 3, 4, 5, 6]]\n, Design a RISC-V instruction decoder module that decodes instructions into specific operational signals for a processor. This module will extract the opcode, register addresses, and immediate values from a 32-bit instruction and output relevant control signals for execution stages.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal.\n    inst [31:0]: 32-bit instruction input.\n\nOutput ports:\n    opcode [6:0]: Extracted opcode from the instruction.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    rd [4:0]: Destination register.\n    imm [11:0]: Immediate value for I-type instructions.\n\nImplementation:\n    The instruction decoder uses separate submodules to decode different parts of the instruction. On each clock's rising edge, if an instruction is present, it forwards relevant bits to respective decoding submodules which then output the decoded information.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [11:0] imm\n);\n\n    // Instantiation of submodules\n    opcode_decoder op_dec (\n        .inst(inst),\n        .opcode(opcode)\n    );\n\n    register_decoder reg_dec (\n        .inst(inst),\n        .rs1(rs1),\n        .rs2(rs2),\n        .rd(rd)\n    );\n\n    immediate_decoder imm_dec (\n        .inst(inst),\n        .imm(imm)\n    );\n\nendmodule\n\n// Submodule to decode opcode\nmodule opcode_decoder (\n    input [31:0] inst,\n    output [6:0] opcode\n);\n    assign opcode = inst[6:0];\nendmodule\n\n// Submodule to decode register fields\nmodule register_decoder (\n    input [31:0] inst,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd\n);\n    assign rs1 = inst[19:15];\n    assign rs2 = inst[24:20];\n    assign rd = inst[11:7];\nendmodule\n\n// Submodule to decode immediate values\nmodule immediate_decoder (\n    input [31:0] inst,\n    output reg [11:0] imm\n);\n    always @* begin\n        case(inst[6:0])  // Depending on opcode, different immediate extraction\n            7'b0000011: imm = inst[31:20]; // Example for I-type\n            default: imm = 12'd0;\n        endcase\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'inst', 'type': 'input port'}, {'id': 3, 'content': 'shifted_imm', 'type': 'output port'}, {'id': 4, 'content': 'extract', 'type': 'submodule'}, {'id': 5, 'content': 'shift', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 6, 4, 0, 2, 5], [4, 5, 5, 5, 5, 6, 3]]\n, Design a RISC-V immediate value extractor and shifter module. The module should take a 32-bit instruction input and based on the opcode, extract an immediate value and perform either a left or right shift operation. The module should feature separation of concern by employing two submodules: one for immediate extraction and another for shifting operations.\n\nModule name:\n    imm_val_shifter\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    inst [31:0]: 32-bit instruction input.\n\nOutput ports:\n    shifted_imm [31:0]: The resulting 32-bit immediate value after the appropriate shift operation.\n\nImplementation:\n    The immediate value extraction is based on the opcode, distinguishing between different types of instructions (e.g., I-type, S-type).\n    The shifter module performs either left or right shifts based on a control signal derived from the opcode.\n    On the rising edge of clk, if rst is low, shifted_imm is set to zero.\n    The submodule instantiation includes connections for opcode decoding and immediate extraction, as well as specifying shift direction and distance.\nGive me the complete code."}, {"from": "gpt", "value": "module imm_val_shifter (\n    input clk,\n    input rst,\n    input [31:0] inst,\n    output [31:0] shifted_imm\n);\n\n    wire [6:0] opcode;\n    wire [31:0] immediate;\n    wire shift_dir;\n    wire [4:0] shift_amt;\n\n    assign opcode = inst[6:0];\n\n    // Immediate extraction submodule\n    imm_extractor extract(\n        .opcode(opcode),\n        .inst(inst),\n        .immediate(immediate)\n    );\n\n    // Shifting operation submodule\n    shifter shift(\n        .clk(clk),\n        .rst(rst),\n        .immediate(immediate),\n        .shift_dir(shift_dir),\n        .shift_amt(shift_amt),\n        .shifted_imm(shifted_imm)\n    );\n\n    // Opcode decoder for shift direction and amount\n    opcode_decoder decode(\n        .opcode(opcode),\n        .shift_dir(shift_dir),\n        .shift_amt(shift_amt)\n    );\n\nendmodule\n\n// Submodule for extracting immediate values\nmodule imm_extractor (\n    input [6:0] opcode,\n    input [31:0] inst,\n    output reg [31:0] immediate\n);\n\n    always @(*) begin\n        case (opcode)\n            7'b0010011: immediate = {{20{inst[31]}}, inst[31:20]}; // I-type\n            7'b0100011: immediate = {{20{inst[31]}}, inst[31:25], inst[11:7]}; // S-type\n            default: immediate = 32'd0;\n        endcase\n    end\n\nendmodule\n\n// Shifting operation submodule\nmodule shifter (\n    input clk,\n    input rst,\n    input [31:0] immediate,\n    input shift_dir, // 0 for left, 1 for right\n    input [4:0] shift_amt,\n    output reg [31:0] shifted_imm\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            shifted_imm <= 0;\n        end else begin\n            if (shift_dir == 0)\n                shifted_imm <= immediate << shift_amt;\n            else\n                shifted_imm <= immediate >> shift_amt;\n        end\n    end\n\nendmodule\n\n// Submodule for decoding the opcode to determine shift direction and amount\nmodule opcode_decoder (\n    input [6:0] opcode,\n    output reg shift_dir,\n    output reg [4:0] shift_amt\n);\n\n    always @(*) begin\n        case (opcode)\n            7'b0010011: begin // Example opcode for left shift\n                shift_dir = 0;\n                shift_amt = 5;\n            end\n            7'b0100011: begin // Example opcode for right shift\n                shift_dir = 1;\n                shift_amt = 5;\n            end\n            default: begin\n                shift_dir = 0;\n                shift_amt = 0;\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch_type', 'type': 'input port'}, {'id': 3, 'content': 'reg1', 'type': 'input port'}, {'id': 4, 'content': 'reg2', 'type': 'input port'}, {'id': 5, 'content': 'take_branch', 'type': 'output port'}, {'id': 6, 'content': 'comp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 4, 6], [6, 6, 6, 5]]\n, Design a RISC-V branch condition checker module in Verilog that interprets the branch type and compares two provided registers to determine whether a branch should be taken. The module must be able to handle different branch conditions such as equal, not equal, less than, and greater than.\n\nModule name:\n    branch_condition_checker\n\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Active low reset signal.\n    branch_type [2:0]: Control signal specifying the type of branch comparison (000 for BEQ, 001 for BNE, 010 for BLT, 011 for BGT).\n    reg1 [31:0]: First 32-bit register input for comparison.\n    reg2 [31:0]: Second 32-bit register input for comparison.\n\nOutput ports:\n    take_branch: Output signal that indicates whether the branch should be taken (1) or not (0).\n\nImplementation:\n    The branch_condition_checker module instantiates a compare_unit submodule to handle the actual comparison logic based on the specified branch_type.\n    On the rising edge of clk, if rst is low, take_branch is set to 0.\n    The take_branch output is set based on the output of the compare_unit, which updates its result based on the branch_type and the values in reg1 and reg2.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_condition_checker (\n    input clk,\n    input rst,\n    input [2:0] branch_type,\n    input [31:0] reg1,\n    input [31:0] reg2,\n    output take_branch\n);\n\n    wire comparison_result;\n\n    compare_unit comp (\n        .branch_type(branch_type),\n        .reg1(reg1),\n        .reg2(reg2),\n        .result(comparison_result)\n    );\n\n    reg take_branch_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            take_branch_reg <= 0;\n        end else begin\n            take_branch_reg <= comparison_result;\n        end\n    end\n\n    assign take_branch = take_branch_reg;\n\nendmodule\n\nmodule compare_unit (\n    input [2:0] branch_type,\n    input [31:0] reg1,\n    input [31:0] reg2,\n    output reg result\n);\n\n    always @(*) begin\n        case (branch_type)\n            3'b000: result = (reg1 == reg2); // BEQ\n            3'b001: result = (reg1 != reg2); // BNE\n            3'b010: result = ($signed(reg1) < $signed(reg2)); // BLT\n            3'b011: result = ($signed(reg1) > $signed(reg2)); // BGT\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch', 'type': 'input port'}, {'id': 3, 'content': 'jump', 'type': 'input port'}, {'id': 4, 'content': 'offset', 'type': 'input port'}, {'id': 5, 'content': 'pc', 'type': 'output port'}, {'id': 6, 'content': 'calc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 4, 2, 6, 6], [6, 6, 6, 6, 5]]\n, Design a Verilog module for a RISC-V program counter that handles jumps and branching with additional offset handling. The module will be responsible for updating the program counter based on the provided inputs. \n\nModule name:\n    pc_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset to initialize the program counter.\n    branch: Signal to indicate if a branch is taken.\n    jump: Signal to indicate if a jump is initiated.\n    offset [15:0]: 16-bit sign-extended offset for jump or branch operations.\n\nOutput ports:\n    pc [31:0]: The 32-bit program counter output which will be updated every clock cycle.\n\nImplementation:\n    The program counter module handles the jump and branch operations using a submodule for calculating the new PC value based on the conditions provided by the inputs.\n    If rst is asserted, the program counter is reset to zero.\n    If jump or branch signals are asserted, the program counter is updated based on the provided offset.\n    If neither jump nor branch signals are asserted, the program counter is incremented by 4 (standard instruction length in RISC-V).\nGive me the complete code."}, {"from": "gpt", "value": "module pc_control (\n    input clk,\n    input rst,\n    input branch,\n    input jump,\n    input [15:0] offset,\n    output [31:0] pc\n);\n\n    wire [31:0] new_pc_value;\n\n    pc_calculator calc (\n        .pc_in(pc),\n        .branch(branch),\n        .jump(jump),\n        .offset(offset),\n        .pc_out(new_pc_value)\n    );\n\n    reg [31:0] pc_reg;\n    assign pc = pc_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            pc_reg <= 32'd0;\n        end else begin\n            pc_reg <= new_pc_value;\n        end\n    end\n\nendmodule\n\nmodule pc_calculator (\n    input [31:0] pc_in,\n    input branch,\n    input jump,\n    input [15:0] offset,\n    output [31:0] pc_out\n);\n\n    reg [31:0] pc_temp;\n\n    always @(*) begin\n        if (branch || jump) begin\n            pc_temp = pc_in + {{14{offset[15]}}, offset, 2'b00}; // Sign-extend and calculate new PC\n        end else begin\n            pc_temp = pc_in + 32'd4; // Increment PC by 4\n        end\n    end\n\n    assign pc_out = pc_temp;\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'operation_executed', 'type': 'output port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'memory_address', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}, {'id': 8, 'content': 'arith', 'type': 'submodule'}, {'id': 9, 'content': 'mem_access', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 7, 1, 0, 3, 7, 1, 0, 8, 9, 7, 8, 7, 9], [7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 4, 5, 5, 6, 6]]\n, A RISC-V control unit submodule for decoding and executing instructions based on their type and opcode. The module should handle two types of operations: arithmetic and memory access. It receives the opcode and depending type, executes the operation by updating flags or storing data.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the submodule states.\n    opcode [3:0]: 4-bit opcode to identify the instruction type.\n    data_in [7:0]: Data input for processing or storage.\n\nOutput ports:\n    operation_executed: Flag indicating operation execution completion.\n    result [7:0]: Result of arithmetic operations.\n    memory_address [15:0]: Memory address for memory access operations.\n\nImplementation:\n    The control unit is implemented using separate submodules for arithmetic and memory access operations.\n    On the rising edge of the clock, depending on the opcode, the respective submodule is triggered to perform its functionality.\n    The arithmetic module calculates results and sets the operation_executed flag once complete.\n    The memory module updates the memory_address based on the input and sets the operation_executed flag.\nGive me the complete code."}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [3:0] opcode,\n    input [7:0] data_in,\n    output operation_executed,\n    output [7:0] result,\n    output [15:0] memory_address\n);\n\n    // Decode the opcode and execute relevant operation\n    wire arithmetic_enable, memory_access_enable;\n    wire [7:0] arithmetic_result;\n    wire [15:0] memory_output;\n\n    opcode_decoder decoder (\n        .opcode(opcode),\n        .arithmetic_enable(arithmetic_enable),\n        .memory_access_enable(memory_access_enable)\n    );\n\n    arithmetic_unit arith (\n        .clk(clk),\n        .rst(rst),\n        .enable(arithmetic_enable),\n        .data(data_in),\n        .result(arithmetic_result),\n        .done(operation_executed)\n    );\n\n    memory_access_unit mem_access (\n        .clk(clk),\n        .rst(rst),\n        .enable(memory_access_enable),\n        .data(data_in),\n        .address(memory_output),\n        .done(operation_executed)\n    );\n\n    // Output result based on the type of operation performed\n    assign result = (arithmetic_enable) ? arithmetic_result : 8'd0;\n    assign memory_address = (memory_access_enable) ? memory_output : 16'd0;\n\nendmodule\n\n// Submodule for decoding opcode\nmodule opcode_decoder (\n    input [3:0] opcode,\n    output reg arithmetic_enable,\n    output reg memory_access_enable\n);\n\n    always @(*) begin\n        arithmetic_enable = (opcode < 4'd8);\n        memory_access_enable = (opcode >= 4'd8);\n    end\n\nendmodule\n\n// Submodule for arithmetic operations\nmodule arithmetic_unit (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data,\n    output reg [7:0] result,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            done <= 1'b0;\n        end else if (enable) begin\n            result <= data + 1; // Example operation: Increment\n            done <= 1'b1;\n        end\n    end\n\nendmodule\n\n// Submodule for memory access\nmodule memory_access_unit (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data,\n    output reg [15:0] address,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            address <= 16'd0;\n            done <= 1'b0;\n        end else if (enable) begin\n            address <= {8'd0, data}; // Example operation: Set lower 8 bits\n            done <= 1'b1;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'instr_code', 'type': 'input port'}, {'id': 3, 'content': 'is_arith', 'type': 'output port'}, {'id': 4, 'content': 'is_control', 'type': 'output port'}, {'id': 5, 'content': 'operation', 'type': 'output port'}, {'id': 6, 'content': 'arith_dec', 'type': 'submodule'}, {'id': 7, 'content': 'control_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 2, 1, 0, 6, 7, 6, 7], [6, 6, 6, 7, 7, 7, 3, 4, 5, 5]]\n, Design a Verilog module named `conditional_decoder` that decodes a 5-bit instruction code into specific output signals based on conditional flags. This module should have a hierarchical structure and separate decoding logic for arithmetic and control instructions into submodules.\n\nModule name:\n    conditional_decoder\n\nInput ports:\n    clk: Clock signal.\n    reset: Active low reset signal.\n    instr_code [4:0]: 5-bit instruction code.\n\nOutput ports:\n    is_arith: Output signal that indicates if the instruction is an arithmetic operation.\n    is_control: Output signal that indicates if the instruction is a control operation.\n    operation [2:0]: Outputs a 3-bit code representing the specific operation being performed.\n\nImplementation:\n    The `conditional_decoder` module uses two submodules `arith_decoder` and `control_decoder` to process arithmetic and control instructions respectively.\n    The outputs `is_arith` and `is_control` are exclusive, meaning only one can be true at a time, based on the instruction code.\n    Resetting the module sets all outputs to zero.\n    The main module decodes the type of instruction based on the higher bits and delegates to the appropriate submodule for further decoding.\nGive me the complete code."}, {"from": "gpt", "value": "module conditional_decoder (\n    input clk,\n    input reset,\n    input [4:0] instr_code,\n    output is_arith,\n    output is_control,\n    output [2:0] operation\n);\n\n    wire is_arith_internal, is_control_internal;\n    wire [2:0] arith_op, control_op;\n\n    // Instantiate arithmetic decoder\n    arith_decoder arith_dec (\n        .clk(clk),\n        .reset(reset),\n        .instr_code(instr_code),\n        .is_arith(is_arith_internal),\n        .operation(arith_op)\n    );\n\n    // Instantiate control decoder\n    control_decoder control_dec (\n        .clk(clk),\n        .reset(reset),\n        .instr_code(instr_code),\n        .is_control(is_control_internal),\n        .operation(control_op)\n    );\n\n    // Logic to set outputs based on internal signals\n    assign is_arith = is_arith_internal;\n    assign is_control = is_control_internal;\n    assign operation = is_arith ? arith_op : (is_control ? control_op : 3'b000);\n\nendmodule\n\nmodule arith_decoder (\n    input clk,\n    input reset,\n    input [4:0] instr_code,\n    output reg is_arith,\n    output reg [2:0] operation\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            is_arith <= 0;\n            operation <= 3'b000;\n        end else begin\n            is_arith <= (instr_code[4:3] == 2'b01); // Check if it's arithmetic type\n            operation <= instr_code[2:0]; // Extract operation bits\n        end\n    end\n\nendmodule\n\nmodule control_decoder (\n    input clk,\n    input reset,\n    input [4:0] instr_code,\n    output reg is_control,\n    output reg [2:0] operation\n);\n\n    always @(posedge clk or negedge reset) begin\n        if (!reset) begin\n            is_control <= 0;\n            operation <= 3'b000;\n        end else begin\n            is_control <= (instr_code[4:3] == 2'b10); // Check if it's control type\n            operation <= instr_code[2:0]; // Extract operation bits\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch_type', 'type': 'input port'}, {'id': 3, 'content': 'flags', 'type': 'input port'}, {'id': 4, 'content': 'enable', 'type': 'input port'}, {'id': 5, 'content': 'branch_taken', 'type': 'output port'}, {'id': 6, 'content': 'beq_unit', 'type': 'submodule'}, {'id': 7, 'content': 'bne_unit', 'type': 'submodule'}, {'id': 8, 'content': 'blt_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 0, 3, 1, 0, 3, 1, 0, 8, 7, 6], [6, 6, 6, 7, 7, 7, 8, 8, 8, 5, 5, 5]]\n, Design a RISC-V branch decision module that evaluates branch conditions based on the current instruction. It should decode and check different branch types and determine whether a branch should be taken or not.\n\nModule name:\n    branch_decision\n\nInput ports:\n    clk: Clock signal.\n    rst: Active low reset signal.\n    branch_type [2:0]: Specifies the type of branch (e.g., 000 for BEQ, 001 for BNE, etc.).\n    flags [3:0]: Status flags from the ALU (e.g., Zero, Negative, Overflow, Carry).\n    enable: Enable signal to activate the branch decision process.\n\nOutput ports:\n    branch_taken: Output signal indicating whether the branch should be taken (1) or not (0).\n\nImplementation:\n    The branch_decision module utilizes three submodules: branch_beq (checks BEQ condition), branch_bne (checks BNE condition), and branch_blt (checks BLT condition).\n    On each positive edge of the clock, if the reset is active, all outputs are reset to 0.\n    The enable signal gates the evaluation process: only when enable is high, the branch condition is evaluated.\n    Based on the branch_type input, one of the submodules is activated to assess the condition using the ALU flags.\n    The output, branch_taken, is set based on the submodule's output that corresponds to the current branch_type.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_decision (\n    input clk,\n    input rst,\n    input [2:0] branch_type,\n    input [3:0] flags,\n    input enable,\n    output reg branch_taken\n);\n\n    wire beq_out, bne_out, blt_out;\n\n    branch_beq beq_unit (\n        .clk(clk),\n        .rst(rst),\n        .flags(flags),\n        .branch_out(beq_out)\n    );\n\n    branch_bne bne_unit (\n        .clk(clk),\n        .rst(rst),\n        .flags(flags),\n        .branch_out(bne_out)\n    );\n\n    branch_blt blt_unit (\n        .clk(clk),\n        .rst(rst),\n        .flags(flags),\n        .branch_out(blt_out)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            branch_taken <= 0;\n        end else if (enable) begin\n            case(branch_type)\n                3'b000: branch_taken <= beq_out;\n                3'b001: branch_taken <= bne_out;\n                3'b010: branch_taken <= blt_out;\n                default: branch_taken <= 0;\n            endcase\n        end\n    end\n\nendmodule\n\nmodule branch_beq (\n    input clk,\n    input rst,\n    input [3:0] flags,\n    output reg branch_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            branch_out <= 0;\n        else\n            branch_out <= flags[2]; // Zero flag\n    end\n\nendmodule\n\nmodule branch_bne (\n    input clk,\n    input rst,\n    input [3:0] flags,\n    output reg branch_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            branch_out <= 0;\n        else\n            branch_out <= ~flags[2]; // Not Zero flag\n    end\n\nendmodule\n\nmodule branch_blt (\n    input clk,\n    input rst,\n    input [3:0] flags,\n    output reg branch_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            branch_out <= 0;\n        else\n            branch_out <= flags[1]; // Negative flag\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'inst', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'funct7', 'type': 'output port'}, {'id': 9, 'content': 'imm', 'type': 'output port'}, {'id': 10, 'content': 'i_decoder', 'type': 'submodule'}, {'id': 11, 'content': 's_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2, 2, 2, 11, 2, 10], [10, 11, 3, 4, 5, 6, 7, 8, 9, 9, 9]]\n, A Verilog module for decoding RISC-V instructions into their respective components such as opcode, function codes, and immediate values, catering to different instruction formats. The module handles three types of instruction formats (R, I, S) and segregates their respective fields into output ports.\n\nModule name:\n    riscv_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    inst [31:0]: 32-bit input instruction fetched from instruction memory.\n\nOutput ports:\n    opcode [6:0]: Operation code identifying the type of instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function code used for further specification of the instruction.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address (applicable to R and S formats).\n    funct7 [6:0]: Additional function code used in R type instructions.\n    imm [31:0]: Immediate value extracted and sign-extended (used in I and S formats).\n\nImplementation:\n    The module utilizes separate submodules to decode different fields based on the opcode. The opcode determines the instruction format which dictates the decoding path within the submodules.\nGive me the complete code."}, {"from": "gpt", "value": "module riscv_decoder (\n    input clk,\n    input rst,\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7,\n    output [31:0] imm\n);\n\n    // Decode opcode, rd, funct3, rs1, rs2, funct7\n    assign opcode = inst[6:0];\n    assign rd = inst[11:7];\n    assign funct3 = inst[14:12];\n    assign rs1 = inst[19:15];\n    assign rs2 = inst[24:20];\n    assign funct7 = inst[31:25];\n\n    // Submodules for immediate extraction\n    wire [31:0] imm_i, imm_s;\n\n    immediate_decoder_i i_decoder (\n        .inst(inst),\n        .imm_out(imm_i)\n    );\n\n    immediate_decoder_s s_decoder (\n        .inst(inst),\n        .imm_out(imm_s)\n    );\n\n    // Output immediate based on opcode\n    assign imm = (opcode == 7'b0000011 || opcode == 7'b0010011) ? imm_i :  // I-format opcodes\n                 (opcode == 7'b0100011) ? imm_s :                         // S-format opcode\n                 32'b0;\n\nendmodule\n\n// Immediate decoder for I-format\nmodule immediate_decoder_i (\n    input [31:0] inst,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{inst[31]}}, inst[31:20]};\nendmodule\n\n// Immediate decoder for S-format\nmodule immediate_decoder_s (\n    input [31:0] inst,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{inst[31]}}, inst[31:25], inst[11:7]};\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'operand', 'type': 'output port'}, {'id': 3, 'content': 'valid', 'type': 'output port'}, {'id': 4, 'content': 'val_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 4], [4, 1, 2, 3]]\n, Design a Verilog module named `opcode_decoder` which decodes an 8-bit instruction into a 3-bit opcode and 5-bit operand. The module should handle decoding based on predefined opcode mappings and includes provisions for unrecognized opcodes.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    instr [7:0]: 8-bit input instruction code.\n\nOutput ports:\n    opcode [2:0]: Decoded 3-bit opcode.\n    operand [4:0]: Extracted 5-bit operand.\n    valid: High when the opcode is recognized, Low otherwise.\n\nImplementation:\n    The module uses a submodule to perform the opcode decoding based on predefined mappings.\n    The valid output signal indicates whether the decoded opcode corresponds to a predefined valid operation.\n    The opcode and operand are extracted directly from the instruction where opcode is the higher 3 bits and operand is the lower 5 bits.\n    If the opcode does not match any predefined valid codes, the valid signal is set to Low.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [7:0] instr,\n    output [2:0] opcode,\n    output [4:0] operand,\n    output valid\n);\n\n    // Submodule for opcode validation\n    wire valid_opcode;\n\n    validate_opcode val_op (\n        .opcode(instr[7:5]),\n        .valid(valid_opcode)\n    );\n\n    // Output assignments\n    assign opcode = instr[7:5];\n    assign operand = instr[4:0];\n    assign valid = valid_opcode;\n\nendmodule\n\n// Submodule for opcode validation\nmodule validate_opcode (\n    input [2:0] opcode,\n    output valid\n);\n\n    reg v;\n\n    always @(*) begin\n        case (opcode)\n            3'b000, 3'b001, 3'b010, 3'b011, 3'b100:\n                v = 1'b1;  // Recognized opcodes\n            default:\n                v = 1'b0;  // Unrecognized opcode\n        endcase\n    end\n\n    assign valid = v;\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'imm', 'type': 'output port'}, {'id': 7, 'content': 'decode_opcode', 'type': 'submodule'}, {'id': 8, 'content': 'decode_register', 'type': 'submodule'}, {'id': 9, 'content': 'extract_imm', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 7, 8, 8, 9], [7, 8, 9, 3, 4, 5, 6]]\n, A module for fetching and decoding a RISC-V immediate type instruction in Verilog. It receives raw instruction data and decodes it into several fields for further processing. It employs hierarchical design with separate submodules for handling different parts of the instruction.\n\nModule name:\n    immediate_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    instruction [31:0]: 32-bit input instruction to be decoded.\n\nOutput ports:\n    opcode [6:0]: Opcode of the instruction.\n    rd [4:0]: Destination register.\n    funct3 [2:0]: Function code, part 1.\n    imm [11:0]: Immediate value, extracted and sign-extended.\n\nImplementation:\n    The immediate_decoder module instantiates three submodules: opcode_decoder, register_decoder, and immediate_extractor.\n    On the rising edge of clk, if rst is asserted low, all outputs are reset to zero.\n    The opcode_decoder submodule is responsible for extracting the opcode.\n    The register_decoder extracts the destination register field (rd) and function part (funct3).\n    The immediate_extractor handles the extraction and sign-extension of the immediate field (imm) from the instruction.\nGive me the complete code."}, {"from": "gpt", "value": "module immediate_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [11:0] imm\n);\n\n    // Submodule instances\n    wire [6:0] opcode_out;\n    wire [4:0] rd_out;\n    wire [2:0] funct3_out;\n    wire [11:0] imm_out;\n\n    opcode_decoder decode_opcode (\n        .instruction(instruction),\n        .opcode(opcode_out)\n    );\n\n    register_decoder decode_register (\n        .instruction(instruction),\n        .rd(rd_out),\n        .funct3(funct3_out)\n    );\n\n    immediate_extractor extract_imm (\n        .instruction(instruction),\n        .imm(imm_out)\n    );\n\n    // Output assignments\n    assign opcode = opcode_out;\n    assign rd = rd_out;\n    assign funct3 = funct3_out;\n    assign imm = imm_out;\n\nendmodule\n\n// Submodule for opcode extraction\nmodule opcode_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\n// Submodule for register and funct3 field extraction\nmodule register_decoder (\n    input [31:0] instruction,\n    output [4:0] rd,\n    output [2:0] funct3\n);\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\nendmodule\n\n// Submodule for immediate value extraction and sign-extension\nmodule immediate_extractor (\n    input [31:0] instruction,\n    output reg [11:0] imm\n);\n    always @(*) begin\n        imm = { {1{instruction[31]}}, instruction[30:20] };\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'funct', 'type': 'output port'}, {'id': 5, 'content': 'imm_value', 'type': 'output port'}, {'id': 6, 'content': 'opcode_module', 'type': 'submodule'}, {'id': 7, 'content': 'funct_module', 'type': 'submodule'}, {'id': 8, 'content': 'imm_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 6, 7, 8], [6, 7, 8, 3, 4, 5]]\n, Design a RISC-V instruction decoder module that decodes an incoming instruction into opcode, function code, and immediate value. This module uses hierarchical design by incorporating three submodules for decoding different parts of the instruction based on the instruction format.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear all outputs.\n    instruction [31:0]: 32-bit incoming instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode part of the instruction.\n    funct [9:0]: Function code combining funct3 and funct7 fields.\n    imm_value [31:0]: Immediate value extracted and sign-extended.\n\nImplementation:\n    The instruction decoder module includes three submodules: one for extracting the opcode, another for the function codes, and a third one for computing the immediate value.\n    These submodules process the instruction based on the input and provide outputs accordingly.\n    The opcode submodule extracts bits [6:0] from the instruction.\n    The function code submodule combines bits [14:12] (funct3) and [31:25] (funct7) to form a 10-bit function code.\n    The immediate value submodule is responsible for extracting immediate data from the instruction, sign-extending it to 32 bits.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [9:0] funct,\n    output [31:0] imm_value\n);\n\n    wire [6:0] opcode_out;\n    wire [2:0] funct3_out;\n    wire [6:0] funct7_out;\n    wire [31:0] imm_out;\n\n    opcode_extract opcode_module (\n        .instruction(instruction),\n        .opcode(opcode_out)\n    );\n\n    funct_code_extract funct_module (\n        .instruction(instruction),\n        .funct3(funct3_out),\n        .funct7(funct7_out)\n    );\n\n    immediate_value_extract imm_module (\n        .instruction(instruction),\n        .imm_value(imm_out)\n    );\n\n    assign opcode = opcode_out;\n    assign funct = {funct7_out, funct3_out};\n    assign imm_value = imm_out;\n\nendmodule\n\nmodule opcode_extract(\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\nmodule funct_code_extract(\n    input [31:0] instruction,\n    output [2:0] funct3,\n    output [6:0] funct7\n);\n    assign funct3 = instruction[14:12];\n    assign funct7 = instruction[31:25];\nendmodule\n\nmodule immediate_value_extract(\n    input [31:0] instruction,\n    output reg [31:0] imm_value\n);\n    always @(*) begin\n        imm_value = {{20{instruction[31]}}, instruction[31:20]}; // Example for I-type\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'is_load', 'type': 'output port'}, {'id': 2, 'content': 'is_store', 'type': 'output port'}, {'id': 3, 'content': 'is_branch', 'type': 'output port'}, {'id': 4, 'content': 'is_alu', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0], [1, 2, 3, 4]]\n, Design a Verilog module named 'opcode_decoder' for decoding the 7-bit opcode field from a 32-bit RISC-V instruction. The module should extract and classify the opcode into control signals for other CPU components, identifying main operation types such as Load, Store, Branch, ALU operations, etc.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    instr [31:0]: Full 32-bit instruction.\n\nOutput ports:\n    is_load: Asserted if the opcode is for a load operation.\n    is_store: Asserted if the opcode is for a store operation.\n    is_branch: Asserted if the opcode is for a branching operation.\n    is_alu: Asserted if the opcode is for an ALU operation.\n    \nImplementation:\n    The opcode_decoder module uses a combinational logic block to decode the 7-bit opcode (instr[6:0]). It sets output flags based on the decoded opcode value. The module handles common RISC-V opcode formats and sets the appropriate control signals for the CPU's main operational units.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [31:0] instr,\n    output is_load,\n    output is_store,\n    output is_branch,\n    output is_alu\n);\n\n    reg [6:0] opcode;\n    always @(*) begin\n        opcode = instr[6:0];\n    end\n\n    assign is_load = (opcode == 7'b0000011); // Load\n    assign is_store = (opcode == 7'b0100011); // Store\n    assign is_branch = (opcode == 7'b1100011); // Branch\n    assign is_alu = (opcode == 7'b0110011); // ALU operation\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'imm', 'type': 'output port'}, {'id': 4, 'content': 'op_type', 'type': 'output port'}, {'id': 5, 'content': 'rs1', 'type': 'output port'}, {'id': 6, 'content': 'rs2', 'type': 'output port'}, {'id': 7, 'content': 'decodeI', 'type': 'submodule'}, {'id': 8, 'content': 'decodeS', 'type': 'submodule'}, {'id': 9, 'content': 'decodeB', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 8, 2, 9, 7, 7, 2, 9, 8, 7, 9, 8, 8, 9], [7, 8, 9, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 6, 6]]\n, Design a Verilog module to decode RISC-V immediate instructions. The module should extract the immediate value, operation type, and registers involved based on the instruction type. The design should include submodules to handle different types of immediate extraction specific to RISC-V instruction formats such as I-type, S-type, and B-type.\n\nModule name:\n    imm_decoder\n\nInput ports:\n    clk: Clock signal.\n    rst: Active low reset signal.\n    instruction [31:0]: 32-bit RISC-V instruction input.\n\nOutput ports:\n    imm [11:0]: Extracted immediate value.\n    op_type [2:0]: Operation type (e.g., ALU operation, memory operation).\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n\nImplementation:\n    The immediate decoder module determines the type of the instruction based on specific bits within the instruction and delegates the immediate value extraction to corresponding submodules designed for I-type, S-type, and B-type instructions.\n    Each submodule is responsible for parsing the instruction and outputting the corresponding immediate value which is then selected by the main module.\n    Resets the outputs to zero when rst is active.\nGive me the complete code."}, {"from": "gpt", "value": "module imm_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [11:0] imm,\n    output [2:0] op_type,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n\n    wire [11:0] imm_i, imm_s, imm_b;\n    wire [2:0] type_i, type_s, type_b;\n\n    decode_I_type decodeI (\n        .instruction(instruction),\n        .imm_i(imm_i),\n        .op_type_i(type_i),\n        .rs1_i(rs1)\n    );\n\n    decode_S_type decodeS (\n        .instruction(instruction),\n        .imm_s(imm_s),\n        .op_type_s(type_s),\n        .rs1_s(rs1),\n        .rs2_s(rs2)\n    );\n\n    decode_B_type decodeB (\n        .instruction(instruction),\n        .imm_b(imm_b),\n        .op_type_b(type_b),\n        .rs1_b(rs1),\n        .rs2_b(rs2)\n    );\n\n    assign imm = instruction[6:5] == 2'b00 ? imm_i : (instruction[6:5] == 2'b01 ? imm_s : imm_b);\n    assign op_type = instruction[6:5] == 2'b00 ? type_i : (instruction[6:5] == 2'b01 ? type_s : type_b);\n\nendmodule\n\nmodule decode_I_type (\n    input [31:0] instruction,\n    output reg [11:0] imm_i,\n    output reg [2:0] op_type_i,\n    output reg [4:0] rs1_i\n);\n    always @* begin\n        imm_i = instruction[31:20];\n        op_type_i = instruction[14:12];\n        rs1_i = instruction[19:15];\n    end\nendmodule\n\nmodule decode_S_type (\n    input [31:0] instruction,\n    output reg [11:0] imm_s,\n    output reg [2:0] op_type_s,\n    output reg [4:0] rs1_s,\n    output reg [4:0] rs2_s\n);\n    always @* begin\n        imm_s = {instruction[31:25], instruction[11:7]};\n        op_type_s = instruction[14:12];\n        rs1_s = instruction[19:15];\n        rs2_s = instruction[24:20];\n    end\nendmodule\n\nmodule decode_B_type (\n    input [31:0] instruction,\n    output reg [11:0] imm_b,\n    output reg [2:0] op_type_b,\n    output reg [4:0] rs1_b,\n    output reg [4:0] rs2_b\n);\n    always @* begin\n        imm_b = {instruction[31], instruction[7], instruction[30:25], instruction[11:8], 1'b0};\n        op_type_b = instruction[14:12];\n        rs1_b = instruction[19:15];\n        rs2_b = instruction[24:20];\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch_type', 'type': 'input port'}, {'id': 3, 'content': 'zero_flag', 'type': 'input port'}, {'id': 4, 'content': 'neg_flag', 'type': 'input port'}, {'id': 5, 'content': 'take_branch', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[3, 4], [5, 5]]\n, Design a RISC-V Branch Decision Module that evaluates branch conditions and outputs a decision signal. This module should handle different branch types and conditions as inputs and generate a decision based on the current instruction\u2019s flags and type.\n\nModule name:\n    branch_decision\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to reset the decision output.\n    branch_type [2:0]: Input signal indicating the type of branch (e.g., BEQ, BNE, BLT).\n    zero_flag: Input flag that indicates if the result of the last ALU operation was zero.\n    neg_flag: Input flag that indicates if the result of the last ALU operation was negative.\n\nOutput ports:\n    take_branch: Output signal that indicates whether the branch should be taken (1) or not (0) based on the evaluation.\n\nImplementation:\n    This module should evaluate the input branch type against the flags and output the decision. If reset, the output should be 0. The module uses a combinational logic block to determine the branch decision.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_decision (\n    input clk,\n    input rst,\n    input [2:0] branch_type,\n    input zero_flag,\n    input neg_flag,\n    output reg take_branch\n);\n\n    always @(*) begin\n        if (!rst) begin\n            take_branch = 0;\n        end else begin\n            case (branch_type)\n                3'b000: take_branch = zero_flag;  // BEQ\n                3'b001: take_branch = ~zero_flag; // BNE\n                3'b010: take_branch = neg_flag;    // BLT\n                3'b011: take_branch = ~neg_flag;   // BGE\n                3'b100: take_branch = zero_flag & neg_flag;  // BLE\n                3'b101: take_branch = ~zero_flag | ~neg_flag; // BGT\n                default: take_branch = 0;  // No branch\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'funct7', 'type': 'output port'}, {'id': 9, 'content': 'decode_op', 'type': 'submodule'}, {'id': 10, 'content': 'decode_rdst', 'type': 'submodule'}, {'id': 11, 'content': 'decode_f3', 'type': 'submodule'}, {'id': 12, 'content': 'decode_src1', 'type': 'submodule'}, {'id': 13, 'content': 'decode_src2', 'type': 'submodule'}, {'id': 14, 'content': 'decode_f7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2, 9, 10, 11, 12, 13, 14], [9, 10, 11, 12, 13, 14, 3, 4, 5, 6, 7, 8]]\n, Design a RISC-V instruction decoder module that extracts and decodes the fields from a 32-bit instruction. The module uses hierarchical design by utilizing submodules to handle various parts of the instruction such as opcode, function codes, and register addresses, facilitating separate processing and validation checks.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal for initializing the module.\n    instruction [31:0]: 32-bit instruction input to be decoded.\n\nOutput ports:\n    opcode [6:0]: Opcode extracted from the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function code, part of instruction specifying operation type.\n    rs1 [4:0]: Source register one address.\n    rs2 [4:0]: Source register two address.\n    funct7 [6:0]: Additional function code used with opcode to define the operation.\n\nImplementation:\n    The module utilizes separate submodules for decoding various parts of the instruction based on bit slicing. The output wires connect to internal submodules which decode and output specific fields from the main instruction input based on the field's position in the instruction layout.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7\n);\n\n    // Submodules for instruction field extraction\n    decode_opcode decode_op (.instruction(instruction), .opcode(opcode));\n    decode_rd decode_rdst (.instruction(instruction), .rd(rd));\n    decode_funct3 decode_f3 (.instruction(instruction), .funct3(funct3));\n    decode_rs1 decode_src1 (.instruction(instruction), .rs1(rs1));\n    decode_rs2 decode_src2 (.instruction(instruction), .rs2(rs2));\n    decode_funct7 decode_f7 (.instruction(instruction), .funct7(funct7));\n\nendmodule\n\n// Submodule for decoding opcode\nmodule decode_opcode (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\n// Submodule for decoding rd\nmodule decode_rd (\n    input [31:0] instruction,\n    output [4:0] rd\n);\n    assign rd = instruction[11:7];\nendmodule\n\n// Submodule for decoding funct3\nmodule decode_funct3 (\n    input [31:0] instruction,\n    output [2:0] funct3\n);\n    assign funct3 = instruction[14:12];\nendmodule\n\n// Submodule for decoding rs1\nmodule decode_rs1 (\n    input [31:0] instruction,\n    output [4:0] rs1\n);\n    assign rs1 = instruction[19:15];\nendmodule\n\n// Submodule for decoding rs2\nmodule decode_rs2 (\n    input [31:0] instruction,\n    output [4:0] rs2\n);\n    assign rs2 = instruction[24:20];\nendmodule\n\n// Submodule for decoding funct7\nmodule decode_funct7 (\n    input [31:0] instruction,\n    output [6:0] funct7\n);\n    assign funct7 = instruction[31:25];\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'funct3', 'type': 'output port'}, {'id': 3, 'content': 'funct7', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'opcode_unit', 'type': 'submodule'}, {'id': 8, 'content': 'funct_unit', 'type': 'submodule'}, {'id': 9, 'content': 'operand_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 7, 8, 8, 9, 9, 9], [7, 8, 9, 1, 2, 3, 4, 5, 6]]\n, Design a RISC-V instruction decoder module to decode 32-bit instructions into its opcode, funct3, funct7, and operand fields. It utilizes separate submodules to isolate and interpret each section of the instruction for use in further processing or control logic.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    instruction [31:0]: 32-bit input instruction from the instruction memory.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode.\n    funct3 [2:0]: 3-bit funct3.\n    funct7 [6:0]: 7-bit funct7.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    rd [4:0]: Destination register.\n\nImplementation:\n    The instruction decoder is implemented using multiple submodules:\n    - opcode_decoder for extracting the opcode.\n    - funct_decoder for extracting funct3 and funct7.\n    - operand_decoder for extracting rs1, rs2, and rd.\n    On receiving a 32-bit instruction, each submodule processes its respective part of the instruction concurrently, thus enhancing the speed and modularity of the design.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd\n);\n\n    opcode_decoder opcode_unit (\n        .instruction(instruction),\n        .opcode(opcode)\n    );\n\n    funct_decoder funct_unit (\n        .instruction(instruction),\n        .funct3(funct3),\n        .funct7(funct7)\n    );\n\n    operand_decoder operand_unit (\n        .instruction(instruction),\n        .rs1(rs1),\n        .rs2(rs2),\n        .rd(rd)\n    );\n\nendmodule\n\nmodule opcode_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\nmodule funct_decoder (\n    input [31:0] instruction,\n    output [2:0] funct3,\n    output [6:0] funct7\n);\n    assign funct3 = instruction[14:12];\n    assign funct7 = instruction[31:25];\nendmodule\n\nmodule operand_decoder (\n    input [31:0] instruction,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd\n);\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign rd = instruction[11:7];\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'enable', 'type': 'input port'}, {'id': 2, 'content': 'immediate_in', 'type': 'input port'}, {'id': 3, 'content': 'immediate_out', 'type': 'output port'}, {'id': 4, 'content': 'sign_extender', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 4], [4, 3]]\n, Design a RISC-V immediate-value loader module in Verilog. It handles immediate values for operations like ADDI or SLTI. The module receives the immediate value from an instruction, sign-extends it, and then outputs it to the ALU or other units.\n\nModule name:\n    immediate_loader\n\nInput ports:\n    clk: Clock signal.\n    enable: Enable signal to process data.\n    immediate_in [11:0]: 12-bit immediate value from the instruction.\n\nOutput ports:\n    immediate_out [31:0]: Sign-extended 32-bit output value.\n\nImplementation:\n    Utilizes a submodule for sign-extending the 12-bit immediate value to a 32-bit value.\n    Operates on the rising edge of the clock when the enable signal is high.\n    Outputs the processed immediate value for the next processing stage.\nGive me the complete code."}, {"from": "gpt", "value": "module immediate_loader(\n    input clk,\n    input enable,\n    input [11:0] immediate_in,\n    output [31:0] immediate_out\n);\n\n    // Submodule for sign-extension\n    wire [31:0] extended_value;\n\n    sign_extend sign_extender (\n        .immediate_in(immediate_in),\n        .extended_out(extended_value)\n    );\n\n    reg [31:0] register_out;\n\n    always @(posedge clk) begin\n        if (enable) begin\n            register_out <= extended_value;\n        end\n    end\n\n    assign immediate_out = register_out;\n\nendmodule\n\n// Submodule for sign extension\nmodule sign_extend(\n    input [11:0] immediate_in,\n    output [31:0] extended_out\n);\n\n    assign extended_out = {{20{immediate_in[11]}}, immediate_in};\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'opcode', 'type': 'input port'}, {'id': 1, 'content': 'alu_op', 'type': 'output port'}, {'id': 2, 'content': 'mem_read', 'type': 'output port'}, {'id': 3, 'content': 'mem_write', 'type': 'output port'}, {'id': 4, 'content': 'reg_write', 'type': 'output port'}, {'id': 5, 'content': 'dec1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 5, 5, 5, 5], [5, 1, 2, 3, 4]]\n, Design a Verilog module for a RISC-V control signal decoder, translating a 4-bit instruction opcode into relevant control signals for a CPU's execution unit.\n\nModule name:\n    control_decoder\n\nInput ports:\n    opcode [3:0]: 4-bit opcode input which determines the action of the CPU.\n\nOutput ports:\n    alu_op [2:0]: Control signals for ALU operations.\n    mem_read: Signal indicating if memory read is required.\n    mem_write: Signal indicating if memory write is required.\n    reg_write: Signal indicating if write back to register is required.\n\nImplementation:\n    The control_decoder uses a submodule to decode the opcode into control signals based on the instruction set architecture.\n    On changes in opcode, corresponding control outputs are set to either enable or disable specific operations within the CPU, such as ALU operation, memory access, or register write.\nGive me the complete code."}, {"from": "gpt", "value": "module control_decoder (\n    input [3:0] opcode,\n    output [2:0] alu_op,\n    output mem_read,\n    output mem_write,\n    output reg_write\n);\n\n    // Submodule for opcode decoding\n    opcode_decoder dec1 (\n        .opcode(opcode),\n        .alu_op(alu_op),\n        .mem_read(mem_read),\n        .mem_write(mem_write),\n        .reg_write(reg_write)\n    );\n\nendmodule\n\n// Submodule for opcode decoding\nmodule opcode_decoder (\n    input [3:0] opcode,\n    output reg [2:0] alu_op,\n    output reg mem_read,\n    output reg mem_write,\n    output reg reg_write\n);\n\n    always @(*) begin\n        // Default signal settings\n        alu_op = 3'b000; // Default ALU operation\n        mem_read = 0;\n        mem_write = 0;\n        reg_write = 0;\n\n        case (opcode)\n            4'b0000: begin // Example opcode for ALU add\n                alu_op = 3'b010;\n                reg_write = 1;\n            end\n            4'b0001: begin // Example opcode for memory load\n                alu_op = 3'b000;\n                mem_read = 1;\n                reg_write = 1;\n            end\n            4'b0010: begin // Example opcode for memory store\n                alu_op = 3'b000;\n                mem_write = 1;\n            end\n            // Additional opcodes can be implemented similarly\n            default: begin\n                // Handle default or unrecognized opcode\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'func3', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}, {'id': 9, 'content': 'fetch', 'type': 'submodule'}, {'id': 10, 'content': 'decode', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 9, 1, 0, 10, 10, 10, 10, 10, 10], [9, 10, 10, 10, 3, 4, 5, 6, 7, 8]]\n, Design an enhanced RISC-V instruction decoding module that fetches and decodes instructions into multiple functional units based on the type of operation (ALU, Memory, Control). It facilitates the separation of instruction into several components like opcode, function code, and immediate value.\n\nModule name:\n    enhanced_instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal to clear and initialize the register.\n    instruction [31:0]: 32-bit instruction input fetched from instruction memory.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode for operation type identification.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    rd [4:0]: Destination register.\n    func3 [2:0]: 3-bit function code for further classification of the instruction.\n    imm [11:0]: Immediate value for certain instructions like loads, stores, and immediate operations.\n\nImplementation:\n    The decoder is composed of two submodules: fetch_unit for extracting fields from the instruction, and decode_unit for classifying the instruction into its respective unit (ALU, Memory, Control) based on the opcode and function codes.\n    The module works on the rising edge of the clock (clk). If the reset (rst_n) is active, all outputs are set to their initial states.\n    Extracted fields from the fetch_unit are passed to the decode_unit which assigns outputs based on specific opcodes and function codes to direct instruction to the correct functional unit.\nGive me the complete code."}, {"from": "gpt", "value": "module enhanced_instr_decoder (\n    input clk,\n    input rst_n,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [11:0] imm\n);\n\n    // Intermediate wires\n    wire [6:0] opcode_wire;\n    wire [4:0] rs1_wire, rs2_wire, rd_wire;\n    wire [2:0] func3_wire;\n    wire [11:0] imm_wire;\n\n    // Fetch unit submodule\n    fetch_unit fetch (\n        .instruction(instruction),\n        .opcode(opcode_wire),\n        .rs1(rs1_wire),\n        .rs2(rs2_wire),\n        .rd(rd_wire),\n        .func3(func3_wire),\n        .imm(imm_wire)\n    );\n\n    // Decode unit submodule\n    decode_unit decode (\n        .clk(clk),\n        .rst_n(rst_n),\n        .opcode(opcode_wire),\n        .func3(func3_wire),\n        .opcode_out(opcode),\n        .rs1_out(rs1),\n        .rs2_out(rs2),\n        .rd_out(rd),\n        .func3_out(func3),\n        .imm_out(imm)\n    );\n\nendmodule\n\nmodule fetch_unit (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [11:0] imm\n);\n\n    assign opcode = instruction[6:0];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign rd = instruction[11:7];\n    assign func3 = instruction[14:12];\n    assign imm = instruction[31:20]; // For I-type instructions\n\nendmodule\n\nmodule decode_unit (\n    input clk,\n    input rst_n,\n    input [6:0] opcode,\n    input [2:0] func3,\n    output reg [6:0] opcode_out,\n    output reg [4:0] rs1_out,\n    output reg [4:0] rs2_out,\n    output reg [4:0] rd_out,\n    output reg [2:0] func3_out,\n    output reg [11:0] imm_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            {opcode_out, rs1_out, rs2_out, rd_out, func3_out, imm_out} <= 0;\n        end else begin\n            opcode_out <= opcode;\n            func3_out <= func3;\n            rs1_out <= rs1_out;\n            rs2_out <= rs2_out;\n            rd_out <= rd_out;\n            imm_out <= imm_out;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'inst', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'func3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}, {'id': 9, 'content': 'R_decoder', 'type': 'submodule'}, {'id': 10, 'content': 'I_decoder', 'type': 'submodule'}, {'id': 11, 'content': 'J_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 10, 11, 9, 10, 11, 9, 10, 9, 10, 9, 9, 10, 11, 9], [9, 10, 11, 3, 3, 3, 4, 4, 4, 5, 5, 6, 6, 7, 8, 8, 8]]\n, Design a RISC-V instruction decoder module that decodes the instruction into operation code, destination register, and operand values. The module should support separate decoding paths for R-type, I-type, and J-type instructions.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    inst [31:0]: 32-bit input instruction to be decoded.\n\nOutput ports:\n    opcode [6:0]: 7-bit decoded opcode.\n    rd [4:0]: 5-bit destination register.\n    func3 [2:0]: 3-bit function code.\n    rs1 [4:0]: 5-bit source register 1.\n    rs2 [4:0]: 5-bit source register 2.\n    imm [31:0]: 32-bit immediate value, with support for sign extension.\n\nImplementation:\n    This module uses three submodules, each designed to decode one of the instruction types (R-type, I-type, J-type).\n    Based on the opcode, the appropriate submodule is activated to process the instruction and extract the relevant fields.\n    The decoded outputs (rd, func3, rs1, rs2, imm) are selected and outputted based on the active decoding path.\n    The module also includes logic to handle reset conditions, ensuring all outputs are cleared when rst is asserted.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [31:0] imm\n);\n\n    wire [6:0] opcode_w;\n    wire [4:0] rd_w;\n    wire [2:0] func3_w;\n    wire [4:0] rs1_w;\n    wire [4:0] rs2_w;\n    wire [31:0] imm_w;\n\n    decode_R_type R_decoder (\n        .inst(inst),\n        .opcode(opcode_w),\n        .rd(rd_w),\n        .func3(func3_w),\n        .rs1(rs1_w),\n        .rs2(rs2_w),\n        .imm(imm_w)\n    );\n\n    decode_I_type I_decoder (\n        .inst(inst),\n        .opcode(opcode_w),\n        .rd(rd_w),\n        .func3(func3_w),\n        .rs1(rs1_w),\n        .imm(imm_w)\n    );\n\n    decode_J_type J_decoder (\n        .inst(inst),\n        .opcode(opcode_w),\n        .rd(rd_w),\n        .imm(imm_w)\n    );\n\n    assign opcode = opcode_w;\n    assign rd = rd_w;\n    assign func3 = func3_w;\n    assign rs1 = rs1_w;\n    assign rs2 = rs2_w;\n    assign imm = imm_w;\n\nendmodule\n\nmodule decode_R_type (\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [31:0] imm\n);\n\n    assign opcode = inst[6:0];\n    assign rd = inst[11:7];\n    assign func3 = inst[14:12];\n    assign rs1 = inst[19:15];\n    assign rs2 = inst[24:20];\n    assign imm = 32'd0;\n\nendmodule\n\nmodule decode_I_type (\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [4:0] rs1,\n    output [31:0] imm\n);\n\n    assign opcode = inst[6:0];\n    assign rd = inst[11:7];\n    assign func3 = inst[14:12];\n    assign rs1 = inst[19:15];\n    assign imm = {{20{inst[31]}}, inst[31:20]};\n\nendmodule\n\nmodule decode_J_type (\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [31:0] imm\n);\n\n    assign opcode = inst[6:0];\n    assign rd = inst[11:7];\n    assign imm = {{12{inst[31]}}, inst[19:12], inst[20], inst[30:21], 1'b0};\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'operand1', 'type': 'input port'}, {'id': 4, 'content': 'operand2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'status_flags', 'type': 'output port'}, {'id': 7, 'content': 'arithmetic_unit', 'type': 'submodule'}, {'id': 8, 'content': 'logical_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 2, 4, 1, 3, 0, 2, 4, 1, 7, 2, 8, 7, 2, 8], [7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, Design a Verilog module for a RISC-V execution unit that receives instruction components and executes them based on the opcode. It should interface with arithmetic and logic unit submodules to perform operations.\n\nModule name:\n    exec_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    opcode [2:0]: 3-bit opcode specifying the operation.\n    operand1 [7:0]: First operand for the operation.\n    operand2 [7:0]: Second operand for the operation.\n\nOutput ports:\n    result [7:0]: Result of the operation.\n    status_flags [2:0]: Status flags (0 - Zero, 1 - Negative, 2 - Overflow).\n\nImplementation:\n    The exec_unit module uses two submodules: alu for arithmetic operations and logic_unit for logical operations.\n    Based on the opcode, the corresponding submodule is activated to process the operands.\n    Status flags are updated based on the results from the active submodule.\nGive me the complete code."}, {"from": "gpt", "value": "module exec_unit (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output [7:0] result,\n    output [2:0] status_flags\n);\n\n    wire [7:0] alu_result, logic_result;\n    wire [2:0] alu_status, logic_status;\n\n    alu arithmetic_unit (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(alu_result),\n        .status_flags(alu_status)\n    );\n\n    logic_unit logical_unit (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .operand1(operand1),\n        .operand2(operand2),\n        .result(logic_result),\n        .status_flags(logic_status)\n    );\n\n    assign result = (opcode < 3'b100) ? alu_result : logic_result;\n    assign status_flags = (opcode < 3'b100) ? alu_status : logic_status;\n\nendmodule\n\nmodule alu (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg [2:0] status_flags\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n            status_flags <= 0;\n        end else begin\n            case (opcode)\n                3'b000: result <= operand1 + operand2; // Addition\n                3'b001: result <= operand1 - operand2; // Subtraction\n                3'b010: result <= operand1 & operand2; // Bitwise AND\n                3'b011: result <= operand1 | operand2; // Bitwise OR\n                default: result <= result;\n            endcase\n            status_flags[0] <= (result == 0);\n            status_flags[1] <= result[7];\n            status_flags[2] <= (opcode == 3'b000 && result < operand1); // Overflow\n        end\n    end\n\nendmodule\n\nmodule logic_unit (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg [2:0] status_flags\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 0;\n            status_flags <= 0;\n        end else begin\n            case (opcode)\n                3'b100: result <= operand1 ^ operand2; // XOR\n                3'b101: result <= ~operand1; // NOT\n                3'b110: result <= operand1 << operand2[2:0]; // Shift left\n                3'b111: result <= operand1 >> operand2[2:0]; // Shift right\n                default: result <= result;\n            endcase\n            status_flags[0] <= (result == 0);\n            status_flags[1] <= result[7];\n            status_flags[2] <= 0; // No overflow condition for logical operations\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'funct3', 'type': 'output port'}, {'id': 3, 'content': 'funct7', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'instr_type', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 0, 0, 0], [1, 2, 3, 4, 5, 6, 7]]\n, Design a Verilog module named `instruction_decoder` that decodes a 32-bit RISC-V instruction into its constituent parts based on the opcode. It should decode instructions to identify the type (R, I, S, B, U, J), opcode, funct3, and funct7 fields, and extract the rs1, rs2, rd, and immediate fields as applicable.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    instruction [31:0]: 32-bit input representing the RISC-V instruction.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode extracted from the instruction.\n    funct3 [2:0]: 3-bit funct3 field, valid for some instruction types.\n    funct7 [6:0]: 7-bit funct7 field, valid for R-type instructions.\n    rs1 [4:0]: 5-bit rs1 register specifier.\n    rs2 [4:0]: 5-bit rs2 register specifier.\n    rd [4:0]: 5-bit rd register destination specifier.\n    imm [31:0]: 32-bit immediate value, sign-extended where applicable.\n    instr_type [2:0]: Type of instruction (R, I, S, B, U, J).\n\nImplementation:\n    The `instruction_decoder` module uses combinational logic to decode the instruction based on its type. The opcode field is directly extracted and based on its value, other fields such as funct3, funct7, rs1, rs2, rd, and immediate are extracted and appropriately sign-extended if required. The instruction type is determined based on the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder(\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output reg [31:0] imm,\n    output reg [2:0] instr_type\n);\n\n    // Extract fields from instruction\n    assign opcode = instruction[6:0];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\n    assign funct7 = instruction[31:25];\n\n    // Decode instruction based on opcode\n    always @(*) begin\n        case(opcode)\n            7'b0110011: begin // R-type\n                instr_type = 3'b000;\n                imm = 32'd0;\n            end\n            7'b0010011: begin // I-type\n                instr_type = 3'b001;\n                imm = {{20{instruction[31]}}, instruction[31:20]};\n            end\n            7'b0000011, 7'b1100111: begin // I-type: Loads and JALR\n                instr_type = 3'b001;\n                imm = {{20{instruction[31]}}, instruction[31:20]};\n            end\n            7'b0100011: begin // S-type\n                instr_type = 3'b010;\n                imm = {{20{instruction[31]}}, instruction[31:25], instruction[11:7]};\n            end\n            7'b1100011: begin // B-type\n                instr_type = 3'b011;\n                imm = {{19{instruction[31]}}, instruction[31], instruction[7], instruction[30:25], instruction[11:8], 1'b0};\n            end\n            7'b1101111: begin // J-type\n                instr_type = 3'b100;\n                imm = {{11{instruction[31]}}, instruction[31], instruction[19:12], instruction[20], instruction[30:21], 1'b0};\n            end\n            7'b0110111, 7'b0010111: begin // U-type: LUI and AUIPC\n                instr_type = 3'b101;\n                imm = {instruction[31:12], 12'b0};\n            end\n            default: begin\n                instr_type = 3'b111; // Unknown type\n                imm = 32'd0;\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'pc', 'type': 'input port'}, {'id': 3, 'content': 'branch', 'type': 'input port'}, {'id': 4, 'content': 'target', 'type': 'input port'}, {'id': 5, 'content': 'next_pc', 'type': 'output port'}, {'id': 6, 'content': 'predictor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 4, 3, 1, 6], [6, 6, 6, 6, 6, 5]]\n, Create a modular Verilog design for a branch predictor module in a RISC-V CPU. This module predicts the next program counter (PC) address based on the current PC, a branch flag, and a branch target address. The module includes a main predictor and a submodule for updating the prediction logic.\n\nModule name:\n    branch_predictor\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the predictor.\n    pc [31:0]: Current program counter address.\n    branch [0:0]: Branch flag indicating whether a branch might be taken (1) or not (0).\n    target [31:0]: Branch target address for taken branches.\n\nOutput ports:\n    next_pc [31:0]: Predicted next program counter address.\n\nImplementation:\n    The branch predictor uses a prediction logic submodule that calculates and updates the next program counter address based on the branch flag and the target address.\n    The output, next_pc, is updated every clock cycle based on the output from the prediction logic submodule.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_predictor (\n    input clk,\n    input rst,\n    input [31:0] pc,\n    input branch,\n    input [31:0] target,\n    output [31:0] next_pc\n);\n\n    wire [31:0] predicted_pc;\n\n    prediction_logic predictor (\n        .clk(clk),\n        .rst(rst),\n        .current_pc(pc),\n        .branch_taken(branch),\n        .branch_target(target),\n        .next_pc(predicted_pc)\n    );\n\n    assign next_pc = predicted_pc;\n\nendmodule\n\nmodule prediction_logic (\n    input clk,\n    input rst,\n    input [31:0] current_pc,\n    input branch_taken,\n    input [31:0] branch_target,\n    output reg [31:0] next_pc\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            next_pc <= 32'd0;\n        end else begin\n            if (branch_taken) begin\n                next_pc <= branch_target;\n            end else begin\n                next_pc <= current_pc + 4; // Assumes sequential increment of PC\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'instruction', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'shifted_imm', 'type': 'output port'}, {'id': 7, 'content': 'decoder1', 'type': 'submodule'}, {'id': 8, 'content': 'decoder2', 'type': 'submodule'}, {'id': 9, 'content': 'shifter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 3, 7, 3, 7, 8, 9], [7, 8, 9, 9, 4, 5, 6]]\n, Design a Verilog module named `shifted_instruction_register` that acts as an instruction decoder and output modifier for RISC-V instructions, capable of handling different operation types and providing modified outputs. The module must decompose the input instruction into opcode, funct3, and immediate value parts, then shift the immediate value based on the opcode for specific operation types.\n\nModule name:\n    shifted_instruction_register\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal to clear the outputs.\n    enable: Enable signal to process the instruction.\n    instruction [31:0]: 32-bit input instruction.\n\nOutput ports:\n    opcode [6:0]: Extracted 7-bit opcode.\n    funct3 [2:0]: Extracted 3-bit function code.\n    shifted_imm [31:0]: Shifted immediate value, the shift amount is determined by the opcode.\n\nImplementation:\n    The module leverages three submodules: opcode_decoder, funct3_decoder, and imm_shifter. Each submodule is specialized:\n    - `opcode_decoder` extracts the opcode from the instruction.\n    - `funct3_decoder` extracts the funct3 value.\n    - `imm_shifter` calculates the shifted immediate value, where the shift amount is opcode-dependent. If the opcode corresponds to an arithmetic operation, the immediate value is shifted left by 1; otherwise, it's taken as is.\nGive me the complete code."}, {"from": "gpt", "value": "module shifted_instruction_register (\n    input clk,\n    input rst_n,\n    input enable,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [31:0] shifted_imm\n);\n\n    // Submodule instances\n    wire [6:0] opcode_out;\n    wire [2:0] funct3_out;\n    wire [31:0] imm_out;\n\n    opcode_decoder decoder1 (\n        .instruction(instruction),\n        .opcode(opcode_out)\n    );\n\n    funct3_decoder decoder2 (\n        .instruction(instruction),\n        .funct3(funct3_out)\n    );\n\n    imm_shifter shifter (\n        .opcode(opcode_out),\n        .instruction(instruction),\n        .shifted_imm(imm_out)\n    );\n\n    // Output assignments\n    assign opcode = opcode_out;\n    assign funct3 = funct3_out;\n    assign shifted_imm = imm_out;\n\nendmodule\n\nmodule opcode_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\nmodule funct3_decoder (\n    input [31:0] instruction,\n    output [2:0] funct3\n);\n    assign funct3 = instruction[14:12];\nendmodule\n\nmodule imm_shifter (\n    input [6:0] opcode,\n    input [31:0] instruction,\n    output reg [31:0] shifted_imm\n);\n    always @(*) begin\n        // Example logic for shifting\n        if (opcode == 7'b0110011) // Example opcode for arithmetic operations\n            shifted_imm = instruction[31:20] << 1;\n        else\n            shifted_imm = instruction[31:20];\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'flags', 'type': 'input port'}, {'id': 2, 'content': 'branch_taken', 'type': 'output port'}, {'id': 3, 'content': 'branch_type', 'type': 'output port'}, {'id': 4, 'content': 'decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4], [4, 2, 3]]\n, Design a Verilog module for a RISC-V branch instruction decoder that reads a 32-bit instruction and outputs control signals to direct the program counter (PC) logic. The module should isolate and decode the branch type and determine if the branch condition is taken based on flags from the execution unit.\n\nModule name:\n    branch_decoder\n\nInput ports:\n    instruction [31:0]: The 32-bit instruction word.\n    flags [3:0]: Processor flags where [0] is zero, [1] is negative, [2] is carry, and [3] is overflow.\n    \nOutput ports:\n    branch_taken: A signal to indicate whether the branch should be taken.\n    branch_type [2:0]: Type of branch (e.g., BEQ, BNE, BLT, BGE).\n\nImplementation:\n    The module utilizes a submodule to determine the branch type based on opcode and funct3 fields.\n    The main module evaluates the flags and the branch type to determine if the condition for the branch is satisfied.\n    Supports standard RISC-V branches including equality, inequality, less than, and greater than or equal.\n    Efficient handling for signal conditioning and branching decision-making.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_decoder (\n    input [31:0] instruction,\n    input [3:0] flags,\n    output branch_taken,\n    output [2:0] branch_type\n);\n\n    // Submodule for decoding branch type\n    wire [6:0] opcode;\n    wire [2:0] funct3;\n    assign opcode = instruction[6:0];\n    assign funct3 = instruction[14:12];\n\n    branch_type_decoder decoder (\n        .opcode(opcode),\n        .funct3(funct3),\n        .branch_type(branch_type)\n    );\n\n    // Branch condition evaluation\n    reg branch_taken_reg;\n    always @* begin\n        case (branch_type)\n            3'b000: branch_taken_reg = flags[0]; // BEQ\n            3'b001: branch_taken_reg = ~flags[0]; // BNE\n            3'b100: branch_taken_reg = flags[1]; // BLT\n            3'b101: branch_taken_reg = ~flags[1] | flags[0]; // BGE\n            default: branch_taken_reg = 1'b0;\n        endcase\n    end\n\n    assign branch_taken = branch_taken_reg;\n\nendmodule\n\nmodule branch_type_decoder (\n    input [6:0] opcode,\n    input [2:0] funct3,\n    output reg [2:0] branch_type\n);\n\n    always @* begin\n        if (opcode == 7'b1100011) begin // BRANCH opcode\n            branch_type = funct3;\n        end else begin\n            branch_type = 3'b111; // Invalid or not a branch\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'instruction', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'output port'}, {'id': 3, 'content': 'rd', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'funct3', 'type': 'output port'}, {'id': 7, 'content': 'funct7', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}, {'id': 9, 'content': 'imm_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 1, 1, 1, 1, 9], [9, 2, 3, 4, 5, 6, 7, 8]]\n, Design a Verilog module for a RISC-V CPU instruction decoder that parses a 32-bit instruction into various fields such as opcode, destination register, source registers, and immediate value. The module should be capable of decoding R-type, I-type, S-type, and B-type instructions, and utilizes submodules for handling each type.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    instruction [31:0]: 32-bit instruction input to be decoded.\n\nOutput ports:\n    opcode [6:0]: Opcode of the instruction.\n    rd [4:0]: Destination register.\n    rs1 [4:0]: First source register.\n    rs2 [4:0]: Second source register.\n    funct3 [2:0]: Function3 field.\n    funct7 [6:0]: Function7 field for R-type instructions.\n    imm [31:0]: Immediate value for I-type, S-type, and B-type instructions.\n\nImplementation:\n    The instruction decoder separates the instruction into different fields depending on the instruction type determined by the opcode. Each type of instruction decoding is managed by a separate submodule.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output reg [31:0] imm\n);\n\n    // Assign opcode, rd, rs1, rs2, funct3 fields directly from instruction\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign funct3 = instruction[14:12];\n    assign funct7 = instruction[31:25];\n\n    // Submodule instantiations\n    imm_decoder imm_dec (\n        .opcode(opcode),\n        .instruction(instruction),\n        .imm(imm)\n    );\n\nendmodule\n\n// Submodule for immediate value decoding\nmodule imm_decoder (\n    input [6:0] opcode,\n    input [31:0] instruction,\n    output reg [31:0] imm\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0000011, 7'b0010011: // I-type\n                imm = {{20{instruction[31]}}, instruction[31:20]};\n            7'b0100011: // S-type\n                imm = {{20{instruction[31]}}, instruction[31:25], instruction[11:7]};\n            7'b1100011: // B-type\n                imm = {{20{instruction[31]}}, instruction[7], instruction[30:25], instruction[11:8], 1'b0};\n            default:\n                imm = 32'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'current_pc', 'type': 'input port'}, {'id': 4, 'content': 'offset', 'type': 'input port'}, {'id': 5, 'content': 'base', 'type': 'input port'}, {'id': 6, 'content': 'next_pc', 'type': 'output port'}, {'id': 7, 'content': 'link_addr', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[4, 5, 3], [6, 6, 7]]\n, A RISC-V jump and link register module that captures the next program counter (PC) and the address to jump to based on the input instruction. The module also provides a link register functionality by saving the return address into a specified register.\n\nModule name:\n    jalr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the registers.\n    enable: Enable signal to update the PC and link address.\n    current_pc [31:0]: The current program counter.\n    offset [11:0]: 12-bit signed offset to calculate the jump target.\n    base [31:0]: Base address from which the offset will be applied to calculate the jump target.\n\nOutput ports:\n    next_pc [31:0]: The new program counter after applying the base address and offset.\n    link_addr [31:0]: The link address where the return address will be stored.\n\nImplementation:\n    The jalr_reg module uses signed extension and addition to compute the jump target address. On the rising edge of the clock, if enable is high, the next_pc is computed as (base + offset) & ~1. The link address is set to current_pc + 4, aligning with typical RISC-V calling conventions.\nGive me the complete code."}, {"from": "gpt", "value": "module jalr_reg (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] current_pc,\n    input [11:0] offset,\n    input [31:0] base,\n    output reg [31:0] next_pc,\n    output reg [31:0] link_addr\n);\n\n    wire [31:0] sign_extended_offset;\n    \n    // Sign extension of 12-bit offset to 32-bit\n    assign sign_extended_offset = {{20{offset[11]}}, offset};\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            next_pc <= 32'd0;\n            link_addr <= 32'd0;\n        end else if (enable) begin\n            next_pc <= (base + sign_extended_offset) & 32'hFFFFFFFE;\n            link_addr <= current_pc + 4;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'instr', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'output port'}, {'id': 3, 'content': 'rd', 'type': 'output port'}, {'id': 4, 'content': 'funct3', 'type': 'output port'}, {'id': 5, 'content': 'immediate', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 1], [2, 3, 4, 5]]\n, Design a RISC-V instruction decoder module that takes a 32-bit instruction and decodes it into various functional signals for a pipeline CPU. This module should identify the type of instruction, destination register, and immediate values.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    instr [31:0]: 32-bit RISC-V instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode extracted from the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function field, specifies a particular operation in the instruction set.\n    immediate [31:0]: Immediate value for type-I and type-S instructions.\n\nImplementation:\n    The instruction decoder module splits the incoming 32-bit instruction into several fields.\n    It extracts the opcode, destination register, function field, and constructs the immediate value based on the type of instruction.\n    This module also identifies if the instruction is type-I or type-S and accordingly sets the immediate value field.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output reg [31:0] immediate\n);\n\n    // Assign outputs directly from instruction fields\n    assign opcode = instr[6:0];\n    assign rd = instr[11:7];\n    assign funct3 = instr[14:12];\n\n    always @(posedge clk) begin\n        // Immediate value calculation based on instruction type\n        if(opcode == 7'b0010011 || opcode == 7'b0000011) begin // Type I: immediate[11:0] are instr[31:20]\n            immediate <= {{20{instr[31]}}, instr[31:20]}; // Sign extend the 12-bit immediate\n        end\n        else if(opcode == 7'b0100011) begin // Type S: immediate[11:5] are instr[31:25], immediate[4:0] are instr[11:7]\n            immediate <= {{20{instr[31]}}, instr[31:25], instr[11:7]}; // Construct S-type immediate\n        end\n        else begin\n            immediate <= 32'd0; // Default immediate value\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'rd', 'type': 'output port'}, {'id': 3, 'content': 'funct3', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'funct7', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'ofe', 'type': 'submodule'}, {'id': 9, 'content': 'ie', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 8, 0, 8, 8, 8, 8, 8, 8, 9], [8, 9, 9, 1, 2, 3, 4, 5, 6, 7]]\n, An instruction decoding module designed to interpret a CPU instruction from the instruction register and decode it into meaningful control signals. This module includes submodules for opcode interpretation and immediate value extraction, useful for various types of instructions in RISC-V, especially for instruction types like R, I, S, B, U, and J.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    instruction [31:0]: The full 32-bit instruction fetched from the instruction memory.\n    \nOutput ports:\n    opcode [6:0]: Extracted opcode from the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function 3-bit code.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address.\n    funct7 [6:0]: Function 7-bit code.\n    imm [31:0]: Immediate value used for various instruction types.\n    \nImplementation:\n    The instruction decoder separates different parts of the instruction based on the RISC-V standard. It uses two submodules: one for opcode and function extraction, and another for immediate value generation, based on instruction type identified by the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder(\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7,\n    output [31:0] imm\n);\n\n    // Submodule for opcode and function fields extraction\n    wire [6:0] opcode_out;\n    wire [4:0] rd_out;\n    wire [2:0] funct3_out;\n    wire [4:0] rs1_out;\n    wire [4:0] rs2_out;\n    wire [6:0] funct7_out;\n\n    opcode_functions_extractor ofe(\n        .instruction(instruction),\n        .opcode(opcode_out),\n        .rd(rd_out),\n        .funct3(funct3_out),\n        .rs1(rs1_out),\n        .rs2(rs2_out),\n        .funct7(funct7_out)\n    );\n\n    // Submodule for immediate value extraction\n    wire [31:0] imm_out;\n\n    immediate_extractor ie(\n        .instruction(instruction),\n        .opcode(opcode_out),\n        .imm(imm_out)\n    );\n\n    // Output assignments\n    assign opcode = opcode_out;\n    assign rd = rd_out;\n    assign funct3 = funct3_out;\n    assign rs1 = rs1_out;\n    assign rs2 = rs2_out;\n    assign funct7 = funct7_out;\n    assign imm = imm_out;\n\nendmodule\n\nmodule opcode_functions_extractor(\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7\n);\n\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign funct7 = instruction[31:25];\n\nendmodule\n\nmodule immediate_extractor(\n    input [31:0] instruction,\n    input [6:0] opcode,\n    output reg [31:0] imm\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0010011: imm = {{20{instruction[31]}}, instruction[31:20]}; // I-type\n            7'b0100011: imm = {{20{instruction[31]}}, instruction[31:25], instruction[11:7]}; // S-type\n            7'b1101111: imm = {{11{instruction[31]}}, instruction[31], instruction[19:12], instruction[20], instruction[30:21], 1'b0}; // J-type\n            default: imm = 32'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'op_sel', 'type': 'input port'}, {'id': 1, 'content': 'operand_a', 'type': 'input port'}, {'id': 2, 'content': 'operand_b', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 2], [3, 3]]\n, Create a RISC-V arithmetic logic unit (ALU) submodule design for a Verilog-based processor. This ALU should support four operations based on a 2-bit operation selector: addition, subtraction, bitwise AND, and bitwise OR. It should be capable of operating on 16-bit operands and provide a 16-bit result.\n\nModule name:\n    alu_16bit\n\nInput ports:\n    op_sel [1:0]: Operation selector (00 for addition, 01 for subtraction, 10 for AND, 11 for OR).\n    operand_a [15:0]: First operand input.\n    operand_b [15:0]: Second operand input.\n\nOutput ports:\n    result [15:0]: Result of the operation based on op_sel.\n\nImplementation:\n    The ALU uses combinational logic to compute the result based on the selected operation. On input changes, the result updates immediately. The design should handle overflow for addition and subtraction gracefully, by ignoring it (as typical in many ALU designs).\nGive me the complete code."}, {"from": "gpt", "value": "module alu_16bit (\n    input [1:0] op_sel,\n    input [15:0] operand_a,\n    input [15:0] operand_b,\n    output reg [15:0] result\n);\n\n    always @(*) begin\n        case (op_sel)\n            2'b00: result = operand_a + operand_b; // Addition\n            2'b01: result = operand_a - operand_b; // Subtraction\n            2'b10: result = operand_a & operand_b; // AND\n            2'b11: result = operand_a | operand_b; // OR\n            default: result = 16'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}, {'id': 9, 'content': 'rtype', 'type': 'submodule'}, {'id': 10, 'content': 'itype', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 10, 2, 9, 10, 2, 9, 10, 2, 9, 9, 2, 10, 2], [9, 10, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 8, 8]]\n, Design a RISC-V instruction decoder module that decodes a fetched instruction into its constituent parts such as operation, destination register, and operands. The module will have separate submodules for decoding different types of instructions (R-type, I-type, etc.).\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    instruction [31:0]: 32-bit instruction fetched from instruction memory.\n\nOutput ports:\n    opcode [6:0]: Operation code part of the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function code for additional instruction decoding.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2 (if applicable).\n    imm [11:0]: Immediate value (if applicable).\n\nImplementation:\n    The instruction decoder separates the input instruction into opcode, rd, funct3, rs1, rs2, and imm based on the instruction type indicated by the opcode. Submodules for R-type and I-type instruction decoding are used based on the opcode value.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [11:0] imm\n);\n\n    // Wires for submodule outputs\n    wire [4:0] rtype_rd, rtype_rs1, rtype_rs2;\n    wire [2:0] rtype_funct3;\n    wire [4:0] itype_rd, itype_rs1;\n    wire [11:0] itype_imm;\n    wire [2:0] itype_funct3;\n\n    rtype_decoder rtype (\n        .instruction(instruction),\n        .rd(rtype_rd),\n        .rs1(rtype_rs1),\n        .rs2(rtype_rs2),\n        .funct3(rtype_funct3)\n    );\n\n    itype_decoder itype (\n        .instruction(instruction),\n        .rd(itype_rd),\n        .rs1(itype_rs1),\n        .imm(itype_imm),\n        .funct3(itype_funct3)\n    );\n\n    assign opcode = instruction[6:0];\n\n    assign rd = (opcode == 7'b0110011) ? rtype_rd : itype_rd;\n    assign rs1 = (opcode == 7'b0110011) ? rtype_rs1 : itype_rs1;\n    assign rs2 = (opcode == 7'b0110011) ? rtype_rs2 : 5'b0;\n    assign funct3 = (opcode == 7'b0110011) ? rtype_funct3 : itype_funct3;\n    assign imm = (opcode != 7'b0110011) ? itype_imm : 12'b0;\n\nendmodule\n\nmodule rtype_decoder (\n    input [31:0] instruction,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [2:0] funct3\n);\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign funct3 = instruction[14:12];\nendmodule\n\nmodule itype_decoder (\n    input [31:0] instruction,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [11:0] imm,\n    output [2:0] funct3\n);\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign imm = instruction[31:20];\n    assign funct3 = instruction[14:12];\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'funct3', 'type': 'output port'}, {'id': 3, 'content': 'funct7', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'imm_calc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 0, 0, 0, 8], [8, 1, 2, 3, 4, 5, 6, 7]]\n, Design a RISC-V instruction decoder module that extracts and decodes a 32-bit instruction into signals for further processing. This module should be capable of identifying the type of instruction (R-type, I-type, S-type, B-type, U-type, J-type) and output relevant control signals and parameters like opcode, funct3, funct7, rs1, rs2, rd, and immediate values as needed.\n\nModule name:\n    decode_instr\n\nInput ports:\n    instr [31:0]: 32-bit input instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode field of the instruction.\n    funct3 [2:0]: Function3 field, only for specific instruction types.\n    funct7 [6:0]: Function7 field, used in R-type instructions.\n    rs1 [4:0], rs2 [4:0], rd [4:0]: Source and destination register indices.\n    imm [31:0]: Immediate value, format adjusted based on instruction type.\n\nImplementation:\n    The instruction decoder is structured into two submodules: one handling decoding of fixed fields (opcode, rs1, rs2, rd, funct3, funct7) and another handling the computation of immediate values based on the instruction type.\n    Outputs are driven based on the extracted information from the instruction and are updated every clock cycle to reflect any changes in the input instruction.\nGive me the complete code."}, {"from": "gpt", "value": "module decode_instr (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [31:0] imm\n);\n\n    // Extract basic fields\n    assign opcode = instr[6:0];\n    assign rd = instr[11:7];\n    assign funct3 = instr[14:12];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign funct7 = instr[31:25];\n\n    // Submodule to calculate immediate values\n    wire [31:0] imm_out;\n    immediate_calculator imm_calc (\n        .instr(instr),\n        .opcode(opcode),\n        .imm(imm_out)\n    );\n\n    assign imm = imm_out;\n\nendmodule\n\n// Submodule to calculate immediate values\nmodule immediate_calculator (\n    input [31:0] instr,\n    input [6:0] opcode,\n    output reg [31:0] imm\n);\n\n    always @(*) begin\n        case (opcode)\n            7'b0010011,  // I-type\n            7'b0000011: imm = {{20{instr[31]}}, instr[31:20]}; // sign-extend\n            7'b0100011: imm = {{20{instr[31]}}, instr[31:25], instr[11:7]}; // S-type\n            7'b1100011: imm = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}; // B-type\n            7'b1101111: imm = {{11{instr[31]}}, instr[31], instr[19:12], instr[20], instr[30:21], 1'b0}; // J-type\n            7'b0110111, // U-type\n            7'b0010111: imm = {instr[31:12], 12'h000}; // direct 20-bit upper imm\n            default: imm = 32'h00000000;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'rd', 'type': 'output port'}, {'id': 3, 'content': 'rs1', 'type': 'output port'}, {'id': 4, 'content': 'rs2', 'type': 'output port'}, {'id': 5, 'content': 'imm', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 0], [1, 2, 3, 4, 5]]\n, Design a Verilog module for a RISC-V instruction decoder that separates an incoming 32-bit instruction into its component parts for a simplified RISC-V architecture. The module should decode instructions into opcode, destination register, source register 1, source register 2, and immediate value, supporting basic R-format, I-format, and S-format instructions.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    instr [31:0]: 32-bit instruction input.\n\nOutput ports:\n    opcode [6:0]: Decoded opcode.\n    rd [4:0]: Decoded destination register.\n    rs1 [4:0]: Decoded source register 1.\n    rs2 [4:0]: Decoded source register 2.\n    imm [11:0]: Decoded immediate value for I and S formats.\n\nImplementation:\n    The decoder extracts bits directly from the input instruction using bit slicing for each output. It handles different instruction formats by checking the opcode and adjusting the bit slices accordingly.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [11:0] imm\n);\n\n    assign opcode = instr[6:0];\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n\n    wire [2:0] fmt;  // Format type: R, I, S\n    assign fmt = opcode[2:0];  // Simplified format type detection\n\n    // Immediate extraction based on format\n    assign imm = (fmt == 3'b010 || fmt == 3'b000) ? instr[31:20] :  // I-format\n                 (fmt == 3'b001) ? {instr[31:25], instr[11:7]} :  // S-format\n                 12'd0;  // Default for R-format (not used)\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'val1', 'type': 'input port'}, {'id': 3, 'content': 'val2', 'type': 'input port'}, {'id': 4, 'content': 'branch', 'type': 'output port'}, {'id': 5, 'content': 'comp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 5], [5, 5, 4]]\n, Design a RISC-V branch condition check module, specifically for the BEQ (Branch if Equal) instruction, that compares two 32-bit register values. When equal, it generates a branch signal to control program flow.\n\nModule name:\n    branch_beq\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the circuit.\n    val1 [31:0]: First 32-bit value for comparison.\n    val2 [31:0]: Second 32-bit value for comparison.\n\nOutput ports:\n    branch [0:0]: Branch signal output (1 for branch, 0 for no branch).\n\nImplementation:\n    The branch_beq module internally uses a comparator submodule to check the equality of the two inputs.\n    On the rising edge of the clock (clk), if the reset (rst) is low, the branch output is set to 0.\n    If both values (val1 and val2) are equal, the branch signal is set to 1; otherwise, it remains 0.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_beq (\n    input clk,\n    input rst,\n    input [31:0] val1,\n    input [31:0] val2,\n    output reg branch\n);\n\n    // Internal wire for comparison result\n    wire comparison_result;\n\n    // Comparator submodule instantiation\n    equal_comparator comp (\n        .a(val1),\n        .b(val2),\n        .result(comparison_result)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            branch <= 1'b0; // Reset branch signal\n        end else begin\n            branch <= comparison_result; // Set branch based on comparison\n        end\n    end\n\nendmodule\n\n// Submodule for equal comparison\nmodule equal_comparator (\n    input [31:0] a,\n    input [31:0] b,\n    output result\n);\n\n    assign result = (a == b) ? 1'b1 : 1'b0;\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'immediate', 'type': 'output port'}, {'id': 9, 'content': 'funct7', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2, 2], [3, 4, 5, 6, 7, 8, 9]]\n, Design a RISC-V instruction decoder module that takes a 32-bit instruction and decodes it into signals suitable for driving a processor\u2019s control logic. The module should separate the instruction into opcode, register addresses, immediate value, and function code.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    instruction [31:0]: 32-bit input representing the complete instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode extracted from the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function field, part of the instruction.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address.\n    immediate [11:0]: Immediate value for immediate-type instructions.\n    funct7 [6:0]: Additional function field for R-type instructions.\n\nImplementation:\n    The instruction decoder module uses combinational logic to extract various fields from the incoming instruction based on the standard RISC-V instruction format. The outputs are derived directly from the respective bit positions of the instruction.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] opcode,\n    output reg [4:0] rd,\n    output reg [2:0] funct3,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2,\n    output reg [11:0] immediate,\n    output reg [6:0] funct7\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            opcode <= 7'b0;\n            rd <= 5'b0;\n            funct3 <= 3'b0;\n            rs1 <= 5'b0;\n            rs2 <= 5'b0;\n            immediate <= 12'b0;\n            funct7 <= 7'b0;\n        end else begin\n            opcode <= instruction[6:0];\n            rd <= instruction[11:7];\n            funct3 <= instruction[14:12];\n            rs1 <= instruction[19:15];\n            rs2 <= instruction[24:20];\n            immediate <= instruction[31:20];\n            funct7 <= instruction[31:25];\n        end\n    end\n\nendmodule"}]}]