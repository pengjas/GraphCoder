[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'op_type', 'type': 'output port'}, {'id': 2, 'content': 'alu_op', 'type': 'output port'}, {'id': 3, 'content': 'mem_control', 'type': 'output port'}, {'id': 4, 'content': 'branch_taken', 'type': 'output port'}, {'id': 5, 'content': 'arith_dec', 'type': 'submodule'}, {'id': 6, 'content': 'mem_dec', 'type': 'submodule'}, {'id': 7, 'content': 'branch_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 5, 5, 6, 7], [5, 6, 7, 1, 2, 3, 4]]\n, Design a RISC-V instruction decoder module that decodes 32-bit instructions into multiple control signals for further execution stages. The module identifies the type of operation (arithmetic, memory, branch) and specific control flags (e.g., ALU operation, memory read/write, branch taken).\n\nModule name:\n    instr_decoder\n\nInput ports:\n    instr [31:0]: Full 32-bit instruction input.\n\nOutput ports:\n    op_type [2:0]: Type of operation (e.g., arithmetic, memory, branch).\n    alu_op [3:0]: Specific ALU operation code.\n    mem_control [1:0]: Memory control signals (00: none, 01: read, 10: write).\n    branch_taken: Branch taken signal.\n\nImplementation:\n    The instruction decoder consists of several submodules, each responsible for decoding different parts of the instruction. The module parses the opcode, function codes, and other necessary fields to determine the output signals. Outputs vary based on instruction type. For simplicity in routing signals, separate submodules are instantiated for handling arithmetic, memory, and branching decisions. Outputs from these submodules are combined in the top module to produce the final control signals.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input [31:0] instr,\n    output [2:0] op_type,\n    output [3:0] alu_op,\n    output [1:0] mem_control,\n    output branch_taken\n);\n\n    wire [6:0] opcode;\n    wire [2:0] funct3;\n    wire [6:0] funct7;\n\n    assign opcode = instr[6:0];\n    assign funct3 = instr[14:12];\n    assign funct7 = instr[31:25];\n\n    // Submodules for decoding different instruction fields\n    arithmetic_decoder arith_dec (\n        .opcode(opcode),\n        .funct3(funct3),\n        .funct7(funct7),\n        .op_type(op_type),\n        .alu_op(alu_op)\n    );\n\n    memory_decoder mem_dec (\n        .opcode(opcode),\n        .funct3(funct3),\n        .mem_control(mem_control)\n    );\n\n    branch_decoder branch_dec (\n        .opcode(opcode),\n        .branch_taken(branch_taken)\n    );\n\nendmodule\n\nmodule arithmetic_decoder (\n    input [6:0] opcode,\n    input [2:0] funct3,\n    input [6:0] funct7,\n    output reg [2:0] op_type,\n    output reg [3:0] alu_op\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0110011: begin // R-type\n                op_type = 3'b001;\n                alu_op = {1'b0, funct7[5], funct3};\n            end\n            default: begin\n                op_type = 3'b000;\n                alu_op = 4'b0000;\n            end\n        endcase\n    end\nendmodule\n\nmodule memory_decoder (\n    input [6:0] opcode,\n    input [2:0] funct3,\n    output reg [1:0] mem_control\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0000011: mem_control = 2'b01; // Load\n            7'b0100011: mem_control = 2'b10; // Store\n            default: mem_control = 2'b00;\n        endcase\n    end\nendmodule\n\nmodule branch_decoder (\n    input [6:0] opcode,\n    output reg branch_taken\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b1100011: branch_taken = 1'b1; // Branch\n            default: branch_taken = 1'b0;\n        endcase\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'funct3', 'type': 'output port'}, {'id': 5, 'content': 'funct7', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'rs1', 'type': 'output port'}, {'id': 8, 'content': 'rs2', 'type': 'output port'}, {'id': 9, 'content': 'imm', 'type': 'output port'}, {'id': 10, 'content': 'control_signals', 'type': 'output port'}, {'id': 11, 'content': 'td', 'type': 'submodule'}, {'id': 12, 'content': 'csg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 11, 11, 11, 11, 11, 11, 11, 11, 12], [11, 12, 3, 4, 5, 6, 7, 8, 9, 10]]\n, A RISC-V instruction decoder module that interprets a 32-bit instruction and outputs relevant control signals for different stages of an instruction processing pipeline. This module should include a submodule to decode the instruction type (R-type, I-type, S-type, etc.) and another submodule to generate specific control signals based on the instruction type.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    instruction [31:0]: Full 32-bit instruction to be decoded.\n\nOutput ports:\n    opcode [6:0]: Opcode field of the instruction.\n    funct3 [2:0]: Function field, used in some formats.\n    funct7 [6:0]: Function field, used in R-type instructions.\n    rd [4:0]: Destination register.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    imm [31:0]: Immediate value, extracted and sign-extended.\n    control_signals [5:0]: Control signals for the pipeline stages.\n\nImplementation:\n    The instruction decoder is implemented using two submodules: type_decoder and control_signal_generator.\n    The type_decoder extracts fields like opcode, funct3, funct7, rs1, rs2, rd, and also processes immediate values.\n    The control_signal_generator submodule uses the opcode and funct fields to output control signals for further pipeline processing.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [31:0] imm,\n    output [5:0] control_signals\n);\n\n    wire [31:0] imm_gen_out;\n\n    type_decoder td(\n        .instruction(instruction),\n        .opcode(opcode),\n        .funct3(funct3),\n        .funct7(funct7),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2),\n        .imm(imm_gen_out)\n    );\n\n    control_signal_generator csg(\n        .opcode(opcode),\n        .funct3(funct3),\n        .control_out(control_signals)\n    );\n\n    assign imm = imm_gen_out;\n\nendmodule\n\nmodule type_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output reg [31:0] imm\n);\n\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign funct7 = instruction[31:25];\n\n    always @(*) begin\n        case(opcode)\n            7'b0010011: imm = {{20{instruction[31]}}, instruction[31:20]}; // I-type\n            default: imm = 32'd0;\n        endcase\n    end\n\nendmodule\n\nmodule control_signal_generator (\n    input [6:0] opcode,\n    input [2:0] funct3,\n    output reg [5:0] control_out\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0110011: control_out = 6'b000001; // R-type\n            7'b0010011: control_out = 6'b000010; // I-type\n            default: control_out = 6'b000000;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'rd', 'type': 'output port'}, {'id': 3, 'content': 'funct3', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'funct7', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'op_dec', 'type': 'submodule'}, {'id': 9, 'content': 'reg_dec', 'type': 'submodule'}, {'id': 10, 'content': 'func_dec', 'type': 'submodule'}, {'id': 11, 'content': 'imm_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 8, 9, 10, 9, 9, 10, 11], [8, 9, 10, 11, 1, 2, 3, 4, 5, 6, 7]]\n, Design a RISC-V single-cycle instruction decoder module named `instr_decoder` which accepts a 32-bit instruction and extracts key fields such as opcode, function codes, and immediate values. This module is hierarchical and contains submodules for decoding different parts of the instruction based on RISC-V encoding standards.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    instruction [31:0]: Full 32-bit instruction input.\n\nOutput ports:\n    opcode [6:0]: Extracted opcode field.\n    rd [4:0]: Destination register index.\n    funct3 [2:0]: Function code of 3 bits.\n    rs1 [4:0]: Source register 1 index.\n    rs2 [4:0]: Source register 2 index.\n    funct7 [6:0]: Function code of 7 bits.\n    imm [31:0]: Immediate value extracted and sign-extended.\n\nImplementation:\n    The `instr_decoder` module instantiates several smaller decoders:\n    - `opcode_decoder` to extract the opcode.\n    - `register_decoder` to fetch rd, rs1, and rs2 indices.\n    - `function_decoder` to fetch funct3 and funct7.\n    - `immediate_decoder` to calculate the immediate value based on the instruction type.\n    The main module combines outputs from submodules to provide complete decoded information of the instruction.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder(\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7,\n    output [31:0] imm\n);\n\n    // Instantiate submodules\n    opcode_decoder op_dec(.instruction(instruction), .opcode(opcode));\n    register_decoder reg_dec(.instruction(instruction), .rd(rd), .rs1(rs1), .rs2(rs2));\n    function_decoder func_dec(.instruction(instruction), .funct3(funct3), .funct7(funct7));\n    immediate_decoder imm_dec(.instruction(instruction), .imm(imm));\n\nendmodule\n\nmodule opcode_decoder(\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\nmodule register_decoder(\n    input [31:0] instruction,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\nendmodule\n\nmodule function_decoder(\n    input [31:0] instruction,\n    output [2:0] funct3,\n    output [6:0] funct7\n);\n    assign funct3 = instruction[14:12];\n    assign funct7 = instruction[31:25];\nendmodule\n\nmodule immediate_decoder(\n    input [31:0] instruction,\n    output reg [31:0] imm\n);\n    always @(*) begin\n        // Type I immediate\n        imm = {{20{instruction[31]}}, instruction[31:20]};\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2], [3, 4, 5, 6, 7, 8]]\n, A RISC-V decode module that separates an incoming 32-bit instruction into opcode, rd, funct3, rs1, rs2, and immediate fields based on the instruction format. The module handles R, I, S, and B-type formats.\n\nModule name:\n    instr_decode\n\nInput ports:\n    clk: Clock signal.\n    rst: Active low reset signal.\n    instruction [31:0]: 32-bit input instruction from instruction memory.\n\nOutput ports:\n    opcode [6:0]: Opcode of the instruction.\n    rd [4:0]: Destination register.\n    funct3 [2:0]: Function3 field.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    imm [31:0]: Immediate value field.\n\nImplementation:\n    The decode module reads the opcode field to determine the type of the instruction and then uses that information to correctly extract the other fields. The immediate field extraction varies significantly between formats; therefore, separate logic is used for each.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decode (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output reg [31:0] imm\n);\n\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            imm <= 32'd0;\n        end else begin\n            case (opcode)\n                7'b0110011: imm <= 32'd0; // R-type\n                7'b0010011,  // I-type\n                7'b0000011: imm <= {{20{instruction[31]}}, instruction[31:20]};\n                7'b0100011: imm <= {{20{instruction[31]}}, instruction[31:25], instruction[11:7]}; // S-type\n                7'b1100011: imm <= {{20{instruction[31]}}, instruction[7], instruction[30:25], instruction[11:8], 1'b0}; // B-type\n                default: imm <= 32'd0;\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'current_pc', 'type': 'input port'}, {'id': 4, 'content': 'offset', 'type': 'input port'}, {'id': 5, 'content': 'base', 'type': 'input port'}, {'id': 6, 'content': 'next_pc', 'type': 'output port'}, {'id': 7, 'content': 'link_addr', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[5, 4, 3], [6, 6, 7]]\n, A RISC-V jump and link register module that captures the next program counter (PC) and the address to jump to based on the input instruction. The module also provides a link register functionality by saving the return address into a specified register.\n\nModule name:\n    jalr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the registers.\n    enable: Enable signal to update the PC and link address.\n    current_pc [31:0]: The current program counter.\n    offset [11:0]: 12-bit signed offset to calculate the jump target.\n    base [31:0]: Base address from which the offset will be applied to calculate the jump target.\n\nOutput ports:\n    next_pc [31:0]: The new program counter after applying the base address and offset.\n    link_addr [31:0]: The link address where the return address will be stored.\n\nImplementation:\n    The jalr_reg module uses signed extension and addition to compute the jump target address. On the rising edge of the clock, if enable is high, the next_pc is computed as (base + offset) & ~1. The link address is set to current_pc + 4, aligning with typical RISC-V calling conventions.\nGive me the complete code."}, {"from": "gpt", "value": "module jalr_reg (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] current_pc,\n    input [11:0] offset,\n    input [31:0] base,\n    output reg [31:0] next_pc,\n    output reg [31:0] link_addr\n);\n\n    wire [31:0] sign_extended_offset;\n    \n    // Sign extension of 12-bit offset to 32-bit\n    assign sign_extended_offset = {{20{offset[11]}}, offset};\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            next_pc <= 32'd0;\n            link_addr <= 32'd0;\n        end else if (enable) begin\n            next_pc <= (base + sign_extended_offset) & 32'hFFFFFFFE;\n            link_addr <= current_pc + 4;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'pc', 'type': 'input port'}, {'id': 2, 'content': 'offset', 'type': 'input port'}, {'id': 3, 'content': 'branch_decision', 'type': 'input port'}, {'id': 4, 'content': 'next_pc', 'type': 'output port'}, {'id': 5, 'content': 'jump_calc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 1, 5], [5, 5, 4, 4]]\n, Design a Verilog module for a RISC-V type branch address calculator intended for computing jump addresses in a pipelined CPU architecture. The module should receive the current program counter (PC), an offset for jumps, and a branch decision signal to decide whether to take the jump or not.\n\nModule name:\n    branch_addr_calc\n\nInput ports:\n    clk: Clock input to synchronize operations.\n    pc [31:0]: Current program counter value.\n    offset [31:0]: Signed offset to compute the next address when a jump is taken.\n    branch_decision: Signal to decide whether to take the branch (1) or continue linearly (0).\n\nOutput ports:\n    next_pc [31:0]: Computed next program counter address.\n\nImplementation:\n    The branch address calculator uses one submodule to calculate the possible jump address. The main module decides based on the branch decision input whether to pass the jump address or the incremented PC as the next program counter value.\n    If the branch decision is high, the submodule output (potential jump address) is selected.\n    If the branch decision is low, the PC incremented by 4 (next sequential instruction) is selected.\n    The submodule takes the current PC and the offset, adds them, and provides this potential jump address.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_addr_calc (\n    input clk,\n    input [31:0] pc,\n    input [31:0] offset,\n    input branch_decision,\n    output reg [31:0] next_pc\n);\n\n    // Submodule to calculate potential jump address\n    wire [31:0] jump_address;\n\n    adder jump_calc (\n        .pc(pc),\n        .offset(offset),\n        .result(jump_address)\n    );\n\n    always @(posedge clk) begin\n        if (branch_decision) begin\n            next_pc <= jump_address;  // Take the jump\n        end else begin\n            next_pc <= pc + 32'd4;  // Next sequential instruction\n        end\n    end\n\nendmodule\n\n// Submodule for adding PC and offset\nmodule adder (\n    input [31:0] pc,\n    input [31:0] offset,\n    output [31:0] result\n);\n\n    assign result = pc + offset;  // Simply add PC and offset\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'is_R_type', 'type': 'output port'}, {'id': 4, 'content': 'is_I_type', 'type': 'output port'}, {'id': 5, 'content': 'is_S_type', 'type': 'output port'}, {'id': 6, 'content': 'is_B_type', 'type': 'output port'}, {'id': 7, 'content': 'is_U_type', 'type': 'output port'}, {'id': 8, 'content': 'is_J_type', 'type': 'output port'}, {'id': 9, 'content': 'r_type_decoder', 'type': 'submodule'}, {'id': 10, 'content': 'i_type_decoder', 'type': 'submodule'}, {'id': 11, 'content': 's_type_decoder', 'type': 'submodule'}, {'id': 12, 'content': 'b_type_decoder', 'type': 'submodule'}, {'id': 13, 'content': 'u_type_decoder', 'type': 'submodule'}, {'id': 14, 'content': 'j_type_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2, 9, 10, 11, 12, 13, 14], [9, 10, 11, 12, 13, 14, 3, 4, 5, 6, 7, 8]]\n, An instruction register module called \"opcode_decoder\" designed to decode the opcode from a given 32-bit instruction and categorize it as R-type, I-type, S-type, B-type, U-type, or J-type based on RISC-V architecture specifics. It uses submodule decoders to handle each instruction type detection.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active low.\n    instruction [31:0]: 32-bit instruction input from which the opcode will be decoded.\n\nOutput ports:\n    is_R_type: Output signal indicating if the instruction is R-type.\n    is_I_type: Output signal indicating if the instruction is I-type.\n    is_S_type: Output signal indicating if the instruction is S-type.\n    is_B_type: Output signal indicating if the instruction is B-type.\n    is_U_type: Output signal indicating if the instruction is U-type.\n    is_J_type: Output signal indicating if the instruction is J-type.\n\nImplementation:\n    The opcode_decoder module will instantiate several submodules, each designed to detect a specific type of instruction based on the opcode field. The detection is carried out by comparing opcode bits extracted from the 32-bit instruction.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output is_R_type,\n    output is_I_type,\n    output is_S_type,\n    output is_B_type,\n    output is_U_type,\n    output is_J_type\n);\n\n    wire [6:0] opcode;\n    assign opcode = instruction[6:0];\n\n    type_decoder r_type_decoder (\n        .opcode(opcode),\n        .is_type(is_R_type),\n        .type_code(7'b0110011)\n    );\n\n    type_decoder i_type_decoder (\n        .opcode(opcode),\n        .is_type(is_I_type),\n        .type_code(7'b0010011)\n    );\n\n    type_decoder s_type_decoder (\n        .opcode(opcode),\n        .is_type(is_S_type),\n        .type_code(7'b0100011)\n    );\n\n    type_decoder b_type_decoder (\n        .opcode(opcode),\n        .is_type(is_B_type),\n        .type_code(7'b1100011)\n    );\n\n    type_decoder u_type_decoder (\n        .opcode(opcode),\n        .is_type(is_U_type),\n        .type_code(7'b0110111)\n    );\n\n    type_decoder j_type_decoder (\n        .opcode(opcode),\n        .is_type(is_J_type),\n        .type_code(7'b1101111)\n    );\n\nendmodule\n\nmodule type_decoder (\n    input [6:0] opcode,\n    output reg is_type,\n    input [6:0] type_code\n);\n\n    always @* begin\n        if(opcode == type_code) \n            is_type = 1;\n        else\n            is_type = 0;\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'func3', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}, {'id': 9, 'content': 'fetch', 'type': 'submodule'}, {'id': 10, 'content': 'decode', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 9, 0, 10, 10, 10, 10, 10, 10], [9, 10, 10, 10, 3, 4, 5, 6, 7, 8]]\n, Design an enhanced RISC-V instruction decoding module that fetches and decodes instructions into multiple functional units based on the type of operation (ALU, Memory, Control). It facilitates the separation of instruction into several components like opcode, function code, and immediate value.\n\nModule name:\n    enhanced_instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal to clear and initialize the register.\n    instruction [31:0]: 32-bit instruction input fetched from instruction memory.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode for operation type identification.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    rd [4:0]: Destination register.\n    func3 [2:0]: 3-bit function code for further classification of the instruction.\n    imm [11:0]: Immediate value for certain instructions like loads, stores, and immediate operations.\n\nImplementation:\n    The decoder is composed of two submodules: fetch_unit for extracting fields from the instruction, and decode_unit for classifying the instruction into its respective unit (ALU, Memory, Control) based on the opcode and function codes.\n    The module works on the rising edge of the clock (clk). If the reset (rst_n) is active, all outputs are set to their initial states.\n    Extracted fields from the fetch_unit are passed to the decode_unit which assigns outputs based on specific opcodes and function codes to direct instruction to the correct functional unit.\nGive me the complete code."}, {"from": "gpt", "value": "module enhanced_instr_decoder (\n    input clk,\n    input rst_n,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [11:0] imm\n);\n\n    // Intermediate wires\n    wire [6:0] opcode_wire;\n    wire [4:0] rs1_wire, rs2_wire, rd_wire;\n    wire [2:0] func3_wire;\n    wire [11:0] imm_wire;\n\n    // Fetch unit submodule\n    fetch_unit fetch (\n        .instruction(instruction),\n        .opcode(opcode_wire),\n        .rs1(rs1_wire),\n        .rs2(rs2_wire),\n        .rd(rd_wire),\n        .func3(func3_wire),\n        .imm(imm_wire)\n    );\n\n    // Decode unit submodule\n    decode_unit decode (\n        .clk(clk),\n        .rst_n(rst_n),\n        .opcode(opcode_wire),\n        .func3(func3_wire),\n        .opcode_out(opcode),\n        .rs1_out(rs1),\n        .rs2_out(rs2),\n        .rd_out(rd),\n        .func3_out(func3),\n        .imm_out(imm)\n    );\n\nendmodule\n\nmodule fetch_unit (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [11:0] imm\n);\n\n    assign opcode = instruction[6:0];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign rd = instruction[11:7];\n    assign func3 = instruction[14:12];\n    assign imm = instruction[31:20]; // For I-type instructions\n\nendmodule\n\nmodule decode_unit (\n    input clk,\n    input rst_n,\n    input [6:0] opcode,\n    input [2:0] func3,\n    output reg [6:0] opcode_out,\n    output reg [4:0] rs1_out,\n    output reg [4:0] rs2_out,\n    output reg [4:0] rd_out,\n    output reg [2:0] func3_out,\n    output reg [11:0] imm_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            {opcode_out, rs1_out, rs2_out, rd_out, func3_out, imm_out} <= 0;\n        end else begin\n            opcode_out <= opcode;\n            func3_out <= func3;\n            rs1_out <= rs1_out;\n            rs2_out <= rs2_out;\n            rd_out <= rd_out;\n            imm_out <= imm_out;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'instruction', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'shifted_imm', 'type': 'output port'}, {'id': 7, 'content': 'decoder1', 'type': 'submodule'}, {'id': 8, 'content': 'decoder2', 'type': 'submodule'}, {'id': 9, 'content': 'shifter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 3, 7, 3, 7, 8, 9], [7, 8, 9, 9, 4, 5, 6]]\n, Design a Verilog module named `shifted_instruction_register` that acts as an instruction decoder and output modifier for RISC-V instructions, capable of handling different operation types and providing modified outputs. The module must decompose the input instruction into opcode, funct3, and immediate value parts, then shift the immediate value based on the opcode for specific operation types.\n\nModule name:\n    shifted_instruction_register\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal to clear the outputs.\n    enable: Enable signal to process the instruction.\n    instruction [31:0]: 32-bit input instruction.\n\nOutput ports:\n    opcode [6:0]: Extracted 7-bit opcode.\n    funct3 [2:0]: Extracted 3-bit function code.\n    shifted_imm [31:0]: Shifted immediate value, the shift amount is determined by the opcode.\n\nImplementation:\n    The module leverages three submodules: opcode_decoder, funct3_decoder, and imm_shifter. Each submodule is specialized:\n    - `opcode_decoder` extracts the opcode from the instruction.\n    - `funct3_decoder` extracts the funct3 value.\n    - `imm_shifter` calculates the shifted immediate value, where the shift amount is opcode-dependent. If the opcode corresponds to an arithmetic operation, the immediate value is shifted left by 1; otherwise, it's taken as is.\nGive me the complete code."}, {"from": "gpt", "value": "module shifted_instruction_register (\n    input clk,\n    input rst_n,\n    input enable,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [31:0] shifted_imm\n);\n\n    // Submodule instances\n    wire [6:0] opcode_out;\n    wire [2:0] funct3_out;\n    wire [31:0] imm_out;\n\n    opcode_decoder decoder1 (\n        .instruction(instruction),\n        .opcode(opcode_out)\n    );\n\n    funct3_decoder decoder2 (\n        .instruction(instruction),\n        .funct3(funct3_out)\n    );\n\n    imm_shifter shifter (\n        .opcode(opcode_out),\n        .instruction(instruction),\n        .shifted_imm(imm_out)\n    );\n\n    // Output assignments\n    assign opcode = opcode_out;\n    assign funct3 = funct3_out;\n    assign shifted_imm = imm_out;\n\nendmodule\n\nmodule opcode_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\nmodule funct3_decoder (\n    input [31:0] instruction,\n    output [2:0] funct3\n);\n    assign funct3 = instruction[14:12];\nendmodule\n\nmodule imm_shifter (\n    input [6:0] opcode,\n    input [31:0] instruction,\n    output reg [31:0] shifted_imm\n);\n    always @(*) begin\n        // Example logic for shifting\n        if (opcode == 7'b0110011) // Example opcode for arithmetic operations\n            shifted_imm = instruction[31:20] << 1;\n        else\n            shifted_imm = instruction[31:20];\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'pc_in', 'type': 'input port'}, {'id': 3, 'content': 'jump', 'type': 'input port'}, {'id': 4, 'content': 'pc_out', 'type': 'output port'}, {'id': 5, 'content': 'pc_logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 3, 2, 0, 5], [5, 5, 5, 5, 4]]\n, Design a RISC-V Program Counter (PC) module that manages the sequence of instruction execution. The module should be capable of basic operations such as reset, update, and conditional jumps based on signal inputs, utilizing hierarchical design principles.\n\nModule name:\n    pc_module\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the program counter to zero.\n    pc_in [31:0]: 32-bit input for the next program counter value.\n    jump [1:0]: 2-bit control signal (00 for normal increment, 01 for jump to pc_in, 10 to hold the current value).\n    \nOutput ports:\n    pc_out [31:0]: 32-bit output of the current program counter value.\n\nImplementation:\n    This module should include a submodule for handling the program counter logic.\n    On reset (rst), the PC is set to zero.\n    Based on the jump input:\n    - 00: PC is incremented by 4 (standard next instruction in sequence).\n    - 01: PC is set to pc_in (jump to a new instruction address).\n    - 10: PC retains its current value (used in stalls or conditional jumps).\n    The submodule processes the actual update or hold operation.\nGive me the complete code."}, {"from": "gpt", "value": "module pc_module (\n    input clk,\n    input rst,\n    input [31:0] pc_in,\n    input [1:0] jump,\n    output [31:0] pc_out\n);\n\n    // Submodule for program counter logic\n    wire [31:0] pc_logic_out;\n\n    pc_logic pc_logic_inst (\n        .clk(clk),\n        .rst(rst),\n        .pc_in(pc_in),\n        .jump(jump),\n        .pc_out(pc_logic_out)\n    );\n\n    // Output assignment\n    assign pc_out = pc_logic_out;\n\nendmodule\n\n// Submodule for handling the PC logic based on the control input\nmodule pc_logic (\n    input clk,\n    input rst,\n    input [31:0] pc_in,\n    input [1:0] jump,\n    output reg [31:0] pc_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            pc_out <= 32'd0; // Reset PC to zero\n        end else begin\n            case (jump)\n                2'b00: pc_out <= pc_out + 32'd4; // Increment PC\n                2'b01: pc_out <= pc_in;          // Jump to pc_in\n                2'b10: ;                         // Hold PC (no change)\n                default: pc_out <= pc_out;       // Retain current value in all other cases\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'rs1', 'type': 'output port'}, {'id': 3, 'content': 'rs2', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'funct7', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 0, 0], [1, 2, 3, 4, 5, 6]]\n, Design an instruction decoder module for a RISC-V based system that decodes a 32-bit instruction into its constituent parts such as opcode, function codes, and registers. The module should decode instructions for arithmetic operations (like add, sub) and logical operations (like and, or) depending on the instruction type.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    instr [31:0]: 32-bit instruction input from the instruction memory.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode extracted from the instruction.\n    rs1 [4:0]: 5-bit source register 1.\n    rs2 [4:0]: 5-bit source register 2.\n    rd [4:0]: 5-bit destination register.\n    funct3 [2:0]: 3-bit function code part of the instruction.\n    funct7 [6:0]: 7-bit function code part of the instruction.\n\nImplementation:\n    The instruction decoder is implemented directly within a single module. Based on the position of the bits in the standard RISC-V instruction format:\n    - opcode is extracted from bits [6:0]\n    - rs1 from bits [19:15]\n    - rs2 from bits [24:20]\n    - rd from bits [11:7]\n    - funct3 from bits [14:12]\n    - funct7 from bits [31:25]\n    This straightforward extraction based on bit slicing makes the module efficient and easy to incorporate into larger designs.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [6:0] funct7\n);\n\n    assign opcode = instr[6:0];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign rd = instr[11:7];\n    assign funct3 = instr[14:12];\n    assign funct7 = instr[31:25];\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'alu_op', 'type': 'output port'}, {'id': 4, 'content': 'reg_write', 'type': 'output port'}, {'id': 5, 'content': 'mem_read', 'type': 'output port'}, {'id': 6, 'content': 'mem_write', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 7, 7, 7, 7], [7, 3, 4, 5, 6]]\n, Design a Verilog module named `control_unit` which acts as a control unit for a simple RISC-V based CPU. This module should decode a 5-bit opcode and generate appropriate control signals for the ALU, the register file, and memory access operations.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal.\n    rst: Active low reset signal.\n    opcode [4:0]: The 5-bit opcode part of an instruction.\n\nOutput ports:\n    alu_op [3:0]: Control signals to the ALU specifying the operation to be performed.\n    reg_write: Signal to enable writing to the register file.\n    mem_read: Signal to enable reading from memory.\n    mem_write: Signal to enable writing to memory.\n\nImplementation:\n    The `control_unit` module uses a sub-module called `opcode_decoder` which takes the opcode and decodes it into signals for the ALU, memory, and register file operations.\n    On the rising edge of the clk, if rst is low, all outputs are reset to zero.\n    The outputs are otherwise controlled by the decoded signals from the `opcode_decoder` submodule based on the current opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [4:0] opcode,\n    output [3:0] alu_op,\n    output reg_write,\n    output mem_read,\n    output mem_write\n);\n\n    wire [3:0] alu_decoded;\n    wire reg_wr_decoded, mem_rd_decoded, mem_wr_decoded;\n\n    opcode_decoder decoder (\n        .opcode(opcode),\n        .alu_op(alu_decoded),\n        .reg_write(reg_wr_decoded),\n        .mem_read(mem_rd_decoded),\n        .mem_write(mem_wr_decoded)\n    );\n\n    assign alu_op = alu_decoded;\n    assign reg_write = reg_wr_decoded;\n    assign mem_read = mem_rd_decoded;\n    assign mem_write = mem_wr_decoded;\n\nendmodule\n\nmodule opcode_decoder (\n    input [4:0] opcode,\n    output reg [3:0] alu_op,\n    output reg reg_write,\n    output reg mem_read,\n    output reg mem_write\n);\n\n    always @(*) begin\n        case (opcode)\n            5'b00000: begin // Example opcode for ADD\n                alu_op = 4'b0010;\n                reg_write = 1'b1;\n                mem_read = 1'b0;\n                mem_write = 1'b0;\n            end\n            5'b00001: begin // Example opcode for SUB\n                alu_op = 4'b0110;\n                reg_write = 1'b1;\n                mem_read = 1'b0;\n                mem_write = 1'b0;\n            end\n            // Add more opcodes as required\n            default: begin\n                alu_op = 4'b0000;\n                reg_write = 1'b0;\n                mem_read = 1'b0;\n                mem_write = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'op_type', 'type': 'output port'}, {'id': 2, 'content': 'write_back', 'type': 'output port'}, {'id': 3, 'content': 'imm_flag', 'type': 'output port'}, {'id': 4, 'content': 'branch_flag', 'type': 'output port'}, {'id': 5, 'content': 'mem_access', 'type': 'output port'}, {'id': 6, 'content': 'decoder', 'type': 'submodule'}, {'id': 7, 'content': 'controller', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 6, 7, 7, 7, 7, 7], [6, 7, 1, 2, 3, 4, 5]]\n, Design a Verilog module named \"opcode_decoder\" that decodes RISC-V instructions into control signals for the processor. The module should take a 32-bit instruction input and output various control signals indicating the type of operation (arithmetic, logical, memory access, etc.), the need for register write-back, and additional signals specific to RISC-V operations.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    instruction [31:0]: Full 32-bit instruction fetched from memory.\n\nOutput ports:\n    op_type [2:0]: Indicates operation type (arithmetic, logical, etc.).\n    write_back: Flag that indicates if the result needs to be written back to a register.\n    imm_flag: Flag to indicate the presence of an immediate value in the instruction.\n    branch_flag: Flag for indicating branch operations.\n    mem_access: Flag for memory access instructions.\n\nImplementation:\n    The opcode_decoder uses a submodule named \"decode_logic\" to perform the decoding based on the opcode field of the instruction. It uses another submodule \"control_signals\" to convert decoded outputs to control signals used by the rest of the CPU. The module operates purely combinational.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [31:0] instruction,\n    output [2:0] op_type,\n    output write_back,\n    output imm_flag,\n    output branch_flag,\n    output mem_access\n);\n\n    // Wire for internal connections\n    wire [6:0] opcode;\n    wire [4:0] decoded_signals;\n\n    assign opcode = instruction[6:0];\n\n    // Submodule for decoding the opcode into signals\n    decode_logic decoder (\n        .opcode(opcode),\n        .decoded_out(decoded_signals)\n    );\n\n    // Submodule for generating control signals from decoded signals\n    control_signals controller (\n        .decoded_in(decoded_signals),\n        .op_type(op_type),\n        .write_back(write_back),\n        .imm_flag(imm_flag),\n        .branch_flag(branch_flag),\n        .mem_access(mem_access)\n    );\n\nendmodule\n\n// Submodule for decoding the opcode\nmodule decode_logic (\n    input [6:0] opcode,\n    output reg [4:0] decoded_out\n);\n\n    always @(*) begin\n        case(opcode)\n            7'b0110011: decoded_out = 5'b10010; // R-type\n            7'b0010011: decoded_out = 5'b11000; // I-type\n            7'b0000011: decoded_out = 5'b01101; // Load\n            7'b1100011: decoded_out = 5'b00011; // Branch\n            default:    decoded_out = 5'b00000;\n        endcase\n    end\n\nendmodule\n\n// Submodule for generating control signals from decoded signals\nmodule control_signals (\n    input [4:0] decoded_in,\n    output reg [2:0] op_type,\n    output reg write_back,\n    output reg imm_flag,\n    output reg branch_flag,\n    output reg mem_access\n);\n\n    always @(*) begin\n        op_type = decoded_in[4:2];\n        write_back = decoded_in[1];\n        imm_flag = decoded_in[2];\n        branch_flag = decoded_in[1];\n        mem_access = decoded_in[0];\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'pc', 'type': 'input port'}, {'id': 1, 'content': 'offset', 'type': 'input port'}, {'id': 2, 'content': 'branch_taken', 'type': 'input port'}, {'id': 3, 'content': 'branch_target', 'type': 'output port'}, {'id': 4, 'content': 'extender', 'type': 'submodule'}, {'id': 5, 'content': 'adder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 5, 2], [4, 5, 5, 3, 3, 3]]\n, Design a Verilog module for a RISC-V Branch Target Address Calculator. The module computes the target address for branch instructions based on the current program counter (PC), a signed offset, and a branch taken signal. This module will use a submodule for sign extension of the offset and another for the addition operation.\n\nModule name:\n    branch_target_calc\n\nInput ports:\n    pc [31:0]: Current program counter address.\n    offset [11:0]: 12-bit immediate offset, which is used to compute the branch target.\n    branch_taken: Signal indicating whether the branch is taken or not.\n\nOutput ports:\n    branch_target [31:0]: Computed branch target address.\n\nImplementation:\n    The module uses two submodules:\n    - A sign extender that converts the 12-bit offset into a 32-bit signed value.\n    - An adder that adds the sign-extended offset to the current PC if the branch is taken.\n    The output (branch_target) holds the value of the current PC if the branch is not taken, otherwise it computes the new target address.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_target_calc(\n    input [31:0] pc,\n    input [11:0] offset,\n    input branch_taken,\n    output [31:0] branch_target\n);\n\n    // Wires for submodule outputs\n    wire [31:0] offset_extended;\n    wire [31:0] target_computed;\n\n    // Instantiate sign extension submodule\n    sign_extend_12_to_32 extender (\n        .offset(offset),\n        .offset_extended(offset_extended)\n    );\n\n    // Instantiate addition submodule\n    adder_32bit adder (\n        .a(pc),\n        .b(offset_extended),\n        .sum(target_computed)\n    );\n\n    // Compute branch target address based on branch_taken signal\n    assign branch_target = branch_taken ? target_computed : pc;\n\nendmodule\n\n// Submodule for sign extension from 12 to 32 bits\nmodule sign_extend_12_to_32(\n    input [11:0] offset,\n    output [31:0] offset_extended\n);\n\n    assign offset_extended = {{20{offset[11]}}, offset};\n\nendmodule\n\n// Submodule for 32-bit addition\nmodule adder_32bit(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n\n    assign sum = a + b;\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'inst', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'funct3', 'type': 'output port'}, {'id': 3, 'content': 'funct7', 'type': 'output port'}, {'id': 4, 'content': 'inst_type', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0], [1, 2, 3]]\n, Design a RISC-V opcode decoder module that extracts and decodes the opcode, funct3, and funct7 fields from a given 32-bit instruction input. This module should categorize the instruction type (R-type, I-type, S-type, B-type, U-type, J-type) based on the opcode and provide appropriate signal outputs for further usage in a CPU design.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    inst [31:0]: 32-bit instruction input.\n\nOutput ports:\n    opcode [6:0]: Extracted opcode.\n    funct3 [2:0]: Extracted funct3 field.\n    funct7 [6:0]: Extracted funct7 field.\n    inst_type [5:0]: Instruction type signal indicating R, I, S, B, U, or J-type.\n\nImplementation:\n    This module uses combinational logic to decode the instruction fields. The inst_type output is derived by decoding the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output reg [5:0] inst_type\n);\n\n    assign opcode = inst[6:0];\n    assign funct3 = inst[14:12];\n    assign funct7 = inst[31:25];\n\n    always @(*) begin\n        case(opcode)\n            7'b0110011: inst_type = 6'b000001; // R-type\n            7'b0010011: inst_type = 6'b000010; // I-type\n            7'b0000011: inst_type = 6'b000010; // I-type (Load)\n            7'b0100011: inst_type = 6'b000100; // S-type\n            7'b1100011: inst_type = 6'b001000; // B-type\n            7'b0110111: inst_type = 6'b010000; // U-type (LUI)\n            7'b0010111: inst_type = 6'b010000; // U-type (AUIPC)\n            7'b1101111: inst_type = 6'b100000; // J-type\n            default: inst_type = 6'b000000; // Unknown type\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr', 'type': 'input port'}, {'id': 3, 'content': 'flags', 'type': 'input port'}, {'id': 4, 'content': 'branch', 'type': 'output port'}, {'id': 5, 'content': 'fe', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 5], [5, 5, 4]]\n, Design a Verilog module named `cond_decoder` for a RISC-V instruction set, which decodes conditional branching instructions and outputs a signal to indicate whether to branch or not based on conditions given in the instruction. The instruction bits are divided into condition codes and compared to internal flags to decide the branching.\n\nModule name:\n    cond_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    instr [15:0]: 16-bit input representing the conditional instruction.\n    flags [3:0]: 4-bit input representing current status flags (e.g., Z-zero flag, L-less than, G-greater than, E-equal).\n\nOutput ports:\n    branch: Output signal that indicates whether to branch (1) or not (0) based on the decoded instruction and flags.\n\nImplementation:\n    The `cond_decoder` utilizes a submodule named `flag_evaluator` that evaluates the flags based on the condition codes from the instruction. If the evaluation matches the branch condition, the branch output is set high.\nGive me the complete code."}, {"from": "gpt", "value": "module cond_decoder (\n    input clk,\n    input rst,\n    input [15:0] instr,\n    input [3:0] flags,\n    output reg branch\n);\n\n    wire should_branch;\n\n    flag_evaluator fe (\n        .condition_code(instr[15:12]), // top 4 bits for condition code\n        .flags(flags),\n        .result(should_branch)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            branch <= 1'b0;\n        end else begin\n            branch <= should_branch;\n        end\n    end\n\nendmodule\n\nmodule flag_evaluator (\n    input [3:0] condition_code,\n    input [3:0] flags,\n    output reg result\n);\n\n    always @(*) begin\n        case (condition_code)\n            4'b0001: result = flags[0]; // Z flag\n            4'b0010: result = flags[1]; // L flag\n            4'b0100: result = flags[2]; // G flag\n            4'b1000: result = flags[3]; // E flag\n            default: result = 1'b0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'input port'}, {'id': 2, 'content': 'immediate', 'type': 'output port'}, {'id': 3, 'content': 'i_type_extract', 'type': 'submodule'}, {'id': 4, 'content': 's_type_extract', 'type': 'submodule'}, {'id': 5, 'content': 'b_type_extract', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 4, 1, 5, 3], [3, 4, 5, 2, 2, 2, 2]]\n, Design a RISC-V Immediate Generation Module that extracts immediate values from different RISC-V instruction formats (I-Type, S-Type, and B-Type). The module should receive the instruction as input and output the appropriate immediate value, depending on the instruction type determined by the opcode. \n\nModule name:\n    imm_gen\n\nInput ports:\n    instr [31:0]: 32-bit input instruction from which the immediate value will be extracted.\n    opcode [6:0]: Opcode to determine the instruction format.\n\nOutput ports:\n    immediate [31:0]: The 32-bit immediate value extracted and sign-extended from the input instruction.\n\nImplementation:\n    The immediate generation module uses a submodule for each instruction type to extract and sign-extend the immediate value.\n    The top module decodes the opcode and directs the instruction to the appropriate submodule.\n    The immediate output depends on the submodule that processes the instruction based on the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module imm_gen (\n    input [31:0] instr,\n    input [6:0] opcode,\n    output [31:0] immediate\n);\n\n    // Wires for submodule outputs\n    wire [31:0] imm_i_type, imm_s_type, imm_b_type;\n\n    // Submodules for each instruction type\n    i_type_imm_extractor i_type_extract (\n        .instr(instr),\n        .imm_out(imm_i_type)\n    );\n\n    s_type_imm_extractor s_type_extract (\n        .instr(instr),\n        .imm_out(imm_s_type)\n    );\n\n    b_type_imm_extractor b_type_extract (\n        .instr(instr),\n        .imm_out(imm_b_type)\n    );\n\n    // Immediate output selection based on opcode\n    assign immediate = (opcode == 7'b0010011) ? imm_i_type :   // Opcode for I-Type\n                       (opcode == 7'b0100011) ? imm_s_type :   // Opcode for S-Type\n                       (opcode == 7'b1100011) ? imm_b_type :   // Opcode for B-Type\n                       32'b0;                                   // Default case\n\nendmodule\n\n// I-Type immediate extractor submodule\nmodule i_type_imm_extractor (\n    input [31:0] instr,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{instr[31]}}, instr[31:20]}; // Sign-extend the immediate\nendmodule\n\n// S-Type immediate extractor submodule\nmodule s_type_imm_extractor (\n    input [31:0] instr,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{instr[31]}}, instr[31:25], instr[11:7]}; // Sign-extend the immediate\nendmodule\n\n// B-Type immediate extractor submodule\nmodule b_type_imm_extractor (\n    input [31:0] instr,\n    output [31:0] imm_out\n);\n    assign imm_out = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0}; // Sign-extend the immediate\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'is_arithmetic', 'type': 'output port'}, {'id': 2, 'content': 'is_load', 'type': 'output port'}, {'id': 3, 'content': 'is_store', 'type': 'output port'}, {'id': 4, 'content': 'is_branch', 'type': 'output port'}, {'id': 5, 'content': 'extractor', 'type': 'submodule'}, {'id': 6, 'content': 'setter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 5, 6, 6, 6, 6], [5, 6, 1, 2, 3, 4]]\n, Design a RISC-V instruction decoder module that decodes the instruction type and generates control signals accordingly. The module receives a full 32-bit instruction and outputs specific control signals for arithmetic, load, store, and branch operations.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    instr [31:0]: 32-bit input representing the full RISC-V instruction.\n\nOutput ports:\n    is_arithmetic: Signal indicating if the instruction is an arithmetic operation.\n    is_load: Signal indicating if the instruction is a load operation.\n    is_store: Signal indicating if the instruction is a store operation.\n    is_branch: Signal indicating if the instruction is a branch operation.\n\nImplementation:\n    The instruction decoder should analyze the opcode field of the instruction to set the appropriate control signals.\n    Each control signal is derived by comparing the opcode part of the instruction with predefined constants that represent different types of instructions.\n    The module includes a submodule that handles opcode extraction and another that uses this extracted opcode to set the control signals.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input [31:0] instr,\n    output is_arithmetic,\n    output is_load,\n    output is_store,\n    output is_branch\n);\n\n    // Submodule for opcode extraction\n    wire [6:0] opcode;\n    opcode_extractor extractor (\n        .instr(instr),\n        .opcode(opcode)\n    );\n\n    // Submodule for setting control signals\n    control_signals setter (\n        .opcode(opcode),\n        .is_arithmetic(is_arithmetic),\n        .is_load(is_load),\n        .is_store(is_store),\n        .is_branch(is_branch)\n    );\n\nendmodule\n\n// Submodule for opcode extraction\nmodule opcode_extractor (\n    input [31:0] instr,\n    output [6:0] opcode\n);\n\n    assign opcode = instr[6:0];\n\nendmodule\n\n// Submodule for control signals\nmodule control_signals (\n    input [6:0] opcode,\n    output is_arithmetic,\n    output is_load,\n    output is_store,\n    output is_branch\n);\n\n    assign is_arithmetic = (opcode == 7'b0110011);\n    assign is_load = (opcode == 7'b0000011);\n    assign is_store = (opcode == 7'b0100011);\n    assign is_branch = (opcode == 7'b1100011);\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'arithmetic_flag', 'type': 'output port'}, {'id': 4, 'content': 'memory_access_flag', 'type': 'output port'}, {'id': 5, 'content': 'branch_flag', 'type': 'output port'}, {'id': 6, 'content': 'arithmetic_decoder', 'type': 'submodule'}, {'id': 7, 'content': 'memory_decoder', 'type': 'submodule'}, {'id': 8, 'content': 'branch_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 1, 2, 0, 1, 2, 0, 6, 7, 8], [6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 4, 5]]\n, Design a RISC-V control status register module that decodes instruction opcodes to set specific control flags. The module decodes incoming 8-bit opcodes and sets flags for arithmetic operations, memory access, and branching conditions.\n\nModule name:\n    control_status_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    opcode [7:0]: 8-bit opcode representing the CPU instruction.\n\nOutput ports:\n    arithmetic_flag: Flag indicating if the current instruction is an arithmetic operation.\n    memory_access_flag: Flag indicating if the instruction involves memory access.\n    branch_flag: Flag indicating if the instruction is for branching.\n\nImplementation:\n    Each flag is controlled by a submodule that checks the opcode against a predefined set of opcodes for that category. If the opcode matches, the flag is set; otherwise, it is reset.\n    On reset, all flags are cleared.\nGive me the complete code."}, {"from": "gpt", "value": "module control_status_reg (\n    input clk,\n    input rst,\n    input [7:0] opcode,\n    output arithmetic_flag,\n    output memory_access_flag,\n    output branch_flag\n);\n\n    // Submodules to decode opcodes and set flags\n    opcode_decoder arithmetic_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .output_flag(arithmetic_flag),\n        .target_opcodes(8'h00) // Example opcode for arithmetic operations\n    );\n\n    opcode_decoder memory_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .output_flag(memory_access_flag),\n        .target_opcodes(8'h01) // Example opcode for memory access\n    );\n\n    opcode_decoder branch_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .output_flag(branch_flag),\n        .target_opcodes(8'h02) // Example opcode for branching\n    );\n\nendmodule\n\n// Submodule for decoding opcodes\nmodule opcode_decoder (\n    input clk,\n    input rst,\n    input [7:0] opcode,\n    output reg output_flag,\n    input [7:0] target_opcodes\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output_flag <= 1'b0; // Reset flag\n        end else begin\n            output_flag <= (opcode == target_opcodes); // Set flag if opcode matches\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'alu_op', 'type': 'output port'}, {'id': 2, 'content': 'mem_cmd', 'type': 'output port'}, {'id': 3, 'content': 'branch_type', 'type': 'output port'}, {'id': 4, 'content': 'immediate_val', 'type': 'output port'}, {'id': 5, 'content': 'alu_dec', 'type': 'submodule'}, {'id': 6, 'content': 'mem_dec', 'type': 'submodule'}, {'id': 7, 'content': 'branch_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 5, 6, 7, 7], [5, 6, 7, 1, 2, 3, 4]]\n, Design a Verilog module named `opcode_decoder` for a RISC-V CPU. This module receives a 32-bit instruction and decodes it into various control signals essential for the execution stage. The module is hierarchically designed with submodules handling specific parts of the decoding process, such as determining the operation type (ALU, Memory, Control), ALU operation specifics, and branch conditions.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    instruction [31:0]: 32-bit instruction fetched from the instruction memory.\n\nOutput ports:\n    alu_op [3:0]: ALU operation code.\n    mem_cmd [1:0]: Memory command (e.g., Read, Write).\n    branch_type [2:0]: Type of branch instruction.\n    immediate_val [31:0]: Immediate value extracted from the instruction.\n\nImplementation:\n    The `opcode_decoder` module utilizes three submodules: `alu_decoder`, `mem_decoder`, and `branch_decoder`.\n    Each submodule is responsible for interpreting a specific part of the instruction and generating the relevant outputs.\n    `alu_decoder` generates the `alu_op` based on the opcode field.\n    `mem_decoder` produces the `mem_cmd` depending on the instruction type.\n    `branch_decoder` calculates the `branch_type` and `immediate_val` if applicable.\n    The complete instruction is passed to each submodule, and they use parts of it as required by their functionality.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [31:0] instruction,\n    output [3:0] alu_op,\n    output [1:0] mem_cmd,\n    output [2:0] branch_type,\n    output [31:0] immediate_val\n);\n\n    // Instantiate submodules\n    alu_decoder alu_dec(\n        .instruction(instruction),\n        .alu_op(alu_op)\n    );\n\n    mem_decoder mem_dec(\n        .instruction(instruction),\n        .mem_cmd(mem_cmd)\n    );\n\n    branch_decoder branch_dec(\n        .instruction(instruction),\n        .branch_type(branch_type),\n        .immediate_val(immediate_val)\n    );\n\nendmodule\n\n// Submodule for ALU operation decoding\nmodule alu_decoder (\n    input [31:0] instruction,\n    output reg [3:0] alu_op\n);\n\n    always @* begin\n        case (instruction[6:0])\n            7'b0110011: alu_op = 4'b0001; // Example: ADD\n            7'b0010011: alu_op = 4'b0010; // Example: ADDI\n            default: alu_op = 4'b0000; // NOP\n        endcase\n    end\n\nendmodule\n\n// Submodule for memory operation decoding\nmodule mem_decoder (\n    input [31:0] instruction,\n    output reg [1:0] mem_cmd\n);\n\n    always @* begin\n        case (instruction[6:0])\n            7'b0000011: mem_cmd = 2'b01; // Load\n            7'b0100011: mem_cmd = 2'b10; // Store\n            default: mem_cmd = 2'b00; // No memory operation\n        endcase\n    end\n\nendmodule\n\n// Submodule for branch operation decoding\nmodule branch_decoder (\n    input [31:0] instruction,\n    output reg [2:0] branch_type,\n    output reg [31:0] immediate_val\n);\n\n    always @* begin\n        case (instruction[6:0])\n            7'b1100011: begin // Example: BEQ\n                branch_type = 3'b001;\n                immediate_val = {{20{instruction[31]}}, instruction[7], instruction[30:25], instruction[11:8], 1'b0};\n            end\n            default: begin\n                branch_type = 3'b000; // No branch\n                immediate_val = 32'b0;\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'instruction', 'type': 'input port'}, {'id': 2, 'content': 'op_type', 'type': 'output port'}, {'id': 3, 'content': 'specific_op', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'rs1', 'type': 'output port'}, {'id': 6, 'content': 'rs2', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 1, 1], [3, 4, 5, 6, 7]]\n, Design a Verilog module named `opcode_decoder` that decodes 32-bit RISC-V instructions to identify the type of operation (ALU, Memory, Control) and the specific operation within the type. It also extracts important fields such as rd, rs1, rs2, and immediate values.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    instruction [31:0]: 32-bit wide input holding the complete RISC-V instruction.\n\nOutput ports:\n    op_type [2:0]: Operation type (e.g., ALU, Memory, Control).\n    specific_op [4:0]: Specific operation code.\n    rd [4:0]: Destination register.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    imm [11:0]: Immediate value.\n\nImplementation:\n    The opcode decoder separates the instruction into opcode, funct3, and funct7 fields.\n    Based on the opcode, the module sets the op_type and specific_op outputs.\n    The fields for registers (rd, rs1, rs2) and immediate values are also extracted based on the instruction format and type.\n    Use of separate decoding submodules for extracting rd, rs1, rs2, and imm values enhances modularity.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input [31:0] instruction,\n    output reg [2:0] op_type,\n    output reg [4:0] specific_op,\n    output reg [4:0] rd,\n    output reg [4:0] rs1,\n    output reg [4:0] rs2,\n    output reg [11:0] imm\n);\n\n    wire [6:0] opcode;\n    wire [2:0] funct3;\n    wire [6:0] funct7;\n\n    assign opcode = instruction[6:0];\n    assign funct3 = instruction[14:12];\n    assign funct7 = instruction[31:25];\n\n    always @(posedge clk) begin\n        case (opcode)\n            7'b0110011: begin // R-type\n                op_type <= 3'b001; // ALU operation\n                specific_op <= {funct7[5], funct3};\n                rd <= instruction[11:7];\n                rs1 <= instruction[19:15];\n                rs2 <= instruction[24:20];\n            end\n            7'b0010011: begin // I-type (ALU)\n                op_type <= 3'b001; // ALU operation\n                specific_op <= funct3;\n                rd <= instruction[11:7];\n                rs1 <= instruction[19:15];\n                imm <= instruction[31:20];\n            end\n            default: begin\n                op_type <= 3'b000; // Unknown type\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch_type', 'type': 'input port'}, {'id': 3, 'content': 'reg1', 'type': 'input port'}, {'id': 4, 'content': 'reg2', 'type': 'input port'}, {'id': 5, 'content': 'take_branch', 'type': 'output port'}, {'id': 6, 'content': 'comp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 4, 3, 6], [6, 6, 6, 5]]\n, Design a RISC-V branch condition checker module in Verilog that interprets the branch type and compares two provided registers to determine whether a branch should be taken. The module must be able to handle different branch conditions such as equal, not equal, less than, and greater than.\n\nModule name:\n    branch_condition_checker\n\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Active low reset signal.\n    branch_type [2:0]: Control signal specifying the type of branch comparison (000 for BEQ, 001 for BNE, 010 for BLT, 011 for BGT).\n    reg1 [31:0]: First 32-bit register input for comparison.\n    reg2 [31:0]: Second 32-bit register input for comparison.\n\nOutput ports:\n    take_branch: Output signal that indicates whether the branch should be taken (1) or not (0).\n\nImplementation:\n    The branch_condition_checker module instantiates a compare_unit submodule to handle the actual comparison logic based on the specified branch_type.\n    On the rising edge of clk, if rst is low, take_branch is set to 0.\n    The take_branch output is set based on the output of the compare_unit, which updates its result based on the branch_type and the values in reg1 and reg2.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_condition_checker (\n    input clk,\n    input rst,\n    input [2:0] branch_type,\n    input [31:0] reg1,\n    input [31:0] reg2,\n    output take_branch\n);\n\n    wire comparison_result;\n\n    compare_unit comp (\n        .branch_type(branch_type),\n        .reg1(reg1),\n        .reg2(reg2),\n        .result(comparison_result)\n    );\n\n    reg take_branch_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            take_branch_reg <= 0;\n        end else begin\n            take_branch_reg <= comparison_result;\n        end\n    end\n\n    assign take_branch = take_branch_reg;\n\nendmodule\n\nmodule compare_unit (\n    input [2:0] branch_type,\n    input [31:0] reg1,\n    input [31:0] reg2,\n    output reg result\n);\n\n    always @(*) begin\n        case (branch_type)\n            3'b000: result = (reg1 == reg2); // BEQ\n            3'b001: result = (reg1 != reg2); // BNE\n            3'b010: result = ($signed(reg1) < $signed(reg2)); // BLT\n            3'b011: result = ($signed(reg1) > $signed(reg2)); // BGT\n            default: result = 0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'funct3', 'type': 'output port'}, {'id': 5, 'content': 'funct7', 'type': 'output port'}, {'id': 6, 'content': 'imm_value', 'type': 'output port'}, {'id': 7, 'content': 'op_extractor', 'type': 'submodule'}, {'id': 8, 'content': 'funct3_extractor', 'type': 'submodule'}, {'id': 9, 'content': 'funct7_extractor', 'type': 'submodule'}, {'id': 10, 'content': 'imm_extractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 7, 8, 9, 10], [7, 8, 9, 10, 3, 4, 5, 6]]\n, Create a Verilog module named `op_decoder` designed to decode operation types from a 32-bit instruction word input for a simplified RISC-V CPU. The module should extract three crucial fields from the instruction: the operation code (opcode), function codes (funct3 and funct7), and immediate value, using separate submodules for each extraction.\n\nModule name:\n    op_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    instruction [31:0]: 32-bit instruction input.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode extracted from the instruction.\n    funct3 [2:0]: 3-bit function code part of the instruction.\n    funct7 [6:0]: 7-bit function code part of the instruction.\n    imm_value [11:0]: 12-bit immediate value extracted from the instruction for certain types of operations.\n\nImplementation:\n    The `op_decoder` module is implemented with four submodules: one for extracting each field. On the rising edge of the clock, if the reset signal is low, all outputs are initialized to zero. The outputs are updated based on the current 32-bit instruction input.\n    The opcode, funct3, funct7, and imm_value fields are derived directly from the instruction input via separate submodules, ensuring modular design and easy updates for each field.\nGive me the complete code."}, {"from": "gpt", "value": "module op_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [11:0] imm_value\n);\n\n    // Submodules to extract instruction fields\n    field_extractor #(.START(0), .WIDTH(7)) op_extractor (\n        .data(instruction),\n        .field(opcode)\n    );\n\n    field_extractor #(.START(12), .WIDTH(3)) funct3_extractor (\n        .data(instruction),\n        .field(funct3)\n    );\n\n    field_extractor #(.START(25), .WIDTH(7)) funct7_extractor (\n        .data(instruction),\n        .field(funct7)\n    );\n\n    field_extractor #(.START(20), .WIDTH(12)) imm_extractor (\n        .data(instruction),\n        .field(imm_value)\n    );\n\nendmodule\n\n// Submodule for field extraction\nmodule field_extractor #(\n    parameter START = 0,\n    parameter WIDTH = 1\n) (\n    input [31:0] data,\n    output [WIDTH-1:0] field\n);\n\n    assign field = data[START + WIDTH-1:START];\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'instruction', 'type': 'input port'}, {'id': 4, 'content': 'target_addr', 'type': 'output port'}, {'id': 5, 'content': 'link_addr', 'type': 'output port'}, {'id': 6, 'content': 'target_module', 'type': 'submodule'}, {'id': 7, 'content': 'link_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 3, 1, 2, 0, 3, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 4, 5]]\n, Design a Verilog module for a RISC-V jump instruction register that captures and decodes jump target addresses. The module should handle jump and link instructions (JAL), extracting the target address and link address, and update them based on the control signal input.\n\nModule name:\n    jal_register\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal for module reset.\n    enable: Enable signal to update the target and link registers.\n    instruction [31:0]: 32-bit input instruction signal.\n\nOutput ports:\n    target_addr [31:0]: Calculated jump target address.\n    link_addr [31:0]: Link address for return.\n\nImplementation:\n    Two submodules are employed, one to handle the extraction and calculation of the jump target address and another to handle the link address.\n    Upon the rising edge of the clock, if the reset signal is low, both target and link addresses are reset to zero.\n    If the enable signal is high, the module processes the incoming instruction to update the target and link addresses based on the input instruction fields.\nGive me the complete code."}, {"from": "gpt", "value": "module jal_register (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] instruction,\n    output [31:0] target_addr,\n    output [31:0] link_addr\n);\n\n    wire [31:0] target_out, link_out;\n\n    target_calculation target_module (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .instruction(instruction),\n        .target(target_out)\n    );\n\n    link_calculation link_module (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .instruction(instruction),\n        .link(link_out)\n    );\n\n    assign target_addr = target_out;\n    assign link_addr = link_out;\n\nendmodule\n\n// Submodule for target address calculation\nmodule target_calculation (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] instruction,\n    output reg [31:0] target\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            target <= 32'd0;\n        end else if (enable) begin\n            target <= instruction + 32'd4; // Example operation\n        end\n    end\n\nendmodule\n\n// Submodule for link address calculation\nmodule link_calculation (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] instruction,\n    output reg [31:0] link\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            link <= 32'd0;\n        end else if (enable) begin\n            link <= instruction; // Example placeholder\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'zero_flag', 'type': 'input port'}, {'id': 4, 'content': 'negative_flag', 'type': 'input port'}, {'id': 5, 'content': 'take_branch', 'type': 'output port'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'eval', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 6, 4, 7], [6, 7, 7, 7, 5]]\n, Design a RISC-V branch decision module that analyzes a branch instruction and a set of comparison flags to determine if a branch should be taken. The module incorporates submodules for extracting instruction details and evaluating the branch condition.\n\nModule name:\n    branch_decision\n\nInput ports:\n    clk: Clock signal.\n    rst: Active low reset signal.\n    instruction [15:0]: 16-bit branch instruction input.\n    zero_flag: Indicates a zero result from the ALU.\n    negative_flag: Indicates a negative result from the ALU.\n\nOutput ports:\n    take_branch: Signal indicating whether to take the branch based on the instruction and flags.\n\nImplementation:\n    The instruction is split into opcode, branch condition, and unused bits using the instruction_decode submodule.\n    Based on the decoded branch condition and flags, the eval_branch submodule determines if the branch should be taken.\n    The take_branch output is updated on every positive clock edge, subject to the reset condition.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_decision (\n    input clk,\n    input rst,\n    input [15:0] instruction,\n    input zero_flag,\n    input negative_flag,\n    output take_branch\n);\n\n    // Decode signals\n    wire [3:0] opcode;\n    wire [1:0] branch_cond;\n\n    // Submodule for decoding the instruction\n    instruction_decode decode (\n        .instruction(instruction),\n        .opcode(opcode),\n        .branch_cond(branch_cond)\n    );\n\n    // Submodule for evaluating the branch\n    eval_branch eval (\n        .opcode(opcode),\n        .branch_cond(branch_cond),\n        .zero_flag(zero_flag),\n        .negative_flag(negative_flag),\n        .take_branch(take_branch)\n    );\n\nendmodule\n\n// Submodule for decoding instructions\nmodule instruction_decode (\n    input [15:0] instruction,\n    output [3:0] opcode,\n    output [1:0] branch_cond\n);\n\n    assign opcode = instruction[15:12];\n    assign branch_cond = instruction[11:10];\n\nendmodule\n\n// Submodule for evaluating branch conditions\nmodule eval_branch (\n    input [3:0] opcode,\n    input [1:0] branch_cond,\n    input zero_flag,\n    input negative_flag,\n    output reg take_branch\n);\n\n    always @(*) begin\n        case (branch_cond)\n            2'b00: take_branch = zero_flag;        // BEQ\n            2'b01: take_branch = !zero_flag;       // BNE\n            2'b10: take_branch = negative_flag;    // BLT\n            2'b11: take_branch = !negative_flag;   // BGE\n            default: take_branch = 1'b0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'rs1', 'type': 'output port'}, {'id': 6, 'content': 'rs2', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'r_decoder', 'type': 'submodule'}, {'id': 9, 'content': 'i_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 9, 8, 9, 8, 9, 8, 8, 9], [8, 9, 3, 3, 4, 4, 5, 5, 6, 7]]\n, Design a RISC-V instruction decoder module that extracts and decodes various components of an instruction for a simple RISC-V subset. The module should be capable of extracting the opcode, destination register index, source register indices, and immediate values from a standard 32-bit instruction. It should handle both R-type and I-type instructions using separate submodules for decoding.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    instruction [31:0]: 32-bit RISC-V instruction input.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode field.\n    rd [4:0]: 5-bit destination register index.\n    rs1 [4:0]: 5-bit first source register index.\n    rs2 [4:0]: 5-bit second source register index for R-type.\n    imm [11:0]: 12-bit immediate value for I-type instructions.\n\nImplementation:\n    The instruction decoder separates the RISC-V instruction into opcode, rd, rs1, rs2, and immediate fields depending on the type of instruction (R-type or I-type).\n    On the rising edge of the clock (clk), if the reset (rst) is low, all outputs are initialized to zero.\n    Based on the opcode:\n    If opcode indicates an R-type instruction, the respective fields are extracted using an R-type decode submodule.\n    If opcode indicates an I-type instruction, the respective fields are extracted using an I-type decode submodule.\n    These submodules are instantiated within the top module.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [11:0] imm\n);\n\n    wire [6:0] opcode_wire;\n    wire [4:0] rd_wire, rs1_wire, rs2_wire;\n    wire [11:0] imm_wire;\n\n    assign opcode = opcode_wire;\n    assign rd = rd_wire;\n    assign rs1 = rs1_wire;\n    assign rs2 = rs2_wire;\n    assign imm = imm_wire;\n\n    r_type_decoder r_decoder (\n        .instruction(instruction),\n        .opcode(opcode_wire),\n        .rd(rd_wire),\n        .rs1(rs1_wire),\n        .rs2(rs2_wire)\n    );\n\n    i_type_decoder i_decoder (\n        .instruction(instruction),\n        .opcode(opcode_wire),\n        .rd(rd_wire),\n        .rs1(rs1_wire),\n        .imm(imm_wire)\n    );\n\nendmodule\n\nmodule r_type_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\nendmodule\n\nmodule i_type_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [11:0] imm\n);\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign imm = instruction[31:20];\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'funct7', 'type': 'output port'}, {'id': 9, 'content': 'dec_logic', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 9, 9, 9, 9, 9, 9], [9, 3, 4, 5, 6, 7, 8]]\n, Design a RISC-V instruction decoder module named \"instr_decoder\" which separates a 32-bit instruction into its components parts such as opcode, function codes, and register addresses for further processing by other parts of a CPU system.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Active low reset signal to clear outputs.\n    instruction [31:0]: 32-bit input representing the full RISC-V instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode part of the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function 3 bits of the instruction.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address.\n    funct7 [6:0]: Function 7 bits of the instruction.\n\nImplementation:\n    The instruction decoder uses a single submodule to decode and separate the instruction components.\n    The submodule \"decode_logic\" will take a 32-bit instruction and output the decoded fields such as opcode, rd, funct3, rs1, rs2, and funct7.\n    The decoded outputs are registered for synchronization with the CPU clock cycle.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7\n);\n\n    wire [6:0] w_opcode;\n    wire [4:0] w_rd;\n    wire [2:0] w_funct3;\n    wire [4:0] w_rs1;\n    wire [4:0] w_rs2;\n    wire [6:0] w_funct7;\n\n    decode_logic dec_logic (\n        .instruction(instruction),\n        .opcode(w_opcode),\n        .rd(w_rd),\n        .funct3(w_funct3),\n        .rs1(w_rs1),\n        .rs2(w_rs2),\n        .funct7(w_funct7)\n    );\n\n    // Register outputs to sync with clk\n    reg [6:0] r_opcode;\n    reg [4:0] r_rd;\n    reg [2:0] r_funct3;\n    reg [4:0] r_rs1;\n    reg [4:0] r_rs2;\n    reg [6:0] r_funct7;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            r_opcode <= 7'd0;\n            r_rd <= 5'd0;\n            r_funct3 <= 3'd0;\n            r_rs1 <= 5'd0;\n            r_rs2 <= 5'd0;\n            r_funct7 <= 7'd0;\n        end else begin\n            r_opcode <= w_opcode;\n            r_rd <= w_rd;\n            r_funct3 <= w_funct3;\n            r_rs1 <= w_rs1;\n            r_rs2 <= w_rs2;\n            r_funct7 <= w_funct7;\n        end\n    end\n\n    assign opcode = r_opcode;\n    assign rd = r_rd;\n    assign funct3 = r_funct3;\n    assign rs1 = r_rs1;\n    assign rs2 = r_rs2;\n    assign funct7 = r_funct7;\n\nendmodule\n\nmodule decode_logic (\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7\n);\n\n    assign opcode = instruction[6:0];\n    assign rd = instruction[11:7];\n    assign funct3 = instruction[14:12];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign funct7 = instruction[31:25];\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'flags', 'type': 'input port'}, {'id': 2, 'content': 'branch_taken', 'type': 'output port'}, {'id': 3, 'content': 'branch_type', 'type': 'output port'}, {'id': 4, 'content': 'decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4], [4, 2, 3]]\n, Design a Verilog module for a RISC-V branch instruction decoder that reads a 32-bit instruction and outputs control signals to direct the program counter (PC) logic. The module should isolate and decode the branch type and determine if the branch condition is taken based on flags from the execution unit.\n\nModule name:\n    branch_decoder\n\nInput ports:\n    instruction [31:0]: The 32-bit instruction word.\n    flags [3:0]: Processor flags where [0] is zero, [1] is negative, [2] is carry, and [3] is overflow.\n    \nOutput ports:\n    branch_taken: A signal to indicate whether the branch should be taken.\n    branch_type [2:0]: Type of branch (e.g., BEQ, BNE, BLT, BGE).\n\nImplementation:\n    The module utilizes a submodule to determine the branch type based on opcode and funct3 fields.\n    The main module evaluates the flags and the branch type to determine if the condition for the branch is satisfied.\n    Supports standard RISC-V branches including equality, inequality, less than, and greater than or equal.\n    Efficient handling for signal conditioning and branching decision-making.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_decoder (\n    input [31:0] instruction,\n    input [3:0] flags,\n    output branch_taken,\n    output [2:0] branch_type\n);\n\n    // Submodule for decoding branch type\n    wire [6:0] opcode;\n    wire [2:0] funct3;\n    assign opcode = instruction[6:0];\n    assign funct3 = instruction[14:12];\n\n    branch_type_decoder decoder (\n        .opcode(opcode),\n        .funct3(funct3),\n        .branch_type(branch_type)\n    );\n\n    // Branch condition evaluation\n    reg branch_taken_reg;\n    always @* begin\n        case (branch_type)\n            3'b000: branch_taken_reg = flags[0]; // BEQ\n            3'b001: branch_taken_reg = ~flags[0]; // BNE\n            3'b100: branch_taken_reg = flags[1]; // BLT\n            3'b101: branch_taken_reg = ~flags[1] | flags[0]; // BGE\n            default: branch_taken_reg = 1'b0;\n        endcase\n    end\n\n    assign branch_taken = branch_taken_reg;\n\nendmodule\n\nmodule branch_type_decoder (\n    input [6:0] opcode,\n    input [2:0] funct3,\n    output reg [2:0] branch_type\n);\n\n    always @* begin\n        if (opcode == 7'b1100011) begin // BRANCH opcode\n            branch_type = funct3;\n        end else begin\n            branch_type = 3'b111; // Invalid or not a branch\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'imm_val', 'type': 'output port'}, {'id': 2, 'content': 'imm_needed', 'type': 'output port'}, {'id': 3, 'content': 'dec1', 'type': 'submodule'}, {'id': 4, 'content': 'ext1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 0, 4, 3], [3, 4, 4, 1, 2]]\n, A Verilog module for a RISC-V immediate value extraction circuit tailored for I-type instructions, which extracts immediate values for operations like load and ALU operations. This module will take in a 32-bit instruction and output the 12-bit immediate value along with flags indicating whether the instruction requires an immediate value.\n\nModule name:\n    imm_extractor\n\nInput ports:\n    instruction [31:0]: Full 32-bit instruction input.\n\nOutput ports:\n    imm_val [11:0]: Extracted 12-bit immediate value from the instruction.\n    imm_needed: Flag indicating whether the instruction utilizes an immediate value.\n\nImplementation:\n    The module is separated into two submodules: \n    1. decode_imm that decodes if an immediate is needed based on the opcode.\n    2. extract_imm that extracts the immediate value if needed.\n    The imm_needed flag is set by decode_imm based on the opcode of the instruction, and the imm_val is extracted by extract_imm if imm_needed is true.\nGive me the complete code."}, {"from": "gpt", "value": "module imm_extractor (\n    input [31:0] instruction,\n    output [11:0] imm_val,\n    output imm_needed\n);\n\n    wire opcode_imm_needed;\n\n    decode_imm dec1 (\n        .opcode(instruction[6:0]),\n        .imm_needed(opcode_imm_needed)\n    );\n\n    extract_imm ext1 (\n        .instruction(instruction),\n        .imm_needed(opcode_imm_needed),\n        .imm_val(imm_val)\n    );\n\n    assign imm_needed = opcode_imm_needed;\n\nendmodule\n\nmodule decode_imm (\n    input [6:0] opcode,\n    output imm_needed\n);\n\n    assign imm_needed = (opcode == 7'b0000011) || // Load type\n                        (opcode == 7'b0010011);  // I-type ALU ops\n\nendmodule\n\nmodule extract_imm (\n    input [31:0] instruction,\n    input imm_needed,\n    output reg [11:0] imm_val\n);\n\n    always @(*) begin\n        if (imm_needed) begin\n            imm_val = instruction[31:20]; // Extracting 12-bit immediate from I-type instruction\n        end else begin\n            imm_val = 12'b0;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'imm_I', 'type': 'output port'}, {'id': 2, 'content': 'imm_S', 'type': 'output port'}, {'id': 3, 'content': 'imm_B', 'type': 'output port'}, {'id': 4, 'content': 'imm_U', 'type': 'output port'}, {'id': 5, 'content': 'imm_J', 'type': 'output port'}, {'id': 6, 'content': 'imm_gen_i', 'type': 'submodule'}, {'id': 7, 'content': 'imm_gen_s', 'type': 'submodule'}, {'id': 8, 'content': 'imm_gen_b', 'type': 'submodule'}, {'id': 9, 'content': 'imm_gen_u', 'type': 'submodule'}, {'id': 10, 'content': 'imm_gen_j', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 0, 6, 7, 8, 9, 10], [6, 7, 8, 9, 10, 1, 2, 3, 4, 5]]\n, Design a Verilog module named \"RISC_Imm_Generator\" which takes a 32-bit instruction input and generates immediate values for I, S, B, U, and J type instructions in a RISC-V architecture. This module should implement separate submodules for each immediate type extraction, facilitating modular design and easier maintenance.\n\nModule name:\n    RISC_Imm_Generator\n\nInput ports:\n    instruction [31:0]: The 32-bit RISC-V instruction.\n\nOutput ports:\n    imm_I [11:0]: Immediate value for I-type instructions.\n    imm_S [11:0]: Immediate value for S-type instructions.\n    imm_B [12:0]: Immediate value for B-type instructions.\n    imm_U [19:0]: Immediate value for U-type instructions.\n    imm_J [20:0]: Immediate value for J-type instructions.\n\nImplementation:\n    The module should instantiate separate submodules for each type of immediate value extraction based on the RISC-V standard.\n    I-type imm is extracted from bits 31:20 of instruction.\n    S-type imm is composed of bits 31:25 and 11:7.\n    B-type imm consists of bits 31, 7, and bits 30:25 combined with bits 11:8.\n    U-type imm is directly taken from bits 31:12.\n    J-type imm combines bits 31, and bits 19:12 with bits 20 and bits 30:21.\nGive me the complete code."}, {"from": "gpt", "value": "module RISC_Imm_Generator (\n    input [31:0] instruction,\n    output [11:0] imm_I,\n    output [11:0] imm_S,\n    output [12:0] imm_B,\n    output [19:0] imm_U,\n    output [20:0] imm_J\n);\n\n    wire [11:0] imm_I_wire;\n    wire [11:0] imm_S_wire;\n    wire [12:0] imm_B_wire;\n    wire [19:0] imm_U_wire;\n    wire [20:0] imm_J_wire;\n\n    Imm_Gen_I imm_gen_i (\n        .instruction(instruction),\n        .imm_I(imm_I_wire)\n    );\n\n    Imm_Gen_S imm_gen_s (\n        .instruction(instruction),\n        .imm_S(imm_S_wire)\n    );\n\n    Imm_Gen_B imm_gen_b (\n        .instruction(instruction),\n        .imm_B(imm_B_wire)\n    );\n\n    Imm_Gen_U imm_gen_u (\n        .instruction(instruction),\n        .imm_U(imm_U_wire)\n    );\n\n    Imm_Gen_J imm_gen_j (\n        .instruction(instruction),\n        .imm_J(imm_J_wire)\n    );\n\n    assign imm_I = imm_I_wire;\n    assign imm_S = imm_S_wire;\n    assign imm_B = imm_B_wire;\n    assign imm_U = imm_U_wire;\n    assign imm_J = imm_J_wire;\n\nendmodule\n\nmodule Imm_Gen_I(input [31:0] instruction, output [11:0] imm_I);\n    assign imm_I = instruction[31:20];\nendmodule\n\nmodule Imm_Gen_S(input [31:0] instruction, output [11:0] imm_S);\n    assign imm_S = {instruction[31:25], instruction[11:7]};\nendmodule\n\nmodule Imm_Gen_B(input [31:0] instruction, output [12:0] imm_B);\n    assign imm_B = {instruction[31], instruction[7], instruction[30:25], instruction[11:8]};\nendmodule\n\nmodule Imm_Gen_U(input [31:0] instruction, output [19:0] imm_U);\n    assign imm_U = instruction[31:12];\nendmodule\n\nmodule Imm_Gen_J(input [31:0] instruction, output [20:0] imm_J);\n    assign imm_J = {instruction[31], instruction[19:12], instruction[20], instruction[30:21]};\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'instruction', 'type': 'input port'}, {'id': 4, 'content': 'new_pc', 'type': 'output port'}, {'id': 5, 'content': 'link_address', 'type': 'output port'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'update', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 2, 6, 0, 7, 7], [6, 7, 7, 7, 7, 4, 5]]\n, A module named \"jump_control\" designed to decode and execute the JAL (Jump and Link) RISC-V instruction, controlling program flow based on input conditions. It reads the current instruction, extracts the jump offset, updates the program counter (PC), and stores the return address.\n\nModule name:\n    jump_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the state.\n    enable: Enable signal to initiate the jump calculation.\n    instruction [31:0]: Full 32-bit instruction containing opcode and jump offset.\n\nOutput ports:\n    new_pc [31:0]: The new program counter value after the jump.\n    link_address [31:0]: The address to return to after the function call.\n\nImplementation:\n    The module uses an \"offset_decoder\" submodule to decode the 20-bit offset from the instruction and compute the effective jump target. Another submodule, \"pc_updater\", computes the new program counter based on the jump target.\n    On the rising edge of the clock, if the reset is low, it initializes all outputs to zero. If enabled and the opcode matches the JAL instruction (opcode 0x6F), it activates the submodules to compute the new PC and the link address (current PC + 4).\nGive me the complete code."}, {"from": "gpt", "value": "module jump_control (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] instruction,\n    output [31:0] new_pc,\n    output [31:0] link_address\n);\n\n    wire [31:0] jump_target, current_pc;\n    wire [19:0] offset;\n\n    assign offset = instruction[31:12]; // Extract 20-bit offset from instruction\n\n    offset_decoder decode (\n        .offset(offset),\n        .jump_target(jump_target)\n    );\n\n    pc_updater update (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable),\n        .jump_target(jump_target),\n        .new_pc(new_pc),\n        .link_address(link_address),\n        .current_pc(current_pc)\n    );\n\n    // Assign the current PC for testing purposes or from another module\n    assign current_pc = 32'd100; // Example starting PC for functionality\n\nendmodule\n\n// Submodule for decoding the jump offset\nmodule offset_decoder (\n    input [19:0] offset,\n    output [31:0] jump_target\n);\n\n    assign jump_target = {offset, 12'b0}; // Shift offset to form the full address\n\nendmodule\n\n// Submodule for updating the program counter\nmodule pc_updater (\n    input clk,\n    input rst,\n    input enable,\n    input [31:0] jump_target,\n    output reg [31:0] new_pc,\n    output reg [31:0] link_address,\n    input [31:0] current_pc\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            new_pc <= 32'd0;\n            link_address <= 32'd0;\n        end else if (enable) begin\n            new_pc <= jump_target;\n            link_address <= current_pc + 4;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'inst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'output port'}, {'id': 3, 'content': 'rs1', 'type': 'output port'}, {'id': 4, 'content': 'rs2', 'type': 'output port'}, {'id': 5, 'content': 'rd', 'type': 'output port'}, {'id': 6, 'content': 'imm', 'type': 'output port'}, {'id': 7, 'content': 'op_dec', 'type': 'submodule'}, {'id': 8, 'content': 'reg_dec', 'type': 'submodule'}, {'id': 9, 'content': 'imm_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 7, 8, 8, 8, 9], [7, 8, 9, 2, 3, 4, 5, 6]]\n, Design a RISC-V instruction decoder module that decodes instructions into specific operational signals for a processor. This module will extract the opcode, register addresses, and immediate values from a 32-bit instruction and output relevant control signals for execution stages.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal.\n    inst [31:0]: 32-bit instruction input.\n\nOutput ports:\n    opcode [6:0]: Extracted opcode from the instruction.\n    rs1 [4:0]: Source register 1.\n    rs2 [4:0]: Source register 2.\n    rd [4:0]: Destination register.\n    imm [11:0]: Immediate value for I-type instructions.\n\nImplementation:\n    The instruction decoder uses separate submodules to decode different parts of the instruction. On each clock's rising edge, if an instruction is present, it forwards relevant bits to respective decoding submodules which then output the decoded information.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [11:0] imm\n);\n\n    // Instantiation of submodules\n    opcode_decoder op_dec (\n        .inst(inst),\n        .opcode(opcode)\n    );\n\n    register_decoder reg_dec (\n        .inst(inst),\n        .rs1(rs1),\n        .rs2(rs2),\n        .rd(rd)\n    );\n\n    immediate_decoder imm_dec (\n        .inst(inst),\n        .imm(imm)\n    );\n\nendmodule\n\n// Submodule to decode opcode\nmodule opcode_decoder (\n    input [31:0] inst,\n    output [6:0] opcode\n);\n    assign opcode = inst[6:0];\nendmodule\n\n// Submodule to decode register fields\nmodule register_decoder (\n    input [31:0] inst,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd\n);\n    assign rs1 = inst[19:15];\n    assign rs2 = inst[24:20];\n    assign rd = inst[11:7];\nendmodule\n\n// Submodule to decode immediate values\nmodule immediate_decoder (\n    input [31:0] inst,\n    output reg [11:0] imm\n);\n    always @* begin\n        case(inst[6:0])  // Depending on opcode, different immediate extraction\n            7'b0000011: imm = inst[31:20]; // Example for I-type\n            default: imm = 12'd0;\n        endcase\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch_type', 'type': 'input port'}, {'id': 3, 'content': 'zero_flag', 'type': 'input port'}, {'id': 4, 'content': 'neg_flag', 'type': 'input port'}, {'id': 5, 'content': 'take_branch', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[3, 4], [5, 5]]\n, Design a RISC-V Branch Decision Module that evaluates branch conditions and outputs a decision signal. This module should handle different branch types and conditions as inputs and generate a decision based on the current instruction\u2019s flags and type.\n\nModule name:\n    branch_decision\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to reset the decision output.\n    branch_type [2:0]: Input signal indicating the type of branch (e.g., BEQ, BNE, BLT).\n    zero_flag: Input flag that indicates if the result of the last ALU operation was zero.\n    neg_flag: Input flag that indicates if the result of the last ALU operation was negative.\n\nOutput ports:\n    take_branch: Output signal that indicates whether the branch should be taken (1) or not (0) based on the evaluation.\n\nImplementation:\n    This module should evaluate the input branch type against the flags and output the decision. If reset, the output should be 0. The module uses a combinational logic block to determine the branch decision.\nGive me the complete code."}, {"from": "gpt", "value": "module branch_decision (\n    input clk,\n    input rst,\n    input [2:0] branch_type,\n    input zero_flag,\n    input neg_flag,\n    output reg take_branch\n);\n\n    always @(*) begin\n        if (!rst) begin\n            take_branch = 0;\n        end else begin\n            case (branch_type)\n                3'b000: take_branch = zero_flag;  // BEQ\n                3'b001: take_branch = ~zero_flag; // BNE\n                3'b010: take_branch = neg_flag;    // BLT\n                3'b011: take_branch = ~neg_flag;   // BGE\n                3'b100: take_branch = zero_flag & neg_flag;  // BLE\n                3'b101: take_branch = ~zero_flag | ~neg_flag; // BGT\n                default: take_branch = 0;  // No branch\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rs1', 'type': 'output port'}, {'id': 5, 'content': 'rs2', 'type': 'output port'}, {'id': 6, 'content': 'rd', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'im_compute', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 2, 2, 2, 2, 8], [8, 8, 8, 3, 4, 5, 6, 7]]\n, Create a RISC-V instruction decoder module to handle opcode extraction and immediate value computation for a subset of instructions. The module should separate an incoming 32-bit instruction into its opcode, register addresses, and compute immediate values for I-type instructions.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    instruction [31:0]: 32-bit input instruction to be decoded.\n\nOutput ports:\n    opcode [6:0]: Extracted 7-bit opcode.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address for R-type instructions.\n    rd [4:0]: Destination register address.\n    imm [31:0]: Computed 32-bit immediate for I-type instructions.\n\nImplementation:\n    The instruction decoder uses a submodule for immediate value computation, which operates based on the opcode.\n    On a rising edge of clk, if rst is active, the outputs are zeroed.\n    The opcode, rs1, rs2, and rd are directly extracted from fixed bit positions within the instruction.\n    The immediate value computation submodule is activated only for opcodes corresponding to I-type instructions and calculates a sign-extended immediate value.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [31:0] imm\n);\n\n    // Submodule for immediate value computation\n    wire [31:0] imm_computed;\n\n    immediate_value_compute im_compute (\n        .clk(clk),\n        .rst(rst),\n        .opcode(instruction[6:0]),\n        .imm_field(instruction[31:20]),\n        .imm_out(imm_computed)\n    );\n\n    // Output assignments\n    assign opcode = instruction[6:0];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\n    assign rd = instruction[11:7];\n    assign imm = imm_computed;\n\nendmodule\n\n// Submodule for computing immediate values for I-type instructions\nmodule immediate_value_compute (\n    input clk,\n    input rst,\n    input [6:0] opcode,\n    input [11:0] imm_field,\n    output reg [31:0] imm_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            imm_out <= 32'd0;\n        end else begin\n            if (opcode == 7'b???????) begin // I-type opcode check\n                imm_out <= {{20{imm_field[11]}}, imm_field}; // Sign-extension\n            end else begin\n                imm_out <= 32'd0; // Clear for non-I-type instructions\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'is_load', 'type': 'output port'}, {'id': 2, 'content': 'is_store', 'type': 'output port'}, {'id': 3, 'content': 'is_branch', 'type': 'output port'}, {'id': 4, 'content': 'is_alu', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0], [1, 2, 3, 4]]\n, Design a Verilog module named 'opcode_decoder' for decoding the 7-bit opcode field from a 32-bit RISC-V instruction. The module should extract and classify the opcode into control signals for other CPU components, identifying main operation types such as Load, Store, Branch, ALU operations, etc.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    instr [31:0]: Full 32-bit instruction.\n\nOutput ports:\n    is_load: Asserted if the opcode is for a load operation.\n    is_store: Asserted if the opcode is for a store operation.\n    is_branch: Asserted if the opcode is for a branching operation.\n    is_alu: Asserted if the opcode is for an ALU operation.\n    \nImplementation:\n    The opcode_decoder module uses a combinational logic block to decode the 7-bit opcode (instr[6:0]). It sets output flags based on the decoded opcode value. The module handles common RISC-V opcode formats and sets the appropriate control signals for the CPU's main operational units.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [31:0] instr,\n    output is_load,\n    output is_store,\n    output is_branch,\n    output is_alu\n);\n\n    reg [6:0] opcode;\n    always @(*) begin\n        opcode = instr[6:0];\n    end\n\n    assign is_load = (opcode == 7'b0000011); // Load\n    assign is_store = (opcode == 7'b0100011); // Store\n    assign is_branch = (opcode == 7'b1100011); // Branch\n    assign is_alu = (opcode == 7'b0110011); // ALU operation\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'rs1', 'type': 'output port'}, {'id': 6, 'content': 'rs2', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'op_dec', 'type': 'submodule'}, {'id': 9, 'content': 'reg_dec', 'type': 'submodule'}, {'id': 10, 'content': 'imm_dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 8, 2, 8, 9, 9, 9, 10], [8, 9, 10, 10, 3, 4, 5, 6, 7]]\n, Design a RISC-V 32-bit instruction decoder module in Verilog, aimed at extracting the opcode, source register identifiers, destination register, and immediate values from a given 32-bit instruction. This module should contain separate submodules for decoding different parts of the instruction based on the RISC-V ISA.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    instruction [31:0]: 32-bit input representing the entire RISC-V instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode field of the instruction.\n    rd [4:0]: Destination register identifier.\n    rs1 [4:0]: Source register 1 identifier.\n    rs2 [4:0]: Source register 2 identifier.\n    imm [31:0]: Immediate value extracted and sign-extended.\n\nImplementation:\n    The instruction decoder module instantiates separate submodules for decoding the opcode, register identifiers, and immediate value from the 32-bit instruction.\n    On the rising edge of the clock, if the reset is low, all outputs are reset to zero.\n    The submodule 'opcode_decoder' extracts the opcode from the instruction.\n    The submodule 'reg_decoder' extracts rd, rs1, and rs2 from the instruction.\n    The submodule 'imm_decoder' computes the immediate value, handling sign extension based on the opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [31:0] imm\n);\n\n    // Opcode decoder submodule\n    opcode_decoder op_dec (\n        .instruction(instruction),\n        .opcode(opcode)\n    );\n\n    // Register identifiers decoder submodule\n    reg_decoder reg_dec (\n        .instruction(instruction),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2)\n    );\n\n    // Immediate value decoder submodule\n    imm_decoder imm_dec (\n        .instruction(instruction),\n        .opcode(opcode),\n        .imm(imm)\n    );\n\nendmodule\n\nmodule opcode_decoder (\n    input [31:0] instruction,\n    output [6:0] opcode\n);\n    assign opcode = instruction[6:0];\nendmodule\n\nmodule reg_decoder (\n    input [31:0] instruction,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign rd = instruction[11:7];\n    assign rs1 = instruction[19:15];\n    assign rs2 = instruction[24:20];\nendmodule\n\nmodule imm_decoder (\n    input [31:0] instruction,\n    input [6:0] opcode,\n    output reg [31:0] imm\n);\n    always @(*) begin\n        case (opcode)\n            7'b0000011, 7'b1100111: // Load and JALR, I-type\n                imm = {{20{instruction[31]}}, instruction[31:20]};\n            7'b0100011: // S-type\n                imm = {{20{instruction[31]}}, instruction[31:25], instruction[11:7]};\n            7'b1100011: // B-type\n                imm = {{19{instruction[31]}}, instruction[31], instruction[7], instruction[30:25], instruction[11:8], 1'b0};\n            7'b0010111, 7'b0110111: // U-type\n                imm = {instruction[31:12], 12'h000};\n            7'b1101111: // J-type\n                imm = {{11{instruction[31]}}, instruction[31], instruction[19:12], instruction[20], instruction[30:21], 1'b0};\n            default: // Default case\n                imm = 32'b0;\n        endcase\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'funct3', 'type': 'output port'}, {'id': 5, 'content': 'funct7', 'type': 'output port'}, {'id': 6, 'content': 'imm', 'type': 'output port'}, {'id': 7, 'content': 'fd', 'type': 'submodule'}, {'id': 8, 'content': 'ie', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 2, 2, 7, 7, 8], [7, 7, 7, 8, 8, 8, 3, 4, 5, 6]]\n, Design a Verilog module named `opcode_decoder` that decodes a 32-bit RISC-V instruction into its constituent parts: the opcode, funct3, funct7, and immediate fields. The module uses two submodules: `funct_decoder` for decoding funct fields and `immediate_extractor` for extracting immediate values based on the type of the instruction.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal.\n    rst: Synchronous reset signal.\n    instruction [31:0]: 32-bit input instruction.\n\nOutput ports:\n    opcode [6:0]: Decoded opcode.\n    funct3 [2:0]: Decoded funct3 field.\n    funct7 [6:0]: Decoded funct7 field.\n    imm [31:0]: Extracted immediate value.\n\nImplementation:\n    The `opcode_decoder` module uses two submodules, `funct_decoder` to decode funct3 and funct7, and `immediate_extractor` to handle immediate value extraction.\n    On the positive edge of the clock, the instruction is decoded into opcode directly from bits [6:0].\n    The funct fields and the immediate value are decoded using the respective submodules. The module maintains the output stable between clock cycles unless reset is asserted.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [31:0] imm\n);\n\n    // Outputs from submodules\n    wire [2:0] funct3_out;\n    wire [6:0] funct7_out;\n    wire [31:0] imm_out;\n\n    assign opcode = instruction[6:0]; // Direct extraction of opcode\n\n    funct_decoder fd (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .funct3(funct3_out),\n        .funct7(funct7_out)\n    );\n\n    immediate_extractor ie (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .imm(imm_out)\n    );\n\n    // Output assignments\n    assign funct3 = funct3_out;\n    assign funct7 = funct7_out;\n    assign imm = imm_out;\n\nendmodule\n\nmodule funct_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [2:0] funct3,\n    output reg [6:0] funct7\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            funct3 <= instruction[14:12];\n            funct7 <= instruction[31:25];\n        end else begin\n            funct3 <= 3'b000;\n            funct7 <= 7'b0000000;\n        end\n    end\n\nendmodule\n\nmodule immediate_extractor (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] imm\n);\n\n    always @(posedge clk) begin\n        if (rst) begin\n            case (instruction[6:0])\n                7'b0010011, 7'b0000011, 7'b1100111: // I-Type\n                    imm <= {{20{instruction[31]}}, instruction[31:20]};\n                7'b0100011: // S-Type\n                    imm <= {{20{instruction[31]}}, instruction[31:25], instruction[11:7]};\n                7'b1100011: // B-Type\n                    imm <= {{19{instruction[31]}}, instruction[31], instruction[7], instruction[30:25], instruction[11:8], 1'b0};\n                default:\n                    imm <= 32'b0;\n            endcase\n        end else begin\n            imm <= 32'b0;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'input port'}, {'id': 3, 'content': 'operation_complete', 'type': 'input port'}, {'id': 4, 'content': 'zero_flag', 'type': 'output port'}, {'id': 5, 'content': 'carry_flag', 'type': 'output port'}, {'id': 6, 'content': 'negative_flag', 'type': 'output port'}, {'id': 7, 'content': 'flags', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 7, 7, 7], [7, 4, 5, 6]]\n, Design a RISC-V flag status register module for a processor that updates its flags based on arithmetic operations. The module should set flags for zero, carry, and negative based on the result of the operation.\n\nModule name:\n    flag_status_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    result [7:0]: Result of arithmetic operation.\n    operation_complete: Signal indicating the completion of an arithmetic operation.\n\nOutput ports:\n    zero_flag: High if the result is zero.\n    carry_flag: High if the operation resulted in a carry.\n    negative_flag: High if the result is negative.\n\nImplementation:\n    The flag status register module captures and updates flags on each arithmetic operation completion. The zero_flag is set if the result is zero, carry_flag if a carry occurred, and negative_flag if the most significant bit of the result is high, indicating a negative number. The module includes a submodule to handle the detection and setting of each specific flag based on the type of arithmetic result.\nGive me the complete code."}, {"from": "gpt", "value": "module flag_status_reg (\n    input clk,\n    input rst,\n    input [7:0] result,\n    input operation_complete,\n    output zero_flag,\n    output carry_flag,\n    output negative_flag\n);\n\n    // Submodule for flag detection\n    wire zero_detect, carry_detect, negative_detect;\n\n    flag_detection flags (\n        .result(result),\n        .zero(zero_detect),\n        .carry(carry_detect),\n        .negative(negative_detect)\n    );\n\n    // Registers to store flag status\n    reg zero_flag_reg, carry_flag_reg, negative_flag_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            zero_flag_reg <= 1'b0;\n            carry_flag_reg <= 1'b0;\n            negative_flag_reg <= 1'b0;\n        end else if (operation_complete) begin\n            zero_flag_reg <= zero_detect;\n            carry_flag_reg <= carry_detect;\n            negative_flag_reg <= negative_detect;\n        end\n    end\n\n    // Output assignments\n    assign zero_flag = zero_flag_reg;\n    assign carry_flag = carry_flag_reg;\n    assign negative_flag = negative_flag_reg;\n\nendmodule\n\n// Submodule for detecting flags\nmodule flag_detection (\n    input [7:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\n    assign zero = (result == 8'd0);\n    assign carry = (result[7] && (result[6:0] == 7'd0)); // Simplified example\n    assign negative = result[7];\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'opcode', 'type': 'input port'}, {'id': 1, 'content': 'isArith', 'type': 'output port'}, {'id': 2, 'content': 'isLogic', 'type': 'output port'}, {'id': 3, 'content': 'isMemory', 'type': 'output port'}, {'id': 4, 'content': 'isError', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[], []]\n, Design a RISC-V control signal decoder module that interprets the opcode from an instruction register and generates control signals for various CPU operations. The module should parse the opcode from a given instruction and provide signals indicating the type of operation (arithmetic, logic, memory access, etc.).\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    opcode [6:0]: 7-bit input representing the opcode part of the instruction.\n\nOutput ports:\n    isArith [0:0]: Indicates if the operation is arithmetic.\n    isLogic [0:0]: Indicates if the operation is logical.\n    isMemory [0:0]: Indicates if the operation involves memory access.\n    isError [0:0]: Indicates an error in opcode decoding (undefined opcode).\n\nImplementation:\n    The opcode_decoder is a simple combinational logic module that decodes the 7-bit opcode into specific control signals. Each output port represents a type of CPU operation. Specific opcodes are predefined to represent arithmetic, logic, and memory operations. Any undefined opcode will trigger the isError signal.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [6:0] opcode,\n    output reg isArith,\n    output reg isLogic,\n    output reg isMemory,\n    output reg isError\n);\n\n    always @(*) begin\n        // Initialize outputs to avoid latches\n        isArith = 0;\n        isLogic = 0;\n        isMemory = 0;\n        isError = 0;\n\n        case (opcode)\n            7'b0110011: isArith = 1; // Example opcode for arithmetic\n            7'b0010011: isLogic = 1;  // Example opcode for logic\n            7'b0000011: isMemory = 1; // Example opcode for memory access\n            default: isError = 1;      // Undefined opcode\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'instr', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'output port'}, {'id': 3, 'content': 'rs1', 'type': 'output port'}, {'id': 4, 'content': 'rs2', 'type': 'output port'}, {'id': 5, 'content': 'rd', 'type': 'output port'}, {'id': 6, 'content': 'funct3', 'type': 'output port'}, {'id': 7, 'content': 'funct7', 'type': 'output port'}, {'id': 8, 'content': 'imm', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 1, 1, 1, 1, 1], [2, 3, 4, 5, 6, 7, 8]]\n, Design a RISC-V instruction decoder module that takes a 32-bit encoded instruction and decodes it into various control signals for a processor's control unit. This module should support decoding of basic RISC-V instructions including register-register arithmetic, immediate arithmetic, and load/store operations.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    instr [31:0]: 32-bit input representing the full instruction code.\n\nOutput ports:\n    opcode [6:0]: Opcode field of the instruction.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function3 field, used in arithmetic and memory access.\n    funct7 [6:0]: Function7 field, used in arithmetic.\n    imm [11:0]: Immediate value for immediate operations.\n\nImplementation:\n    The instruction decoder module reads the instruction from the input and breaks it down into several fields which are commonly used in the control logic of RISC-V CPUs. Each field is directly mapped from specific bit positions of the 32-bit instruction. This module does not implement any logic operations but simply partitions the instruction into relevant fields.\nGive me the complete code."}, {"from": "gpt", "value": "module instr_decoder (\n    input clk,\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output reg [11:0] imm\n);\n\n    // Decode each field from the instruction\n    assign opcode = instr[6:0];\n    assign rd = instr[11:7];\n    assign funct3 = instr[14:12];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign funct7 = instr[31:25];\n\n    always @(posedge clk) begin\n        // Decode immediate value based on opcode\n        case (opcode)\n            7'b0010011, // I-Type\n            7'b0000011: // Load-type\n                imm <= instr[31:20];\n            7'b0100011: // S-Type\n                imm <= {instr[31:25], instr[11:7]};\n            default:\n                imm <= 12'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'alu_op', 'type': 'input port'}, {'id': 1, 'content': 'funct', 'type': 'input port'}, {'id': 2, 'content': 'alu_ctrl', 'type': 'output port'}, {'id': 3, 'content': 'arith_ctrl', 'type': 'submodule'}, {'id': 4, 'content': 'logic_ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 1, 4, 3], [3, 4, 2, 2]]\n, Design a Verilog module named \"alu_control_unit\" for a RISC-V ALU that interprets a 4-bit ALU operation code and 3-bit function code to generate a 4-bit control signal for various arithmetic and logical operations. This module utilizes submodules to separately handle arithmetic and logical operations based on the ALU operation code.\n\nModule name:\n    alu_control_unit\n\nInput ports:\n    alu_op [3:0]: 4-bit control code defining the type of operation (e.g., add, subtract, and, or).\n    funct [2:0]: 3-bit function code to further specify the operation within a given type.\n\nOutput ports:\n    alu_ctrl [3:0]: 4-bit control signal output that directs the main ALU operation.\n\nImplementation:\n    The \"alu_control_unit\" uses two submodules: one for handling arithmetic operations (arith_ctrl) and one for handling logical operations (logic_ctrl).\n    Based on the alu_op code:\n    - If alu_op is 4'b0001, the control signal is generated by the arith_ctrl submodule.\n    - If alu_op is 4'b0010, the control signal is generated by the logic_ctrl submodule.\n    - For other codes, alu_ctrl is set to 4'b0000 (no operation).\n    The outputs are switched based on alu_op, and the alu_ctrl reflects the output of the active submodule.\nGive me the complete code."}, {"from": "gpt", "value": "module alu_control_unit (\n    input [3:0] alu_op,\n    input [2:0] funct,\n    output [3:0] alu_ctrl\n);\n\n    wire [3:0] arith_ctrl_out, logic_ctrl_out;\n\n    // Instantiation of Arithmetic Control Submodule\n    arithmetic_control arith_ctrl (\n        .funct(funct),\n        .ctrl_out(arith_ctrl_out)\n    );\n\n    // Instantiation of Logical Control Submodule\n    logical_control logic_ctrl (\n        .funct(funct),\n        .ctrl_out(logic_ctrl_out)\n    );\n\n    // ALU Control Logic\n    reg [3:0] ctrl_signal;\n    always @(*) begin\n        case(alu_op)\n            4'b0001: ctrl_signal = arith_ctrl_out;\n            4'b0010: ctrl_signal = logic_ctrl_out;\n            default: ctrl_signal = 4'b0000;\n        endcase\n    end\n\n    assign alu_ctrl = ctrl_signal;\n\nendmodule\n\n// Submodule for Arithmetic Operations Control\nmodule arithmetic_control (\n    input [2:0] funct,\n    output reg [3:0] ctrl_out\n);\n\n    always @(*) begin\n        case(funct)\n            3'b000: ctrl_out = 4'b0010; // ADD\n            3'b001: ctrl_out = 4'b0110; // SUB\n            default: ctrl_out = 4'b0000; // Default NO-OP\n        endcase\n    end\n\nendmodule\n\n// Submodule for Logical Operations Control\nmodule logical_control (\n    input [2:0] funct,\n    output reg [3:0] ctrl_out\n);\n\n    always @(*) begin\n        case(funct)\n            3'b000: ctrl_out = 4'b0000; // AND\n            3'b001: ctrl_out = 4'b0001; // OR\n            default: ctrl_out = 4'b1111; // Default NO-OP\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'inst', 'type': 'input port'}, {'id': 2, 'content': 'imm_val', 'type': 'output port'}, {'id': 3, 'content': 'se', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 3], [3, 3, 2]]\n, Design an immediate value extraction module for RISC-V instructions, specifically focusing on the I-Type format. The module should extract immediate values from the 32-bit instruction, handle sign extension, and output the extended 32-bit immediate value to be used in further processing stages.\n\nModule name:\n    immediate_extractor\n\nInput ports:\n    clk: Clock signal for synchronization.\n    inst [31:0]: 32-bit instruction from which the immediate value will be extracted.\n\nOutput ports:\n    imm_val [31:0]: Extracted and sign-extended 32-bit immediate value.\n\nImplementation:\n    The immediate_extractor module uses a submodule for sign extension. The immediate value is taken from bits [31:20] of the instruction. The submodule reads the 12-bit immediate from the instruction, checks the most significant bit (sign bit), and extends this sign throughout the higher 20 bits to form a 32-bit immediate value. The sign extension ensures correct arithmetic operations in subsequent instruction processing.\nGive me the complete code."}, {"from": "gpt", "value": "module immediate_extractor (\n    input clk,\n    input [31:0] inst,\n    output [31:0] imm_val\n);\n\n    // Intermediate signal for the 12-bit immediate value\n    wire [11:0] imm_12bit;\n    assign imm_12bit = inst[31:20];\n\n    // Submodule for sign extension\n    sign_extend se (\n        .clk(clk),\n        .in(imm_12bit),\n        .out(imm_val)\n    );\n\nendmodule\n\n// Submodule for sign extension\nmodule sign_extend (\n    input clk,\n    input [11:0] in,\n    output reg [31:0] out\n);\n\n    always @(posedge clk) begin\n        out <= { {20{in[11]}}, in }; // Sign-extend the 12-bit input to 32-bit\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'inst', 'type': 'input port'}, {'id': 3, 'content': 'shift_type', 'type': 'output port'}, {'id': 4, 'content': 'shift_dist', 'type': 'output port'}, {'id': 5, 'content': 'left_shift_decoder', 'type': 'submodule'}, {'id': 6, 'content': 'right_shift_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 1, 2, 0, 6, 6, 5], [5, 5, 5, 6, 6, 6, 3, 4, 4]]\n, Design a RISC-V Shift Register Decoder module that separates an instruction into opcode and operand parts, aimed to decode shift operations. The module identifies if the operation is a logical left or right shift, and outputs the operation details, including shift direction and distance.\n\nModule name:\n    shift_decoder\n\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Active low reset signal for initialization.\n    inst [15:0]: 16-bit instruction input where [15:12] indicates the operation and [11:0] are operands.\n\nOutput ports:\n    shift_type: Indicates the type of shift (0 for left, 1 for right).\n    shift_dist [5:0]: Indicates the distance to shift, taken from the lower 6 bits of the operand.\n\nImplementation:\n    Based on the opcode, the decoder module directs the instruction to one of two submodules to handle either left or right shifts.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Depending on the opcode:\n    If opcode is 4'h0, the left shift is decoded.\n    If opcode is 4'h1, the right shift is decoded.\n    If neither opcode matches, outputs remain unchanged.\n    The outputs shift_type and shift_dist are generated based on the active submodule's outputs.\nGive me the complete code."}, {"from": "gpt", "value": "module shift_decoder (\n    input clk,\n    input rst,\n    input [15:0] inst,\n    output shift_type,\n    output [5:0] shift_dist\n);\n\n    wire [3:0] opcode = inst[15:12];\n    wire [11:0] operand = inst[11:0];\n\n    // Submodule wires\n    wire left_shift_active, right_shift_active;\n    wire [5:0] left_shift_dist, right_shift_dist;\n\n    decode_left_shift left_shift_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .operand(operand),\n        .active(left_shift_active),\n        .shift_dist(left_shift_dist)\n    );\n\n    decode_right_shift right_shift_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .operand(operand),\n        .active(right_shift_active),\n        .shift_dist(right_shift_dist)\n    );\n\n    assign shift_type = right_shift_active;\n    assign shift_dist = (left_shift_active ? left_shift_dist : right_shift_dist);\n\nendmodule\n\nmodule decode_left_shift (\n    input clk,\n    input rst,\n    input [3:0] opcode,\n    input [11:0] operand,\n    output reg active,\n    output reg [5:0] shift_dist\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            active <= 0;\n            shift_dist <= 0;\n        end else if (opcode == 4'h0) begin\n            active <= 1;\n            shift_dist <= operand[5:0];\n        end else begin\n            active <= 0;\n            shift_dist <= shift_dist;\n        end\n    end\n\nendmodule\n\nmodule decode_right_shift (\n    input clk,\n    input rst,\n    input [3:0] opcode,\n    input [11:0] operand,\n    output reg active,\n    output reg [5:0] shift_dist\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            active <= 0;\n            shift_dist <= 0;\n        end else if (opcode == 4'h1) begin\n            active <= 1;\n            shift_dist <= operand[5:0];\n        end else begin\n            active <= 0;\n            shift_dist <= shift_dist;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instruction', 'type': 'input port'}, {'id': 1, 'content': 'is_arith', 'type': 'output port'}, {'id': 2, 'content': 'is_logic', 'type': 'output port'}, {'id': 3, 'content': 'is_control', 'type': 'output port'}, {'id': 4, 'content': 'ol', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 4, 4, 4], [4, 1, 2, 3]]\n, A RISC-V instruction decoder module that interprets the opcode from a fetched instruction and generates control signals for further processing in the processor. This module segregates opcodes and provides flag outputs indicating the type of operation such as arithmetic, logical, or control.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    instruction [31:0]: 32-bit instruction fetched from the instruction memory.\n\nOutput ports:\n    is_arith [0:0]: Flag to indicate if the operation is arithmetic.\n    is_logic [0:0]: Flag to indicate if the operation is logical.\n    is_control [0:0]: Flag to indicate if the operation is a control instruction.\n\nImplementation:\n    The opcode_decoder module determines the type of operation based on the opcode extracted from the instruction input. It employs hierarchical design through submodules that each handle specific tasks like extracting the opcode and setting the respective flags based on opcode.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input [31:0] instruction,\n    output is_arith,\n    output is_logic,\n    output is_control\n);\n\n    // Extract opcode from the instruction\n    wire [6:0] opcode;\n    assign opcode = instruction[6:0];\n\n    // Decode the opcode to set flags\n    opcode_logic ol (\n        .opcode(opcode),\n        .is_arith(is_arith),\n        .is_logic(is_logic),\n        .is_control(is_control)\n    );\n\nendmodule\n\n// Submodule for decoding opcode to operation flags\nmodule opcode_logic (\n    input [6:0] opcode,\n    output reg is_arith,\n    output reg is_logic,\n    output reg is_control\n);\n\n    always @(*) begin\n        // Default values\n        is_arith = 1'b0;\n        is_logic = 1'b0;\n        is_control = 1'b0;\n\n        // Set flags based on opcode\n        case (opcode)\n            7'b0110011: is_arith = 1'b1; // Example opcode for arithmetic\n            7'b0010011: is_logic = 1'b1; // Example opcode for logical\n            7'b1100011: is_control = 1'b1; // Example opcode for control\n            default: begin\n                is_arith = 1'b0;\n                is_logic = 1'b0;\n                is_control = 1'b0;\n            end\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'funct3', 'type': 'output port'}, {'id': 5, 'content': 'funct7', 'type': 'output port'}, {'id': 6, 'content': 'operation_type', 'type': 'output port'}, {'id': 7, 'content': 'opcode_module', 'type': 'submodule'}, {'id': 8, 'content': 'funct_module', 'type': 'submodule'}, {'id': 9, 'content': 'op_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 2, 1, 7, 0, 7, 8, 8, 9], [7, 7, 7, 8, 8, 8, 9, 9, 9, 3, 4, 5, 6]]\n, Design a Verilog module named \"opcode_decoder\" that decodes a 32-bit instruction into relevant control signals for a RISC-V processor. The module should identify the type of operation (e.g., arithmetic, logical, load/store) and extract the opcode, function3, and function7 fields. This module utilizes submodules to handle decoding of different parts of the instruction.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal.\n    instruction [31:0]: The 32-bit RISC-V instruction input.\n\nOutput ports:\n    opcode [6:0]: Extracted opcode field.\n    funct3 [2:0]: Extracted function3 field.\n    funct7 [6:0]: Extracted function7 field.\n    operation_type [2:0]: Type of operation (00 for arithmetic, 01 for logical, 10 for load/store, 11 for other).\n\nImplementation:\n    The opcode_decoder uses three submodules: one for extracting the opcode, one for extracting the funct3 and funct7 fields, and one for determining the operation type based on the opcode. Resetting any submodule sets outputs to zero. Changes in the instruction input are processed on the rising edge of the clock signal.\nGive me the complete code."}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [2:0] funct3,\n    output [6:0] funct7,\n    output [2:0] operation_type\n);\n\n    wire [6:0] opcode_wire;\n    wire [2:0] funct3_wire;\n    wire [6:0] funct7_wire;\n    wire [2:0] operation_type_wire;\n\n    extract_opcode opcode_module (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .opcode(opcode_wire)\n    );\n\n    extract_funct funct_module (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .funct3(funct3_wire),\n        .funct7(funct7_wire)\n    );\n\n    operation_decoder op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode_wire),\n        .operation_type(operation_type_wire)\n    );\n\n    assign opcode = opcode_wire;\n    assign funct3 = funct3_wire;\n    assign funct7 = funct7_wire;\n    assign operation_type = operation_type_wire;\n\nendmodule\n\nmodule extract_opcode (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] opcode\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            opcode <= 0;\n        else\n            opcode <= instruction[6:0];\n    end\nendmodule\n\nmodule extract_funct (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [2:0] funct3,\n    output reg [6:0] funct7\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            funct3 <= 0;\n            funct7 <= 0;\n        end else begin\n            funct3 <= instruction[14:12];\n            funct7 <= instruction[31:25];\n        end\n    end\nendmodule\n\nmodule operation_decoder (\n    input clk,\n    input rst,\n    input [6:0] opcode,\n    output reg [2:0] operation_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            operation_type <= 0;\n        else begin\n            case (opcode)\n                7'b0110011, 7'b0010011: operation_type <= 2'b00; // Arithmetic\n                7'b0000011, 7'b0100011: operation_type <= 2'b10; // Load/Store\n                default: operation_type <= 2'b11; // Others\n            endcase\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'operation_executed', 'type': 'output port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'memory_address', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}, {'id': 8, 'content': 'arith', 'type': 'submodule'}, {'id': 9, 'content': 'mem_access', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 7, 0, 3, 1, 7, 0, 3, 9, 8, 7, 8, 7, 9], [7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 4, 5, 5, 6, 6]]\n, A RISC-V control unit submodule for decoding and executing instructions based on their type and opcode. The module should handle two types of operations: arithmetic and memory access. It receives the opcode and depending type, executes the operation by updating flags or storing data.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the submodule states.\n    opcode [3:0]: 4-bit opcode to identify the instruction type.\n    data_in [7:0]: Data input for processing or storage.\n\nOutput ports:\n    operation_executed: Flag indicating operation execution completion.\n    result [7:0]: Result of arithmetic operations.\n    memory_address [15:0]: Memory address for memory access operations.\n\nImplementation:\n    The control unit is implemented using separate submodules for arithmetic and memory access operations.\n    On the rising edge of the clock, depending on the opcode, the respective submodule is triggered to perform its functionality.\n    The arithmetic module calculates results and sets the operation_executed flag once complete.\n    The memory module updates the memory_address based on the input and sets the operation_executed flag.\nGive me the complete code."}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [3:0] opcode,\n    input [7:0] data_in,\n    output operation_executed,\n    output [7:0] result,\n    output [15:0] memory_address\n);\n\n    // Decode the opcode and execute relevant operation\n    wire arithmetic_enable, memory_access_enable;\n    wire [7:0] arithmetic_result;\n    wire [15:0] memory_output;\n\n    opcode_decoder decoder (\n        .opcode(opcode),\n        .arithmetic_enable(arithmetic_enable),\n        .memory_access_enable(memory_access_enable)\n    );\n\n    arithmetic_unit arith (\n        .clk(clk),\n        .rst(rst),\n        .enable(arithmetic_enable),\n        .data(data_in),\n        .result(arithmetic_result),\n        .done(operation_executed)\n    );\n\n    memory_access_unit mem_access (\n        .clk(clk),\n        .rst(rst),\n        .enable(memory_access_enable),\n        .data(data_in),\n        .address(memory_output),\n        .done(operation_executed)\n    );\n\n    // Output result based on the type of operation performed\n    assign result = (arithmetic_enable) ? arithmetic_result : 8'd0;\n    assign memory_address = (memory_access_enable) ? memory_output : 16'd0;\n\nendmodule\n\n// Submodule for decoding opcode\nmodule opcode_decoder (\n    input [3:0] opcode,\n    output reg arithmetic_enable,\n    output reg memory_access_enable\n);\n\n    always @(*) begin\n        arithmetic_enable = (opcode < 4'd8);\n        memory_access_enable = (opcode >= 4'd8);\n    end\n\nendmodule\n\n// Submodule for arithmetic operations\nmodule arithmetic_unit (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data,\n    output reg [7:0] result,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            done <= 1'b0;\n        end else if (enable) begin\n            result <= data + 1; // Example operation: Increment\n            done <= 1'b1;\n        end\n    end\n\nendmodule\n\n// Submodule for memory access\nmodule memory_access_unit (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data,\n    output reg [15:0] address,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            address <= 16'd0;\n            done <= 1'b0;\n        end else if (enable) begin\n            address <= {8'd0, data}; // Example operation: Set lower 8 bits\n            done <= 1'b1;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'inst', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'rs2', 'type': 'output port'}, {'id': 8, 'content': 'funct7', 'type': 'output port'}, {'id': 9, 'content': 'imm', 'type': 'output port'}, {'id': 10, 'content': 'i_decoder', 'type': 'submodule'}, {'id': 11, 'content': 's_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2, 2, 2, 2, 11, 2, 10], [10, 11, 3, 4, 5, 6, 7, 8, 9, 9, 9]]\n, A Verilog module for decoding RISC-V instructions into their respective components such as opcode, function codes, and immediate values, catering to different instruction formats. The module handles three types of instruction formats (R, I, S) and segregates their respective fields into output ports.\n\nModule name:\n    riscv_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    inst [31:0]: 32-bit input instruction fetched from instruction memory.\n\nOutput ports:\n    opcode [6:0]: Operation code identifying the type of instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: Function code used for further specification of the instruction.\n    rs1 [4:0]: Source register 1 address.\n    rs2 [4:0]: Source register 2 address (applicable to R and S formats).\n    funct7 [6:0]: Additional function code used in R type instructions.\n    imm [31:0]: Immediate value extracted and sign-extended (used in I and S formats).\n\nImplementation:\n    The module utilizes separate submodules to decode different fields based on the opcode. The opcode determines the instruction format which dictates the decoding path within the submodules.\nGive me the complete code."}, {"from": "gpt", "value": "module riscv_decoder (\n    input clk,\n    input rst,\n    input [31:0] inst,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [6:0] funct7,\n    output [31:0] imm\n);\n\n    // Decode opcode, rd, funct3, rs1, rs2, funct7\n    assign opcode = inst[6:0];\n    assign rd = inst[11:7];\n    assign funct3 = inst[14:12];\n    assign rs1 = inst[19:15];\n    assign rs2 = inst[24:20];\n    assign funct7 = inst[31:25];\n\n    // Submodules for immediate extraction\n    wire [31:0] imm_i, imm_s;\n\n    immediate_decoder_i i_decoder (\n        .inst(inst),\n        .imm_out(imm_i)\n    );\n\n    immediate_decoder_s s_decoder (\n        .inst(inst),\n        .imm_out(imm_s)\n    );\n\n    // Output immediate based on opcode\n    assign imm = (opcode == 7'b0000011 || opcode == 7'b0010011) ? imm_i :  // I-format opcodes\n                 (opcode == 7'b0100011) ? imm_s :                         // S-format opcode\n                 32'b0;\n\nendmodule\n\n// Immediate decoder for I-format\nmodule immediate_decoder_i (\n    input [31:0] inst,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{inst[31]}}, inst[31:20]};\nendmodule\n\n// Immediate decoder for S-format\nmodule immediate_decoder_s (\n    input [31:0] inst,\n    output [31:0] imm_out\n);\n    assign imm_out = {{20{inst[31]}}, inst[31:25], inst[11:7]};\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'mode', 'type': 'input port'}, {'id': 2, 'content': 'imm_val', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[0], [2]]\n, Create a RISC-V immediate value extraction module for handling immediate value decoding from instruction formats I, S, B, and J. The module should take a 32-bit instruction input and decode the immediate value based on the type of instruction, controlled by a 2-bit mode signal.\n\nModule name:\n    immediate_decoder\n\nInput ports:\n    instr [31:0]: 32-bit instruction from which the immediate value is to be decoded.\n    mode [1:0]: Control signal specifying the instruction type (00 for I-type, 01 for S-type, 10 for B-type, 11 for J-type).\n\nOutput ports:\n    imm_val [31:0]: The decoded 32-bit sign-extended immediate value.\n\nImplementation:\n    Immediate values are extracted and sign-extended based on the instruction type indicated by the mode input. The high order bit of the immediate field is replicated through the higher bits for sign extension.\nGive me the complete code."}, {"from": "gpt", "value": "module immediate_decoder (\n    input [31:0] instr,\n    input [1:0] mode,\n    output reg [31:0] imm_val\n);\n\n    always @(*) begin\n        case(mode)\n            2'b00: // I-Type\n                imm_val = {{20{instr[31]}}, instr[30:20]};\n            2'b01: // S-Type\n                imm_val = {{20{instr[31]}}, instr[30:25], instr[11:7]};\n            2'b10: // B-Type\n                imm_val = {{19{instr[31]}}, instr[31], instr[7], instr[30:25], instr[11:8], 1'b0};\n            2'b11: // J-Type\n                imm_val = {{11{instr[31]}}, instr[31], instr[19:12], instr[20], instr[30:21], 1'b0};\n            default:\n                imm_val = 32'b0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'opcode', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'funct3', 'type': 'output port'}, {'id': 6, 'content': 'rs1', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2, 2, 2], [3, 4, 5, 6, 7]]\n, Design a Verilog module for a RISC-V instruction decoder that separates incoming 32-bit instruction into its components, such as opcode, register addresses, and immediate values, specifically for I-type instructions. The module will decode the instruction and provide outputs for each component. \n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal to initialize the output registers.\n    instruction [31:0]: 32-bit input representing the complete instruction.\n\nOutput ports:\n    opcode [6:0]: Opcode of the instruction.\n    rd [4:0]: Destination register address.\n    funct3 [2:0]: 3-bit function field from the instruction.\n    rs1 [4:0]: Source register address.\n    imm [11:0]: 12-bit immediate field extracted from the instruction.\n\nImplementation:\n    The instruction decoder module contains separate smaller modules, each of which is responsible for decoding specific parts of the instruction based on the I-type format. The main module controls these submodules using the clock and reset signals. Each submodule outputs its corresponding part of the instruction which is combined in the top module to form the complete decoded output.\nGive me the complete code."}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst_n,\n    input [31:0] instruction,\n    output [6:0] opcode,\n    output [4:0] rd,\n    output [2:0] funct3,\n    output [4:0] rs1,\n    output [11:0] imm\n);\n\n    // Opcode Decoder\n    assign opcode = instruction[6:0];\n\n    // Destination Register Decoder\n    assign rd = instruction[11:7];\n\n    // Function 3 Decoder\n    assign funct3 = instruction[14:12];\n\n    // Source Register 1 Decoder\n    assign rs1 = instruction[19:15];\n\n    // Immediate Value Decoder\n    assign imm = instruction[31:20];\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'branch', 'type': 'input port'}, {'id': 3, 'content': 'jump', 'type': 'input port'}, {'id': 4, 'content': 'offset', 'type': 'input port'}, {'id': 5, 'content': 'pc', 'type': 'output port'}, {'id': 6, 'content': 'calc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 6, 4, 6], [6, 6, 6, 6, 5]]\n, Design a Verilog module for a RISC-V program counter that handles jumps and branching with additional offset handling. The module will be responsible for updating the program counter based on the provided inputs. \n\nModule name:\n    pc_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset to initialize the program counter.\n    branch: Signal to indicate if a branch is taken.\n    jump: Signal to indicate if a jump is initiated.\n    offset [15:0]: 16-bit sign-extended offset for jump or branch operations.\n\nOutput ports:\n    pc [31:0]: The 32-bit program counter output which will be updated every clock cycle.\n\nImplementation:\n    The program counter module handles the jump and branch operations using a submodule for calculating the new PC value based on the conditions provided by the inputs.\n    If rst is asserted, the program counter is reset to zero.\n    If jump or branch signals are asserted, the program counter is updated based on the provided offset.\n    If neither jump nor branch signals are asserted, the program counter is incremented by 4 (standard instruction length in RISC-V).\nGive me the complete code."}, {"from": "gpt", "value": "module pc_control (\n    input clk,\n    input rst,\n    input branch,\n    input jump,\n    input [15:0] offset,\n    output [31:0] pc\n);\n\n    wire [31:0] new_pc_value;\n\n    pc_calculator calc (\n        .pc_in(pc),\n        .branch(branch),\n        .jump(jump),\n        .offset(offset),\n        .pc_out(new_pc_value)\n    );\n\n    reg [31:0] pc_reg;\n    assign pc = pc_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            pc_reg <= 32'd0;\n        end else begin\n            pc_reg <= new_pc_value;\n        end\n    end\n\nendmodule\n\nmodule pc_calculator (\n    input [31:0] pc_in,\n    input branch,\n    input jump,\n    input [15:0] offset,\n    output [31:0] pc_out\n);\n\n    reg [31:0] pc_temp;\n\n    always @(*) begin\n        if (branch || jump) begin\n            pc_temp = pc_in + {{14{offset[15]}}, offset, 2'b00}; // Sign-extend and calculate new PC\n        end else begin\n            pc_temp = pc_in + 32'd4; // Increment PC by 4\n        end\n    end\n\n    assign pc_out = pc_temp;\n\nendmodule"}]}]