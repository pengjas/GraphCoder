[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl_flag', 'type': 'input port'}, {'id': 3, 'content': 'bus_data', 'type': 'input port'}, {'id': 4, 'content': 'reg1_out', 'type': 'output port'}, {'id': 5, 'content': 'reg2_out', 'type': 'output port'}, {'id': 6, 'content': 'reg1', 'type': 'submodule'}, {'id': 7, 'content': 'reg2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 4, 5]]\n, A data bus control module that processes and directs input signals across multiple registers based on control flags. The module captures data from a bus, storing it into appropriate registers, and extracts specific fields from the registers to be sent to output interfaces.\n\nModule name:\n    data_bus_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize all registers.\n    ctrl_flag [1:0]: Control flag determining the destination register for incoming data.\n    bus_data [15:0]: 16-bit data input from the data bus.\n\nOutput ports:\n    reg1_out [7:0]: Output from the first register representing the lower 8 bits of the bus data.\n    reg2_out [7:0]: Output from the second register representing the upper 8 bits of the bus data.\n\nImplementation:\n    The data bus control module utilizes two submodules, each responsible for storing parts of the bus data into different registers.\n    On the rising edge of the clock (clk), if the reset (rst) is active, all outputs are set to zero.\n    Based on the control flag (ctrl_flag):\n    If ctrl_flag is 2'b01, the bus data is split and stored into the first register (reg1).\n    If ctrl_flag is 2'b10, the bus data is split and stored into the second register (reg2).\n    The outputs reg1_out and reg2_out are derived from the bus data stored in reg1 and reg2 respectively, with reg1_out receiving the lower 8 bits and reg2_out the upper 8 bits.\nGive me the complete code.\nmodule data_bus_control (\n    input clk,\n    input rst,\n    input [1:0] ctrl_flag,\n    input [15:0] bus_data,\n    output [7:0] reg1_out,\n    output [7:0] reg2_out\n);"}, {"from": "gpt", "value": "module data_bus_control (\n    input clk,\n    input rst,\n    input [1:0] ctrl_flag,\n    input [15:0] bus_data,\n    output [7:0] reg1_out,\n    output [7:0] reg2_out\n);\n\n    // Submodule for register storage\n    wire [7:0] reg1_data, reg2_data;\n\n    register_storage reg1 (\n        .clk(clk),\n        .rst(rst),\n        .ctrl_flag(ctrl_flag),\n        .data_in(bus_data[7:0]), // Lower 8 bits of bus data\n        .data_out(reg1_data),\n        .ctrl_code(2'b01) // Control for first register\n    );\n\n    register_storage reg2 (\n        .clk(clk),\n        .rst(rst),\n        .ctrl_flag(ctrl_flag),\n        .data_in(bus_data[15:8]), // Upper 8 bits of bus data\n        .data_out(reg2_data),\n        .ctrl_code(2'b10) // Control for second register\n    );\n\n    // Output assignments\n    assign reg1_out = reg1_data;\n    assign reg2_out = reg2_data;\n\nendmodule\n\n// Submodule for register storage\nmodule register_storage (\n    input clk,\n    input rst,\n    input [1:0] ctrl_flag,\n    input [7:0] data_in,\n    output reg [7:0] data_out,\n    input [1:0] ctrl_code // Code to distinguish control flags\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (ctrl_flag == ctrl_code) begin\n                data_out <= data_in; // Capture incoming data if control code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'data3', 'type': 'input port'}, {'id': 6, 'content': 'critical_data', 'type': 'output port'}, {'id': 7, 'content': 'sensor_type', 'type': 'output port'}, {'id': 8, 'content': 'sensor1', 'type': 'submodule'}, {'id': 9, 'content': 'sensor2', 'type': 'submodule'}, {'id': 10, 'content': 'sensor3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 3, 0, 4, 2, 1, 5, 0, 2, 1, 10, 9, 8], [8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 6, 6, 6]]\n, A control unit for handling multiple sensor inputs and processing them based on priority and type. The control unit will take sensor data from three different sources, decode the priority, and output the most critical sensor data along with its type.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the unit.\n    enable [2:0]: Control signal indicating the active sensor source (bitwise).\n    data1 [7:0], data2 [7:0], data3 [7:0]: 8-bit data inputs from three sensors.\n\nOutput ports:\n    critical_data [7:0]: The most critical sensor data.\n    sensor_type [1:0]: Indicator of the sensor type (00 for data1, 01 for data2, 10 for data3).\n\nImplementation:\n    The control unit is implemented using submodules, each responsible for storing data from different sensors.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the enable signal:\n    Data from the sensor which has its corresponding enable bit set to high is processed; if multiple bits are high, data from the lowest numbered sensor is selected.\n    The outputs critical_data and sensor_type are updated based on the selected sensor data.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [2:0] enable,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] critical_data,\n    output reg [1:0] sensor_type\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [2:0] enable,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] critical_data,\n    output reg [1:0] sensor_type\n);\n\n    // Submodule for sensor data storage\n    wire [7:0] data1_out, data2_out, data3_out;\n\n    sensor_data_storage sensor1 (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable[0]),\n        .data(data1),\n        .data_out(data1_out)\n    );\n\n    sensor_data_storage sensor2 (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable[1]),\n        .data(data2),\n        .data_out(data2_out)\n    );\n\n    sensor_data_storage sensor3 (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable[2]),\n        .data(data3),\n        .data_out(data3_out)\n    );\n\n    // Output logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            critical_data <= 8'd0;\n            sensor_type <= 2'b00;\n        end else begin\n            if (enable[0]) begin\n                critical_data <= data1_out;\n                sensor_type <= 2'b00;\n            end else if (enable[1]) begin\n                critical_data <= data2_out;\n                sensor_type <= 2'b01;\n            end else if (enable[2]) begin\n                critical_data <= data3_out;\n                sensor_type <= 2'b10;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for sensor data storage\nmodule sensor_data_storage (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (enable) begin\n                data_out <= data; // Capture data if enabled\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'ctrl', 'type': 'output port'}, {'id': 5, 'content': 'flag', 'type': 'output port'}, {'id': 6, 'content': 'buffer_out', 'type': 'output port'}, {'id': 7, 'content': 'direct_decoder', 'type': 'submodule'}, {'id': 8, 'content': 'buffer_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 3, 0, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, A data decoder module that interprets and separates incoming data into multiple control and status signals, facilitating subsequent processing in a CPU or control system. This module collects data from either direct input or a memory buffer, decoding into various flags and control bits based on a control signal.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    sel [1:0]: Selection signal determining the data source (0 for direct, 1 for buffer).\n    data_in [15:0]: 16-bit data input to be decoded.\n\nOutput ports:\n    ctrl [3:0]: Control signals extracted from data.\n    flag [3:0]: Status flags derived from data.\n    buffer_out [7:0]: Data from the buffer when sel is high.\n\nImplementation:\n    The data decoder is structured using two submodules, each tasked with processing data from the specified sources.\n    On the rising edge of the clock (clk), if the reset (rst) is active, all outputs are reset to zero.\n    Depending on the sel signal:\n    If sel is 2'b00, data is directly decoded from data_in into the first submodule (direct_decoder).\n    If sel is 2'b01, data is fetched from the buffer and processed in the second submodule (buffer_decoder).\n    If neither condition is met, the previous values in all outputs are maintained.\n    The outputs ctrl, flag, and buffer_out are determined by the respective submodules' processed data.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_in,\n    output [3:0] ctrl,\n    output [3:0] flag,\n    output [7:0] buffer_out\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_in,\n    output [3:0] ctrl,\n    output [3:0] flag,\n    output [7:0] buffer_out\n);\n\n    // Submodules for data decoding\n    wire [15:0] direct_out, buffer_out_wire;\n\n    decode_direct direct_decoder (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_in),\n        .decoded_out(direct_out),\n        .sel_code(2'b00) // Decode direct input\n    );\n\n    decode_buffer buffer_decoder (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_in),\n        .buffer_out(buffer_out_wire),\n        .sel_code(2'b01) // Process buffer data\n    );\n\n    // Output assignments\n    assign ctrl = direct_out[15:12]; // Extract top 4 bits as control signals\n    assign flag = direct_out[11:8];  // Next 4 bits as flags\n    assign buffer_out = buffer_out_wire[7:0]; // 8 bits from buffer output\n\nendmodule\n\n// Submodule for direct data decoding\nmodule decode_direct (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [15:0] decoded_out,\n    input [1:0] sel_code // Code for direct decoding\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_out <= 16'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                decoded_out <= data; // Decode if selection matches\n            end else begin\n                decoded_out <= decoded_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for buffer data processing\nmodule decode_buffer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [7:0] buffer_out,\n    input [1:0] sel_code // Code for buffer processing\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            buffer_out <= 8'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                buffer_out <= data[7:0]; // Process buffer if selection matches\n            end else begin\n                buffer_out <= buffer_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'sensor1_data', 'type': 'input port'}, {'id': 4, 'content': 'sensor2_data', 'type': 'input port'}, {'id': 5, 'content': 'sensor3_data', 'type': 'input port'}, {'id': 6, 'content': 'valid', 'type': 'input port'}, {'id': 7, 'content': 'processed_data', 'type': 'output port'}, {'id': 8, 'content': 'data_valid', 'type': 'output port'}, {'id': 9, 'content': 'proc1', 'type': 'submodule'}, {'id': 10, 'content': 'proc2', 'type': 'submodule'}, {'id': 11, 'content': 'proc3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[6, 3, 0, 1, 6, 4, 0, 1, 6, 5, 0, 1, 11, 10, 9, 11, 10, 9], [9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 7, 7, 7, 8, 8, 8]]\n, A multi-source data selector for capturing and processing sensor signals in an industrial control system. It selects data from multiple sensors and processes it based on priority and signal validity, using parameterized control.\n\nModule name:\n    sensor_data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    sel [1:0]: Control signal to select the sensor source.\n    sensor1_data [15:0]: 16-bit data from sensor 1.\n    sensor2_data [15:0]: 16-bit data from sensor 2.\n    sensor3_data [15:0]: 16-bit data from sensor 3.\n    valid [2:0]: Validity bits for each sensor data (1-valid, 0-invalid).\n\nOutput ports:\n    processed_data [15:0]: Processed output data based on the selected sensor.\n    data_valid: Indicates if the output data is valid.\n\nImplementation:\n    The module includes three submodules, each corresponding to a sensor data input.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the processed_data and data_valid are initialized to zero.\n    Based on the sel signal, the data from the corresponding sensor is selected if its valid bit is high:\n    If sel is 2'b00 and the first sensor's data is valid, data from sensor1_data is used.\n    If sel is 2'b01 and the second sensor's data is valid, data from sensor2_data is selected.\n    If sel is 2'b10 and the third sensor's data is valid, data from sensor3_data is used.\n    If no conditions are met, data_valid is set to 0 indicating no valid data.\n    The processed_data is possibly further processed within each submodule before being output.\nGive me the complete code.\nmodule sensor_data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] sensor1_data,\n    input [15:0] sensor2_data,\n    input [15:0] sensor3_data,\n    input [2:0] valid,\n    output reg [15:0] processed_data,\n    output reg data_valid\n);"}, {"from": "gpt", "value": "module sensor_data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] sensor1_data,\n    input [15:0] sensor2_data,\n    input [15:0] sensor3_data,\n    input [2:0] valid,\n    output reg [15:0] processed_data,\n    output reg data_valid\n);\n\n    // Submodules for each sensor data processing\n    wire [15:0] data1_out, data2_out, data3_out;\n\n    sensor_processor proc1 (\n        .clk(clk),\n        .rst(rst),\n        .data(sensor1_data),\n        .valid(valid[0]),\n        .data_out(data1_out)\n    );\n\n    sensor_processor proc2 (\n        .clk(clk),\n        .rst(rst),\n        .data(sensor2_data),\n        .valid(valid[1]),\n        .data_out(data2_out)\n    );\n\n    sensor_processor proc3 (\n        .clk(clk),\n        .rst(rst),\n        .data(sensor3_data),\n        .valid(valid[2]),\n        .data_out(data3_out)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            processed_data <= 16'd0;\n            data_valid <= 1'b0;\n        end else begin\n            case(sel)\n                2'b00: if (valid[0]) {processed_data, data_valid} <= {data1_out, 1'b1};\n                2'b01: if (valid[1]) {processed_data, data_valid} <= {data2_out, 1'b1};\n                2'b10: if (valid[2]) {processed_data, data_valid} <= {data3_out, 1'b1};\n                default: data_valid <= 1'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule sensor_processor (\n    input clk,\n    input rst,\n    input [15:0] data,\n    input valid,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0;\n        end else if (valid) begin\n            data_out <= data; // Process data if valid\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'dataA', 'type': 'input port'}, {'id': 4, 'content': 'dataB', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'tag', 'type': 'output port'}, {'id': 7, 'content': 'sourceA', 'type': 'submodule'}, {'id': 8, 'content': 'sourceB', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 3, 4, 2, 0, 1, 7, 2, 8, 7, 2, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, Design a multi-source data capture module for a digital communication system. It should accommodate two data sources and a control signal to select which source to use. Extract and deliver distinct data fields from each source.\n\nModule name:\n    multi_source_capture\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    select [1:0]: Control signal to select the data source (1 for Source A, 2 for Source B).\n    dataA [15:0]: 16-bit data input from Source A.\n    dataB [15:0]: 16-bit data input from Source B.\n\nOutput ports:\n    data_out [7:0]: 8-bit extracted data output.\n    tag [3:0]: 4-bit field extracted as a tag from the selected data source.\n\nImplementation:\n    The module utilizes two submodules, each responsible for processing data from one of the sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the select signal:\n    If select is 2'b01, data is fetched from the dataA input into the first submodule (process_source_A).\n    If select is 2'b10, data is fetched from the dataB input into the second submodule (process_source_B).\n    If neither condition is met, the previous values in both outputs are retained.\n    The outputs data_out and tag are derived from the outputs of the active submodule based on the select signal.\nGive me the complete code.\nmodule multi_source_capture (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] dataA,\n    input [15:0] dataB,\n    output [7:0] data_out,\n    output [3:0] tag\n);"}, {"from": "gpt", "value": "module multi_source_capture (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] dataA,\n    input [15:0] dataB,\n    output [7:0] data_out,\n    output [3:0] tag\n);\n\n    // Submodule outputs\n    wire [7:0] data_out_A, data_out_B;\n    wire [3:0] tag_A, tag_B;\n\n    // Submodule for Source A processing\n    source_processor sourceA (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(dataA),\n        .data_out(data_out_A),\n        .tag_out(tag_A),\n        .select_code(2'b01) // Process Source A\n    );\n\n    // Submodule for Source B processing\n    source_processor sourceB (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(dataB),\n        .data_out(data_out_B),\n        .tag_out(tag_B),\n        .select_code(2'b10) // Process Source B\n    );\n\n    // Output assignments based on select\n    assign data_out = (select == 2'b01) ? data_out_A : (select == 2'b10) ? data_out_B : 8'd0;\n    assign tag = (select == 2'b01) ? tag_A : (select == 2'b10) ? tag_B : 4'd0;\n\nendmodule\n\n// Submodule for processing each data source\nmodule source_processor (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data,\n    output reg [7:0] data_out,\n    output reg [3:0] tag_out,\n    input [1:0] select_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset outputs\n            tag_out <= 4'd0;\n        end else begin\n            if (select == select_code) begin\n                data_out <= data[15:8]; // Capture high 8 bits as data\n                tag_out <= data[3:0]; // Capture low 4 bits as tag\n            end else begin\n                data_out <= data_out; // Retain previous values\n                tag_out <= tag_out;\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'cmd', 'type': 'input port'}, {'id': 3, 'content': 'state', 'type': 'input port'}, {'id': 4, 'content': 'en_exec', 'type': 'output port'}, {'id': 5, 'content': 'en_mem', 'type': 'output port'}, {'id': 6, 'content': 'en_io', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 7, 7, 7], [7, 7, 4, 5, 6]]\n, Design a control unit for a microprocessor that processes control signals and outputs appropriate commands to other parts of the system. It should decode input commands from a control bus and produce multiple control signals based on the microprocessor's operational state and external inputs.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    cmd [3:0]: 4-bit command input representing different control operations.\n    state [1:0]: 2-bit input representing the current state of the microprocessor.\n\nOutput ports:\n    en_exec: Enable signal for the execution unit.\n    en_mem: Enable signal for the memory unit.\n    en_io: Enable signal for the I/O unit.\n\nImplementation:\n    The control unit decodes the input command and the microprocessor state to generate specific enable signals.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all output enable signals are set to zero.\n    The unit includes a submodule for decoding commands which outputs control flags based on the command and state inputs.\n    The flags are then used to set the respective enable signals for execution, memory, and I/O units.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [3:0] cmd,\n    input [1:0] state,\n    output reg en_exec,\n    output reg en_mem,\n    output reg en_io\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [3:0] cmd,\n    input [1:0] state,\n    output reg en_exec,\n    output reg en_mem,\n    output reg en_io\n);\n\n    // Submodule for command decoding\n    wire [2:0] control_flags;\n\n    command_decoder decoder (\n        .cmd(cmd),\n        .state(state),\n        .flags_out(control_flags)\n    );\n\n    // Control logic based on decoded flags\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            en_exec <= 1'b0;\n            en_mem <= 1'b0;\n            en_io <= 1'b0;\n        end else begin\n            en_exec <= control_flags[0];\n            en_mem <= control_flags[1];\n            en_io <= control_flags[2];\n        end\n    end\n\nendmodule\n\n// Submodule for decoding commands based on the microprocessor's state\nmodule command_decoder (\n    input [3:0] cmd,\n    input [1:0] state,\n    output reg [2:0] flags_out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: flags_out = 3'b000; // default state\n            2'b01: begin // Example state processing\n                case (cmd)\n                    4'b0001: flags_out = 3'b110; // Enable exec and mem\n                    4'b0010: flags_out = 3'b101; // Enable exec and io\n                    default: flags_out = 3'b000;\n                endcase\n            end\n            2'b10: begin\n                case (cmd)\n                    4'b0100: flags_out = 3'b011; // Enable mem and io\n                    default: flags_out = 3'b000;\n                endcase\n            end\n            default: flags_out = 3'b000;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'field1', 'type': 'output port'}, {'id': 5, 'content': 'field2', 'type': 'output port'}, {'id': 6, 'content': 'status', 'type': 'output port'}, {'id': 7, 'content': 'dp1', 'type': 'submodule'}, {'id': 8, 'content': 'dp2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, Design a multi-source data capture unit in Verilog to selectively read and store data from different peripherals based on control signals, and output specific data fields after processing.\n\nModule name:\n    data_capture_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the unit.\n    select [2:0]: Control signal to select the data source (e.g., 3'b001 for sensor, 3'b010 for memory).\n    data_in [15:0]: 16-bit input data from peripherals.\n\nOutput ports:\n    field1 [7:0]: Extracted byte representing a processed high priority data field.\n    field2 [3:0]: Extracted nibble representing a secondary data field.\n    status [1:0]: Status bits indicating the processing results or error states.\n\nImplementation:\n    The data capture unit is implemented using two submodules, each responsible for capturing data from a designated set of peripherals.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all outputs are initialized to zero.\n    Based on the select signal:\n    If select is 3'b001 or 3'b010, the data is captured from the input data_in into the first submodule (data_processor1).\n    If select is 3'b100 or 3'b101, the data is captured from the data_in into the second submodule (data_processor2).\n    The outputs field1, field2, and status are derived from the processed data in the respective submodules.\nGive me the complete code.\nmodule data_capture_unit (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] field1,\n    output [3:0] field2,\n    output [1:0] status\n);"}, {"from": "gpt", "value": "module data_capture_unit (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] field1,\n    output [3:0] field2,\n    output [1:0] status\n);\n\n    // Submodule for data processing\n    wire [15:0] dp1_out, dp2_out;\n\n    data_processor dp1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(data_in),\n        .data_out(dp1_out),\n        .select_code(3'b001) // Priority peripherals\n    );\n\n    data_processor dp2 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(data_in),\n        .data_out(dp2_out),\n        .select_code(3'b100) // Secondary peripherals\n    );\n\n    // Output assignments\n    assign field1 = dp1_out[15:8]; // High byte, priority data\n    assign field2 = dp1_out[3:0];  // Low nibble, minor data\n    assign status = dp2_out[1:0];  // Status from secondary data source\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    input [2:0] select_code // Code to distinguish data sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= data_in; // Capture data if select code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'address', 'type': 'output port'}, {'id': 5, 'content': 'command', 'type': 'output port'}, {'id': 6, 'content': 'ext_decode', 'type': 'submodule'}, {'id': 7, 'content': 'int_decode', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 7, 2, 6, 7, 2, 6], [6, 6, 6, 6, 7, 7, 7, 7, 4, 4, 4, 5, 5, 5]]\n, A data decoder module designed to interface with a memory unit and a processing unit, decoding the memory addresses and control signals. It is responsible for decoding the input data based on the source specified by control signals and distributing it to multiple output channels.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    select [1:0]: Control signal to select the source of data (0 for external, 1 for internal memory).\n    data_in [15:0]: 16-bit input data that needs decoding.\n\nOutput ports:\n    address [7:0]: 8-bit address extracted from the data.\n    command [7:0]: 8-bit command field extracted from the data.\n\nImplementation:\n    The data decoder module utilizes internal submodules for processing different sources of data.\n    On the rising edge of the clock (clk), if the reset (rst) is active, the outputs address and command are reset to zero.\n    Based on the select signal:\n    If select is 2'b00, data is decoded from the external source submodule (ext_decode).\n    If select is 2'b01, data is decoded from the internal memory submodule (int_decode).\n    The outputs address and command are calculated based on the decoded outputs from the respective submodule.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output [7:0] address,\n    output [7:0] command\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output [7:0] address,\n    output [7:0] command\n);\n\n    // Submodule outputs\n    wire [7:0] address_ext, command_ext;\n    wire [7:0] address_int, command_int;\n\n    // Submodule for external data decoding\n    decode_module ext_decode (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .decoded_address(address_ext),\n        .decoded_command(command_ext),\n        .select_code(2'b00) // Decode from external source\n    );\n\n    // Submodule for internal data decoding\n    decode_module int_decode (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .decoded_address(address_int),\n        .decoded_command(command_int),\n        .select_code(2'b01) // Decode from internal memory\n    );\n\n    // Output assignments based on selected source\n    assign address = (select == 2'b00) ? address_ext : address_int;\n    assign command = (select == 2'b00) ? command_ext : command_int;\n\nendmodule\n\n// Submodule for decoding data\nmodule decode_module (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data,\n    output reg [7:0] decoded_address,\n    output reg [7:0] decoded_command,\n    input [1:0] select_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_address <= 8'd0; // Initialize address\n            decoded_command <= 8'd0; // Initialize command\n        end else begin\n            if (select == select_code) begin\n                decoded_address <= data[15:8]; // Decode address from high byte\n                decoded_command <= data[7:0];  // Decode command from low byte\n            end else begin\n                decoded_address <= decoded_address; // Retain previous values\n                decoded_command <= decoded_command;\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'exec_stage', 'type': 'input port'}, {'id': 3, 'content': 'instr', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'operand', 'type': 'output port'}, {'id': 6, 'content': 'opcode_dec', 'type': 'submodule'}, {'id': 7, 'content': 'operand_ext', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 2, 3, 0, 1, 2, 6, 2, 7, 2], [6, 6, 6, 6, 7, 7, 7, 7, 4, 4, 5, 5]]\n, A control unit module responsible for managing execution stages in a simple processor. This module determines the current stage based on control signals and processes instruction stages via submodules, dividing instruction into opcode and operand parts.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the control unit.\n    exec_stage [1:0]: Control signal indicating the current execution stage (00 for fetch, 01 for decode, 10 for execute).\n    instr [15:0]: 16-bit instruction input containing both operation and data.\n\nOutput ports:\n    opcode [3:0]: 4 bits representing the type of operation.\n    operand [11:0]: 12 bits representing the data or address.\n\nImplementation:\n    The control unit uses two submodules, one for decoding the opcode and the other for extracting the operand.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs opcode and operand are initialized to zero.\n    Based on the exec_stage signal:\n    If exec_stage is 2'b00, the instruction is fetched but not processed.\n    If exec_stage is 2'b01, the instruction is decoded into opcode and operand by corresponding submodules.\n    If exec_stage is 2'b10, the previous stage outputs are retained, preparing for execution.\n    The outputs opcode and operand are driven by the decoded results from submodules during the decode stage.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output [3:0] opcode,\n    output [11:0] operand\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output [3:0] opcode,\n    output [11:0] operand\n);\n\n    // Submodules for instruction processing\n    wire [3:0] opcode_out;\n    wire [11:0] operand_out;\n\n    opcode_decoder opcode_dec (\n        .clk(clk),\n        .rst(rst),\n        .exec_stage(exec_stage),\n        .instr(instr),\n        .opcode_out(opcode_out)\n    );\n\n    operand_extractor operand_ext (\n        .clk(clk),\n        .rst(rst),\n        .exec_stage(exec_stage),\n        .instr(instr),\n        .operand_out(operand_out)\n    );\n\n    // Output assignments\n    assign opcode = (exec_stage == 2'b01) ? opcode_out : 4'b0000;\n    assign operand = (exec_stage == 2'b01) ? operand_out : 12'b000000000000;\n\nendmodule\n\n// Submodule for opcode decoding\nmodule opcode_decoder (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output reg [3:0] opcode_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            opcode_out <= 4'd0; // Reset output\n        end else if (exec_stage == 2'b01) begin\n            opcode_out <= instr[15:12]; // Decode opcode from high bits\n        end\n    end\n\nendmodule\n\n// Submodule for operand extraction\nmodule operand_extractor (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output reg [11:0] operand_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            operand_out <= 12'd0; // Reset output\n        end else if (exec_stage == 2'b01) begin\n            operand_out <= instr[11:0]; // Extract operand from low bits\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'src1', 'type': 'input port'}, {'id': 4, 'content': 'src2', 'type': 'input port'}, {'id': 5, 'content': 'output_data', 'type': 'output port'}, {'id': 6, 'content': 'hold1', 'type': 'submodule'}, {'id': 7, 'content': 'hold2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 0, 1, 4, 6, 7], [6, 6, 6, 7, 7, 7, 5, 5]]\n, A data selector module that selects and outputs data based on the specified control signals. It uses register-based storage to hold the current state of data inputs from two distinct sources and outputs the selected data synchronized with the clock signal.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the registers.\n    sel [1:0]: Control signal for selecting the data source (0 for none, 1 for source 1, 2 for source 2).\n    src1 [7:0]: 8-bit data input from the first data source.\n    src2 [7:0]: 8-bit data input from the second data source.\n\nOutput ports:\n    output_data [7:0]: Output port to provide the selected data.\n\nImplementation:\n    The data selector is implemented using two submodules, each responsible for holding data from a particular source.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both data outputs are initialized to zero.\n    Based on the sel signal:\n    If sel is 2'b01, the data from the first submodule (data_holder1) is selected.\n    If sel is 2'b10, the data from the second submodule (data_holder2) is selected.\n    If sel is 2'b00, output_data is set to zero.\n    The output output_data is assigned the value from the selected submodule.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] output_data\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] output_data\n);\n\n    // Submodule instances for data holding\n    wire [7:0] data_out1, data_out2;\n\n    data_holder hold1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(src1),\n        .data_out(data_out1)\n    );\n\n    data_holder hold2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(src2),\n        .data_out(data_out2)\n    );\n\n    // Output selection logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output_data <= 8'd0; // Reset data output\n        end else begin\n            case (sel)\n                2'b01: output_data <= data_out1;\n                2'b10: output_data <= data_out2;\n                default: output_data <= 8'd0;\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for data holding\nmodule data_holder (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset data output\n        end else begin\n            data_out <= data_in; // Hold incoming data\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sensor1', 'type': 'input port'}, {'id': 3, 'content': 'sensor2', 'type': 'input port'}, {'id': 4, 'content': 'control_enable', 'type': 'input port'}, {'id': 5, 'content': 'control_out', 'type': 'output port'}, {'id': 6, 'content': 'status_flags', 'type': 'output port'}, {'id': 7, 'content': 'sensor_proc1', 'type': 'submodule'}, {'id': 8, 'content': 'sensor_proc2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 4, 0, 3, 1, 4, 7, 8, 7, 8, 4], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 6, 6, 6]]\n, A register-based control system designed to manage signals from multiple sensors and adjust control outputs based on combined sensor inputs. It utilizes submodules to process each sensor's data, maintain state using registers, and output control signals after processing.\n\nModule name:\n    multi_sensor_controller\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    sensor1 [7:0]: 8-bit data input from the first sensor.\n    sensor2 [7:0]: 8-bit data input from the second sensor.\n    control_enable [1:0]: Control signal to enable processing for each sensor (1 for active).\n\nOutput ports:\n    control_out [2:0]: Control output signals derived from sensor inputs.\n    status_flags [1:0]: Status flags indicating the operational state.\n\nImplementation:\n    The multi_sensor_controller uses submodules, each processing the input from one sensor.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    When control_enable signals are active, corresponding sensor data is processed in the respective submodules.\n    Control outputs and status flags are updated based on the processed data from both submodules.\nGive me the complete code.\nmodule multi_sensor_controller (\n    input clk,\n    input rst,\n    input [7:0] sensor1,\n    input [7:0] sensor2,\n    input [1:0] control_enable,\n    output [2:0] control_out,\n    output [1:0] status_flags\n);"}, {"from": "gpt", "value": "module multi_sensor_controller (\n    input clk,\n    input rst,\n    input [7:0] sensor1,\n    input [7:0] sensor2,\n    input [1:0] control_enable,\n    output [2:0] control_out,\n    output [1:0] status_flags\n);\n\n    // Submodule for sensor data processing\n    wire [7:0] sensor1_processed, sensor2_processed;\n\n    sensor_processing sensor_proc1 (\n        .clk(clk),\n        .rst(rst),\n        .sensor_data(sensor1),\n        .process_enable(control_enable[0]),\n        .processed_data(sensor1_processed)\n    );\n\n    sensor_processing sensor_proc2 (\n        .clk(clk),\n        .rst(rst),\n        .sensor_data(sensor2),\n        .process_enable(control_enable[1]),\n        .processed_data(sensor2_processed)\n    );\n\n    // Output assignments\n    assign control_out = (sensor1_processed[7:5] & sensor2_processed[7:5]); // Combine and process control signals\n    assign status_flags[0] = control_enable[0] & (sensor1_processed != 8'd0); // Status flag for sensor 1\n    assign status_flags[1] = control_enable[1] & (sensor2_processed != 8'd0); // Status flag for sensor 2\n\nendmodule\n\n// Submodule for processing sensor data\nmodule sensor_processing (\n    input clk,\n    input rst,\n    input [7:0] sensor_data,\n    input process_enable,\n    output reg [7:0] processed_data\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            processed_data <= 8'd0; // Reset output\n        end else if (process_enable) begin\n            processed_data <= sensor_data; // Process and store data if enabled\n        end else begin\n            processed_data <= processed_data; // Retain previous value\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'carry_out', 'type': 'output port'}, {'id': 7, 'content': 'alu', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 3, 7, 7], [7, 7, 7, 5, 6]]\n, Design a multi-functional arithmetic logic unit (ALU) capable of performing different arithmetic and bitwise operations based on a control signal. The module should also include multiple data source inputs and register-based storage for intermediate results, using synchronous reset for initializing registers.\n\nModule name:\n    multi_func_alu\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize internal registers.\n    op_code [3:0]: Control signal to select the operation (e.g., add, subtract, and, or).\n    data1 [7:0], data2 [7:0]: Two 8-bit data inputs for arithmetic operations.\n\nOutput ports:\n    result [7:0]: The result of the selected ALU operation.\n    carry_out: Carry output for operations like addition and subtraction.\n\nImplementation:\n    The ALU uses a submodule for performing the arithmetic and bitwise operations.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the result and carry_out are initialized to zero.\n    Based on the op_code:\n    - 4'b0001: Perform addition of data1 and data2.\n    - 4'b0010: Perform subtraction of data1 from data2.\n    - 4'b0100: Perform bitwise AND of data1 and data2.\n    - 4'b1000: Perform bitwise OR of data1 and data2.\n    The results of these operations are stored in a register and outputted through result and carry_out, based on the operation performed.\nGive me the complete code.\nmodule multi_func_alu (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result,\n    output reg carry_out\n);"}, {"from": "gpt", "value": "module multi_func_alu (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result,\n    output reg carry_out\n);\n\n    // Submodule for ALU operations\n    wire [7:0] alu_result;\n    wire alu_carry;\n\n    alu_core alu (\n        .data1(data1),\n        .data2(data2),\n        .op_code(op_code),\n        .result(alu_result),\n        .carry_out(alu_carry)\n    );\n\n    // Result storage and output assignment\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            carry_out <= 1'b0;\n        end else begin\n            result <= alu_result;\n            carry_out <= alu_carry;\n        end\n    end\n\nendmodule\n\n// Submodule for ALU core operations\nmodule alu_core (\n    input [7:0] data1,\n    input [7:0] data2,\n    input [3:0] op_code,\n    output reg [7:0] result,\n    output reg carry_out\n);\n\n    always @* begin\n        case(op_code)\n            4'b0001: {carry_out, result} = data1 + data2; // Addition\n            4'b0010: {carry_out, result} = data1 - data2; // Subtraction\n            4'b0100: result = data1 & data2; // Bitwise AND\n            4'b1000: result = data1 | data2; // Bitwise OR\n            default: result = 8'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl_bus', 'type': 'input port'}, {'id': 3, 'content': 'decode', 'type': 'output port'}, {'id': 4, 'content': 'exec_cmd', 'type': 'output port'}, {'id': 5, 'content': 'cpu_state', 'type': 'output port'}, {'id': 6, 'content': 'decoder', 'type': 'submodule'}, {'id': 7, 'content': 'executor', 'type': 'submodule'}, {'id': 8, 'content': 'state_manage', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 6, 0, 1, 7, 0, 1, 6, 7, 8], [6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 4, 5]]\n, Design a control unit for a CPU that manages instruction decoding and execution flow based on incoming command signals. This module should capture commands from a control bus, decode them into executable signals for different operational units, and manage the CPU state with register-based tracking.\n\nModule name:\n    cpu_control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    ctrl_bus [15:0]: 16-bit control bus input carrying command signals.\n\nOutput ports:\n    decode [3:0]: Signals representing decoded instruction types.\n    exec_cmd [7:0]: Execution commands for the CPU's operational units.\n    cpu_state [2:0]: Indicates the current state of the CPU.\n\nImplementation:\n    The CPU control unit uses multiple submodules for decoding and executing commands.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Commands from the ctrl_bus are first passed to a decoding submodule that translates them into discrete signals (decode).\n    Based on the decoded signals, another submodule generates specific execution commands (exec_cmd).\n    A third submodule tracks and updates the CPU state (cpu_state) based on command execution progress.\nGive me the complete code.\nmodule cpu_control_unit (\n    input clk,\n    input rst,\n    input [15:0] ctrl_bus,\n    output [3:0] decode,\n    output [7:0] exec_cmd,\n    output [2:0] cpu_state\n);"}, {"from": "gpt", "value": "module cpu_control_unit (\n    input clk,\n    input rst,\n    input [15:0] ctrl_bus,\n    output [3:0] decode,\n    output [7:0] exec_cmd,\n    output [2:0] cpu_state\n);\n\n    // Submodule for command decoding\n    wire [3:0] decoded_signals;\n    command_decoder decoder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl_bus(ctrl_bus),\n        .decoded_out(decoded_signals)\n    );\n\n    // Submodule for command execution\n    wire [7:0] execution_commands;\n    command_executor executor (\n        .clk(clk),\n        .rst(rst),\n        .decoded_signals(decoded_signals),\n        .exec_cmd_out(execution_commands)\n    );\n\n    // Submodule for CPU state management\n    wire [2:0] state_output;\n    state_tracker state_manage (\n        .clk(clk),\n        .rst(rst),\n        .executing_cmd(execution_commands),\n        .state_out(state_output)\n    );\n\n    // Output assignments\n    assign decode = decoded_signals;\n    assign exec_cmd = execution_commands;\n    assign cpu_state = state_output;\n\nendmodule\n\n// Submodule for command decoding\nmodule command_decoder (\n    input clk,\n    input rst,\n    input [15:0] ctrl_bus,\n    output reg [3:0] decoded_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_out <= 4'd0; // Reset output\n        end else begin\n            // Decoding logic based on control bus\n            decoded_out <= ctrl_bus[15:12]; // Simple example of decoding\n        end\n    end\n\nendmodule\n\n// Submodule for executing commands\nmodule command_executor (\n    input clk,\n    input rst,\n    input [3:0] decoded_signals,\n    output reg [7:0] exec_cmd_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            exec_cmd_out <= 8'd0; // Reset output\n        end else begin\n            // Execution command logic based on decoded signals\n            exec_cmd_out <= {decoded_signals, 4'd0}; // Example: augment with zeroes\n        end\n    end\n\nendmodule\n\n// Submodule for state tracking\nmodule state_tracker (\n    input clk,\n    input rst,\n    input [7:0] executing_cmd,\n    output reg [2:0] state_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            state_out <= 3'd0; // Reset state\n        end else begin\n            // State update logic\n            state_out <= (executing_cmd[7:5] != 3'd0) ? 3'd1 : 3'd2; // Simplified state logic\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'src_sel', 'type': 'input port'}, {'id': 4, 'content': 'data_a', 'type': 'input port'}, {'id': 5, 'content': 'data_b', 'type': 'input port'}, {'id': 6, 'content': 'result_add', 'type': 'output port'}, {'id': 7, 'content': 'result_sub', 'type': 'output port'}, {'id': 8, 'content': 'df_a', 'type': 'submodule'}, {'id': 9, 'content': 'df_b', 'type': 'submodule'}, {'id': 10, 'content': 'add_module', 'type': 'submodule'}, {'id': 11, 'content': 'sub_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 3, 5, 1, 0, 3, 9, 1, 8, 2, 0, 9, 1, 8, 2, 0, 10, 11], [8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 6, 7]]\n, Design a data processor module that accepts binary data for arithmetic operations and decodes it based on operation code. The module should support addition and subtraction, handle data inputs from different sources, and provide output separately for each operation.\n\nModule name:\n    data_processor\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the processor.\n    op_code [1:0]: Control signal indicating the type of arithmetic operation (00 for addition, 01 for subtraction).\n    src_sel [1:0]: Control signal to select the source of data inputs (1 for internal register, 2 for external input).\n    data_a [7:0]: 8-bit data input A.\n    data_b [7:0]: 8-bit data input B.\n\nOutput ports:\n    result_add [7:0]: 8-bit result of the addition operation.\n    result_sub [7:0]: 8-bit result of the subtraction operation.\n\nImplementation:\n    The data processor is implemented using submodules for each arithmetic operation.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the op_code signal:\n    If op_code is 2'b00, the addition operation is triggered.\n    If op_code is 2'b01, the subtraction operation is performed.\n    Based on the src_sel signal, data inputs are fetched from either an internal register or an external source before processing.\n    The results from each operation are stored in separate outputs.\nGive me the complete code.\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [1:0] src_sel,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [7:0] result_add,\n    output [7:0] result_sub\n);"}, {"from": "gpt", "value": "module data_processor (\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [1:0] src_sel,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [7:0] result_add,\n    output [7:0] result_sub\n);\n\n    // Submodule for adder and subtractor\n    wire [7:0] data_a_int, data_b_int;\n\n    data_fetch df_a (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data_in(data_a),\n        .data_out(data_a_int)\n    );\n\n    data_fetch df_b (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data_in(data_b),\n        .data_out(data_b_int)\n    );\n\n    adder add_module (\n        .clk(clk),\n        .rst(rst),\n        .enable(op_code == 2'b00),\n        .data_a(data_a_int),\n        .data_b(data_b_int),\n        .result(result_add)\n    );\n\n    subtractor sub_module (\n        .clk(clk),\n        .rst(rst),\n        .enable(op_code == 2'b01),\n        .data_a(data_a_int),\n        .data_b(data_b_int),\n        .result(result_sub)\n    );\n\nendmodule\n\n// Submodule for data fetching\nmodule data_fetch (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset data\n        end else begin\n            data_out <= data_in; // Direct data assignment\n        end\n    end\n\nendmodule\n\n// Submodule for addition\nmodule adder (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n        end else if (enable) begin\n            result <= data_a + data_b;\n        end\n    end\n\nendmodule\n\n// Submodule for subtraction\nmodule subtractor (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n        end else if (enable) begin\n            result <= data_a - data_b;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'src_sel', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'data_A', 'type': 'output port'}, {'id': 5, 'content': 'data_B', 'type': 'output port'}, {'id': 6, 'content': 'data_C', 'type': 'output port'}, {'id': 7, 'content': 'sensor_A', 'type': 'submodule'}, {'id': 8, 'content': 'sensor_B', 'type': 'submodule'}, {'id': 9, 'content': 'sensor_C', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 7, 8, 9], [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 5, 6]]\n, A multi-source data capture unit for capturing and processing input data from multiple peripherals. This module should be able to distinguish between different data sources, capturing and storing data separately before processing. The processed outputs are then split into various bit-width fields for different uses.\n\nModule name:\n    data_capture_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    src_sel [1:0]: Control signal indicating the source of data (0 for Sensor A, 1 for Sensor B, 2 for Sensor C).\n    data_in [15:0]: 16-bit data input from the selected peripheral.\n\nOutput ports:\n    data_A [3:0]: Processed data from Sensor A, 4 bits.\n    data_B [7:0]: Processed data from Sensor B, 8 bits.\n    data_C [15:0]: Raw data from Sensor C, 16 bits.\n\nImplementation:\n    The data capture unit uses three submodules to store and process data from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all data outputs are initialized to zero.\n    Depending on the src_sel signal:\n    If src_sel is 2'b00, data from data_in is captured by the first submodule (sensor_A_proc).\n    If src_sel is 2'b01, data from data_in is captured by the second submodule (sensor_B_proc).\n    If src_sel is 2'b10, data from data_in is captured by the third submodule (sensor_C_proc).\n    The outputs data_A, data_B, and data_C are derived from the processed or stored data in the respective submodules.\nGive me the complete code.\nmodule data_capture_unit (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [15:0] data_in,\n    output [3:0] data_A,\n    output [7:0] data_B,\n    output [15:0] data_C\n);"}, {"from": "gpt", "value": "module data_capture_unit (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [15:0] data_in,\n    output [3:0] data_A,\n    output [7:0] data_B,\n    output [15:0] data_C\n);\n\n    // Submodules for data processing\n    wire [15:0] sensor_A_out, sensor_B_out, sensor_C_out;\n\n    data_processor sensor_A (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data(data_in),\n        .data_out(sensor_A_out),\n        .sel_code(2'b00) // Data from Sensor A\n    );\n\n    data_processor sensor_B (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data(data_in),\n        .data_out(sensor_B_out),\n        .sel_code(2'b01) // Data from Sensor B\n    );\n\n    data_processor sensor_C (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data(data_in),\n        .data_out(sensor_C_out),\n        .sel_code(2'b10) // Data from Sensor C\n    );\n\n    // Output assignments\n    assign data_A = sensor_A_out[3:0]; // Processed 4 bits from Sensor A\n    assign data_B = sensor_B_out[7:0]; // Processed 8 bits from Sensor B\n    assign data_C = sensor_C_out;      // Raw 16 bits from Sensor C\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [1:0] sel_code // Code to distinguish data sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (src_sel == sel_code) begin\n                data_out <= data; // Capture data if source code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'out_data', 'type': 'output port'}, {'id': 6, 'content': 'select_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 4, 3, 6], [6, 6, 6, 5]]\n, A multiplexer for selecting data from multiple input sources to a central processing unit, controlled by a programmable select signal, and storing the output in a register for subsequent operations.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    sel [1:0]: Control signal to select data source.\n    data1 [7:0]: 8-bit data input from the first source.\n    data2 [7:0]: 8-bit data input from the second source.\n\nOutput ports:\n    out_data [7:0]: Selected data output stored in the register.\n\nImplementation:\n    The data selection is handled by a submodule that determines which data source to use based on the sel signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the output register (out_data) is initialized to zero.\n    The output out_data is updated with data from the selected source whenever there's a change in the selection or the input data.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] out_data\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] out_data\n);\n\n    // Submodule for selecting data\n    wire [7:0] selected_data;\n\n    data_mux select_unit (\n        .sel(sel),\n        .data1(data1),\n        .data2(data2),\n        .selected_output(selected_data)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out_data <= 8'd0; // Reset output\n        end else begin\n            out_data <= selected_data; // Update register with selected data\n        end\n    end\n\nendmodule\n\n// Submodule for data multiplexing\nmodule data_mux (\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] selected_output\n);\n\n    always @(*) begin\n        case (sel)\n            2'b01: selected_output = data1;\n            2'b10: selected_output = data2;\n            default: selected_output = 8'd0; // Default to zero if no valid selection\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'inst_data', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'operand1', 'type': 'output port'}, {'id': 6, 'content': 'operand2', 'type': 'output port'}, {'id': 7, 'content': 'dec1', 'type': 'submodule'}, {'id': 8, 'content': 'dec2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 3, 2, 0, 1, 3, 8, 7, 2, 7, 8, 2, 8, 7, 2], [7, 7, 7, 7, 8, 8, 8, 8, 4, 4, 4, 5, 5, 5, 6, 6, 6]]\n, A multi-source instruction decoder for decoding operation codes (opcodes) from a central instruction registry that stores and parses inputs from various sources such as immediate values, memory, or peripherals. This module should include handling and storage of instructions with parameterized control over decoding behavior.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    fetch [1:0]: Control signal indicating the source of the instruction to be decoded.\n    inst_data [15:0]: 16-bit data input representing the complete instruction.\n\nOutput ports:\n    opcode [3:0]: Extracted 4-bit opcode indicating the type of operation.\n    operand1 [5:0]: Extracted 6-bit field, usually an address or an immediate value.\n    operand2 [5:0]: Extracted secondary 6-bit field, may represent an additional operand.\n\nImplementation:\n    The opcode_decoder utilizes submodules for handling the decoding from different instruction sources, synchronizing on the rising edge of the clock (clk).\n    If the reset (rst) signal is low, all outputs are initialized to zero.\n    The submodule responsible for decoding is selected based on the fetch signal:\n    If fetch is 2'b01, the instruction is decoded from immediate value source.\n    If fetch is 2'b10, the instruction is decoded from a memory source.\n    The outputs opcode, operand1, and operand2 are derived from the instruction data based on the active decoding path.\nGive me the complete code.\nmodule opcode_decoder (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] inst_data,\n    output [3:0] opcode,\n    output [5:0] operand1,\n    output [5:0] operand2\n);"}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] inst_data,\n    output [3:0] opcode,\n    output [5:0] operand1,\n    output [5:0] operand2\n);\n\n    // Submodule for opcode decoding\n    wire [15:0] decode_out_immediate, decode_out_memory;\n\n    instruction_decode dec1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .inst_data(inst_data),\n        .decode_out(decode_out_immediate),\n        .fetch_code(2'b01) // Decode from immediate value\n    );\n\n    instruction_decode dec2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .inst_data(inst_data),\n        .decode_out(decode_out_memory),\n        .fetch_code(2'b10) // Decode from memory\n    );\n\n    // Output assignments based on active decode path\n    assign opcode = (fetch == 2'b01) ? decode_out_immediate[15:12] : decode_out_memory[15:12];\n    assign operand1 = (fetch == 2'b01) ? decode_out_immediate[11:6] : decode_out_memory[11:6];\n    assign operand2 = (fetch == 2'b01) ? decode_out_immediate[5:0] : decode_out_memory[5:0];\n\nendmodule\n\n// Submodule for instruction decoding\nmodule instruction_decode (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] inst_data,\n    output reg [15:0] decode_out,\n    input [1:0] fetch_code // Code to distinguish fetch sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decode_out <= 16'd0; // Reset output\n        end else begin\n            if (fetch == fetch_code) begin\n                decode_out <= inst_data; // Use data if fetch code matches\n            end else begin\n                decode_out <= decode_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'reg1_data', 'type': 'output port'}, {'id': 5, 'content': 'reg2_data', 'type': 'output port'}, {'id': 6, 'content': 'reg3_data', 'type': 'output port'}, {'id': 7, 'content': 'reg1', 'type': 'submodule'}, {'id': 8, 'content': 'reg2', 'type': 'submodule'}, {'id': 9, 'content': 'reg3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 3, 2, 0, 1, 7, 8, 9], [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 5, 6]]\n, Design a data router module that directs input data to specified registers based on control signals. The module must accommodate data inputs from multiple sources and distribute them into distinct registers, with field separation for targeted processing.\n\nModule name:\n    data_router\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the router.\n    select [2:0]: Control signal determining the destination register (0 for reg1, 1 for reg2, etc.).\n    data_in [15:0]: 16-bit data input from external sources.\n\nOutput ports:\n    reg1_data [7:0]: Data directed to the first register.\n    reg2_data [7:0]: Data directed to the second register.\n    reg3_data [7:0]: Data directed to the third register.\n\nImplementation:\n    The data router uses three submodules, each handling data storage for a different register.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all data outputs are initialized to zero.\n    Based on the select signal:\n    If select is 3'b000, data_in's lower 8 bits are routed to the first submodule (reg1).\n    If select is 3'b001, data_in's upper 8 bits are routed to the second submodule (reg2).\n    If select is 3'b010, the entire 16 bits are stored into the third submodule (reg3).\n    Outputs reg1_data, reg2_data, and reg3_data retrieve their values from the data stored in the respective submodules.\nGive me the complete code.\nmodule data_router (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] reg1_data,\n    output [7:0] reg2_data,\n    output [7:0] reg3_data\n);"}, {"from": "gpt", "value": "module data_router (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] reg1_data,\n    output [7:0] reg2_data,\n    output [7:0] reg3_data\n);\n\n    // Submodules for register data storage\n    wire [7:0] reg1_out, reg2_out;\n    wire [15:0] reg3_out;\n\n    register_storage reg1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in[7:0]),\n        .data_out(reg1_out),\n        .select_code(3'b000) // Data for first register\n    );\n\n    register_storage reg2 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in[15:8]),\n        .data_out(reg2_out),\n        .select_code(3'b001) // Data for second register\n    );\n\n    register_storage reg3 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .data_out(reg3_out),\n        .select_code(3'b010) // Data for third register\n    );\n\n    // Output assignments\n    assign reg1_data = reg1_out; // 8-bit data for first register\n    assign reg2_data = reg2_out; // 8-bit data for second register\n    assign reg3_data = reg3_out[7:0]; // Lower 8-bits of 16-bit data for third register\n\nendmodule\n\n// Submodule for register data storage\nmodule register_storage (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [2:0] select_code // Code to distinguish select targets\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= data; // Capture data if select code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'read_write', 'type': 'input port'}, {'id': 3, 'content': 'src_select', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'op_complete', 'type': 'output port'}, {'id': 7, 'content': 'dp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 3, 7, 4], [7, 7, 5, 5]]\n, Design a memory control module that manages read and write operations to memory. It utilizes control signals to select the source of data and the type of operation. This module includes a submodule for data processing that outputs the modified data based on operation type.\n\nModule name:\n    mem_ctrl\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the controller.\n    read_write: Control signal indicating operation type (0 for read, 1 for write).\n    src_select [1:0]: Control signal to choose the data source (00 from CPU, 01 from IO device).\n    data_in [15:0]: 16-bit input data to be written or read.\n\nOutput ports:\n    data_out [15:0]: 16-bit output data after read or process operation.\n    op_complete: Signal to indicate completion of the read/write operation.\n\nImplementation:\n    The memory control module includes a submodule for processing the data based on the type of operation.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the output data_out and the operation complete signal are initialized to zero.\n    Based on the read_write and src_select signals:\n    If read_write is 0, data is read from data_in directly to data_out.\n    If read_write is 1, the data is processed based on the source selected by src_select and the processed data is placed in data_out.\n    The operation complete signal is asserted once the data is ready in data_out.\nGive me the complete code.\nmodule mem_ctrl (\n    input clk,\n    input rst,\n    input read_write,\n    input [1:0] src_select,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output reg op_complete\n);"}, {"from": "gpt", "value": "module mem_ctrl (\n    input clk,\n    input rst,\n    input read_write,\n    input [1:0] src_select,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output reg op_complete\n);\n\n    // Submodule for data processing\n    wire [15:0] processed_data;\n\n    data_processor dp (\n        .data_in(data_in),\n        .src_select(src_select),\n        .processed_data(processed_data)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0;\n            op_complete <= 1'b0;\n        end else begin\n            if (read_write == 1'b0) begin\n                data_out <= data_in; // Direct read operation\n                op_complete <= 1'b1;\n            end else if (read_write == 1'b1) begin\n                data_out <= processed_data; // Write processed data\n                op_complete <= 1'b1;\n            end else begin\n                op_complete <= 1'b0; // No operation\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input [15:0] data_in,\n    input [1:0] src_select,\n    output reg [15:0] processed_data\n);\n\n    always @(*) begin\n        case(src_select)\n            2'b00: processed_data = data_in + 1; // Simulate a simple processing for CPU data\n            2'b01: processed_data = data_in - 1; // Simulate a simple processing for IO device data\n            default: processed_data = data_in; // Default no processing\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'cmd', 'type': 'input port'}, {'id': 3, 'content': 'serial_data', 'type': 'input port'}, {'id': 4, 'content': 'operation', 'type': 'output port'}, {'id': 5, 'content': 'address', 'type': 'output port'}, {'id': 6, 'content': 'payload', 'type': 'output port'}, {'id': 7, 'content': 'ds', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 7, 7], [7, 7, 7, 7, 4, 5, 6]]\n, Design a data decoder module that extracts and distributes control and data segments from a serial input stream. The module should decode signals based on the operational command received and store the data in register-based storage elements using synchronous reset. Each segment should be sent to its appropriate output after processing.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize outputs.\n    cmd [2:0]: Control signal dictating the operation mode.\n    serial_data [15:0]: 16-bit serial input data.\n\nOutput ports:\n    operation [2:0]: Operation mode extracted from the command.\n    address [7:0]: Address segment extracted from the data based on command.\n    payload [7:0]: Payload segment derived from the data according to the command.\n\nImplementation:\n    The data decoder module includes submodules responsible for splitting and storing the serial_data based on the cmd input.\n    On the rising edge of the clk, if the rst is active, all outputs are initialized to zero.\n    The submodule interprets the cmd and selectively stores parts of serial_data into two distinct outputs, address and payload.\n    Operation output directly reflects the cmd input to indicate the current mode of operation.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [2:0] cmd,\n    input [15:0] serial_data,\n    output [2:0] operation,\n    output [7:0] address,\n    output [7:0] payload\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [2:0] cmd,\n    input [15:0] serial_data,\n    output [2:0] operation,\n    output [7:0] address,\n    output [7:0] payload\n);\n\n    // Submodule for data separation\n    wire [7:0] addr_out, payload_out;\n\n    data_splitter ds (\n        .clk(clk),\n        .rst(rst),\n        .cmd(cmd),\n        .serial_data(serial_data),\n        .address_out(addr_out),\n        .payload_out(payload_out)\n    );\n\n    // Output assignments\n    assign operation = cmd;            // Direct assignment of command to operation\n    assign address = addr_out;         // Address extracted from serial_data\n    assign payload = payload_out;      // Payload extracted from serial_data\n\nendmodule\n\n// Submodule for splitting data\nmodule data_splitter (\n    input clk,\n    input rst,\n    input [2:0] cmd,\n    input [15:0] serial_data,\n    output reg [7:0] address_out,\n    output reg [7:0] payload_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            address_out <= 8'd0; // Reset address output\n            payload_out <= 8'd0; // Reset payload output\n        end else begin\n            case (cmd)\n                3'b001: begin\n                    address_out <= serial_data[15:8]; // High byte as address\n                    payload_out <= serial_data[7:0];  // Low byte as payload\n                end\n                3'b010: begin\n                    address_out <= serial_data[7:0];   // Low byte as address\n                    payload_out <= serial_data[15:8]; // High byte as payload\n                end\n                default: begin\n                    address_out <= 8'hFF; // Default or undefined command\n                    payload_out <= 8'hFF;\n                end\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'wr_en', 'type': 'input port'}, {'id': 3, 'content': 'rd_sel', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'reg0', 'type': 'submodule'}, {'id': 7, 'content': 'reg1', 'type': 'submodule'}, {'id': 8, 'content': 'reg2', 'type': 'submodule'}, {'id': 9, 'content': 'reg3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 2, 4, 0, 1, 2, 4, 0, 1, 2, 4, 0, 1, 2, 6, 7, 8, 9, 3], [6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 5, 5, 5, 5, 5]]\n, A register file module that manages read and write operations to an array of registers. It incorporates control logic to handle multiple data sources and outputs selected register data based on input control signals. \n\nModule name:\n    reg_file\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear all registers.\n    wr_en [3:0]: 4-bit write-enable signal, each bit corresponding to a register.\n    rd_sel [1:0]: 2-bit control signal to select which register's data to output.\n    data_in [15:0]: 16-bit data input to be written into the registers.\n\nOutput ports:\n    data_out [15:0]: 16-bit output data from the selected register.\n\nImplementation:\n    The register file module uses four submodules, each being a 16-bit register.\n    On the rising edge of the clock, if the reset signal is low, all registers are cleared.\n    If the write-enable (wr_en) for a particular register is high, the data is written to that register.\n    The output (data_out) is determined by the read select signal (rd_sel), which chooses from the four registers based on the value provided.\n    Registers retain their value if no write operation is specified for them during a clock cycle.\nGive me the complete code.\nmodule reg_file (\n    input clk,\n    input rst,\n    input [3:0] wr_en,\n    input [1:0] rd_sel,\n    input [15:0] data_in,\n    output [15:0] data_out\n);"}, {"from": "gpt", "value": "module reg_file (\n    input clk,\n    input rst,\n    input [3:0] wr_en,\n    input [1:0] rd_sel,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\n    // Submodules for each register\n    wire [15:0] reg_0_out, reg_1_out, reg_2_out, reg_3_out;\n\n    register_16bit reg0 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[0]),\n        .data_in(data_in),\n        .data_out(reg_0_out)\n    );\n\n    register_16bit reg1 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[1]),\n        .data_in(data_in),\n        .data_out(reg_1_out)\n    );\n\n    register_16bit reg2 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[2]),\n        .data_in(data_in),\n        .data_out(reg_2_out)\n    );\n\n    register_16bit reg3 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[3]),\n        .data_in(data_in),\n        .data_out(reg_3_out)\n    );\n\n    // Output assignment using multiplexer logic\n    assign data_out = (rd_sel == 2'b00) ? reg_0_out :\n                      (rd_sel == 2'b01) ? reg_1_out :\n                      (rd_sel == 2'b10) ? reg_2_out :\n                                           reg_3_out;\n\nendmodule\n\n// Submodule for 16-bit registers\nmodule register_16bit (\n    input clk,\n    input rst,\n    input write_en,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Clear the register\n        end else if (write_en) begin\n            data_out <= data_in; // Write data if enabled\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'control_bits', 'type': 'output port'}, {'id': 6, 'content': 'payload', 'type': 'output port'}, {'id': 7, 'content': 'data_proc_A', 'type': 'submodule'}, {'id': 8, 'content': 'data_proc_B', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 3, 1, 2, 0, 1, 4, 2, 8, 7, 2, 8, 7], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data selector module that manages data streams from multiple peripherals based on the input control signals and splits the output based on data type, utilizing parameterized submodules.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    sel [1:0]: Control signal to select the data source (1 for Peripheral A, 2 for Peripheral B).\n    data_a [15:0]: 16-bit data input from Peripheral A.\n    data_b [15:0]: 16-bit data input from Peripheral B.\n\nOutput ports:\n    control_bits [3:0]: Control bits extracted from the selected data stream.\n    payload [11:0]: Main data payload extracted from the selected data stream.\n\nImplementation:\n    The data selector is implemented using two parameterized submodules, each storing and processing data from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the outputs control_bits and payload are initialized to zero.\n    Depending on the sel signal:\n    If sel is 2'b01, data is fetched from data_a input into the first submodule (data_proc_A).\n    If sel is 2'b10, data is fetched from data_b input into the second submodule (data_proc_B).\n    If neither condition is met, the previous values of control_bits and payload are retained.\n    The outputs control_bits and payload are derived from the stored data in the respective submodules, with control_bits representing the highest 4 bits and payload representing the next 12 bits.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [3:0] control_bits,\n    output [11:0] payload\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [3:0] control_bits,\n    output [11:0] payload\n);\n\n    // Submodule for data processing\n    wire [15:0] data_proc_A_out, data_proc_B_out;\n\n    data_processor data_proc_A (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_a),\n        .data_out(data_proc_A_out),\n        .sel_code(2'b01) // Select Peripheral A\n    );\n\n    data_processor data_proc_B (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_b),\n        .data_out(data_proc_B_out),\n        .sel_code(2'b10) // Select Peripheral B\n    );\n\n    // Output assignments\n    assign control_bits = (sel == 2'b01) ? data_proc_A_out[15:12] : (sel == 2'b10) ? data_proc_B_out[15:12] : 4'd0;\n    assign payload = (sel == 2'b01) ? data_proc_A_out[11:0] : (sel == 2'b10) ? data_proc_B_out[11:0] : 12'd0;\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [1:0] sel_code // Code to distinguish data source selection\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                data_out <= data; // Capture data if selection code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'basic_out', 'type': 'output port'}, {'id': 5, 'content': 'adv_out', 'type': 'output port'}, {'id': 6, 'content': 'selected_out', 'type': 'output port'}, {'id': 7, 'content': 'basic_proc', 'type': 'submodule'}, {'id': 8, 'content': 'adv_proc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 3, 0, 1, 7, 8, 7, 8, 2], [7, 7, 7, 8, 8, 8, 4, 5, 6, 6, 6]]\n, A data dispatcher module designed to route data inputs to different processing units based on signal flags, and to output specific bits of the processed data. It captures inputs from multiple sources, processes the data via submodules, and selectively outputs processed fields based on control signals.\n\nModule name:\n    data_dispatcher\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the dispatcher.\n    ctrl [1:0]: Control signal indicating the processing path (0 for basic processing, 1 for advanced processing).\n    data_in [15:0]: 16-bit data input to be processed and routed.\n\nOutput ports:\n    basic_out [7:0]: Output from the basic processing submodule.\n    adv_out [15:0]: Output from the advanced processing submodule.\n    selected_out [7:0]: Output selected based on the ctrl signal.\n\nImplementation:\n    The data dispatcher uses two submodules: one for basic processing and another for advanced processing.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the ctrl signal:\n    If ctrl is 2'b00, data is routed to the basic processing submodule (basic_proc).\n    If ctrl is 2'b01, data is routed to the advanced processing submodule (adv_proc).\n    The selected_out output depends on the ctrl signal, either the lower byte from adv_proc or the full output from basic_proc is selected.\nGive me the complete code.\nmodule data_dispatcher (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [7:0] basic_out,\n    output [15:0] adv_out,\n    output [7:0] selected_out\n);"}, {"from": "gpt", "value": "module data_dispatcher (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [7:0] basic_out,\n    output [15:0] adv_out,\n    output [7:0] selected_out\n);\n\n    // Submodules for data processing\n    wire [7:0] basic_proc_out;\n    wire [15:0] adv_proc_out;\n\n    basic_processing basic_proc (\n        .clk(clk),\n        .rst(rst),\n        .data(data_in[7:0]),\n        .out(basic_proc_out)\n    );\n\n    advanced_processing adv_proc (\n        .clk(clk),\n        .rst(rst),\n        .data(data_in),\n        .out(adv_proc_out)\n    );\n\n    // Output assignment\n    assign basic_out = basic_proc_out;\n    assign adv_out = adv_proc_out;\n    assign selected_out = (ctrl == 2'b00) ? basic_proc_out : adv_proc_out[7:0];\n\nendmodule\n\n// Submodule for basic processing\nmodule basic_processing (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 8'd0; // Reset output\n        end else begin\n            out <= data; // Simple processing, direct pass-through\n        end\n    end\n\nendmodule\n\n// Submodule for advanced processing\nmodule advanced_processing (\n    input clk,\n    input rst,\n    input [15:0] data,\n    output reg [15:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 16'd0; // Reset output\n        end else begin\n            out <= data + 16'd1; // Example processing, increment each bit\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'exec', 'type': 'input port'}, {'id': 3, 'content': 'instr', 'type': 'input port'}, {'id': 4, 'content': 'en_reg', 'type': 'output port'}, {'id': 5, 'content': 'addr_mem', 'type': 'output port'}, {'id': 6, 'content': 'ctrl_mem', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}, {'id': 8, 'content': 'mem_ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 2, 0, 1, 7, 7, 8], [7, 7, 7, 8, 8, 8, 4, 5, 6]]\n, A control unit module that manages the execution cycle of a CPU by using control signals to orchestrate data flow between registers and memory, utilizing submodules for specific task execution within the cycle.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    exec [1:0]: Control signal indicating the type of operation (1 for data fetch, 2 for execution).\n    instr [15:0]: 16-bit instruction code input indicating operations to perform.\n\nOutput ports:\n    en_reg [3:0]: Enables specific register based on decoded instruction.\n    addr_mem [7:0]: Memory address to be fetched or written to.\n    ctrl_mem: Control signal for memory read/write operations.\n\nImplementation:\n    The control unit is implemented using two submodules: one for decoding the instruction and another for generating memory control signals.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all output controls are initialized to their default inactive states.\n    Based on the exec signal:\n    If exec is 2'b01, the instruction is decoded to determine the memory address and register enable signals.\n    If exec is 2'b10, control signals for memory operations (read or write) are generated based on the decoded instruction.\n    If neither condition is met, the previous states are retained.\n    The outputs en_reg, addr_mem, and ctrl_mem are derived from the stored data and controls in the respective submodules.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec,\n    input [15:0] instr,\n    output [3:0] en_reg,\n    output [7:0] addr_mem,\n    output ctrl_mem\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec,\n    input [15:0] instr,\n    output [3:0] en_reg,\n    output [7:0] addr_mem,\n    output ctrl_mem\n);\n\n    // Submodules for decoding and control\n    wire [3:0] dec_out_reg;\n    wire [7:0] dec_out_mem;\n    wire dec_out_ctrl;\n\n    instruction_decoder decoder (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .out_reg(dec_out_reg),\n        .out_mem(dec_out_mem)\n    );\n\n    memory_control mem_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .exec(exec),\n        .ctrl_signal(dec_out_ctrl)\n    );\n\n    // Output assignments\n    assign en_reg = dec_out_reg;  // Register enable output\n    assign addr_mem = dec_out_mem;  // Memory address output\n    assign ctrl_mem = dec_out_ctrl; // Memory control signal\n\nendmodule\n\n// Submodule for instruction decoding\nmodule instruction_decoder (\n    input clk,\n    input rst,\n    input [15:0] instr,\n    output reg [3:0] out_reg,\n    output reg [7:0] out_mem\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out_reg <= 4'd0;\n            out_mem <= 8'd0;\n        end else begin\n            out_reg <= instr[11:8]; // Decode register enable bits\n            out_mem <= instr[7:0];  // Decode memory address\n        end\n    end\n\nendmodule\n\n// Submodule for memory control signal generation\nmodule memory_control (\n    input clk,\n    input rst,\n    input [1:0] exec,\n    output reg ctrl_signal\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ctrl_signal <= 1'b0; // Reset output\n        end else begin\n            if (exec == 2'b10) begin\n                ctrl_signal <= 1'b1; // Enable memory operation\n            end else begin\n                ctrl_signal <= 1'b0; // Disable memory operation\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'input_data1', 'type': 'input port'}, {'id': 4, 'content': 'input_data2', 'type': 'input port'}, {'id': 5, 'content': 'output_data', 'type': 'output port'}, {'id': 6, 'content': 'flags', 'type': 'output port'}, {'id': 7, 'content': 'process1', 'type': 'submodule'}, {'id': 8, 'content': 'process2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 4, 2, 0, 1, 8, 2, 7, 8, 2, 7], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data selector module designed to facilitate the control and distribution of data from multiple inputs to various output fields, tailored for different processing units in a computational system. It incorporates clock synchronization, reset capabilities, and specific select signals to decide from which input source to capture the data, preparing it for subsequent decoding or direct usage.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize outputs to a predefined state.\n    select [1:0]: Control signal to choose the data source.\n    input_data1 [15:0]: 16-bit data input from the first source.\n    input_data2 [15:0]: 16-bit data input from the second source.\n\nOutput ports:\n    output_data [7:0]: Selected 8-bit data to be used by other modules.\n    flags [3:0]: Status flags indicating specifics of the data selected (e.g., parity, validity).\n\nImplementation:\n    The data selector module includes submodules to handle data from each source independently.\n    On the rising edge of the clock (clk), or if the reset (rst) is active, the outputs are reset.\n    Depending on the select signal:\n    If select is 2'b01, data is fetched from input_data1 and passed through a processing submodule (process_data1).\n    If select is 2'b10, data is fetched from input_data2 and processed by another submodule (process_data2).\n    The output_data and flags are set based on the outputs from the active processing submodule.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] input_data1,\n    input [15:0] input_data2,\n    output [7:0] output_data,\n    output [3:0] flags\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] input_data1,\n    input [15:0] input_data2,\n    output [7:0] output_data,\n    output [3:0] flags\n);\n\n    // Wires for submodule outputs\n    wire [7:0] data1_processed, data2_processed;\n    wire [3:0] flags1, flags2;\n\n    // Submodule for first data source processing\n    data_processing process1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(input_data1),\n        .data_out(data1_processed),\n        .flags_out(flags1),\n        .select_code(2'b01) // Process data from first source\n    );\n\n    // Submodule for second data source processing\n    data_processing process2 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(input_data2),\n        .data_out(data2_processed),\n        .flags_out(flags2),\n        .select_code(2'b10) // Process data from second source\n    );\n\n    // Output assignment logic\n    assign output_data = (select == 2'b01) ? data1_processed : \n                         (select == 2'b10) ? data2_processed : 8'b00000000;\n    assign flags = (select == 2'b01) ? flags1 : \n                   (select == 2'b10) ? flags2 : 4'b0000;\n\nendmodule\n\n// Submodule for data processing\nmodule data_processing (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output reg [7:0] data_out,\n    output reg [3:0] flags_out,\n    input [1:0] select_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n            flags_out <= 4'b0000; // Reset flags\n        end else begin\n            if (select == select_code) begin\n                data_out <= data_in[7:0]; // Capture lower 8 bits\n                flags_out <= {1'b0, data_in[15], data_in[14], 1'b1}; // Example flag settings\n            end else begin\n                data_out <= data_out; // Retain previous value\n                flags_out <= flags_out; // Retain previous flags\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'result_high', 'type': 'output port'}, {'id': 6, 'content': 'result_low', 'type': 'output port'}, {'id': 7, 'content': 'arithm_ops', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 4, 2, 0, 7, 7], [7, 7, 7, 7, 7, 5, 6]]\n, A data processing unit that manages arithmetic operations based on control signals and two data inputs. It accepts operation codes and directs the arithmetic results to specific outputs split for further usage.\n\nModule name:\n    data_processing_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the data processing operations.\n    op_code [2:0]: Control signal determining the type of arithmetic operation (e.g., add, subtract).\n    data_a [7:0]: 8-bit data input representing the first operand.\n    data_b [7:0]: 8-bit data input representing the second operand.\n\nOutput ports:\n    result_high [3:0]: High 4 bits of the arithmetic result.\n    result_low [3:0]: Low 4 bits of the arithmetic result.\n\nImplementation:\n    The data processing unit utilizes submodules for different arithmetic operations, each parameterized by a unique operation code.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    The submodule responsible for the operation is triggered based on the op_code:\n    If op_code matches specific values, the corresponding operation is executed using data inputs data_a and data_b.\n    The outputs result_high and result_low are derived from the result of the operation performed by the selected submodule.\nGive me the complete code.\nmodule data_processing_unit (\n    input clk,\n    input rst,\n    input [2:0] op_code,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [3:0] result_high,\n    output [3:0] result_low\n);"}, {"from": "gpt", "value": "module data_processing_unit (\n    input clk,\n    input rst,\n    input [2:0] op_code,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [3:0] result_high,\n    output [3:0] result_low\n);\n\n    // Wire to hold the output of arithmetic operations\n    wire [7:0] arithmetic_out;\n\n    // Submodule for arithmetic operations\n    arithmetic_operations arithm_ops (\n        .clk(clk),\n        .rst(rst),\n        .op_code(op_code),\n        .data_a(data_a),\n        .data_b(data_b),\n        .operation_result(arithmetic_out)\n    );\n\n    // Output assignments\n    assign result_high = arithmetic_out[7:4]; // High 4 bits of the result\n    assign result_low = arithmetic_out[3:0];  // Low 4 bits of the result\n\nendmodule\n\n// Submodule for arithmetic operations\nmodule arithmetic_operations (\n    input clk,\n    input rst,\n    input [2:0] op_code,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [7:0] operation_result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            operation_result <= 8'd0; // Reset output\n        end else begin\n            case (op_code)\n                3'b000: operation_result <= data_a + data_b; // Addition\n                3'b001: operation_result <= data_a - data_b; // Subtraction\n                // More operations can be added here\n                default: operation_result <= operation_result; // Retain the previous value\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'imm_val', 'type': 'output port'}, {'id': 6, 'content': 'addr', 'type': 'output port'}, {'id': 7, 'content': 'imm_decoder', 'type': 'submodule'}, {'id': 8, 'content': 'addr_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 3, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, Design a data decoder module in Verilog to decode input data based on control signals and extract various fields, which can be used for further data processing or control. This module should handle data from multiple sources and decode them into operation codes, immediate values, and addresses using parameterized submodules.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    ctrl [1:0]: Control signal to select the data source (1 for immediate data, 2 for address).\n    data_in [15:0]: 16-bit input data representing the instruction or data to be decoded.\n\nOutput ports:\n    opcode [3:0]: Upper 4 bits of the data, used as operation code.\n    imm_val [7:0]: Immediate value extracted from middle 8 bits of the data.\n    addr [3:0]: Lower 4 bits of the data, used as an address or identifier.\n\nImplementation:\n    The data decoder uses two submodules; each responsible for handling a specific type of data based on the control signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Based on the ctrl signal:\n    If ctrl is 2'b01, the data is passed to the immediate submodule (imm_decoder) for extracting the immediate value.\n    If ctrl is 2'b10, the data is passed to the address submodule (addr_decoder) for extracting the address.\n    The opcode, imm_val, and addr outputs are derived from the data in the respective submodules.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [3:0] opcode,\n    output [7:0] imm_val,\n    output [3:0] addr\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [3:0] opcode,\n    output [7:0] imm_val,\n    output [3:0] addr\n);\n\n    // Submodules for data decoding\n    wire [7:0] imm_out;\n    wire [3:0] addr_out;\n\n    immediate_decoder imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data_in(data_in),\n        .imm_out(imm_out),\n        .ctrl_code(2'b01) // Control code for immediate data\n    );\n\n    address_decoder addr_decoder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data_in(data_in),\n        .addr_out(addr_out),\n        .ctrl_code(2'b10) // Control code for address data\n    );\n\n    // Output assignments\n    assign opcode = data_in[15:12];\n    assign imm_val = imm_out;\n    assign addr = addr_out;\n\nendmodule\n\n// Submodule for immediate value decoding\nmodule immediate_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output reg [7:0] imm_out,\n    input [1:0] ctrl_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            imm_out <= 8'd0; // Reset output\n        end else begin\n            if (ctrl == ctrl_code) begin\n                imm_out <= data_in[11:4]; // Extract immediate value\n            end else begin\n                imm_out <= imm_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for address decoding\nmodule address_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output reg [3:0] addr_out,\n    input [1:0] ctrl_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            addr_out <= 4'd0; // Reset output\n        end else begin\n            if (ctrl == ctrl_code) begin\n                addr_out <= data_in[3:0]; // Extract address\n            end else begin\n                addr_out <= addr_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'control', 'type': 'input port'}, {'id': 3, 'content': 'data_in1', 'type': 'input port'}, {'id': 4, 'content': 'data_in2', 'type': 'input port'}, {'id': 5, 'content': 'out1', 'type': 'output port'}, {'id': 6, 'content': 'out2', 'type': 'output port'}, {'id': 7, 'content': 'out3', 'type': 'output port'}, {'id': 8, 'content': 'out4', 'type': 'output port'}, {'id': 9, 'content': 'dp1', 'type': 'submodule'}, {'id': 10, 'content': 'dp2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 4, 0, 2, 1, 9, 9, 10, 10], [9, 9, 9, 9, 10, 10, 10, 10, 5, 6, 7, 8]]\n, A multi-source data capture system designed for digital signal processing. The system synchronizes with multiple data streams, processes them based on a control signal, and outputs various processed signals to multiple output channels, each carrying distinct parts of the captured data.\n\nModule name:\n    multi_source_capture\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    control [1:0]: Control signal indicating the source of data (00 for Source 1, 01 for Source 2, etc.).\n    data_in1 [7:0]: 8-bit data input from Source 1.\n    data_in2 [7:0]: 8-bit data input from Source 2.\n\nOutput ports:\n    out1 [3:0]: Extracted lower 4 bits of data from Source 1.\n    out2 [3:0]: Extracted upper 4 bits of data from Source 1.\n    out3 [3:0]: Extracted lower 4 bits of data from Source 2.\n    out4 [3:0]: Extracted upper 4 bits of data from Source 2.\n\nImplementation:\n    The system uses submodules for each data source which process incoming data based on the control signal.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all outputs are initialized to zero.\n    Depending on the control signal:\n    If control is 2'b00, the data from Source 1 is processed and split into out1 and out2.\n    If control is 2'b01, the data from Source 2 is processed and split into out3 and out4.\n    If neither condition is met, the outputs retain their previous values.\nGive me the complete code.\nmodule multi_source_capture (\n    input clk,\n    input rst,\n    input [1:0] control,\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    output [3:0] out1,\n    output [3:0] out2,\n    output [3:0] out3,\n    output [3:0] out4\n);"}, {"from": "gpt", "value": "module multi_source_capture (\n    input clk,\n    input rst,\n    input [1:0] control,\n    input [7:0] data_in1,\n    input [7:0] data_in2,\n    output [3:0] out1,\n    output [3:0] out2,\n    output [3:0] out3,\n    output [3:0] out4\n);\n\n    // Data processing submodules\n    wire [7:0] processed_data1, processed_data2;\n\n    data_processor dp1 (\n        .clk(clk),\n        .rst(rst),\n        .control(control),\n        .data_in(data_in1),\n        .data_out(processed_data1),\n        .control_code(2'b00)  // Control for Source 1\n    );\n\n    data_processor dp2 (\n        .clk(clk),\n        .rst(rst),\n        .control(control),\n        .data_in(data_in2),\n        .data_out(processed_data2),\n        .control_code(2'b01)  // Control for Source 2\n    );\n\n    // Output assignments\n    assign out1 = processed_data1[3:0];  // Lower 4 bits of data from Source 1\n    assign out2 = processed_data1[7:4];  // Upper 4 bits of data from Source 1\n    assign out3 = processed_data2[3:0];  // Lower 4 bits of data from Source 2\n    assign out4 = processed_data2[7:4];  // Upper 4 bits of data from Source 2\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] control,\n    input [7:0] data_in,\n    output reg [7:0] data_out,\n    input [1:0] control_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (control == control_code) begin\n                data_out <= data_in; // Process data if control code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'data_out_A', 'type': 'output port'}, {'id': 5, 'content': 'data_out_B', 'type': 'output port'}, {'id': 6, 'content': 'main_ctrl', 'type': 'submodule'}, {'id': 7, 'content': 'path_A', 'type': 'submodule'}, {'id': 8, 'content': 'path_B', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 3, 0, 6, 1, 3, 0, 6, 1, 7, 8], [6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, A data bus management module that efficiently controls and routes incoming data signals based on operation codes. This module includes a main controller submodule for parsing operation codes and multiple submodules to handle different routing paths of the data based on the operation specifics.\n\nModule name:\n    data_bus_controller\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the configurations.\n    op_code [3:0]: 4-bit operation code that determines the data path.\n    data_in [15:0]: 16-bit incoming data to be routed.\n\nOutput ports:\n    data_out_A [7:0]: Data output for path A.\n    data_out_B [7:0]: Data output for path B.\n\nImplementation:\n    The data bus controller utilizes three submodules; the main controller parses the operation codes and two path controllers that manage data routing based on the control signals from the main controller.\n    On the rising edge of the clock, if the reset is low, the outputs to both paths are initialized to zero.\n    The main controller submodule parses the operation code and generates specific control signals for the path submodules.\n    Depending on the generated control signals, data is routed to outputs data_out_A or data_out_B, or possibly both.\nGive me the complete code.\nmodule data_bus_controller (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    input [15:0] data_in,\n    output [7:0] data_out_A,\n    output [7:0] data_out_B\n);"}, {"from": "gpt", "value": "module data_bus_controller (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    input [15:0] data_in,\n    output [7:0] data_out_A,\n    output [7:0] data_out_B\n);\n\n    // Control signals for data path routing\n    wire control_A, control_B;\n\n    // Main controller submodule\n    op_code_parser main_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .op_code(op_code),\n        .control_A(control_A),\n        .control_B(control_B)\n    );\n\n    // Path submodules for data routing\n    data_path_controller path_A (\n        .clk(clk),\n        .rst(rst),\n        .control(control_A),\n        .data_in(data_in[15:8]), // Upper 8 bits\n        .data_out(data_out_A)\n    );\n\n    data_path_controller path_B (\n        .clk(clk),\n        .rst(rst),\n        .control(control_B),\n        .data_in(data_in[7:0]), // Lower 8 bits\n        .data_out(data_out_B)\n    );\n\nendmodule\n\n// Submodule for operation code parsing\nmodule op_code_parser (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    output reg control_A,\n    output reg control_B\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            control_A <= 0;\n            control_B <= 0;\n        end else begin\n            case (op_code)\n                4'b0001: begin\n                    control_A <= 1;\n                    control_B <= 0;\n                end\n                4'b0010: begin\n                    control_A <= 0;\n                    control_B <= 1;\n                end\n                4'b0011: begin\n                    control_A <= 1;\n                    control_B <= 1;\n                end\n                default: begin\n                    control_A <= 0;\n                    control_B <= 0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for data path control\nmodule data_path_controller (\n    input clk,\n    input rst,\n    input control,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 0; // Initialize output\n        end else if (control) begin\n            data_out <= data_in; // Route data to output\n        end else begin\n            data_out <= data_out; // Retain previous value\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'control_sig', 'type': 'input port'}, {'id': 3, 'content': 'sensor_data', 'type': 'input port'}, {'id': 4, 'content': 'action', 'type': 'output port'}, {'id': 5, 'content': 'sensor_val', 'type': 'output port'}, {'id': 6, 'content': 'sensorA', 'type': 'submodule'}, {'id': 7, 'content': 'sensorB', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 7, 2, 6, 7, 2, 6], [6, 6, 6, 6, 7, 7, 7, 7, 4, 4, 4, 5, 5, 5]]\n, A data capture and control module for a processor that reads and decodes sensor inputs, separating them into actionable control signals and data fields. It supports capturing data from multiple sensors based on control signals and decodes them for further processing in different system modules.\n\nModule name:\n    sensor_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    control_sig [1:0]: Control signal that determines the sensor input to be decoded (1 for Sensor A, 2 for Sensor B).\n    sensor_data [15:0]: 16-bit data input from sensors.\n\nOutput ports:\n    action [3:0]: Control signals derived from the upper bits of the sensor input.\n    sensor_val [11:0]: Data field extracted from the lower bits of the sensor input.\n\nImplementation:\n    The sensor decoder is implemented with two submodules, each responsible for decoding data from a specific sensor.\n    At the rising edge of the clock (clk), if the reset (rst) signal is low, outputs are reset to zero.\n    Based on the control_sig:\n    If control_sig is 2'b01, the data is decoded from sensor_data input in the first submodule (sensor_A).\n    If control_sig is 2'b10, the data is decoded from sensor_data input in the second submodule (sensor_B).\n    If neither condition is met, the previous values are retained.\n    The outputs action and sensor_val are derived from the stored values in the respective submodules.\nGive me the complete code.\nmodule sensor_decoder (\n    input clk,\n    input rst,\n    input [1:0] control_sig,\n    input [15:0] sensor_data,\n    output [3:0] action,\n    output [11:0] sensor_val\n);"}, {"from": "gpt", "value": "module sensor_decoder (\n    input clk,\n    input rst,\n    input [1:0] control_sig,\n    input [15:0] sensor_data,\n    output [3:0] action,\n    output [11:0] sensor_val\n);\n\n    // Submodule for sensor data processing\n    wire [15:0] sensor_A_out, sensor_B_out;\n\n    sensor_processor sensorA (\n        .clk(clk),\n        .rst(rst),\n        .control(control_sig),\n        .data(sensor_data),\n        .processed_data(sensor_A_out),\n        .control_code(2'b01) // Sensor A\n    );\n\n    sensor_processor sensorB (\n        .clk(clk),\n        .rst(rst),\n        .control(control_sig),\n        .data(sensor_data),\n        .processed_data(sensor_B_out),\n        .control_code(2'b10) // Sensor B\n    );\n\n    // Output assignments\n    assign action = (control_sig == 2'b01) ? sensor_A_out[15:12] : (control_sig == 2'b10) ? sensor_B_out[15:12] : 4'b0;\n    assign sensor_val = (control_sig == 2'b01) ? sensor_A_out[11:0] : (control_sig == 2'b10) ? sensor_B_out[11:0] : 12'b0;\n\nendmodule\n\n// Submodule for processing sensor data\nmodule sensor_processor (\n    input clk,\n    input rst,\n    input [1:0] control,\n    input [15:0] data,\n    output reg [15:0] processed_data,\n    input [1:0] control_code // Control signal for sensor selection\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            processed_data <= 16'd0; // Reset output\n        end else begin\n            if (control == control_code) begin\n                processed_data <= data; // Capture and process data if control code matches\n            end else begin\n                processed_data <= processed_data; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'execute', 'type': 'input port'}, {'id': 3, 'content': 'source1', 'type': 'input port'}, {'id': 4, 'content': 'source2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'status', 'type': 'output port'}, {'id': 7, 'content': 'adder', 'type': 'submodule'}, {'id': 8, 'content': 'subtractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 4, 0, 3, 1, 2, 4, 0, 3, 8, 2, 7, 8, 2, 7], [7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data processing unit module that captures and decodes arithmetic operations from two distinct sources, then executes based on a control signal. It utilizes submodules for decoding and execution, ensuring modularity in operations.\n\nModule name:\n    data_proc_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the registers.\n    execute [1:0]: Control signal indicating which operation to perform (1 for ADD, 2 for SUB).\n    source1 [7:0]: 8-bit data input representing the first operand.\n    source2 [7:0]: 8-bit data input representing the second operand.\n\nOutput ports:\n    result [7:0]: The 8-bit result of the arithmetic operation.\n    status [2:0]: Status bits, with specific bits indicating overflow, zero result, and carry out.\n\nImplementation:\n    The data processing unit is implemented using two submodules, each responsible for handling arithmetic operations from the two sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs, result and status, are initialized to zero.\n    Based on the execute signal:\n    If execute is 2'b01, an addition operation is performed using the inputs from both sources.\n    If execute is 2'b10, a subtraction operation is performed.\n    If neither condition is met, the outputs retain their previous values.\n    The outputs result and status are generated based on the arithmetic operation performed in the respective submodules.\nGive me the complete code.\nmodule data_processing_unit (\n    input clk,\n    input rst,\n    input [1:0] execute,\n    input [7:0] source1,\n    input [7:0] source2,\n    output [7:0] result,\n    output [2:0] status\n);"}, {"from": "gpt", "value": "module data_processing_unit (\n    input clk,\n    input rst,\n    input [1:0] execute,\n    input [7:0] source1,\n    input [7:0] source2,\n    output [7:0] result,\n    output [2:0] status\n);\n\n    // Submodules for processing arithmetic operations\n    wire [7:0] result_add, result_sub;\n    wire [2:0] status_add, status_sub;\n\n    arithmetic_operation adder (\n        .clk(clk),\n        .rst(rst),\n        .execute(execute),\n        .operand1(source1),\n        .operand2(source2),\n        .result(result_add),\n        .status(status_add),\n        .operation_code(2'b01) // Addition\n    );\n\n    arithmetic_operation subtractor (\n        .clk(clk),\n        .rst(rst),\n        .execute(execute),\n        .operand1(source1),\n        .operand2(source2),\n        .result(result_sub),\n        .status(status_sub),\n        .operation_code(2'b10) // Subtraction\n    );\n\n    // Output selection based on control signal\n    assign result = (execute == 2'b01) ? result_add :\n                    (execute == 2'b10) ? result_sub : 8'd0;\n\n    assign status = (execute == 2'b01) ? status_add :\n                    (execute == 2'b10) ? status_sub : 3'd0;\n\nendmodule\n\n// Submodule for arithmetic operations\nmodule arithmetic_operation (\n    input clk,\n    input rst,\n    input [1:0] execute,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg [2:0] status,\n    input [1:0] operation_code // Distinguish between ADD and SUB\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset output\n            status <= 3'b000; // Reset status\n        end else begin\n            if (execute == operation_code) begin\n                if (operation_code == 2'b01) begin\n                    {status[2], result} = operand1 + operand2; // ADD with carry\n                    status[1] = (result == 8'd0); // Zero flag\n                end else if (operation_code == 2'b10) begin\n                    {status[2], result} = operand1 - operand2; // SUB with borrow\n                    status[1] = (result == 8'd0); // Zero flag\n                end\n                status[0] = (operand1[7] != operand2[7] && operand1[7] != result[7]); // Overflow flag\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'operand1', 'type': 'input port'}, {'id': 4, 'content': 'operand2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'zero_flag', 'type': 'output port'}, {'id': 7, 'content': 'carry_flag', 'type': 'output port'}, {'id': 8, 'content': 'alu_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 3, 2, 8, 8, 8], [8, 8, 8, 5, 6, 7]]\n, A data processing unit capable of executing arithmetic operations based on control signals and incoming data. It reads operands from an input bus, processes them using specified arithmetic operations, and outputs the result along with flags for zero and carry conditions.\n\nModule name:\n    alu_module\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    ctrl [2:0]: Control signal defining the arithmetic operation (e.g., 000 for ADD, 001 for SUB).\n    operand1 [7:0]: 8-bit first operand.\n    operand2 [7:0]: 8-bit second operand.\n\nOutput ports:\n    result [7:0]: Result of the arithmetic operation.\n    zero_flag: Signal high when result is zero.\n    carry_flag: Signal high when there is an overflow in addition or borrow in subtraction.\n\nImplementation:\n    The ALU (Arithmetic Logic Unit) is implemented using a submodule that performs arithmetic operations.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the outputs result, zero_flag, and carry_flag are initialized to zero.\n    Based on the ctrl signal:\n    - ctrl 3'b000 results in addition,\n    - ctrl 3'b001 results in subtraction,\n    Other operations can be defined similarly.\n    Zero and carry flags are updated based on the result of the operations.\nGive me the complete code.\nmodule alu_module (\n    input clk,\n    input rst,\n    input [2:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg zero_flag,\n    output reg carry_flag\n);"}, {"from": "gpt", "value": "module alu_module (\n    input clk,\n    input rst,\n    input [2:0] ctrl,\n    input [7:0] operand1,\n    input [7:0] operand2,\n    output reg [7:0] result,\n    output reg zero_flag,\n    output reg carry_flag\n);\n\n    // Submodule for arithmetic operations\n    wire [8:0] sum; // Include carry in sum\n\n    alu_operations alu_op (\n        .operand1(operand1),\n        .operand2(operand2),\n        .ctrl(ctrl),\n        .result(sum)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            zero_flag <= 1'b0;\n            carry_flag <= 1'b0;\n        end else begin\n            result <= sum[7:0];\n            zero_flag <= (sum[7:0] == 0);\n            carry_flag <= sum[8];\n        end\n    end\n\nendmodule\n\n// Submodule for arithmetic operations\nmodule alu_operations (\n    input [7:0] operand1,\n    input [7:0] operand2,\n    input [2:0] ctrl,\n    output reg [8:0] result\n);\n\n    always @* begin\n        case (ctrl)\n            3'b000: result = operand1 + operand2; // ADD operation\n            3'b001: result = operand1 - operand2; // SUB operation\n            default: result = 9'd0;\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'data_field1', 'type': 'output port'}, {'id': 5, 'content': 'data_field2', 'type': 'output port'}, {'id': 6, 'content': 'data_field3', 'type': 'output port'}, {'id': 7, 'content': 'dev_a', 'type': 'submodule'}, {'id': 8, 'content': 'dev_b', 'type': 'submodule'}, {'id': 9, 'content': 'dev_c', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 3, 2, 0, 1, 7, 8, 9], [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 5, 6]]\n, A multi-source data selector and decoder designed for selecting and decoding data from different peripheral devices in a computational system. The module captures data inputs from multiple sources based on a control signal, decodes it into various output fields for further processing, and uses submodules for handling each source separately.\n\nModule name:\n    data_selector_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    select [1:0]: Control signal indicating the source of the data (00 for Device A, 01 for Device B, 10 for Device C).\n    data_in [15:0]: 16-bit data input representing the data from devices.\n\nOutput ports:\n    data_field1 [3:0]: The highest 4 bits, decoding specific flags or commands.\n    data_field2 [11:0]: The middle 12 bits, main data content.\n    data_field3 [15:0]: The lowest 16 bits directly from the selected device.\n\nImplementation:\n    The data selector and decoder are implemented using three submodules, each responsible for handling data from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Based on the select signal:\n    If select is 2'b00, the data is fetched from Device A into the first submodule (dev_a).\n    If select is 2'b01, the data is fetched from Device B into the second submodule (dev_b).\n    If select is 2'b10, the data is fetched from Device C into the third submodule (dev_c).\n    The outputs data_field1, data_field2, and data_field3 are derived from the stored data in the respective submodules.\nGive me the complete code.\nmodule data_selector_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output [3:0] data_field1,\n    output [11:0] data_field2,\n    output [15:0] data_field3\n);"}, {"from": "gpt", "value": "module data_selector_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output [3:0] data_field1,\n    output [11:0] data_field2,\n    output [15:0] data_field3\n);\n\n    // Submodule for data handling\n    wire [15:0] dev_a_out, dev_b_out, dev_c_out;\n\n    data_processor dev_a (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .data_out(dev_a_out),\n        .select_code(2'b00) // Device A\n    );\n\n    data_processor dev_b (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .data_out(dev_b_out),\n        .select_code(2'b01) // Device B\n    );\n\n    data_processor dev_c (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .data_out(dev_c_out),\n        .select_code(2'b10) // Device C\n    );\n\n    // Output assignments\n    assign data_field1 = dev_a_out[15:12];  // Highest 4 bits, specific flags or commands\n    assign data_field2 = dev_b_out[11:0];   // Middle 12 bits, main data\n    assign data_field3 = dev_c_out;         // Direct 16-bit data from Device C\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [1:0] select_code // Code to distinguish data sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= data; // Capture data if select code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'status_flags', 'type': 'output port'}, {'id': 6, 'content': 'add_unit', 'type': 'submodule'}, {'id': 7, 'content': 'sub_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 3, 0, 1, 7, 6, 2, 7, 6, 2], [6, 6, 6, 7, 7, 7, 4, 4, 4, 5, 5, 5]]\n, A multi-function data processing unit for computational operations in a modular CPU architecture. This module processes incoming data through multiple functional units based on control signals and stores intermediate results in registers. The outputs are specifically segmented for further CPU operations.\n\nModule name:\n    data_processing_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the processing unit.\n    op_select [1:0]: Control signal determining the type of operation (00 for addition, 01 for subtraction).\n    data_in [15:0]: 16-bit data input representing two 8-bit operands.\n\nOutput ports:\n    result [7:0]: Result of the operation.\n    status_flags [2:0]: Status flags indicating zero, overflow, and negative results.\n\nImplementation:\n    The data processing unit consists of several submodules, each responsible for a different type of arithmetic operation.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the outputs are initialized to zero.\n    Based on the op_select signal:\n    If op_select is 2'b00, data_in is processed for addition in the first submodule.\n    If op_select is 2'b01, data_in is processed for subtraction in the second submodule.\n    The result and status_flags are updated based on the outputs from the selected operation submodule.\nGive me the complete code.\nmodule data_processing_unit (\n    input clk,\n    input rst,\n    input [1:0] op_select,\n    input [15:0] data_in,\n    output [7:0] result,\n    output [2:0] status_flags\n);"}, {"from": "gpt", "value": "module data_processing_unit (\n    input clk,\n    input rst,\n    input [1:0] op_select,\n    input [15:0] data_in,\n    output [7:0] result,\n    output [2:0] status_flags\n);\n\n    // Submodules for arithmetic operations\n    wire [7:0] add_out, sub_out;\n    wire [2:0] add_flags, sub_flags;\n\n    arithmetic_adder add_unit (\n        .clk(clk),\n        .rst(rst),\n        .data(data_in),\n        .result(add_out),\n        .flags(add_flags)\n    );\n\n    arithmetic_subtractor sub_unit (\n        .clk(clk),\n        .rst(rst),\n        .data(data_in),\n        .result(sub_out),\n        .flags(sub_flags)\n    );\n\n    // Output assignment based on operation selection\n    assign result = (op_select == 2'b00) ? add_out : (op_select == 2'b01) ? sub_out : 8'd0;\n    assign status_flags = (op_select == 2'b00) ? add_flags : (op_select == 2'b01) ? sub_flags : 3'd0;\n\nendmodule\n\n// Submodule for addition\nmodule arithmetic_adder (\n    input clk,\n    input rst,\n    input [15:0] data,\n    output reg [7:0] result,\n    output reg [2:0] flags // Zero, Overflow, Negative\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            flags <= 3'd0;\n        end else begin\n            result <= data[7:0] + data[15:8];\n            flags[0] <= (result == 8'd0); // Zero flag\n            flags[1] <= (^data[15:8] ^ data[7:0] ^ result[7]); // Overflow flag\n            flags[2] <= result[7]; // Negative flag\n        end\n    end\nendmodule\n\n// Submodule for subtraction\nmodule arithmetic_subtractor (\n    input clk,\n    input rst,\n    input [15:0] data,\n    output reg [7:0] result,\n    output reg [2:0] flags // Zero, Overflow, Negative\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            flags <= 3'd0;\n        end else begin\n            result <= data[7:0] - data[15:8];\n            flags[0] <= (result == 8'd0); // Zero flag\n            flags[1] <= (^data[7:0] ^ data[15:8] ^ result[7]); // Overflow flag\n            flags[2] <= result[7]; // Negative flag\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'instr', 'type': 'input port'}, {'id': 4, 'content': 'op_type', 'type': 'output port'}, {'id': 5, 'content': 'operand1', 'type': 'output port'}, {'id': 6, 'content': 'operand2', 'type': 'output port'}, {'id': 7, 'content': 'dec_internal', 'type': 'submodule'}, {'id': 8, 'content': 'dec_external', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 3, 0, 1, 8, 7, 2, 8, 7, 2, 8, 7, 2], [7, 7, 7, 7, 8, 8, 8, 8, 4, 4, 4, 5, 5, 5, 6, 6, 6]]\n, A multi-source instruction decoder designed to decode and distribute CPU instructions based on a control signal. It captures instructions from two different sources and decodes them into operation type and operand fields, handling them through submodules for each source.\n\nModule name:\n    multi_instr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    ctrl [1:0]: Control signal dictating the source of the instruction (0 for internal, 1 for external).\n    instr [15:0]: 16-bit instruction input containing the instruction to be decoded.\n\nOutput ports:\n    op_type [3:0]: 4-bit output specifying the type of operation.\n    operand1 [5:0]: 6-bit output representing the first operand.\n    operand2 [5:0]: 6-bit output representing the second operand.\n\nImplementation:\n    The instruction decoder uses two submodules to decode instructions from the specified sources.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all outputs are reset to zero.\n    Depending on the ctrl signal:\n    If ctrl is 2'b00, the instruction from the internal source is processed by the first submodule (dec_int).\n    If ctrl is 2'b01, the instruction from the external source is processed by the second submodule (dec_ext).\n    If neither condition is met, the outputs retain their previous values.\n    The outputs op_type, operand1, and operand2 are populated based on the decoded instruction from the respective submodules.\nGive me the complete code.\nmodule multi_instr_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] instr,\n    output [3:0] op_type,\n    output [5:0] operand1,\n    output [5:0] operand2\n);"}, {"from": "gpt", "value": "module multi_instr_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] instr,\n    output [3:0] op_type,\n    output [5:0] operand1,\n    output [5:0] operand2\n);\n\n    // Submodules for instruction decoding\n    wire [15:0] dec_int_out, dec_ext_out;\n\n    decode_instruction dec_internal (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .instr(instr),\n        .decoded_out(dec_int_out),\n        .ctrl_code(2'b00) // Internal source\n    );\n\n    decode_instruction dec_external (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .instr(instr),\n        .decoded_out(dec_ext_out),\n        .ctrl_code(2'b01) // External source\n    );\n\n    // Output assignments\n    assign op_type = (ctrl == 2'b00) ? dec_int_out[15:12] : dec_ext_out[15:12]; // Top 4 bits, operation type\n    assign operand1 = (ctrl == 2'b00) ? dec_int_out[11:6] : dec_ext_out[11:6]; // Middle 6 bits, first operand\n    assign operand2 = (ctrl == 2'b00) ? dec_int_out[5:0] : dec_ext_out[5:0]; // Bottom 6 bits, second operand\n\nendmodule\n\n// Submodule for instruction decoding\nmodule decode_instruction (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] instr,\n    output reg [15:0] decoded_out,\n    input [1:0] ctrl_code // Code to distinguish control sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_out <= 16'd0; // Reset output\n        end else begin\n            if (ctrl == ctrl_code) begin\n                decoded_out <= instr; // Decode instruction if control code matches\n            end else begin\n                decoded_out <= decoded_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'source1', 'type': 'input port'}, {'id': 4, 'content': 'source2', 'type': 'input port'}, {'id': 5, 'content': 'source3', 'type': 'input port'}, {'id': 6, 'content': 'high_bits', 'type': 'output port'}, {'id': 7, 'content': 'mid_bits', 'type': 'output port'}, {'id': 8, 'content': 'low_bits', 'type': 'output port'}, {'id': 9, 'content': 'src1', 'type': 'submodule'}, {'id': 10, 'content': 'src2', 'type': 'submodule'}, {'id': 11, 'content': 'src3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 4, 1, 0, 5, 1, 10, 11, 9, 2, 10, 2, 11, 9, 10, 2, 11, 9], [9, 9, 9, 10, 10, 10, 11, 11, 11, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8]]\n, A multi-source data capture module that fetches and processes data from multiple input sources based on control signals. The module should store incoming data into different registers, extract specific bits for outputs, and provide synchronization using a clock signal.\n\nModule name:\n    multi_source_capture\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the registers.\n    select [2:0]: Control signal to select the data source.\n    source1 [15:0]: 16-bit data input from the first source.\n    source2 [15:0]: 16-bit data input from the second source.\n    source3 [15:0]: 16-bit data input from the third source.\n\nOutput ports:\n    high_bits [7:0]: High 8 bits of the selected data source.\n    mid_bits [7:0]: Middle 8 bits of the selected data source.\n    low_bits [7:0]: Low 8 bits of the selected data source.\n\nImplementation:\n    Three submodules are used to store data from each input source.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Based on the select signal, data from the corresponding source is fetched and stored into the respective register submodule.\n    The outputs high_bits, mid_bits, and low_bits are derived from slicing the stored data from the selected register submodule.\nGive me the complete code.\nmodule multi_source_capture (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] source1,\n    input [15:0] source2,\n    input [15:0] source3,\n    output [7:0] high_bits,\n    output [7:0] mid_bits,\n    output [7:0] low_bits\n);"}, {"from": "gpt", "value": "module multi_source_capture (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] source1,\n    input [15:0] source2,\n    input [15:0] source3,\n    output [7:0] high_bits,\n    output [7:0] mid_bits,\n    output [7:0] low_bits\n);\n\n    // Submodules for data storage\n    wire [15:0] data_out1, data_out2, data_out3;\n\n    data_register src1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(source1),\n        .data_out(data_out1)\n    );\n\n    data_register src2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(source2),\n        .data_out(data_out2)\n    );\n\n    data_register src3 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(source3),\n        .data_out(data_out3)\n    );\n\n    // Output assignment based on selected input\n    assign high_bits = (select == 3'b001) ? data_out1[15:8] :\n                       (select == 3'b010) ? data_out2[15:8] :\n                       (select == 3'b011) ? data_out3[15:8] : 8'd0;\n\n    assign mid_bits = (select == 3'b001) ? data_out1[7:0] :\n                      (select == 3'b010) ? data_out2[7:0] :\n                      (select == 3'b011) ? data_out3[7:0] : 8'd0;\n\n    assign low_bits = (select == 3'b001) ? data_out1[7:0] :\n                      (select == 3'b010) ? data_out2[7:0] :\n                      (select == 3'b011) ? data_out3[7:0] : 8'd0;\n\nendmodule\n\n// Submodule for individual data register storage\nmodule data_register (\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset data\n        end else begin\n            data_out <= data_in; // Store new data\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'execute', 'type': 'output port'}, {'id': 4, 'content': 'flag', 'type': 'output port'}, {'id': 5, 'content': 'opcode_proc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 5, 5], [5, 5, 5, 3, 4]]\n, A decoder module for a CPU that extracts control signals based on the opcode of the instruction. The module decodes the instruction into signal outputs for execution units, utilizing submodule design for handling different opcode scenarios.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    instruction [7:0]: 8-bit instruction containing the opcode.\n\nOutput ports:\n    execute [1:0]: Control signals to command execution units.\n    flag: Indicator flag for specific operations like interrupts or exceptions.\n\nImplementation:\n    The decoder uses a submodule for decoding the opcode based on a given range or specific values.\n    On the rising edge of the clock (clk), if the reset (rst) is asserted, the outputs execute and flag are initialized to zero.\n    The submodule assesses the opcode and sets the appropriate control signals based on the instruction content.\n    If the instruction is not recognized, default signals are provided to ensure safe operation of the execution units.\nGive me the complete code.\nmodule opcode_decoder (\n    input clk,\n    input rst,\n    input [7:0] instruction,\n    output [1:0] execute,\n    output flag\n);"}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [7:0] instruction,\n    output [1:0] execute,\n    output flag\n);\n\n    // Submodule for opcode processing\n    wire [1:0] execute_internal;\n    wire flag_internal;\n\n    opcode_processing opcode_proc (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .execute_out(execute_internal),\n        .flag_out(flag_internal)\n    );\n\n    // Output assignments\n    assign execute = execute_internal;\n    assign flag = flag_internal;\n\nendmodule\n\n// Submodule for opcode processing\nmodule opcode_processing (\n    input clk,\n    input rst,\n    input [7:0] instruction,\n    output reg [1:0] execute_out,\n    output reg flag_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            execute_out <= 2'b00; // Reset output signals\n            flag_out <= 1'b0;     // Reset flag\n        end else begin\n            case (instruction[7:5]) // Decode based on high 3 bits\n                3'b101: begin\n                    execute_out <= 2'b01; // Example command\n                    flag_out <= 1'b0;\n                end\n                3'b110: begin\n                    execute_out <= 2'b10; // Another example command\n                    flag_out <= 1'b1; // Set flag for special operations\n                end\n                default: begin\n                    execute_out <= 2'b00; // Default safe state\n                    flag_out <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'opcode', 'type': 'output port'}, {'id': 6, 'content': 'operand', 'type': 'output port'}, {'id': 7, 'content': 'ds1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 1, 2, 3, 0, 7, 7], [7, 7, 7, 7, 7, 5, 6]]\n, A data multiplexer module designed for a CPU to select between multiple data sources based on control signals, and to output specific bit fields of the data for different CPU operations.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the outputs.\n    select [1:0]: Control signal to select the data source.\n    data1 [15:0]: 16-bit data input from source 1.\n    data2 [15:0]: 16-bit data input from source 2.\n\nOutput ports:\n    opcode [3:0]: Selected 4 bits representing the operation code.\n    operand [11:0]: Selected 12 bits representing the operand.\n\nImplementation:\n    The data multiplexer is implemented using two submodules, each responsible for extracting different sections of the data based on the control signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    The select signal determines which data source to use:\n    If select is 2'b01, data is fetched from data1.\n    If select is 2'b10, data is fetched from data2.\n    The opcode output is always taken from the highest 4 bits of the selected data source.\n    The operand output is always taken from the 12 bits following the opcode.\nGive me the complete code.\nmodule data_mux (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data1,\n    input [15:0] data2,\n    output [3:0] opcode,\n    output [11:0] operand\n);"}, {"from": "gpt", "value": "module data_mux (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data1,\n    input [15:0] data2,\n    output [3:0] opcode,\n    output [11:0] operand\n);\n\n    // Submodule for data selection\n    wire [15:0] selected_data;\n\n    data_selector ds1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data1(data1),\n        .data2(data2),\n        .data_out(selected_data)\n    );\n\n    // Output assignments\n    assign opcode = selected_data[15:12]; // High 4 bits, operation code\n    assign operand = selected_data[11:0]; // Middle 12 bits, operand\n\nendmodule\n\n// Submodule for data selection\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data1,\n    input [15:0] data2,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            case (select)\n                2'b01: data_out <= data1; // Select data1\n                2'b10: data_out <= data2; // Select data2\n                default: data_out <= data_out; // Retain previous value\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_select', 'type': 'input port'}, {'id': 3, 'content': 'source_select', 'type': 'input port'}, {'id': 4, 'content': 'data1', 'type': 'input port'}, {'id': 5, 'content': 'data2', 'type': 'input port'}, {'id': 6, 'content': 'result', 'type': 'output port'}, {'id': 7, 'content': 'adder', 'type': 'submodule'}, {'id': 8, 'content': 'ander', 'type': 'submodule'}, {'id': 9, 'content': 'result_reg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[5, 4, 5, 4, 7, 1, 0, 2, 8, 9], [7, 7, 8, 8, 9, 9, 9, 9, 9, 6]]\n, A multi-source arithmetic logic unit (ALU) module that computes either addition or bitwise AND operations based on control signals and inputs from different data sources. It should store the results temporarily and output the result based on the selected operation.\n\nModule name:\n    multi_source_alu\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the internal storage.\n    op_select [1:0]: Control signal to select the operation (00 for addition, 01 for AND).\n    source_select [1:0]: Control signal to select the data source (00 for data1, 01 for data2).\n    data1 [7:0]: 8-bit data input from the first source.\n    data2 [7:0]: 8-bit data input from the second source.\n\nOutput ports:\n    result [7:0]: Output result of the selected arithmetic operation.\n\nImplementation:\n    The ALU module uses two submodules to perform the operations and another submodule to hold the results.\n    On the rising edge of the clock (clk), if the reset (rst) is active, the result register is cleared.\n    Depending on the op_select signal:\n    If op_select is 2'b00, the addition operation is performed on the selected source.\n    If op_select is 2'b01, the bitwise AND operation is performed on the selected source.\n    The result submodule holds and outputs the result of the operation based on the last computed operation.\nGive me the complete code.\nmodule multi_source_alu (\n    input clk,\n    input rst,\n    input [1:0] op_select,\n    input [1:0] source_select,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] result\n);"}, {"from": "gpt", "value": "module multi_source_alu (\n    input clk,\n    input rst,\n    input [1:0] op_select,\n    input [1:0] source_select,\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] result\n);\n\n    // Intermediate wires to store operation results\n    wire [7:0] add_result, and_result;\n    reg [7:0] selected_data;\n\n    // Submodule for addition operation\n    adder_module adder (\n        .data1(selected_data),\n        .data2(data2),\n        .result(add_result)\n    );\n\n    // Submodule for AND operation\n    and_module ander (\n        .data1(selected_data),\n        .data2(data2),\n        .result(and_result)\n    );\n\n    // Submodule to store result\n    result_storage result_reg (\n        .clk(clk),\n        .rst(rst),\n        .data_in((op_select == 2'b00) ? add_result : and_result),\n        .result_out(result)\n    );\n\n    // Data selection logic\n    always @* begin\n        case (source_select)\n            2'b00: selected_data = data1;\n            2'b01: selected_data = data2;\n            default: selected_data = 8'd0;\n        endcase\n    end\n\nendmodule\n\n// Addition submodule\nmodule adder_module (\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] result\n);\n    assign result = data1 + data2;\nendmodule\n\n// AND operation submodule\nmodule and_module (\n    input [7:0] data1,\n    input [7:0] data2,\n    output [7:0] result\n);\n    assign result = data1 & data2;\nendmodule\n\n// Result storage submodule\nmodule result_storage (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] result_out\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst)\n            result_out <= 8'd0;\n        else\n            result_out <= data_in;\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'cmd', 'type': 'input port'}, {'id': 3, 'content': 'src1', 'type': 'input port'}, {'id': 4, 'content': 'src2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'zero_flag', 'type': 'output port'}, {'id': 7, 'content': 'compute', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 4, 7, 7], [7, 7, 7, 5, 6]]\n, A register-based arithmetic logic unit (ALU) module that performs arithmetic and logical operations based on a given command. This module captures input operands from multiple sources and computes results while facilitating bit-wise manipulation and arithmetic operations.\n\nModule name:\n    alu_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the ALU and outputs.\n    cmd [3:0]: Control signal indicating the type of operation (e.g., addition, subtraction, AND, OR).\n    src1 [7:0]: 8-bit data input representing the first operand.\n    src2 [7:0]: 8-bit data input representing the second operand.\n\nOutput ports:\n    result [7:0]: The result of the computed operation.\n    zero_flag: Flag that indicates if the result is zero.\n\nImplementation:\n    The ALU uses parameterized operations to handle different arithmetic and logical functions.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the result and zero_flag are initialized to zero.\n    The operation to be performed is determined by the cmd input, and computations are executed accordingly using separate ALU operations submodules.\n    The zero_flag is set if the result of the operation is zero after execution.\nGive me the complete code.\nmodule alu_reg (\n    input clk,\n    input rst,\n    input [3:0] cmd,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] result,\n    output reg zero_flag\n);"}, {"from": "gpt", "value": "module alu_reg (\n    input clk,\n    input rst,\n    input [3:0] cmd,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] result,\n    output reg zero_flag\n);\n\n    // ALU operations submodule\n    wire [7:0] operation_result;\n\n    alu_operations compute (\n        .cmd(cmd),\n        .src1(src1),\n        .src2(src2),\n        .result(operation_result)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Initialize result\n            zero_flag <= 1'b0; // Initialize zero_flag\n        end else begin\n            result <= operation_result; // Store the computation result\n            zero_flag <= (result == 8'd0) ? 1'b1 : 1'b0; // Update zero flag based on the result\n        end\n    end\n\nendmodule\n\n// Submodule for ALU operations\nmodule alu_operations (\n    input [3:0] cmd,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] result\n);\n\n    always @(*) begin\n        case (cmd)\n            4'b0000: result = src1 + src2; // Addition\n            4'b0001: result = src1 - src2; // Subtraction\n            4'b0010: result = src1 & src2; // AND\n            4'b0011: result = src1 | src2; // OR\n            default: result = 8'd0; // Default to 0 for unknown cmd\n        endcase\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'operand_sel', 'type': 'input port'}, {'id': 3, 'content': 'direct_data', 'type': 'input port'}, {'id': 4, 'content': 'register_data', 'type': 'input port'}, {'id': 5, 'content': 'operand1', 'type': 'output port'}, {'id': 6, 'content': 'operand2', 'type': 'output port'}, {'id': 7, 'content': 'direct_operand', 'type': 'submodule'}, {'id': 8, 'content': 'register_operand', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 2, 1, 4, 0, 2, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Design a module that functions as a multi-source operand fetch unit for an arithmetic logic unit (ALU) in a processor. The module should capture operands from different data sources based on control signals and provide them to the ALU for computation. The operands are fetched either from a register or direct input data and should be available in separate output fields.\n\nModule name:\n    operand_fetch_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    operand_sel [1:0]: Control signal indicating the operand source (00 for direct input, 01 for register).\n    direct_data [15:0]: 16-bit data input representing the direct operand.\n    register_data [15:0]: 16-bit data from register to be used as operand.\n\nOutput ports:\n    operand1 [15:0]: The operand fetched from the direct data source.\n    operand2 [15:0]: The operand fetched from the register data source.\n\nImplementation:\n    The operand fetch unit is implemented using two submodules, each responsible for handling a source of operand data.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both operand outputs are initialized to zero.\n    Based on the operand_sel signal:\n    If operand_sel is 2'b00, the operand is fetched from the direct_data input into the first submodule (direct_operand).\n    If operand_sel is 2'b01, the operand is fetched from the register_data input into the second submodule (register_operand).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs operand1 and operand2 are derived from the stored operands in the respective submodules.\nGive me the complete code.\nmodule operand_fetch_unit (\n    input clk,\n    input rst,\n    input [1:0] operand_sel,\n    input [15:0] direct_data,\n    input [15:0] register_data,\n    output [15:0] operand1,\n    output [15:0] operand2\n);"}, {"from": "gpt", "value": "module operand_fetch_unit (\n    input clk,\n    input rst,\n    input [1:0] operand_sel,\n    input [15:0] direct_data,\n    input [15:0] register_data,\n    output [15:0] operand1,\n    output [15:0] operand2\n);\n\n    // Submodule for operand storage\n    wire [15:0] direct_operand_out, register_operand_out;\n\n    operand_storage direct_operand (\n        .clk(clk),\n        .rst(rst),\n        .operand_sel(operand_sel),\n        .data(direct_data),\n        .operand_out(direct_operand_out),\n        .sel_code(2'b00) // Direct input\n    );\n\n    operand_storage register_operand (\n        .clk(clk),\n        .rst(rst),\n        .operand_sel(operand_sel),\n        .data(register_data),\n        .operand_out(register_operand_out),\n        .sel_code(2'b01) // Fetch from register\n    );\n\n    // Output assignments\n    assign operand1 = direct_operand_out; // Direct input operand\n    assign operand2 = register_operand_out; // Register input operand\n\nendmodule\n\n// Submodule for operand storage\nmodule operand_storage (\n    input clk,\n    input rst,\n    input [1:0] operand_sel,\n    input [15:0] data,\n    output reg [15:0] operand_out,\n    input [1:0] sel_code // Code to distinguish operand sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            operand_out <= 16'd0; // Reset output\n        end else begin\n            if (operand_sel == sel_code) begin\n                operand_out <= data; // Capture data if operand selection matches\n            end else begin\n                operand_out <= operand_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'address', 'type': 'input port'}, {'id': 4, 'content': 'high_addr', 'type': 'output port'}, {'id': 5, 'content': 'low_addr', 'type': 'output port'}, {'id': 6, 'content': 'mem_data', 'type': 'output port'}, {'id': 7, 'content': 'primary', 'type': 'submodule'}, {'id': 8, 'content': 'backup', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 3, 2, 0, 1, 3, 3, 3, 7, 2, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6, 6, 6]]\n, A memory address decoder that selects the memory bank based on input address and control signals. It must separate the address into higher and lower parts, while simultaneously fetching data from either primary or backup memory depending on the control signal.\n\nModule name:\n    mem_addr_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the output registers.\n    select [1:0]: Control signal to select memory bank (0 for primary, 1 for backup).\n    address [15:0]: 16-bit address input from the CPU.\n\nOutput ports:\n    high_addr [7:0]: High 8 bits of the address for bank addressing.\n    low_addr [7:0]: Low 8 bits of the address for offset within the bank.\n    mem_data [7:0]: Data fetched from the selected memory bank.\n\nImplementation:\n    The memory address decoder utilizes separate submodules for high and low address generation.\n    On the rising edge of the clock, if the reset signal is low, all outputs are reset to zero.\n    Based on the select signal:\n    If select is 2'b00, data is fetched from the primary memory submodule (primary_mem).\n    If select is 2'b01, data is fetched from the backup memory submodule (backup_mem).\n    High and low addresses are continuously updated based on the current input address.\nGive me the complete code.\nmodule mem_addr_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] address,\n    output [7:0] high_addr,\n    output [7:0] low_addr,\n    output [7:0] mem_data\n);"}, {"from": "gpt", "value": "module mem_addr_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] address,\n    output [7:0] high_addr,\n    output [7:0] low_addr,\n    output [7:0] mem_data\n);\n\n    // Submodules for memory data retrieval\n    wire [7:0] primary_mem_out, backup_mem_out;\n\n    primary_memory primary (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .address(address),\n        .data_out(primary_mem_out),\n        .select_code(2'b00) // Primary memory select\n    );\n\n    backup_memory backup (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .address(address),\n        .data_out(backup_mem_out),\n        .select_code(2'b01) // Backup memory select\n    );\n\n    // Output assignments\n    assign high_addr = address[15:8]; // High 8 bits, memory bank address\n    assign low_addr = address[7:0];  // Low 8 bits, offset within bank\n    assign mem_data = (select == 2'b00) ? primary_mem_out : \n                      (select == 2'b01) ? backup_mem_out : 8'd0;\n\nendmodule\n\n// Submodule for primary memory data retrieval\nmodule primary_memory (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] address,\n    output reg [7:0] data_out,\n    input [1:0] select_code // Memory select code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= address[7:0]; // Simulated data fetch based on address\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for backup memory data retrieval\nmodule backup_memory (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] address,\n    output reg [7:0] data_out,\n    input [1:0] select_code // Memory select code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= address[15:8]; // Simulated data fetch based on address\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'source_info', 'type': 'output port'}, {'id': 6, 'content': 'add_proc', 'type': 'submodule'}, {'id': 7, 'content': 'and_proc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 3, 1, 2, 0, 3, 1, 7, 6, 2, 2], [6, 6, 6, 6, 7, 7, 7, 7, 4, 4, 4, 5]]\n, A data processing unit that retrieves and processes numeric operations from different data sources based on control signals, outputting processed data for various application needs.\n\nModule name:\n    data_proc_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the processing unit.\n    fetch [1:0]: Control signal indicating the source of data (0 for internal cache, 1 for external memory).\n    data [15:0]: 16-bit data input representing the numeric data to be processed.\n\nOutput ports:\n    result [7:0]: The result of the arithmetic operation, either addition or bitwise AND, based on the control signal.\n    source_info [1:0]: Identifies the source of the data based on the fetch signal.\n\nImplementation:\n    The data processing unit contains two submodules for handling data operations from the specified sources.\n    At each rising edge of the clk, if the rst signal is low, all outputs are reset to zero.\n    Depending on the fetch signal:\n    If fetch is 2'b00, the data is processed using the first submodule (add_proc) performing an addition.\n    If fetch is 2'b01, the data is processed using the second submodule (and_proc) performing a bitwise AND operation.\n    The result and source_info outputs are derived from the outputs of the active submodule based on the fetch control.\nGive me the complete code.\nmodule data_proc_unit (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] data,\n    output [7:0] result,\n    output [1:0] source_info\n);"}, {"from": "gpt", "value": "module data_proc_unit (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] data,\n    output [7:0] result,\n    output [1:0] source_info\n);\n\n    // Submodules for data operations\n    wire [7:0] add_out, and_out;\n\n    addition_processor add_proc (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .output_result(add_out),\n        .fetch_code(2'b00) // Perform addition for internal cache\n    );\n\n    and_processor and_proc (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .output_result(and_out),\n        .fetch_code(2'b01) // Perform bitwise AND for external memory\n    );\n\n    // Output assignments\n    assign result = (fetch == 2'b00) ? add_out : (fetch == 2'b01) ? and_out : 8'd0;\n    assign source_info = fetch;\n\nendmodule\n\n// Submodule for addition operation\nmodule addition_processor (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] data,\n    output reg [7:0] output_result,\n    input [1:0] fetch_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output_result <= 8'd0;\n        end else begin\n            if (fetch == fetch_code) begin\n                output_result <= data[7:0] + data[15:8]; // Perform addition\n            end else begin\n                output_result <= output_result;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for bitwise AND operation\nmodule and_processor (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] data,\n    output reg [7:0] output_result,\n    input [1:0] fetch_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output_result <= 8'd0;\n        end else begin\n            if (fetch == fetch_code) begin\n                output_result <= data[7:0] & data[15:8]; // Perform bitwise AND\n            end else begin\n                output_result <= output_result;\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_select', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'status_flags', 'type': 'output port'}, {'id': 7, 'content': 'adder', 'type': 'submodule'}, {'id': 8, 'content': 'subtractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 4, 0, 2, 3, 1, 4, 0, 2, 8, 7, 2, 8, 7, 2], [7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data processing unit designed to handle arithmetic operations. It supports addition and subtraction based on control signals. The module captures data from a shared input bus and processes it into two distinct outputs depending on the operation selected.\n\nModule name:\n    data_proc_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the operations.\n    op_select [1:0]: Control signal to select the operation (1 for addition, 2 for subtraction).\n    data_a [7:0]: 8-bit data input representing the first operand.\n    data_b [7:0]: 8-bit data input representing the second operand.\n\nOutput ports:\n    result [7:0]: The result of the arithmetic operation.\n    status_flags [1:0]: Flags indicating operation status (0 for OK, 1 for overflow, 2 for underflow).\n\nImplementation:\n    The data processing unit is implemented using a submodule for each arithmetic operation.\n    On the rising edge of the clock (clk), if the reset (rst) is low, both outputs are initialized to zero.\n    Based on the op_select signal:\n    If op_select is 2'b01, addition is performed using the first submodule (adder).\n    If op_select is 2'b10, subtraction is performed using the second submodule (subtractor).\n    If neither condition is met, the previous values are retained.\n    The output result and status_flags are derived based on the operation performed in the respective submodules.\nGive me the complete code.\nmodule data_proc_unit (\n    input clk,\n    input rst,\n    input [1:0] op_select,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [7:0] result,\n    output [1:0] status_flags\n);"}, {"from": "gpt", "value": "module data_proc_unit (\n    input clk,\n    input rst,\n    input [1:0] op_select,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [7:0] result,\n    output [1:0] status_flags\n);\n\n    // Submodules for arithmetic operations\n    wire [7:0] add_result, sub_result;\n    wire [1:0] add_status, sub_status;\n\n    arithmetic_adder adder (\n        .clk(clk),\n        .rst(rst),\n        .enable(op_select[0]),\n        .operand_a(data_a),\n        .operand_b(data_b),\n        .result(add_result),\n        .status(add_status)\n    );\n\n    arithmetic_subtractor subtractor (\n        .clk(clk),\n        .rst(rst),\n        .enable(op_select[1]),\n        .operand_a(data_a),\n        .operand_b(data_b),\n        .result(sub_result),\n        .status(sub_status)\n    );\n\n    // Output assignment based on operation\n    assign result = (op_select == 2'b01) ? add_result : \n                    (op_select == 2'b10) ? sub_result : 8'd0;\n    assign status_flags = (op_select == 2'b01) ? add_status : \n                          (op_select == 2'b10) ? sub_status : 2'b00;\n\nendmodule\n\n// Submodule for addition\nmodule arithmetic_adder (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] operand_a,\n    input [7:0] operand_b,\n    output reg [7:0] result,\n    output reg [1:0] status\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset result\n            status <= 2'b00; // Reset status\n        end else if (enable) begin\n            {status[1], result} = operand_a + operand_b; // Detect overflow\n            status[0] = (result == 8'd0) ? 1'b1 : 1'b0; // Set underflow flag\n        end\n    end\n\nendmodule\n\n// Submodule for subtraction\nmodule arithmetic_subtractor (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] operand_a,\n    input [7:0] operand_b,\n    output reg [7:0] result,\n    output reg [1:0] status\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset result\n            status <= 2'b00; // Reset status\n        end else if (enable) begin\n            {status[1], result} = operand_a - operand_b; // Detect overflow\n            status[0] = (result == 8'd0) ? 1'b1 : 1'b0; // Set underflow flag\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'encoded_data', 'type': 'input port'}, {'id': 4, 'content': 'stream1_data', 'type': 'output port'}, {'id': 5, 'content': 'stream2_data', 'type': 'output port'}, {'id': 6, 'content': 'dec1', 'type': 'submodule'}, {'id': 7, 'content': 'dec2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 2, 0, 3, 1, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 4, 5]]\n, Design a data decoder module that takes encoded input signals representing multiple types of data streams and decodes them into separate, meaningful outputs. It supports dynamic selection based on a control signal, adjusting which data stream to process and decode.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    select [1:0]: Control signal to select the data stream (0 for stream1, 1 for stream2, others for idle).\n    encoded_data [15:0]: 16-bit encoded data input from multiple sources.\n\nOutput ports:\n    stream1_data [7:0]: Decoded data for stream1.\n    stream2_data [7:0]: Decoded data for stream2.\n\nImplementation:\n    The data decoder module consists of two submodules, each dedicated to decoding data streams from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Depending on the select signal:\n    If select is 2'b00, the data is routed to the first submodule (decode_stream1) for processing.\n    If select is 2'b01, the data is routed to the second submodule (decode_stream2) for processing.\n    If neither condition is met, both outputs retain their previous states.\n    The outputs stream1_data and stream2_data are generated from the outputs of the respective submodules.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] encoded_data,\n    output [7:0] stream1_data,\n    output [7:0] stream2_data\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] encoded_data,\n    output [7:0] stream1_data,\n    output [7:0] stream2_data\n);\n\n    // Submodules for data decoding\n    wire [7:0] stream1_out, stream2_out;\n\n    data_stream_decoder dec1 (\n        .clk(clk),\n        .rst(rst),\n        .enable(select == 2'b00),\n        .data_in(encoded_data[15:8]),\n        .data_out(stream1_out)\n    );\n\n    data_stream_decoder dec2 (\n        .clk(clk),\n        .rst(rst),\n        .enable(select == 2'b01),\n        .data_in(encoded_data[7:0]),\n        .data_out(stream2_out)\n    );\n\n    // Output assignments\n    assign stream1_data = stream1_out;\n    assign stream2_data = stream2_out;\n\nendmodule\n\n// Submodule for data stream decoding\nmodule data_stream_decoder (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else if (enable) begin\n            data_out <= data_in; // Decode data if enabled\n        end else begin\n            data_out <= data_out; // Retain previous value\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'source1_data', 'type': 'input port'}, {'id': 4, 'content': 'source2_data', 'type': 'input port'}, {'id': 5, 'content': 'bus_data', 'type': 'output port'}, {'id': 6, 'content': 'buf1', 'type': 'submodule'}, {'id': 7, 'content': 'buf2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 4, 0, 1, 2, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 5, 5, 5]]\n, A data buffer module designed to receive and store 8-bit data segments from two different sources and provide these segments on a shared bus under command control. The module uses submodules to handle each data source separately and combines them into a unified output based on control signals.\n\nModule name:\n    data_buffer\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the buffers.\n    sel [1:0]: Control signal for selecting the data source (0 for source 1, 1 for source 2).\n    source1_data [7:0]: 8-bit data input from source 1.\n    source2_data [7:0]: 8-bit data input from source 2.\n\nOutput ports:\n    bus_data [7:0]: Output data on the bus, selected based on the control signal.\n\nImplementation:\n    The data buffer uses two submodules, each responsible for holding data from one of the two sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the outputs are initialized to zero.\n    Depending on the sel signal:\n    If sel is 2'b00, data from source 1 is loaded onto the bus from the first submodule (buf1).\n    If sel is 2'b01, data from source 2 is loaded onto the bus from the second submodule (buf2).\n    If neither condition is met, the output retains the previous value.\n    The output bus_data is derived from the active submodule\u2019s output based on the selection signal.\nGive me the complete code.\nmodule data_buffer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] source1_data,\n    input [7:0] source2_data,\n    output [7:0] bus_data\n);"}, {"from": "gpt", "value": "module data_buffer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] source1_data,\n    input [7:0] source2_data,\n    output [7:0] bus_data\n);\n\n    // Submodules for data storage\n    wire [7:0] buf1_out, buf2_out;\n\n    data_storage buf1 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(source1_data),\n        .out(buf1_out),\n        .sel_code(2'b00) // Select source 1\n    );\n\n    data_storage buf2 (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(source2_data),\n        .out(buf2_out),\n        .sel_code(2'b01) // Select source 2\n    );\n\n    // Output assignment\n    assign bus_data = (sel == 2'b00) ? buf1_out : \n                      (sel == 2'b01) ? buf2_out : \n                      8'bz; // High impedance when none selected\n\nendmodule\n\n// Submodule for data storage\nmodule data_storage (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data,\n    output reg [7:0] out,\n    input [1:0] sel_code // Code to distinguish source selection\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 8'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                out <= data; // Load data if selection code matches\n            end else begin\n                out <= out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_sel', 'type': 'input port'}, {'id': 3, 'content': 'op1', 'type': 'input port'}, {'id': 4, 'content': 'op2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'status', 'type': 'output port'}, {'id': 7, 'content': 'add_mod', 'type': 'submodule'}, {'id': 8, 'content': 'sub_mod', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 4, 2, 0, 3, 1, 4, 2, 0, 3, 2, 8, 7, 2, 8, 7], [7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data processing unit (DPU) for processing and distributing arithmetic operations. It stores incoming operation codes and operand values from multiple sources, and generates results by executing the specified operations.\n\nModule name:\n    dpu_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the unit.\n    op_sel [1:0]: Control signal indicating the source of operation (1 for addition, 2 for subtraction).\n    op1 [7:0]: 8-bit operand input for the first number.\n    op2 [7:0]: 8-bit operand input for the second number.\n\nOutput ports:\n    result [7:0]: The result of the arithmetic operation.\n    status [2:0]: Flags representing the status of the operation (e.g., overflow, zero result).\n\nImplementation:\n    The data processing unit is implemented using two submodules, each responsible for handling different arithmetic operations.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the result and status outputs are initialized to zero.\n    Based on the op_sel signal:\n    If op_sel is 2'b01, the addition operation is performed with inputs op1 and op2 in the first submodule (add_module).\n    If op_sel is 2'b10, the subtraction operation is performed with inputs op1 and op2 in the second submodule (sub_module).\n    The result and status outputs are derived from the arithmetic operations performed in the respective submodules.\nGive me the complete code.\nmodule dpu_unit (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] op1,\n    input [7:0] op2,\n    output [7:0] result,\n    output [2:0] status\n);"}, {"from": "gpt", "value": "module dpu_unit (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] op1,\n    input [7:0] op2,\n    output [7:0] result,\n    output [2:0] status\n);\n\n    // Submodule for addition\n    wire [7:0] add_result;\n    wire [2:0] add_status;\n\n    addition_module add_mod (\n        .clk(clk),\n        .rst(rst),\n        .op_sel(op_sel),\n        .op1(op1),\n        .op2(op2),\n        .result(add_result),\n        .status(add_status),\n        .operation_code(2'b01) // Addition\n    );\n\n    // Submodule for subtraction\n    wire [7:0] sub_result;\n    wire [2:0] sub_status;\n\n    subtraction_module sub_mod (\n        .clk(clk),\n        .rst(rst),\n        .op_sel(op_sel),\n        .op1(op1),\n        .op2(op2),\n        .result(sub_result),\n        .status(sub_status),\n        .operation_code(2'b10) // Subtraction\n    );\n\n    // Output assignment based on operation selected\n    assign result = (op_sel == 2'b01) ? add_result : ((op_sel == 2'b10) ? sub_result : 8'b0);\n    assign status = (op_sel == 2'b01) ? add_status : ((op_sel == 2'b10) ? sub_status : 3'b0);\n\nendmodule\n\n// Submodule for addition\nmodule addition_module (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] op1,\n    input [7:0] op2,\n    output reg [7:0] result,\n    output reg [2:0] status,\n    input [1:0] operation_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset result\n            status <= 3'b0; // Reset status\n        end else if (op_sel == operation_code) begin\n            result <= op1 + op2; // Perform addition\n            status <= {2'b0, (result == 8'd0)}; // Zero result status flag\n        end\n    end\n\nendmodule\n\n// Submodule for subtraction\nmodule subtraction_module (\n    input clk,\n    input rst,\n    input [1:0] op_sel,\n    input [7:0] op1,\n    input [7:0] op2,\n    output reg [7:0] result,\n    output reg [2:0] status,\n    input [1:0] operation_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0; // Reset result\n            status <= 3'b0; // Reset status\n        end else if (op_sel == operation_code) begin\n            result <= op1 - op2; // Perform subtraction\n            status <= {2'b0, (result == 8'd0)}; // Zero result status flag\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch_ctrl', 'type': 'input port'}, {'id': 3, 'content': 'data_input', 'type': 'input port'}, {'id': 4, 'content': 'sensor_data', 'type': 'output port'}, {'id': 5, 'content': 'memory_data', 'type': 'output port'}, {'id': 6, 'content': 'peripheral_data', 'type': 'output port'}, {'id': 7, 'content': 'sensor_module', 'type': 'submodule'}, {'id': 8, 'content': 'memory_module', 'type': 'submodule'}, {'id': 9, 'content': 'peripheral_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 7, 8, 9], [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 5, 6]]\n, A multi-source data capture system module designed to retrieve and process data from multiple input sources for a CPU, segregating the data based on signal control codes and storing them into different register files for subsequent use in the system.\n\nModule name:\n    data_capture_system\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize all outputs.\n    fetch_ctrl [1:0]: Control signal to determine the source of data (00 for idle, 01 for Sensor, 10 for Memory, 11 for Peripheral).\n    data_input [15:0]: 16-bit data input coming from various sources.\n\nOutput ports:\n    sensor_data [7:0]: Data captured from sensor source.\n    memory_data [7:0]: Data captured from memory source.\n    peripheral_data [7:0]: Data captured from peripheral source.\n\nImplementation:\n    The data capture system uses three submodules, each specialized for handling data from a specific source controlled by the fetch_ctrl signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are set to zero.\n    Depending on the fetch_ctrl signal:\n    If fetch_ctrl is 2'b01, data is captured from the sensor source into the first submodule (sensor_module).\n    If fetch_ctrl is 2'b10, data is captured from the memory source into the second submodule (memory_module).\n    If fetch_ctrl is 2'b11, data is captured from the peripheral source into the third submodule (peripheral_module).\n    If fetch_ctrl is 2'b00, no action is taken, and current values in the outputs are retained.\n    Outputs sensor_data, memory_data, and peripheral_data are directly derived from the outputs of their respective submodules.\nGive me the complete code.\nmodule data_capture_system (\n    input clk,\n    input rst,\n    input [1:0] fetch_ctrl,\n    input [15:0] data_input,\n    output [7:0] sensor_data,\n    output [7:0] memory_data,\n    output [7:0] peripheral_data\n);"}, {"from": "gpt", "value": "module data_capture_system (\n    input clk,\n    input rst,\n    input [1:0] fetch_ctrl,\n    input [15:0] data_input,\n    output [7:0] sensor_data,\n    output [7:0] memory_data,\n    output [7:0] peripheral_data\n);\n\n    // Submodules for each data source\n    wire [7:0] sensor_out, memory_out, peripheral_out;\n\n    source_module sensor_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch_ctrl(fetch_ctrl),\n        .data_input(data_input[7:0]),\n        .data_output(sensor_out),\n        .control_code(2'b01)  // Control code for sensor\n    );\n\n    source_module memory_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch_ctrl(fetch_ctrl),\n        .data_input(data_input[7:0]),\n        .data_output(memory_out),\n        .control_code(2'b10)  // Control code for memory\n    );\n\n    source_module peripheral_module (\n        .clk(clk),\n        .rst(rst),\n        .fetch_ctrl(fetch_ctrl),\n        .data_input(data_input[15:8]),\n        .data_output(peripheral_out),\n        .control_code(2'b11)  // Control code for peripheral\n    );\n\n    // Output assignments\n    assign sensor_data = sensor_out;\n    assign memory_data = memory_out;\n    assign peripheral_data = peripheral_out;\n\nendmodule\n\n// Submodule for handling specific source data\nmodule source_module (\n    input clk,\n    input rst,\n    input [1:0] fetch_ctrl,\n    input [7:0] data_input,\n    output reg [7:0] data_output,\n    input [1:0] control_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_output <= 8'd0; // Reset output\n        end else begin\n            if (fetch_ctrl == control_code) begin\n                data_output <= data_input; // Capture data if control code matches\n            end else begin\n                data_output <= data_output; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'control', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'data3', 'type': 'input port'}, {'id': 6, 'content': 'proc1', 'type': 'output port'}, {'id': 7, 'content': 'proc2', 'type': 'output port'}, {'id': 8, 'content': 'proc3', 'type': 'output port'}, {'id': 9, 'content': 'dp1', 'type': 'submodule'}, {'id': 10, 'content': 'dp2', 'type': 'submodule'}, {'id': 11, 'content': 'dp3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 3, 0, 4, 2, 1, 5, 0, 2, 1, 9, 10, 11], [9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 6, 7, 8]]\n, A multi-source data router module designed for handling and routing data inputs to targeted data processing units depending on control signals. This module captures data from three distinct sources and routes them to appropriate output channels for further processing.\n\nModule name:\n    data_router\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    control [2:0]: Control signal to select the data source and processing path.\n    data1 [7:0], data2 [7:0], data3 [7:0]: 8-bit data inputs from three different sources.\n\nOutput ports:\n    proc1 [7:0]: Data routed to the first processor.\n    proc2 [7:0]: Data routed to the second processor.\n    proc3 [7:0]: Data routed to the third processor.\n\nImplementation:\n    The data router uses three submodules, each responsible for processing data from a specific input source.\n    On the rising edge of the clock (clk), if the reset (rst) is asserted, all outputs are initialized to zero.\n    Depending on the control signal:\n    If control is 3'b001, data from the first input (data1) is routed to the first processor (proc1).\n    If control is 3'b010, data from the second input (data2) is routed to the second processor (proc2).\n    If control is 3'b100, data from the third input (data3) is routed to the third processor (proc3).\n    If none of these conditions are met, all outputs retain their previous values.\n    Each output proc1, proc2, and proc3 are handled by separate submodules ensuring data integrity and isolation.\nGive me the complete code.\nmodule data_router (\n    input clk,\n    input rst,\n    input [2:0] control,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output [7:0] proc1,\n    output [7:0] proc2,\n    output [7:0] proc3\n);"}, {"from": "gpt", "value": "module data_router (\n    input clk,\n    input rst,\n    input [2:0] control,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output [7:0] proc1,\n    output [7:0] proc2,\n    output [7:0] proc3\n);\n\n    // Submodules for each data processor route\n    wire [7:0] proc1_out, proc2_out, proc3_out;\n\n    data_processing_unit dp1 (\n        .clk(clk),\n        .rst(rst),\n        .enable(control == 3'b001),\n        .data_in(data1),\n        .data_out(proc1_out)\n    );\n\n    data_processing_unit dp2 (\n        .clk(clk),\n        .rst(rst),\n        .enable(control == 3'b010),\n        .data_in(data2),\n        .data_out(proc2_out)\n    );\n\n    data_processing_unit dp3 (\n        .clk(clk),\n        .rst(rst),\n        .enable(control == 3'b100),\n        .data_in(data3),\n        .data_out(proc3_out)\n    );\n\n    // Output assignments\n    assign proc1 = proc1_out;\n    assign proc2 = proc2_out;\n    assign proc3 = proc3_out;\n\nendmodule\n\n// Submodule for data processing\nmodule data_processing_unit (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Initialize output on reset\n        end else if (enable) begin\n            data_out <= data_in; // Process data if enabled\n        end else begin\n            data_out <= data_out; // Retain previous value\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'instruction_a', 'type': 'input port'}, {'id': 4, 'content': 'instruction_b', 'type': 'input port'}, {'id': 5, 'content': 'opcode', 'type': 'output port'}, {'id': 6, 'content': 'operand', 'type': 'output port'}, {'id': 7, 'content': 'inst_select', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 1, 2, 0, 3, 7, 7], [7, 7, 7, 7, 7, 5, 6]]\n, Design a data processing unit that processes 16-bit instructions, dividing the instructions into opcode and operand fields. The unit should handle inputs from two separate sources, utilizing control signals to determine the active source, and output the decoded fields for further utilization.\n\nModule name:\n    data_proc_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the unit.\n    select [1:0]: Control signal to choose the source of the data (0 for Source A, 1 for Source B).\n    instruction_a [15:0]: 16-bit data input from Source A.\n    instruction_b [15:0]: 16-bit data input from Source B.\n\nOutput ports:\n    opcode [3:0]: 4-bit opcode extracted from the active instruction.\n    operand [11:0]: 12-bit operand extracted from the active instruction.\n\nImplementation:\n    The data processing unit is composed of two submodules, each dedicated to handling data from a specified source.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the opcode and operand are set to zero.\n    The select control signal determines which instruction input to process:\n    If select is 2'b00, the instruction from Source A is processed.\n    If select is 2'b01, the instruction from Source B is processed.\n    The opcode and operand outputs are then extracted from the active instruction based on the source selected.\nGive me the complete code.\nmodule data_proc_unit (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] instruction_a,\n    input [15:0] instruction_b,\n    output [3:0] opcode,\n    output [11:0] operand\n);"}, {"from": "gpt", "value": "module data_proc_unit (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] instruction_a,\n    input [15:0] instruction_b,\n    output [3:0] opcode,\n    output [11:0] operand\n);\n\n    // Submodule for instruction handling\n    wire [15:0] instruction_active;\n\n    instruction_selector inst_select (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .instruction_a(instruction_a),\n        .instruction_b(instruction_b),\n        .instruction_out(instruction_active)\n    );\n\n    // Output assignments\n    assign opcode = instruction_active[15:12];  // Extract the 4-bit opcode\n    assign operand = instruction_active[11:0];  // Extract the 12-bit operand\n\nendmodule\n\n// Submodule for selecting the active instruction\nmodule instruction_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] instruction_a,\n    input [15:0] instruction_b,\n    output reg [15:0] instruction_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            instruction_out <= 16'd0; // Reset the output instruction\n        end else begin\n            case (select)\n                2'b00: instruction_out <= instruction_a; // Select instruction from Source A\n                2'b01: instruction_out <= instruction_b; // Select instruction from Source B\n                default: instruction_out <= instruction_out; // Retain previous instruction\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'arith_data', 'type': 'output port'}, {'id': 5, 'content': 'ls_data', 'type': 'output port'}, {'id': 6, 'content': 'arith1', 'type': 'submodule'}, {'id': 7, 'content': 'ls1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 4, 5]]\n, A data dispatcher module designed to handle data routing based on instruction types in a computing system. This module takes a binary instruction and directs data to appropriate registers depending on the operation specified by the opcode. It utilizes submodules for handling different instruction types and ensures data is synchronized with system clocks and reset mechanisms.\n\nModule name:\n    data_dispatcher\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the dispatcher.\n    opcode [2:0]: Control signal indicating the type of operation (e.g., 3'b001 for arithmetic, 3'b010 for load/store).\n    data_in [15:0]: 16-bit data input representing the data to be dispatched.\n\nOutput ports:\n    arith_data [7:0]: Data directed to arithmetic unit.\n    ls_data [15:0]: Data directed to load/store unit.\n\nImplementation:\n    The data dispatcher is implemented using two submodules, each responsible for dispatching data to different units.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both data outputs are initialized to zero.\n    Based on the opcode:\n    If opcode is 3'b001, the data is sent to the arithmetic unit submodule (arith_module).\n    If opcode is 3'b010, the data is sent to the load/store unit submodule (ls_module).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs arith_data and ls_data are derived from the processed data in the respective submodules.\nGive me the complete code.\nmodule data_dispatcher (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [15:0] data_in,\n    output [7:0] arith_data,\n    output [15:0] ls_data\n);"}, {"from": "gpt", "value": "module data_dispatcher (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [15:0] data_in,\n    output [7:0] arith_data,\n    output [15:0] ls_data\n);\n\n    // Submodule for dispatching data to arithmetic unit\n    wire [7:0] arith_module_out;\n\n    data_arith arith1 (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .data_in(data_in),\n        .arith_out(arith_module_out),\n        .opcode_code(3'b001) // Opcode for arithmetic operations\n    );\n\n    // Submodule for dispatching data to load/store unit\n    wire [15:0] ls_module_out;\n\n    data_ls ls1 (\n        .clk(clk),\n        .rst(rst),\n        .opcode(opcode),\n        .data_in(data_in),\n        .ls_out(ls_module_out),\n        .opcode_code(3'b010) // Opcode for load/store operations\n    );\n\n    // Output assignments\n    assign arith_data = arith_module_out; // Data for arithmetic operations\n    assign ls_data = ls_module_out;       // Data for load/store operations\n\nendmodule\n\n// Submodule for dispatching to arithmetic unit\nmodule data_arith (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [15:0] data_in,\n    output reg [7:0] arith_out,\n    input [2:0] opcode_code // Specific opcode\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            arith_out <= 8'd0; // Reset output\n        end else begin\n            if (opcode == opcode_code) begin\n                arith_out <= data_in[7:0]; // Capture lower 8 bits if opcode matches\n            end else begin\n                arith_out <= arith_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for dispatching to load/store unit\nmodule data_ls (\n    input clk,\n    input rst,\n    input [2:0] opcode,\n    input [15:0] data_in,\n    output reg [15:0] ls_out,\n    input [2:0] opcode_code // Specific opcode\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ls_out <= 16'd0; // Reset output\n        end else begin\n            if (opcode == opcode_code) begin\n                ls_out <= data_in; // Capture full data if opcode matches\n            end else begin\n                ls_out <= ls_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'in_data', 'type': 'input port'}, {'id': 4, 'content': 'out_data', 'type': 'output port'}, {'id': 5, 'content': 'status', 'type': 'output port'}, {'id': 6, 'content': 'proc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 3], [6, 6, 6, 4, 4]]\n, A multi-source data dispatcher module designed to handle data dispatch from different input sources to various output processors based on a control signal. This module captures and routes data, managing the dispatch of either direct input data or data pre-processed by a submodule, according to the specified control logic.\n\nModule name:\n    data_dispatcher\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the dispatch logic.\n    select [1:0]: Control signal dictating the source of data for dispatch (0 for direct, 1 for submodule).\n    in_data [15:0]: 16-bit data input from direct sources.\n\nOutput ports:\n    out_data [7:0]: The dispatched 8-bit data output to processors.\n    status [2:0]: Status signal indicating the data processing mode.\n\nImplementation:\n    The data dispatcher is implemented using a submodule for optional data preprocessing.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Depending on the select control signal:\n    If select is 2'b00, the direct data is output after some bit manipulation.\n    If select is 2'b01, the data is passed to a preprocessing submodule before dispatch.\n    A status output is set based on the select signal to indicate the current data processing mode.\nGive me the complete code.\nmodule data_dispatcher (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] in_data,\n    output [7:0] out_data,\n    output [2:0] status\n);"}, {"from": "gpt", "value": "module data_dispatcher (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] in_data,\n    output [7:0] out_data,\n    output [2:0] status\n);\n\n    // Submodule for data preprocessing\n    wire [7:0] processed_data;\n\n    data_preprocessing proc (\n        .clk(clk),\n        .rst(rst),\n        .in_data(in_data[7:0]),\n        .processed_out(processed_data)\n    );\n\n    // Output logic and status signaling\n    reg [7:0] temp_out;\n    reg [2:0] temp_status;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            temp_out <= 8'd0; // Reset outputs\n            temp_status <= 3'b000;\n        end else begin\n            case (select)\n                2'b00: begin\n                    temp_out <= in_data[7:0]; // Direct data manipulation\n                    temp_status <= 3'b001;\n                end\n                2'b01: begin\n                    temp_out <= processed_data; // Data from submodule\n                    temp_status <= 3'b010;\n                end\n                default: begin\n                    temp_out <= 8'd0; // Default to zero on unknown select\n                    temp_status <= 3'b111;\n                end\n            endcase\n        end\n    end\n\n    assign out_data = temp_out;\n    assign status = temp_status;\n\nendmodule\n\n// Submodule for data preprocessing\nmodule data_preprocessing (\n    input clk,\n    input rst,\n    input [7:0] in_data,\n    output reg [7:0] processed_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            processed_out <= 8'd0; // Reset output\n        end else begin\n            processed_out <= in_data + 8'd1; // Simple increment operation\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr', 'type': 'input port'}, {'id': 3, 'content': 'enable_decode', 'type': 'input port'}, {'id': 4, 'content': 'reg_select', 'type': 'output port'}, {'id': 5, 'content': 'op_enable', 'type': 'output port'}, {'id': 6, 'content': 'decoder', 'type': 'submodule'}, {'id': 7, 'content': 'op_ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 3, 1, 0, 2, 3, 1, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 4, 5]]\n, A control unit module that manages various control signals for CPU operations, including instruction decoding. It utilizes submodules to differentiate and generate signals for register selection, enabling operations based on a decoded instruction set and current system state.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize all control outputs.\n    instr [7:0]: 8-bit instruction code identifying the operation.\n    enable_decode: Control signal to initiate instruction decoding.\n\nOutput ports:\n    reg_select [2:0]: Output selecting which register is active.\n    op_enable: Signal to enable the operation in the execution unit.\n\nImplementation:\n    The control unit is comprised of two submodules:\n    - One submodule decodes the instruction to select the appropriate register.\n    - Another submodule controls the operation enable signal based on the decoded instruction and external control input.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    If the enable_decode signal is high, the instruction is decoded to generate the corresponding control outputs (reg_select and op_enable).\n    Outputs reg_select and op_enable are determined based on the outputs from the respective submodules.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [7:0] instr,\n    input enable_decode,\n    output [2:0] reg_select,\n    output op_enable\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [7:0] instr,\n    input enable_decode,\n    output [2:0] reg_select,\n    output op_enable\n);\n\n    // Submodule for register selection decoding\n    wire [2:0] reg_select_out;\n\n    register_decoder decoder (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .decode_enable(enable_decode),\n        .reg_select(reg_select_out)\n    );\n\n    // Submodule for operation enable control\n    wire op_enable_out;\n\n    operation_enable_ctrl op_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .decode_enable(enable_decode),\n        .op_enable(op_enable_out)\n    );\n\n    // Output assignments\n    assign reg_select = reg_select_out;\n    assign op_enable = op_enable_out;\n\nendmodule\n\n// Submodule for register selection based on instruction\nmodule register_decoder (\n    input clk,\n    input rst,\n    input [7:0] instr,\n    input decode_enable,\n    output reg [2:0] reg_select\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            reg_select <= 3'd0; // Initialize register selection\n        end else if (decode_enable) begin\n            reg_select <= instr[2:0]; // Decode to register select\n        end\n    end\n\nendmodule\n\n// Submodule for controlling operation enable signal\nmodule operation_enable_ctrl (\n    input clk,\n    input rst,\n    input [7:0] instr,\n    input decode_enable,\n    output reg op_enable\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            op_enable <= 1'b0; // Initialize operation enable\n        end else if (decode_enable) begin\n            op_enable <= (instr[7:5] != 3'b000); // Enable operation if not a NOP\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'oper', 'type': 'input port'}, {'id': 3, 'content': 'src1', 'type': 'input port'}, {'id': 4, 'content': 'src2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'proc1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 2, 3, 6], [6, 6, 6, 6, 6, 5]]\n, A data processing unit that handles arithmetic operations between two sources, specifically designed for addition and subtraction based on a control signal. The unit reads from two input buses and outputs the result, implementing internal control logic to decide the operation.\n\nModule name:\n    arithmetic_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    oper [1:0]: Control signal indicating the operation (00 for addition, 01 for subtraction).\n    src1 [7:0]: 8-bit data input representing the first operand.\n    src2 [7:0]: 8-bit data input representing the second operand.\n\nOutput ports:\n    result [7:0]: 8-bit data output representing the result of the operation.\n\nImplementation:\n    The arithmetic unit employs a submodule that processes the input data based on the operation specified by the oper signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the result is initialized to zero.\n    Based on the oper signal:\n    If oper is 2'b00, the operation performed is addition.\n    If oper is 2'b01, the operation performed is subtraction.\n    The output result is computed based on the operation chosen and stored in the submodule.\nGive me the complete code.\nmodule arithmetic_unit (\n    input clk,\n    input rst,\n    input [1:0] oper,\n    input [7:0] src1,\n    input [7:0] src2,\n    output [7:0] result\n);"}, {"from": "gpt", "value": "module arithmetic_unit (\n    input clk,\n    input rst,\n    input [1:0] oper,\n    input [7:0] src1,\n    input [7:0] src2,\n    output [7:0] result\n);\n\n    // Submodule for arithmetic operations\n    wire [7:0] output_res;\n\n    arithmetic_processor proc1 (\n        .clk(clk),\n        .rst(rst),\n        .oper(oper),\n        .src1(src1),\n        .src2(src2),\n        .res(output_res)\n    );\n\n    // Output assignment\n    assign result = output_res;\n\nendmodule\n\n// Submodule for arithmetic processing\nmodule arithmetic_processor (\n    input clk,\n    input rst,\n    input [1:0] oper,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] res\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            res <= 8'd0; // Reset output\n        end else begin\n            case(oper)\n                2'b00: res <= src1 + src2; // Addition\n                2'b01: res <= src1 - src2; // Subtraction\n                default: res <= res; // Retain previous value in case of unrecognized operation\n            endcase\n        end\n    end\n\nendmodule"}]}]