[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'higher_cmp', 'type': 'submodule'}, {'id': 6, 'content': 'lower_cmp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 6, 6, 6], [5, 5, 6, 6, 2, 3, 4]]\n, Design a 16-bit magnitude comparator that evaluates two input numbers, A and B, and outputs three status signals indicating their relative magnitude using smaller 8-bit comparison units.\n\nModule name:\n    magnitude_comparator_16bit\n\nInput ports:\n    A [15:0]: First 16-bit input operand to compare.\n    B [15:0]: Second 16-bit input operand to compare.\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module internally divides the 16-bit inputs A and B into two 8-bit segments each, compares each segment from higher to lower significance, and finally determines the overall relation (greater, equal, less) between A and B.\nLogic Utilization: If the higher 8-bit segments (higher significance) of A and B are equal, then comparison moves to the lower 8-bit segments.\nOutput Signals: Outputs are mutually exclusive with clear conditions setting only one signal active at a time depending on the comparison results.\n\nModular Design:\nThe main module (magnitude_comparator_16bit) instantiates two smaller comparison submodules (magnitude_comparator_8bit) for each 8-bit segment. The results from these submodules are used to decide the final output status of the 16-bit numbers.\nGive me the complete code.\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);"}, {"from": "gpt", "value": "module magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    wire A_higher_greater, A_higher_equal, A_higher_less;\n    wire A_lower_greater, A_lower_equal, A_lower_less;\n\n    // Instantiate the higher 8-bit comparator\n    magnitude_comparator_8bit higher_cmp (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .A_greater(A_higher_greater),\n        .A_equal(A_higher_equal),\n        .A_less(A_higher_less)\n    );\n\n    // Instantiate the lower 8-bit comparator\n    magnitude_comparator_8bit lower_cmp (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .A_greater(A_lower_greater),\n        .A_equal(A_lower_equal),\n        .A_less(A_lower_less)\n    );\n\n    // Determine the final comparison outputs\n    always @ (*) begin\n        if (A_higher_greater) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A_higher_less) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else if (A_higher_equal) begin\n            A_greater = A_lower_greater;\n            A_equal = A_lower_equal;\n            A_less = A_lower_less;\n        end\n    end\n\nendmodule\n\nmodule magnitude_comparator_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\n\nendmodule"}], "task_id": 0}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'sum', 'type': 'output port'}, {'id': 3, 'content': 'adder0_0', 'type': 'submodule'}, {'id': 4, 'content': 'adder0_1', 'type': 'submodule'}, {'id': 5, 'content': 'adder1_0', 'type': 'submodule'}, {'id': 6, 'content': 'adder1_1', 'type': 'submodule'}, {'id': 7, 'content': 'adder2_0', 'type': 'submodule'}, {'id': 8, 'content': 'adder2_1', 'type': 'submodule'}, {'id': 9, 'content': 'adder3_0', 'type': 'submodule'}, {'id': 10, 'content': 'adder3_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 3, 6, 10, 5, 4, 9, 8, 7], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Design a 16-bit carry-select adder (CSLA) module that uses a combination of 4-bit ripple carry adders (RCA) and multiplexers to achieve faster addition by calculating multiple carry scenarios in parallel.\n\nModule name:  \n    adder_16bit_csla             \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n\nImplementation:\nThe 16-bit carry-select adder uses four 4-bit ripple carry adders and multiplexers. The sum and carry output for each block are pre-computed for both carry-in scenarios (0 and 1), and the correct output is selected based on the actual carry input using multiplexers.\nGive me the complete code.\nmodule adder_16bit_csla(\n    input [15:0] a, b,\n    output [15:0] sum\n);"}, {"from": "gpt", "value": "module adder_16bit_csla(\n    input [15:0] a, b,\n    output [15:0] sum\n);\n    wire [3:0] sum0_0, sum0_1, sum1_0, sum1_1, sum2_0, sum2_1, sum3_0, sum3_1;\n    wire carry0_0, carry0_1, carry1_0, carry1_1, carry2_0, carry2_1, carry3_0, carry3_1;\n    wire [3:0] sel;\n\n    adder_4bit_rca adder0_0 (.a(a[3:0]), .b(b[3:0]), .cin(0), .sum(sum0_0), .cout(carry0_0));\n    adder_4bit_rca adder0_1 (.a(a[3:0]), .b(b[3:0]), .cin(1), .sum(sum0_1), .cout(carry0_1));\n    adder_4bit_rca adder1_0 (.a(a[7:4]), .b(b[7:4]), .cin(0), .sum(sum1_0), .cout(carry1_0));\n    adder_4bit_rca adder1_1 (.a(a[7:4]), .b(b[7:4]), .cin(1), .sum(sum1_1), .cout(carry1_1));\n    adder_4bit_rca adder2_0 (.a(a[11:8]), .b(b[11:8]), .cin(0), .sum(sum2_0), .cout(carry2_0));\n    adder_4bit_rca adder2_1 (.a(a[11:8]), .b(b[11:8]), .cin(1), .sum(sum2_1), .cout(carry2_1));\n    adder_4bit_rca adder3_0 (.a(a[15:12]), .b(b[15:12]), .cin(0), .sum(sum3_0), .cout(carry3_0));\n    adder_4bit_rca adder3_1 (.a(a[15:12]), .b(b[15:12]), .cin(1), .sum(sum3_1), .cout(carry3_1));\n\n    assign sel[0] = 0;\n    assign sel[1] = carry0_0;\n    assign sel[2] = carry1_0 ^ carry1_1 ? carry1_1 : carry0_0;\n    assign sel[3] = carry2_0 ^ carry2_1 ? carry2_1 : carry1_0 ^ carry1_1 ? carry1_1 : carry0_0;\n\n    assign sum[3:0] = sel[0] ? sum0_1 : sum0_0;\n    assign sum[7:4] = sel[1] ? sum1_1 : sum1_0;\n    assign sum[11:8] = sel[2] ? sum2_1 : sum2_0;\n    assign sum[15:12] = sel[3] ? sum3_1 : sum3_0;\n\nendmodule\n\nmodule adder_4bit_rca(\n    input [3:0] a, b,\n    input cin,\n    output [3:0] sum,\n    output cout\n);\n    wire [3:1] carry;\n    full_adder fa0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(carry[1]));\n    full_adder fa1 (.a(a[1]), .b(b[1]), .cin(carry[1]), .sum(sum[1]), .cout(carry[2]));\n    full_adder fa2 (.a(a[2]), .b(b[2]), .cin(carry[2]), .sum(sum[2]), .cout(carry[3]));\n    full_adder fa3 (.a(a[3]), .b(b[3]), .cin(carry[3]), .sum(sum[3]), .cout(cout));\nendmodule\n\nmodule full_adder(\n    input a, b, cin,\n    output sum, cout\n);\n    assign {cout, sum} = a + b + cin;\nendmodule"}], "task_id": 1}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_60', 'type': 'output port'}, {'id': 3, 'content': 'CLK_30', 'type': 'output port'}, {'id': 4, 'content': 'CLK_15', 'type': 'output port'}, {'id': 5, 'content': 'CLK_3', 'type': 'output port'}, {'id': 6, 'content': 'u_div_by_2', 'type': 'submodule'}, {'id': 7, 'content': 'u_div_by_4', 'type': 'submodule'}, {'id': 8, 'content': 'u_div_by_8', 'type': 'submodule'}, {'id': 9, 'content': 'u_div_by_40', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 6, 7, 8, 9], [6, 6, 7, 7, 8, 8, 9, 9, 2, 3, 4, 5]]\n, Design a Verilog hierarchical frequency divider named `complex_freq_div` that takes a 120MHz input clock and outputs four different frequencies: 60MHz, 30MHz, 15MHz, and 3MHz. Utilize separate submodules for each division factor.\n\nModule name:\n    complex_freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_60: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_30: Output clock signal with a frequency of CLK_in divided by 4.\n    CLK_15: Output clock signal with a frequency of CLK_in divided by 8.\n    CLK_3: Output clock signal with a frequency of CLK_in divided by 40.\n\nImplementation:\nThe module will use four submodules to generate the required frequencies:\n- `div_by_2` generates the 60MHz clock.\n- `div_by_4` generates the 30MHz clock by counting up to 1.\n- `div_by_8` generates the 15MHz clock by counting up to 3.\n- `div_by_40` generates the 3MHz clock by counting up to 19.\nAll counters are incremented on every positive edge of CLK_in. If RST is asserted, all output clocks and counters are reset to zero.\nGive me the complete code.\nmodule complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_60,\n    output CLK_30,\n    output CLK_15,\n    output CLK_3\n);"}, {"from": "gpt", "value": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_60,\n    output CLK_30,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_60_out;\n    wire clk_30_out;\n    wire clk_15_out;\n    wire clk_3_out;\n\n    div_by_2 u_div_by_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_60_out)\n    );\n\n    div_by_4 u_div_by_4 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_30_out)\n    );\n\n    div_by_8 u_div_by_8 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    div_by_40 u_div_by_40 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_60 = clk_60_out;\n    assign CLK_30 = clk_30_out;\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule div_by_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\nmodule div_by_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [0:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 1) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule div_by_8 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 3) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule\n\nmodule div_by_40 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt == 19) begin\n                CLK_out <= ~CLK_out;\n                cnt <= 0;\n            end else begin\n                cnt <= cnt + 1;\n            end\n        end\n    end\nendmodule"}], "task_id": 2}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_33', 'type': 'output port'}, {'id': 3, 'content': 'CLK_20', 'type': 'output port'}, {'id': 4, 'content': 'CLK_5', 'type': 'output port'}, {'id': 5, 'content': 'CLK_2', 'type': 'output port'}, {'id': 6, 'content': 'div_33', 'type': 'submodule'}, {'id': 7, 'content': 'div_20', 'type': 'submodule'}, {'id': 8, 'content': 'div_5', 'type': 'submodule'}, {'id': 9, 'content': 'div_2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 6, 7, 8, 9], [6, 6, 7, 7, 8, 8, 9, 9, 2, 3, 4, 5]]\n, Design and implement a Verilog module named `complex_freq_div` to act as a frequency divider, which takes an input clock frequency of 100MHz and outputs four different frequencies: 33MHz, 20MHz, 5MHz, and 2MHz. Each frequency should be generated by separate submodules.\n\nModule name:\n    complex_freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_33: Output clock with a frequency of CLK_in divided by 3.\n    CLK_20: Output clock with a frequency of CLK_in divided by 5.\n    CLK_5: Output clock with a frequency of CLK_in divided by 20.\n    CLK_2: Output clock with a frequency of CLK_in divided by 50.\n\nImplementation:\nThe module uses four submodules: `clk_div_3`, `clk_div_5`, `clk_div_20`, and `clk_div_50`. Each submodule generates the required clock frequencies by counting to a set value and toggling the output clock. The `RST` signal resets all outputs and counters when asserted.\nGive me the complete code.\nmodule complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);"}, {"from": "gpt", "value": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);\n\n    wire clk_33_out;\n    wire clk_20_out;\n    wire clk_5_out;\n    wire clk_2_out;\n\n    clk_div_3 div_33 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_33_out)\n    );\n\n    clk_div_5 div_20 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_20_out)\n    );\n\n    clk_div_20 div_5 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_50 div_2 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_2_out)\n    );\n\n    assign CLK_33 = clk_33_out;\n    assign CLK_20 = clk_20_out;\n    assign CLK_5 = clk_5_out;\n    assign CLK_2 = clk_2_out;\n\nendmodule\n\nmodule clk_div_3 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 2) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_5 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 4) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 19) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_50 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}], "task_id": 3}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'inc', 'type': 'submodule'}, {'id': 5, 'content': 'dec', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 2, 1, 4, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Design a 4-bit synchronous up-down counter using Verilog that can count upwards or downwards based on a control input.\n\nModule name:\n    up_down_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the counter.\n    reset: Reset signal to initialize or reset the counter to zero.\n    ctrl: Control signal where '1' means count up and '0' means count down.\nOutput ports:\n    count [3:0]: 4-bit output representing the current count value.\nInternal logic:\nCount Control: Depending on the ctrl input, a submodule will either increment or decrement the current count value.\nReset Behavior: When reset is high, the counter is reset to zero (count = 4'b0000).\nModularity: Design includes separate submodules for counting up and counting down, enhancing maintainability and encapsulation.\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire ctrl,\n    output wire [3:0] count\n);"}, {"from": "gpt", "value": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire ctrl,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n\n    // Submodule for counting up\n    count_up inc (\n        .clk(clk),\n        .reset(reset),\n        .enable(ctrl),\n        .count(current_count)\n    );\n\n    // Submodule for counting down\n    count_down dec (\n        .clk(clk),\n        .reset(reset),\n        .enable(!ctrl),\n        .count(current_count),\n        .out_count(count)\n    );\n\nendmodule\n\n// Submodule for counting up\nmodule count_up (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (enable)\n            count <= count + 1'b1;\n    end\n\nendmodule\n\n// Submodule for counting down\nmodule count_down (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [3:0] count,\n    output reg [3:0] out_count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            out_count <= 4'b0000;\n        else if (enable)\n            out_count <= count - 1'b1;\n    end\n\nendmodule"}], "task_id": 4}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'data_out', 'type': 'output port'}, {'id': 4, 'content': 'stage1', 'type': 'submodule'}, {'id': 5, 'content': 'stage2', 'type': 'submodule'}, {'id': 6, 'content': 'stage3', 'type': 'submodule'}, {'id': 7, 'content': 'stage4', 'type': 'submodule'}, {'id': 8, 'content': 'stage5', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 4, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8], [4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3]]\n, Design a 5-stage pipeline module for an arithmetic computation unit in Verilog.\n\nModule name:\n    arithmetic_pipeline5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    data_in[15:0]: 16-bit input data.\nOutput ports:\n    data_out[15:0]: 16-bit output data representing the result of the computation.\n\nImplementation:\nIn the arithmetic_pipeline5 module, five pipeline stages (input_stage, add_stage, multiply_stage, subtract_stage, output_stage) are instantiated and connected sequentially. The input_stage receives data and passes it to the add_stage, which adds a constant value. The result is passed to the multiply_stage where it is multiplied by another constant. This result goes through the subtract_stage where a final constant is subtracted. The output_stage then drives this final computed result to the output port.\nGive me the complete code.\nmodule arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);"}, {"from": "gpt", "value": "module arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\nwire [15:0] stage1_out, stage2_out, stage3_out, stage4_out;\n\ninput_stage stage1 (.clk(clk), .rst(rst), .data_in(data_in), .data_out(stage1_out));\nadd_stage stage2 (.clk(clk), .rst(rst), .data_in(stage1_out), .data_out(stage2_out));\nmultiply_stage stage3 (.clk(clk), .rst(rst), .data_in(stage2_out), .data_out(stage3_out));\nsubtract_stage stage4 (.clk(clk), .rst(rst), .data_in(stage3_out), .data_out(stage4_out));\noutput_stage stage5 (.clk(clk), .rst(rst), .data_in(stage4_out), .data_out(data_out));\n\nendmodule\n\nmodule input_stage(\n    input clk, input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) data_out <= 0;\n        else data_out <= data_in;\n    end\nendmodule\n\nmodule add_stage(\n    input clk, input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) data_out <= 0;\n        else data_out <= data_in + 16'd5;\n    end\nendmodule\n\nmodule multiply_stage(\n    input clk, input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) data_out <= 0;\n        else data_out <= data_in * 16'd3;\n    end\nendmodule\n\nmodule subtract_stage(\n    input clk, input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst) data_out <= 0;\n        else data_out <= data_in - 16'd2;\n    end\nendmodule\n\nmodule output_stage(\n    input clk, input rst,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        data_out <= data_in;\n    end\nendmodule"}], "task_id": 5}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'data_in', 'type': 'input port'}, {'id': 1, 'content': 'shift', 'type': 'input port'}, {'id': 2, 'content': 'data_out', 'type': 'output port'}, {'id': 3, 'content': 'bs1', 'type': 'submodule'}, {'id': 4, 'content': 'bs2', 'type': 'submodule'}, {'id': 5, 'content': 'bs3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 4, 5, 3, 4, 0], [3, 4, 5, 2, 2, 2, 2]]\n, Design a top-level Verilog module named \"byte_circular_shifter\" to perform byte-wide (8-bit) circular left shifts on a 32-bit input data. The module should take a 32-bit input vector and a 2-bit shift count, and produce a 32-bit output where the specified number of bytes from the input are circularly shifted left. Each submodule \"byte_shifter\" will shift the input by one byte position left, and the output of each will chain to the next submodule. \n\nModule name:\n    byte_circular_shifter\n\nInput ports:\n    data_in [31:0]: 32-bit input data.\n    shift [1:0]: 2-bit value determining the number of byte positions (0-3) to shift data_in left circularly.\n\nOutput ports:\n    data_out [31:0]: 32-bit output data after circular shift operation.\n\nImplementation:\nThe top module instantiates three \"byte_shifter\" submodules. The outputs of these submodules are selectively routed back to the inputs through a multiplexer controlled by the shift value to achieve the circular shift effect.\nGive me the complete code.\nmodule byte_circular_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);"}, {"from": "gpt", "value": "module byte_circular_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);\n    wire [31:0] shift1_out, shift2_out, shift3_out;\n\n    // Instantiating byte shifters\n    byte_shifter bs1 (.data_in(data_in), .data_out(shift1_out));\n    byte_shifter bs2 (.data_in(shift1_out), .data_out(shift2_out));\n    byte_shifter bs3 (.data_in(shift2_out), .data_out(shift3_out));\n\n    // Selecting output based on shift input\n    always @(*) begin\n        case(shift)\n            2'b00: data_out = data_in;\n            2'b01: data_out = shift1_out;\n            2'b10: data_out = shift2_out;\n            2'b11: data_out = shift3_out;\n        endcase\n    end\nendmodule\n\nmodule byte_shifter (\n    input [31:0] data_in,\n    output [31:0] data_out\n);\n    assign data_out = {data_in[23:0], data_in[31:24]}; // Shift left by one byte\nendmodule"}], "task_id": 6}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'op', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 0, 1], [3, 3, 4, 4]]\n, Design a 16-bit ALU for a custom CPU architecture. The ALU should handle the following operations based on a 4-bit opcode (op): addition, subtraction, bitwise AND, bitwise OR, bitwise XOR, left logical shift, right logical shift, and bitwise NOT on operand a. Inputs include two 16-bit operands, a and b, and a 4-bit opcode. Outputs are the 16-bit result of the operation and a 1-bit flag that indicates if the result is zero.\nGive me the complete code.\nmodule custom_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output reg [15:0] result,\n    output zero\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule custom_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output reg [15:0] result,\n    output zero\n);\n\n    always @(*) begin\n        case (op)\n            4'b0000: result = a + b;           // Addition\n            4'b0001: result = a - b;           // Subtraction\n            4'b0010: result = a & b;           // AND\n            4'b0011: result = a | b;           // OR\n            4'b0100: result = a ^ b;           // XOR\n            4'b0101: result = a << 1;          // Left Shift\n            4'b0110: result = a >> 1;          // Right Shift\n            4'b0111: result = ~a;              // NOT\n            default: result = 16'hxxxx;        // Invalid Opcode\n        endcase\n    end\n\n    assign zero = (result == 16'h0000) ? 1'b1 : 1'b0;\n\nendmodule"}], "task_id": 7}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a00', 'type': 'input port'}, {'id': 3, 'content': 'a01', 'type': 'input port'}, {'id': 4, 'content': 'a10', 'type': 'input port'}, {'id': 5, 'content': 'a11', 'type': 'input port'}, {'id': 6, 'content': 'b00', 'type': 'input port'}, {'id': 7, 'content': 'b01', 'type': 'input port'}, {'id': 8, 'content': 'b10', 'type': 'input port'}, {'id': 9, 'content': 'b11', 'type': 'input port'}, {'id': 10, 'content': 'c00', 'type': 'output port'}, {'id': 11, 'content': 'c01', 'type': 'output port'}, {'id': 12, 'content': 'c10', 'type': 'output port'}, {'id': 13, 'content': 'c11', 'type': 'output port'}, {'id': 14, 'content': 'pe00', 'type': 'submodule'}, {'id': 15, 'content': 'pe01', 'type': 'submodule'}, {'id': 16, 'content': 'pe10', 'type': 'submodule'}, {'id': 17, 'content': 'pe11', 'type': 'submodule'}, {'id': 18, 'content': 'pe20', 'type': 'submodule'}, {'id': 19, 'content': 'pe21', 'type': 'submodule'}, {'id': 20, 'content': 'pe30', 'type': 'submodule'}, {'id': 21, 'content': 'pe31', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 6, 0, 1, 8, 3, 0, 1, 2, 7, 0, 1, 9, 3, 0, 1, 6, 4, 0, 1, 5, 8, 0, 1, 4, 7, 0, 1, 5, 9, 15, 14, 16, 17, 18, 19, 21, 20], [14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 10, 10, 11, 11, 12, 12, 13, 13]]\n, Implement a Verilog module for a systolic array with 2x2 configuration for matrix multiplication. Each processing element should multiply two 8-bit inputs and accumulate the result to a 16-bit output.\n\nModule name:  \n    systolic2x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a00[7:0], a01[7:0], a10[7:0], a11[7:0]: 8-bit input operands for the matrix A.\n    b00[7:0], b01[7:0], b10[7:0], b11[7:0]: 8-bit input operands for the matrix B.\nOutput ports:\n    c00[15:0], c01[15:0], c10[15:0], c11[15:0]: 16-bit outputs representing the matrix product of A and B.\n\nImplementation:\nThe systolic2x2 module instantiates four Processing Elements (PEs). Each PE performs multiplication and accumulative addition on its inputs. The PEs are arranged such that:\n- PE00 multiplies a00 with b00, a01 with b10 and accumulates these products to produce c00.\n- PE01 multiplies a00 with b01, a01 with b11 and accumulates these products to produce c01.\n- PE10 multiplies a10 with b00, a11 with b10 and accumulates these products to produce c10.\n- PE11 multiplies a10 with b01, a11 with b11 and accumulates these products to produce c11.\nThe matrix multiplication is facilitated by the pipeline structure, allowing parallel processing of matrix rows and columns.\nGive me the complete code.\nmodule systolic2x2(\n    input clk,\n    input rst,\n    input [7:0] a00, a01, a10, a11,\n    input [7:0] b00, b01, b10, b11,\n    output [15:0] c00, c01, c10, c11\n);"}, {"from": "gpt", "value": "module systolic2x2(\n    input clk,\n    input rst,\n    input [7:0] a00, a01, a10, a11,\n    input [7:0] b00, b01, b10, b11,\n    output [15:0] c00, c01, c10, c11\n);\n    // Internal connections for intermediate values\n    wire [15:0] p00, p01, p10, p11, p12, p13, p20, p21, p30, p31;\n    \n    // Instantiate PEs\n    PE pe00(.clk(clk), .rst(rst), .a(a00), .b(b00), .p(p00));\n    PE pe01(.clk(clk), .rst(rst), .a(a01), .b(b10), .p(p01));\n    PE pe10(.clk(clk), .rst(rst), .a(a00), .b(b01), .p(p10));\n    PE pe11(.clk(clk), .rst(rst), .a(a01), .b(b11), .p(p11));\n    PE pe20(.clk(clk), .rst(rst), .a(a10), .b(b00), .p(p20));\n    PE pe21(.clk(clk), .rst(rst), .a(a11), .b(b10), .p(p21));\n    PE pe30(.clk(clk), .rst(rst), .a(a10), .b(b01), .p(p30));\n    PE pe31(.clk(clk), .rst(rst), .a(a11), .b(b11), .p(p31));\n    \n    // Accumulate results\n    assign c00 = p00 + p01;\n    assign c01 = p10 + p11;\n    assign c10 = p20 + p21;\n    assign c11 = p30 + p31;\nendmodule\n\nmodule PE(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= p + (a * b);\n    end\nendmodule"}], "task_id": 8}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'up_down', 'type': 'input port'}, {'id': 4, 'content': 'count', 'type': 'output port'}, {'id': 5, 'content': 'logic_unit', 'type': 'submodule'}, {'id': 6, 'content': 'correction_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 1, 2, 5, 6], [5, 5, 5, 5, 6, 4]]\n, Design a 4-bit up/down counter with a binary coded decimal (BCD) correction feature.\n\nModule name:\n    bcd_counter\n\nInput ports:\n    clk: Clock signal for triggering counter updates.\n    reset: Reset signal to set the counter to zero.\n    enable: Enable signal to allow counting.\n    up_down: Signal to select counting direction; high for up, low for down.\n\nOutput ports:\n    count [3:0]: 4-bit output representing the current counter value, corrected for BCD.\n\nInternal logic:\nCounter Logic: A submodule increments or decrements the counter based on the up_down signal. On an overflow (above 9 for up count or below 0 for down count), a BCD correction is applied.\nBCD Correction: Another submodule checks the count; if it is outside 0-9, it adjusts the value to wrap within the BCD range.\nReset Behavior: Counter resets to 0 when the reset signal is high.\nGive me the complete code.\nmodule bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);"}, {"from": "gpt", "value": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] raw_count;\n\n    // Submodule for counter logic\n    counter_logic logic_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .up_down(up_down),\n        .count(raw_count)\n    );\n\n    // Submodule for BCD correction\n    bcd_correction correction_unit (\n        .count_in(raw_count),\n        .count_out(count)\n    );\n\nendmodule\n\n// Submodule for counter logic\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output reg [3:0] count\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (enable) begin\n            if (up_down && count != 4'b1001)\n                count <= count + 1;\n            else if (!up_down && count != 4'b0000)\n                count <= count - 1;\n        end\n    end\n\nendmodule\n\n// Submodule for BCD correction\nmodule bcd_correction (\n    input wire [3:0] count_in,\n    output reg [3:0] count_out\n);\n\n    always @ (count_in) begin\n        if (count_in > 4'b1001)\n            count_out <= 4'b0000; // Reset to 0 on overflow\n        else if (count_in < 4'b0000)\n            count_out <= 4'b1001; // Set to 9 on underflow\n        else\n            count_out <= count_in;\n    end\n\nendmodule"}], "task_id": 9}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'cla1', 'type': 'submodule'}, {'id': 6, 'content': 'cla2', 'type': 'submodule'}, {'id': 7, 'content': 'cla3', 'type': 'submodule'}, {'id': 8, 'content': 'cla4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 0, 1, 5, 6, 1, 0, 0, 7, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Design a 32-bit hierarchical carry-lookahead adder using Verilog. \n\nModule name:  \n    carry_lookahead_32bit               \nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[31:0]: 32-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nIn the carry_lookahead_32bit module, you need to design a smaller bit-width carry-lookahead adder (8-bit adder), which will be instantiated four times to achieve the 32-bit functionality. Each submodule should handle the carry-out and carry-in efficiently to ensure correct summation.\nGive me the complete code.\nmodule carry_lookahead_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire cin,\n    output wire [31:0] sum,\n    output wire cout\n);"}, {"from": "gpt", "value": "module carry_lookahead_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire cin,\n    output wire [31:0] sum,\n    output wire cout\n);\n\n    wire [2:0] carry;\n\n    carry_lookahead_8bit cla1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .cin(cin),\n        .sum(sum[7:0]),\n        .cout(carry[0])\n    );\n\n    carry_lookahead_8bit cla2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .cin(carry[0]),\n        .sum(sum[15:8]),\n        .cout(carry[1])\n    );\n\n    carry_lookahead_8bit cla3 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .cin(carry[1]),\n        .sum(sum[23:16]),\n        .cout(carry[2])\n    );\n\n    carry_lookahead_8bit cla4 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .cin(carry[2]),\n        .sum(sum[31:24]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule carry_lookahead_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire cin,\n    output wire [7:0] sum,\n    output wire cout\n);\n\n    wire [1:0] carry;\n    wire [7:0] g, p, x;\n\n    assign x = a ^ b;\n    assign g = a & b;\n    assign p = x & {7{cin}};\n\n    carry_lookahead_4bit cla1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .cin(cin),\n        .sum(sum[3:0]),\n        .cout(carry[0])\n    );\n\n    carry_lookahead_4bit cla2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .cin(carry[0]),\n        .sum(sum[7:4]),\n        .cout(cout)\n    );\n\nendmodule\n\nmodule carry_lookahead_4bit (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire cin,\n    output wire [3:0] sum,\n    output wire cout\n);\n\n    wire [3:0] g, p, c;\n    wire [2:0] c_internal;\n\n    assign g = a & b;\n    assign p = a ^ b;\n    assign c[0] = cin;\n    assign c[1] = g[0] | (p[0] & c[0]);\n    assign c[2] = g[1] | (p[1] & c[1]);\n    assign c[3] = g[2] | (p[2] & c[2]);\n    assign cout = g[3] | (p[3] & c[3]);\n\n    assign sum = p ^ c;\n\nendmodule"}], "task_id": 10}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'cla_adder', 'type': 'submodule'}, {'id': 6, 'content': 'rc_adder1', 'type': 'submodule'}, {'id': 7, 'content': 'rc_adder2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 0, 1, 2, 0, 1, 2, 5, 7, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 7, 3, 3, 3, 4]]\n, Design a 32-bit hybrid carry look-ahead and ripple carry adder.\n\nModule name:  \n    hybrid_adder_32bit               \nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[31:0]: 32-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the hybrid_adder_32bit module, the design should use a 16-bit carry look-ahead adder for the higher bits and two 8-bit ripple carry adders for the lower bits, efficiently managing carry propagation.\nGive me the complete code.\nmodule hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);"}, {"from": "gpt", "value": "module hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);\n\n    wire carry_mid, carry_high;\n\n    carry_lookahead_16bit cla_adder (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(carry_mid),\n        .y(y[31:16]),\n        .Co(carry_high)\n    );\n\n    ripple_carry_8bit rc_adder1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Cin),\n        .y(y[15:8]),\n        .Co(carry_mid)\n    );\n\n    ripple_carry_8bit rc_adder2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co)\n    );\n\nendmodule\n\nmodule carry_lookahead_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n    // Implementation of carry look-ahead logic\nendmodule\n\nmodule ripple_carry_8bit (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    // Implementation of ripple carry logic\nendmodule"}], "task_id": 11}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'sum', 'type': 'output port'}, {'id': 5, 'content': 'pe0', 'type': 'submodule'}, {'id': 6, 'content': 'pe1', 'type': 'submodule'}, {'id': 7, 'content': 'pe2', 'type': 'submodule'}, {'id': 8, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 0, 1, 2, 3, 7, 5, 8, 6], [5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 4, 4, 4, 4]]\n, Design a systolic array module with a 1x4 configuration tailored for parallel vector addition. Each Processing Element (PE) must handle 8-bit inputs and produce an 8-bit sum output.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a[3:0][7:0]: Four 8-bit inputs for operand vector A.\n    b[3:0][7:0]: Four 8-bit inputs for operand vector B.\nOutput ports:\n    sum[3:0][7:0]: Four 8-bit outputs, each representing the sum of the corresponding elements from vectors A and B.\n\nImplementation:\nThe systolic1x4 module instantiates four Processing Elements (PEs). Each PE performs a simple addition of two 8-bit values. Data flow is parallel without inter-PE communication, simplifying the design and enhancing throughput. Each PE outputs the result immediately at every clock cycle, ensuring high-speed operation suitable for real-time applications.\nGive me the complete code.\nmodule systolic1x4 (\n    input clk,\n    input rst,\n    input [7:0] a[3:0],\n    input [7:0] b[3:0],\n    output [7:0] sum[3:0]\n);"}, {"from": "gpt", "value": "module systolic1x4 (\n    input clk,\n    input rst,\n    input [7:0] a[3:0],\n    input [7:0] b[3:0],\n    output [7:0] sum[3:0]\n);\n    PE pe0 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[0]),\n        .b(b[0]),\n        .sum(sum[0])\n    );\n    PE pe1 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[1]),\n        .b(b[1]),\n        .sum(sum[1])\n    );\n    PE pe2 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[2]),\n        .b(b[2]),\n        .sum(sum[2])\n    );\n    PE pe3 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[3]),\n        .b(b[3]),\n        .sum(sum[3])\n    );\n\nendmodule\n\nmodule PE (\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [7:0] sum\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sum <= 0;\n        end else begin\n            sum <= a + b;\n        end\n    end\nendmodule"}], "task_id": 12}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'mode', 'type': 'input port'}, {'id': 3, 'content': 'Result', 'type': 'output port'}, {'id': 4, 'content': 'Overflow', 'type': 'output port'}, {'id': 5, 'content': 'tcs', 'type': 'submodule'}, {'id': 6, 'content': 'us', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 2, 5, 6, 2, 5], [5, 5, 6, 6, 3, 3, 3, 4, 4]]\n, Design and implement a dual-mode arithmetic subtractor module in Verilog, capable of performing either a 32-bit two's complement subtraction or a 32-bit unsigned subtraction based on a mode selection input.\n\nModule name:\n    dual_mode_subtractor               \nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n    mode: Mode selection input (0 for unsigned, 1 for two's complement).\nOutput ports:\n    Result[31:0]: 32-bit output representing the difference of A and B.\n    Overflow: Indicates an overflow condition for two's complement mode.\n\nImplementation:\nThe top module dual_mode_subtractor should instantiate two distinct 32-bit subtractors: one for unsigned subtraction and another for two's complement subtraction. A multiplexer selects the output of these subtractors based on the mode input.\nGive me the complete code.\nmodule dual_mode_subtractor(A, B, mode, Result, Overflow);"}, {"from": "gpt", "value": "module dual_mode_subtractor(A, B, mode, Result, Overflow);\n    input [31:0] A, B;\n    input mode;\n    output [31:0] Result;\n    output Overflow;\n\n    wire [31:0] two_comp_result, unsigned_result;\n    wire two_comp_overflow, unsigned_overflow;\n\n    two_complement_subtractor tcs(\n        .A(A),\n        .B(B),\n        .Result(two_comp_result),\n        .Overflow(two_comp_overflow)\n    );\n\n    unsigned_subtractor us(\n        .A(A),\n        .B(B),\n        .Result(unsigned_result),\n        .Overflow(unsigned_overflow)\n    );\n\n    assign Result = mode ? two_comp_result : unsigned_result;\n    assign Overflow = mode ? two_comp_overflow : 1'b0;\nendmodule\n\nmodule two_complement_subtractor(A, B, Result, Overflow);\n    input [31:0] A, B;\n    output [31:0] Result;\n    output Overflow;\n\n    wire [31:0] B_not;\n    wire carry_out;\n    \n    assign B_not = ~B + 1;\n    assign {Overflow, Result} = A + B_not;\nendmodule\n\nmodule unsigned_subtractor(A, B, Result, Overflow);\n    input [31:0] A, B;\n    output [31:0] Result;\n    output Overflow;\n\n    wire [31:0] B_not;\n    wire carry_out;\n    \n    assign B_not = ~B;\n    assign {carry_out, Result} = A + B_not + 1'b1;\n    assign Overflow = ~carry_out;\nendmodule"}], "task_id": 13}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'input1', 'type': 'input port'}, {'id': 1, 'content': 'input2', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'add_module', 'type': 'submodule'}, {'id': 5, 'content': 'sub_module', 'type': 'submodule'}, {'id': 6, 'content': 'and_module', 'type': 'submodule'}, {'id': 7, 'content': 'or_module', 'type': 'submodule'}, {'id': 8, 'content': 'xor_module', 'type': 'submodule'}, {'id': 9, 'content': 'not_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 8, 9, 4, 5, 6, 7], [4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 3, 3, 3, 3, 3, 3]]\n, Design a Verilog module for a 16-bit ALU supporting basic arithmetic and logic operations. The ALU should take two 16-bit inputs (input1 and input2) and a 4-bit operation selector (op_code). The output should be a 16-bit result. The supported operations with their respective op_codes are ADD (0000), SUBTRACT (0001), AND (0010), OR (0011), XOR (0100), and NOT (0101) on input1. Define separate submodules for each operation within the main ALU module.\nGive me the complete code.\nmodule alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);\n\n    wire [15:0] add_out, sub_out, and_out, or_out, xor_out, not_out;\n\n    add_16 add_module(.a(input1), .b(input2), .out(add_out));\n    subtract_16 sub_module(.a(input1), .b(input2), .out(sub_out));\n    and_16 and_module(.a(input1), .b(input2), .out(and_out));\n    or_16 or_module(.a(input1), .b(input2), .out(or_out));\n    xor_16 xor_module(.a(input1), .b(input2), .out(xor_out));\n    not_16 not_module(.a(input1), .out(not_out));\n\n    always @(*) begin\n        case(op_code)\n            4'b0000: result = add_out;\n            4'b0001: result = sub_out;\n            4'b0010: result = and_out;\n            4'b0011: result = or_out;\n            4'b0100: result = xor_out;\n            4'b0101: result = not_out;\n            default: result = 16'bz;\n        endcase\n    end\nendmodule\n\nmodule add_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a + b;\nendmodule\n\nmodule subtract_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a - b;\nendmodule\n\nmodule and_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\nmodule not_16(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}], "task_id": 14}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'comp0', 'type': 'submodule'}, {'id': 6, 'content': 'comp1', 'type': 'submodule'}, {'id': 7, 'content': 'comp2', 'type': 'submodule'}, {'id': 8, 'content': 'comp3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 5, 8, 6, 7, 5, 8, 6, 7, 5, 8, 6, 7], [5, 5, 6, 6, 7, 7, 8, 8, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]]\n, Design a 16-bit magnitude comparator utilizing hierarchical Verilog design, consisting of multiple 4-bit comparator submodules.\n\nModule name:\n    comparator_16bit\n\nInput ports:\n    A [15:0]: First 16-bit input operand (binary number to compare).\n    B [15:0]: Second 16-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The 16-bit input operands A and B are divided into four 4-bit chunks. Each chunk is compared using a 4-bit comparator submodule.\nAggregation Logic: The results from the submodules are aggregated in the top-level module to determine if A is greater than, equal to, or less than B. Outputs from higher significance chunks take precedence over lower ones in determining the final result.\nModular Design:\nThe main module (comparator_16bit) instantiates four submodules (comparator_4bit), each responsible for comparing a different 4-bit section of the input operands. The outputs are then aggregated to produce the final comparison results.\nGive me the complete code.\nmodule comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);"}, {"from": "gpt", "value": "module comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [3:0] g, e, l;\n\n    comparator_4bit comp0 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .greater(g[0]),\n        .equal(e[0]),\n        .less(l[0])\n    );\n\n    comparator_4bit comp1 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .greater(g[1]),\n        .equal(e[1]),\n        .less(l[1])\n    );\n\n    comparator_4bit comp2 (\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .greater(g[2]),\n        .equal(e[2]),\n        .less(l[2])\n    );\n\n    comparator_4bit comp3 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .greater(g[3]),\n        .equal(e[3]),\n        .less(l[3])\n    );\n\n    assign A_greater = g[3] | (e[3] & g[2]) | (e[3] & e[2] & g[1]) | (e[3] & e[2] & e[1] & g[0]);\n    assign A_equal = e[3] & e[2] & e[1] & e[0];\n    assign A_less = l[3] | (e[3] & l[2]) | (e[3] & e[2] & l[1]) | (e[3] & e[2] & e[1] & l[0]);\n\nendmodule\n\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output greater,\n    output equal,\n    output less\n);\n\n    wire [3:0] diff = A - B;\n    assign greater = diff[3] == 0 && diff != 0;\n    assign equal = diff == 0;\n    assign less = diff[3] == 1;\n\nendmodule"}], "task_id": 15}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'cla1', 'type': 'submodule'}, {'id': 6, 'content': 'cla2', 'type': 'submodule'}, {'id': 7, 'content': 'cla3', 'type': 'submodule'}, {'id': 8, 'content': 'cla4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 0, 5, 1, 6, 1, 0, 0, 7, 1, 6, 5, 7, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Design and implement a Verilog module for a 32-bit carry-lookahead adder using four 8-bit carry-lookahead adder blocks.\n\nModule name: carry_lookahead_adder_32bit\nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[31:0]: 32-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_lookahead_adder_32bit module uses four instances of an 8-bit carry-lookahead adder submodule. Each submodule calculates an 8-bit sum and a carry-out. The carry-out from each submodule is fed as the carry-in to the next submodule, beginning with the least significant submodule.\nGive me the complete code.\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);"}, {"from": "gpt", "value": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] c;\n\ncarry_lookahead_adder_8bit cla1(\n.a(a[7:0]),\n.b(b[7:0]),\n.cin(cin),\n.sum(sum[7:0]),\n.cout(c[0]));\n\ncarry_lookahead_adder_8bit cla2(\n.a(a[15:8]),\n.b(b[15:8]),\n.cin(c[0]),\n.sum(sum[15:8]),\n.cout(c[1]));\n\ncarry_lookahead_adder_8bit cla3(\n.a(a[23:16]),\n.b(b[23:16]),\n.cin(c[1]),\n.sum(sum[23:16]),\n.cout(c[2]));\n\ncarry_lookahead_adder_8bit cla4(\n.a(a[31:24]),\n.b(b[31:24]),\n.cin(c[2]),\n.sum(sum[31:24]),\n.cout(cout));\nendmodule\n\n//////////////////////////////////////\n//8-bit Carry Lookahead Adder\n//////////////////////////////////////\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] g, p, c;\n\nassign g = a & b;\nassign p = a ^ b;\n\nassign c[0] = cin;\nassign c[1] = g[0] | (p[0] & c[0]);\nassign c[2] = g[1] | (p[1] & c[1]);\nassign c[3] = g[2] | (p[2] & c[2]);\nassign c[4] = g[3] | (p[3] & c[3]);\nassign c[5] = g[4] | (p[4] & c[4]);\nassign c[6] = g[5] | (p[5] & c[5]);\nassign c[7] = g[6] | (p[6] & c[6]);\nassign cout = g[7] | (p[7] & c[7]);\n\nassign sum = p ^ c;\nendmodule"}], "task_id": 16}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'phase_shift', 'type': 'input port'}, {'id': 3, 'content': 'wave1_out', 'type': 'output port'}, {'id': 4, 'content': 'wave2_out', 'type': 'output port'}, {'id': 5, 'content': 'wave_gen1', 'type': 'submodule'}, {'id': 6, 'content': 'wave_gen2', 'type': 'submodule'}, {'id': 7, 'content': 'p_ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 6, 2, 1, 5, 7], [5, 5, 6, 6, 7, 7, 7, 7, 3, 4]]\n, Design a 4-bit dual-phase square wave generator using Verilog. This module generates two square waves with a phase shift. The top module integrates two submodules for generating individual square waves and a submodule to manage the phase shift.\n\nModule Name:\n    dual_phase_square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    reset: Synchronous reset signal.\n    [3:0] phase_shift: Control for setting the phase shift between two waves in number of clock cycles.\n\nOutput Ports:\n    wave1_out: First square wave output.\n    wave2_out: Second square wave output with a phase shift.\n\nInternal Modules:\n    BasicWaveGenerator (basic_wave_gen)\n    Functionality: Generates a basic square wave.\n    Input Ports:\n        clk: Clock signal.\n        reset: Reset signal.\n    Output Ports:\n        wave_out: Square wave output signal.\n    PhaseController (phase_ctrl)\n    Functionality: Manages the phase shift by delaying the output of the second wave generator.\n    Input Ports:\n        clk: Clock signal.\n        reset: Reset signal.\n        [3:0] phase_shift: Number of clock cycles to delay the output.\n        wave_in: Input square wave to be phase-shifted.\n    Output Ports:\n        wave_out: Phase-shifted square wave output.\n\nImplementation:\nEach basic wave generator toggles its output every clock cycle. The phase controller delays the wave output from the second generator by the number of clock cycles specified by the phase_shift input.\nGive me the complete code.\nmodule dual_phase_square_wave(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    output wave1_out,\n    output wave2_out\n);"}, {"from": "gpt", "value": "module dual_phase_square_wave(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    output wave1_out,\n    output wave2_out\n);\n\n    wire wave2_intermediate;\n\n    // Instances of basic wave generator modules\n    basic_wave_gen wave_gen1 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave1_out)\n    );\n\n    basic_wave_gen wave_gen2 (\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave2_intermediate)\n    );\n\n    // Instance of phase controller module\n    phase_ctrl p_ctrl (\n        .clk(clk),\n        .reset(reset),\n        .phase_shift(phase_shift),\n        .wave_in(wave2_intermediate),\n        .wave_out(wave2_out)\n    );\n\nendmodule\n\nmodule basic_wave_gen(\n    input clk,\n    input reset,\n    output reg wave_out\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            wave_out <= 0;\n        end else begin\n            wave_out <= ~wave_out;\n        end\n    end\n\nendmodule\n\nmodule phase_ctrl(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    input wave_in,\n    output reg wave_out\n);\n\n    reg [3:0] delay_counter = 0;\n    reg delayed_wave = 0;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            delay_counter <= 0;\n            delayed_wave <= 0;\n        end else begin\n            if (delay_counter < phase_shift) begin\n                delay_counter <= delay_counter + 1;\n            end else begin\n                delayed_wave <= wave_in;\n            end\n            wave_out <= delayed_wave;\n        end\n    end\n\nendmodule"}], "task_id": 17}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'add_mod', 'type': 'submodule'}, {'id': 5, 'content': 'sub_mod', 'type': 'submodule'}, {'id': 6, 'content': 'and_mod', 'type': 'submodule'}, {'id': 7, 'content': 'or_mod', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 4, 5, 7, 6], [4, 4, 5, 5, 6, 6, 7, 7, 3, 3, 3, 3]]\n, Design a 16-bit ALU for basic arithmetic and bitwise operations. The ALU should support 16-bit addition, subtraction, bitwise AND, and bitwise OR operations. The module should have two 16-bit inputs (a and b), a 2-bit control signal (op_code) to select the operation, and a 16-bit output (result). The operations corresponding to the control signal values are as follows:\n\n    00: ADD\n    01: SUB\n    10: AND\n    11: OR\n\nThe ALU should be modular, incorporating separate submodules for addition, subtraction, and bitwise operations.\n\nModule name:\n    simple_alu\nInput ports:\n    a: a 16-bit input operand\n    b: a 16-bit input operand\n    op_code: a 2-bit control signal for selecting the operation\nOutput ports:\n    result: a 16-bit output representing the result of the operation\nGive me the complete code.\nmodule simple_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op_code,\n    output reg [15:0] result\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule simple_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] op_code,\n    output reg [15:0] result\n);\n    wire [15:0] add_res, sub_res, and_res, or_res;\n\n    add_16 add_mod(.a(a), .b(b), .sum(add_res));\n    sub_16 sub_mod(.a(a), .b(b), .diff(sub_res));\n    and_16 and_mod(.a(a), .b(b), .out(and_res));\n    or_16 or_mod(.a(a), .b(b), .out(or_res));\n\n    always @(*) begin\n        case(op_code)\n            2'b00: result = add_res;\n            2'b01: result = sub_res;\n            2'b10: result = and_res;\n            2'b11: result = or_res;\n            default: result = 16'bx;\n        endcase\n    end\nendmodule\n\nmodule add_16(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule sub_16(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] diff\n);\n    assign diff = a - b;\nendmodule\n\nmodule and_16(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] out\n);\n    assign out = a & b;\nendmodule\n\nmodule or_16(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] out\n);\n    assign out = a | b;\nendmodule"}], "task_id": 18}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'data_a', 'type': 'input port'}, {'id': 3, 'content': 'data_b', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 's1', 'type': 'submodule'}, {'id': 7, 'content': 's2', 'type': 'submodule'}, {'id': 8, 'content': 's3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 4, 1, 3, 2, 0, 6, 0, 7, 1, 8], [6, 6, 6, 6, 6, 7, 7, 8, 8, 8, 5]]\n, Design a Verilog module for a 3-stage arithmetic pipeline processor named `arith_pipeline3`. The processor should perform basic arithmetic operations (addition, subtraction, and multiplication) based on opcode inputs.\n\nModule name:\n    arith_pipeline3\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    data_a[15:0]: 16-bit input data A.\n    data_b[15:0]: 16-bit input data B.\n    opcode[1:0]: Operation code where 00 is addition, 01 is subtraction, and 10 is multiplication.\nOutput ports:\n    result[31:0]: 32-bit output result after computation.\n    \nImplementation:\nIn the arith_pipeline3 module, three pipeline stages are instantiated: stage1 (operand fetch), stage2 (arithmetic operation), and stage3 (output register). The stage1 module fetches the operands and opcode and passes them to stage2. The stage2 module performs the arithmetic operation based on the opcode and passes the result to stage3. The stage3 module holds the result until the next clock cycle. The design uses pipeline registers between each stage to hold intermediate values and control signals.\nGive me the complete code.\nmodule arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);"}, {"from": "gpt", "value": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);\n\nwire [15:0] stage1_data_a, stage1_data_b;\nwire [1:0] stage1_opcode;\nwire [31:0] stage2_result;\n\nstage1 s1(\n    .clk(clk),\n    .rst(rst),\n    .data_a(data_a),\n    .data_b(data_b),\n    .opcode(opcode),\n    .data_a_out(stage1_data_a),\n    .data_b_out(stage1_data_b),\n    .opcode_out(stage1_opcode)\n);\n\nstage2 s2(\n    .clk(clk),\n    .data_a(stage1_data_a),\n    .data_b(stage1_data_b),\n    .opcode(stage1_opcode),\n    .result(stage2_result)\n);\n\nstage3 s3(\n    .clk(clk),\n    .rst(rst),\n    .data_in(stage2_result),\n    .data_out(result)\n);\n\nendmodule\n\nmodule stage1(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output reg [15:0] data_a_out,\n    output reg [15:0] data_b_out,\n    output reg [1:0] opcode_out\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_a_out <= 0;\n        data_b_out <= 0;\n        opcode_out <= 0;\n    end else begin\n        data_a_out <= data_a;\n        data_b_out <= data_b;\n        opcode_out <= opcode;\n    end\nend\nendmodule\n\nmodule stage2(\n    input clk,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output reg [31:0] result\n);\nalways @(posedge clk) begin\n    case (opcode)\n        2'b00: result <= data_a + data_b;\n        2'b01: result <= data_a - data_b;\n        2'b10: result <= data_a * data_b;\n        default: result <= 0;\n    endcase\nend\nendmodule\n\nmodule stage3(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        data_out <= 0;\n    end else begin\n        data_out <= data_in;\n    end\nend\nendmodule"}], "task_id": 19}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'write_en', 'type': 'input port'}, {'id': 3, 'content': 'read_en', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'interrupt_en', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[3, 4, 4], [5, 5, 6]]\n, A control and status register (CSR) module for RISC-V CPUs that holds configuration settings and state information vital for CPU operations, specifically enabling and disabling of interrupts. The CSR can be read or modified based on control inputs.\n\nModule name:\n    csr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the register.\n    write_en: Enable signal for writing data to the register.\n    read_en: Enable signal for reading data from the register.\n    data_in [31:0]: 32-bit input data for writing to the register.\n\nOutput ports:\n    data_out [31:0]: 32-bit output data read from the register.\n    interrupt_en: Signal output that indicates if interrupts are enabled (extracted from a specific bit in CSR).\n\nImplementation:\n    The CSR register uses a submodule to manage read and write operations.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the register is set to a default value where all configurations are disabled.\n    If write_en is high, data_in is written to the register.\n    If read_en is high, data from the register is outputted to data_out.\n    interrupt_en is a specific bit within the register that signals whether interrupts are enabled or disabled.\nGive me the complete code.\nmodule csr_reg (\n    input clk,\n    input rst,\n    input write_en,\n    input read_en,\n    input [31:0] data_in,\n    output [31:0] data_out,\n    output interrupt_en\n);"}, {"from": "gpt", "value": "module csr_reg (\n    input clk,\n    input rst,\n    input write_en,\n    input read_en,\n    input [31:0] data_in,\n    output [31:0] data_out,\n    output interrupt_en\n);\n\n    // Internal register to hold the CSR value\n    reg [31:0] csr_value;\n\n    // Handle reset, write and read\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            csr_value <= 32'd0; // Clear CSR on reset\n        end else begin\n            if (write_en) begin\n                csr_value <= data_in; // Update CSR on write enable\n            end\n        end\n    end\n\n    // Reading the CSR value\n    assign data_out = (read_en) ? csr_value : 32'd0;\n    \n    // Output the interrupt enable status bit\n    assign interrupt_en = csr_value[0]; // Assuming the LSB is the interrupt enable bit\n\nendmodule"}], "task_id": 20}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'S', 'type': 'output port'}, {'id': 4, 'content': 'Cout', 'type': 'output port'}, {'id': 5, 'content': 'RCA0', 'type': 'submodule'}, {'id': 6, 'content': 'RCA1', 'type': 'submodule'}, {'id': 7, 'content': 'RCA2', 'type': 'submodule'}, {'id': 8, 'content': 'RCA3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 1, 5, 0, 1, 6, 0, 1, 7, 0, 5, 6, 7, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Design a Verilog module for a hierarchical 8-bit Ripple-Carry Adder (RCA).\n\nModule name:  \n    ripple_carry_adder_8bit\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n    Cin: Input carry.\nOutput ports:\n    S[7:0]: 8-bit output representing the sum of A and B.\n    Cout: Carry-out output.\n\nImplementation:\nThe top module ripple_carry_adder_8bit should use four instances of a 2-bit RCA block. Each 2-bit RCA block internally uses two 1-bit full adders.\nGive me the complete code.\nmodule ripple_carry_adder_8bit(A, B, Cin, S, Cout);"}, {"from": "gpt", "value": "module ripple_carry_adder_8bit(A, B, Cin, S, Cout);\n    input [7:0] A, B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n    wire c1, c2, c3;\n\n    ripple_carry_adder_2bit RCA0(\n        .A(A[1:0]), \n        .B(B[1:0]), \n        .Cin(Cin), \n        .S(S[1:0]), \n        .Cout(c1)\n    );\n\n    ripple_carry_adder_2bit RCA1(\n        .A(A[3:2]), \n        .B(B[3:2]), \n        .Cin(c1), \n        .S(S[3:2]), \n        .Cout(c2)\n    );\n\n    ripple_carry_adder_2bit RCA2(\n        .A(A[5:4]), \n        .B(B[5:4]), \n        .Cin(c2), \n        .S(S[5:4]), \n        .Cout(c3)\n    );\n\n    ripple_carry_adder_2bit RCA3(\n        .A(A[7:6]), \n        .B(B[7:6]), \n        .Cin(c3), \n        .S(S[7:6]), \n        .Cout(Cout)\n    );\nendmodule\n\nmodule ripple_carry_adder_2bit(A, B, Cin, S, Cout);\n    input [1:0] A, B;\n    input Cin;\n    output [1:0] S;\n    output Cout;\n    wire c1;\n\n    full_adder FA0(\n        .A(A[0]), \n        .B(B[0]), \n        .Cin(Cin), \n        .S(S[0]), \n        .Cout(c1)\n    );\n\n    full_adder FA1(\n        .A(A[1]), \n        .B(B[1]), \n        .Cin(c1), \n        .S(S[1]), \n        .Cout(Cout)\n    );\nendmodule\n\nmodule full_adder(A, B, Cin, S, Cout);\n    input A, B, Cin;\n    output S, Cout;\n\n    assign S = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}], "task_id": 21}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'gray_count', 'type': 'output port'}, {'id': 3, 'content': 'u_binary_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_binary_to_gray_converter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 4], [3, 3, 4, 2]]\n, Create a modular Verilog module called `binary_gray_counter`.\n\nFunction:\nAn 8-bit binary-to-Gray code counter with asynchronous reset. The counter increments its Gray code output on each rising edge of the clock.\n\nInput ports:\n- clk: Clock signal (1-bit), triggers the counter increment on the rising edge.\n- reset: Asynchronous reset signal (1-bit), when high, resets the counter output to Gray code of zero.\n\nOutput ports:\n- gray_count [7:0]: 8-bit output representing the current counter value in Gray code format.\n\nImplementation:\nThe module consists of two submodules: binary_counter and binary_to_gray_converter.\n- The binary_counter module increments a binary value on each clock edge or resets it when the reset is triggered.\n- The binary_to_gray_converter module converts the binary counter value to a Gray code value.\nThe gray_count output represents the current Gray code of the binary count, which can range from 0x00 to 0xFF in Gray code values.\nGive me the complete code.\nmodule binary_gray_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] gray_count\n);"}, {"from": "gpt", "value": "module binary_gray_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] gray_count\n);\n\n    wire [7:0] binary_count;\n\n    // Instantiate the binary counter\n    binary_counter u_binary_counter (\n        .clk(clk),\n        .reset(reset),\n        .binary_count(binary_count)\n    );\n\n    // Instantiate the binary to Gray code converter\n    binary_to_gray_converter u_binary_to_gray_converter (\n        .binary_count(binary_count),\n        .gray_count(gray_count)\n    );\n\nendmodule\n\nmodule binary_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] binary_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary_count <= 8'b0;\n        end else begin\n            binary_count <= binary_count + 1;\n        end\n    end\n\nendmodule\n\nmodule binary_to_gray_converter (\n    input wire [7:0] binary_count,\n    output wire [7:0] gray_count\n);\n\n    assign gray_count = (binary_count >> 1) ^ binary_count;\n\nendmodule"}], "task_id": 22}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'data_in', 'type': 'input port'}, {'id': 1, 'content': 'shift_ctrl', 'type': 'input port'}, {'id': 2, 'content': 'data_out', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[1, 0], [2, 2]]\n, Design a Verilog module for a 16-bit Memory Data Shifter.\n\nModule name: \n    data_shifter\n\nFunction:\n    This 16-bit shifter allows for both logical left and right shifts on a data input. It uses a 4-bit control signal to determine the direction and magnitude of the shift.\n\nInput ports:\n    data_in [15:0]: 16-bit input data to be shifted.\n    shift_ctrl [3:0]: 4-bit control signal. The most significant bit determines the direction (0 for left, 1 for right). The lower 3 bits determine the number of positions to shift (0 to 7 positions).\n\nOutput ports:\n    data_out [15:0]: 16-bit shifted output.\n\nImplementation:\n    The data shifter shifts `data_in` either left or right based on `shift_ctrl[3]`. The amount of shift is determined by `shift_ctrl[2:0]`. The shifting logic uses conditional assignments to update the `data_out` based on the control settings. During a left shift, data is shifted left, and zeros are filled on the right. During a right shift, data is shifted right, and zeros are filled on the left. If `shift_ctrl[2:0]` is zero, `data_out` is equal to `data_in` regardless of the shift direction.\nGive me the complete code.\nmodule data_shifter(data_in, shift_ctrl, data_out);"}, {"from": "gpt", "value": "module data_shifter(data_in, shift_ctrl, data_out);\n    input [15:0] data_in;\n    input [3:0] shift_ctrl;\n    output reg [15:0] data_out;\n\n    always @ (data_in or shift_ctrl)\n    begin\n        case(shift_ctrl[3]) // Check direction\n            1'b0: // Left shift\n                data_out = data_in << shift_ctrl[2:0];\n            1'b1: // Right shift\n                data_out = data_in >> shift_ctrl[2:0];\n        endcase\n    end\nendmodule"}], "task_id": 23}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'add_module', 'type': 'submodule'}, {'id': 8, 'content': 'sub_module', 'type': 'submodule'}, {'id': 9, 'content': 'and_module', 'type': 'submodule'}, {'id': 10, 'content': 'or_module', 'type': 'submodule'}, {'id': 11, 'content': 'xor_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 11, 7, 10, 9, 1, 8, 0, 11, 7, 10, 9, 1, 8, 0, 2, 8, 7, 11, 7, 10, 9, 1, 8, 0], [7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6]]\n, Design a 16-bit ALU for basic arithmetic and logical operations with the additional feature of branch condition checks. The module takes two operands `a` and `b`, a control signal `opcode`, and outputs the result `result`, flags `zero`, `carry`, and `negative`. It supports addition, subtraction, bitwise AND, OR, XOR operations, and branch condition checks for equality and less-than conditions.\n\nThe supported operations and corresponding opcodes are:\n\n    ADD: 4'b0000\n    SUB: 4'b0001\n    AND: 4'b0010\n    OR: 4'b0011\n    XOR: 4'b0100\n    BEQ (branch if equal): 4'b0101\n    BLT (branch if less than): 4'b0110\n\nModule name:\n    alu_16bit\nInput ports:\n    a: a 16-bit input operand\n    b: a 16-bit input operand\n    opcode: a 4-bit control signal for selecting the operation\nOutput ports:\n    result: a 16-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero (and for BEQ condition)\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n\nThe design uses hierarchical modules for each operation, selected via multiplexing in the top module based on the opcode.\nGive me the complete code.\nmodule alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\n    wire [15:0] add_out, sub_out, and_out, or_out, xor_out;\n    wire add_carry, sub_carry;\n\n    adder_16 add_module(.a(a), .b(b), .sum(add_out), .carry_out(add_carry));\n    subtractor_16 sub_module(.a(a), .b(b), .diff(sub_out), .carry_out(sub_carry));\n    and_16 and_module(.a(a), .b(b), .out(and_out));\n    or_16 or_module(.a(a), .b(b), .out(or_out));\n    xor_16 xor_module(.a(a), .b(b), .out(xor_out));\n\n    always @(*) begin\n        case (opcode)\n            4'b0000: result = add_out;   // ADD\n            4'b0001: result = sub_out;   // SUB\n            4'b0010: result = and_out;   // AND\n            4'b0011: result = or_out;    // OR\n            4'b0100: result = xor_out;   // XOR\n            4'b0101: result = (a == b) ? 16'b1 : 16'b0;  // BEQ\n            4'b0110: result = ($signed(a) < $signed(b)) ? 16'b1 : 16'b0;  // BLT\n            default: result = 16'bz;\n        endcase\n    end\n\n    assign zero = (result == 16'b0);\n    assign carry = (opcode == 4'b0000) ? add_carry : (opcode == 4'b0001) ? sub_carry : 1'b0;\n    assign negative = result[15];\n\nendmodule\n\nmodule adder_16(input [15:0] a, input [15:0] b, output [15:0] sum, output carry_out);\n    assign {carry_out, sum} = a + b;\nendmodule\n\nmodule subtractor_16(input [15:0] a, input [15:0] b, output [15:0] diff, output carry_out);\n    assign {carry_out, diff} = a - b;\nendmodule\n\nmodule and_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule"}], "task_id": 24}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'inputA', 'type': 'input port'}, {'id': 4, 'content': 'inputB', 'type': 'input port'}, {'id': 5, 'content': 'outputResult', 'type': 'output port'}, {'id': 6, 'content': 'fetch', 'type': 'submodule'}, {'id': 7, 'content': 'decode', 'type': 'submodule'}, {'id': 8, 'content': 'execute', 'type': 'submodule'}, {'id': 9, 'content': 'memory', 'type': 'submodule'}, {'id': 10, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 4, 3, 0, 6, 7, 0, 6, 7, 0, 9, 8, 0, 9, 8, 10], [6, 6, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 5]]\n, Design a 5-stage pipeline arithmetic logic unit (ALU) in Verilog named pipelineALU5. This ALU should be capable of performing addition, subtraction, bitwise AND, and bitwise OR operations, based on opcode input.\n\nModule name:  \n    pipelineALU5               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    opcode[1:0]: 2-bit control signal to determine the operation (00-Add, 01-Subtract, 10-AND, 11-OR).\n    inputA[15:0]: 16-bit input operand A.\n    inputB[15:0]: 16-bit input operand B.\nOutput ports:\n    outputResult[15:0]: 16-bit result of the ALU operation.\n\nImplementation:\nIn the pipelineALU5 module, five stages of a pipeline (fetch, decode, execute, memory, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for passing the opcode, inputA, and inputB to the decode_stage. The decode_stage determines the operation to be performed and forwards it along with the operands to the execute_stage, which performs the arithmetic or logical operation. The memory_stage is simply a pass-through stage in this ALU, forwarding the results to the writeback_stage, which then outputs the result to outputResult.\nGive me the complete code.\nmodule pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);"}, {"from": "gpt", "value": "// Define operation codes\n`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);\nwire [1:0] opcode_wire;\nwire [15:0] inputA_wire, inputB_wire, result_wire;\n\nfetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .opcode_in(opcode),\n    .inputA_in(inputA),\n    .inputB_in(inputB),\n    .opcode_out(opcode_wire),\n    .inputA_out(inputA_wire),\n    .inputB_out(inputB_wire)\n);\n\ndecode_stage decode(\n    .clk(clk),\n    .opcode_in(opcode_wire),\n    .inputA(inputA_wire),\n    .inputB(inputB_wire),\n    .opcode_out(opcode_wire),\n    .inputA_out(inputA_wire),\n    .inputB_out(inputB_wire)\n);\n\nexecute_stage execute(\n    .clk(clk),\n    .opcode(opcode_wire),\n    .inputA(inputA_wire),\n    .inputB(inputB_wire),\n    .result(result_wire)\n);\n\nmemory_stage memory(\n    .clk(clk),\n    .result_in(result_wire),\n    .result_out(result_wire)\n);\n\nwriteback_stage writeback(\n    .clk(clk),\n    .result_in(result_wire),\n    .result_out(outputResult)\n);\nendmodule\n\nmodule fetch_stage(\n    input clk, input rst,\n    input [1:0] opcode_in,\n    input [15:0] inputA_in, inputB_in,\n    output reg [1:0] opcode_out,\n    output reg [15:0] inputA_out, inputB_out\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n        opcode_out <= 0;\n        inputA_out <= 0;\n        inputB_out <= 0;\n    end else begin\n        opcode_out <= opcode_in;\n        inputA_out <= inputA_in;\n        inputB_out <= inputB_in;\n    end\n  end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input [1:0] opcode_in,\n    input [15:0] inputA, inputB,\n    output reg [1:0] opcode_out,\n    output reg [15:0] inputA_out, inputB_out\n);\n  always @(posedge clk) begin\n    opcode_out <= opcode_in;\n    inputA_out <= inputA;\n    inputB_out <= inputB;\n  end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [1:0] opcode,\n    input [15:0] inputA, inputB,\n    output reg [15:0] result\n);\n  always @(posedge clk) begin\n    case (opcode)\n      `ADD_OP: result <= inputA + inputB;\n      `SUB_OP: result <= inputA - inputB;\n      `AND_OP: result <= inputA & inputB;\n      `OR_OP: result <= inputA | inputB;\n      default: result <= 16'h0000;\n    endcase\n  end\nendmodule\n\nmodule memory_stage(\n    input clk,\n    input [15:0] result_in,\n    output reg [15:0] result_out\n);\n  always @(posedge clk) begin\n    result_out <= result_in;\n  end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [15:0] result_in,\n    output reg [15:0] result_out\n);\n  always @(posedge clk) begin\n    result_out <= result_in;\n  end\nendmodule"}], "task_id": 25}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'extend_A', 'type': 'submodule'}, {'id': 6, 'content': 'extend_B', 'type': 'submodule'}, {'id': 7, 'content': 'compare_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 5, 7, 7, 7], [5, 6, 7, 7, 2, 3, 4]]\n, Design a 16-bit signed comparator module to determine the arithmetic relationship between two 16-bit signed integers using hierarchical design.\n\nModule name:\n    signed_comparator_16bit\n\nInput ports:\n    A [15:0]: First 16-bit signed input operand.\n    B [15:0]: Second 16-bit signed input operand.\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nThe main module (signed_comparator_16bit) uses two submodules. The first submodule (extend_sign_16bit) extends the sign bit to transform the input into a 32-bit signed integer, ensuring arithmetic operations behave as expected for negative numbers.\nThe second submodule (comparator_32bit) then compares these extended integers.\nThe results are used to set the output flags for greater than, less than, or equal conditions.\nEach output is mutually exclusive.\nGive me the complete code.\nmodule signed_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);"}, {"from": "gpt", "value": "module signed_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    wire [31:0] extended_A;\n    wire [31:0] extended_B;\n\n    extend_sign_16bit extend_A (\n        .data_in(A),\n        .data_out(extended_A)\n    );\n\n    extend_sign_16bit extend_B (\n        .data_in(B),\n        .data_out(extended_B)\n    );\n\n    comparator_32bit compare_inst (\n        .A(extended_A),\n        .B(extended_B),\n        .A_greater(A_greater),\n        .A_equal(A_equal),\n        .A_less(A_less)\n    );\n\nendmodule\n\nmodule extend_sign_16bit(\n    input [15:0] data_in,\n    output [31:0] data_out\n);\n    assign data_out = {{16{data_in[15]}}, data_in};\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\n\nendmodule"}], "task_id": 26}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'a', 'type': 'input port'}, {'id': 2, 'content': 'b', 'type': 'input port'}, {'id': 3, 'content': 'mode', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'u_multiplier', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 1, 2, 1, 2, 7, 5, 6], [5, 5, 6, 6, 7, 7, 4, 4, 4]]\n, Design a Verilog module named \"tri_op_pe\" that functions as a Tri-Operational Arithmetic Unit for 16-bit integers, capable of addition, subtraction, or multiplication based on a mode signal. This module should incorporate separate submodules for each operation and select the final output based on a 2-bit mode input.\n\nModule name:\n    tri_op_pe\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    a: 16-bit input operand A.\n    b: 16-bit input operand B.\n    mode: 2-bit input to select operation (00 for add, 01 for subtract, 10 for multiply).\n\nOutput ports:\n    result: 16-bit output based on the mode.\n\nImplementation:\nAdder Submodule:\nThis submodule performs addition on two 16-bit inputs (a and b).\nSubtractor Submodule:\nThis submodule performs subtraction on two 16-bit inputs (a and b).\nMultiplier Submodule:\nThis submodule multiplies two 16-bit inputs (a and b) and outputs the lower 16 bits of the result.\nThe main tri_op_pe module includes a mode decoder and connects the appropriate submodule to the output based on the mode signal.\nGive me the complete code.\nmodule tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);"}, {"from": "gpt", "value": "module tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);\n\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mult_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .difference(sub_result)\n);\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .product(mult_result)\n);\n\n// Mode logic to select the operation\nalways @(posedge clk) begin\n    case (mode)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= mult_result[15:0];\n        default: result <= 16'd0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n    assign product = a * b;\nendmodule"}], "task_id": 27}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'branch_type', 'type': 'input port'}, {'id': 3, 'content': 'condition_flags', 'type': 'input port'}, {'id': 4, 'content': 'take_branch', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[3], [4]]\n, Design a Verilog module named `branch_control` which is a subcomponent of a RISC-V instruction set processor. This module checks the branch conditions based on input flags and outputs a decision whether to take the branch or not.\n\nModule name:\n    branch_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal.\n    branch_type [1:0]: Type of the branch (00 - BEQ, 01 - BNE, 10 - BLT, 11 - BGE).\n    condition_flags [2:0]: Flags from the execution unit (bit 0 - zero flag, bit 1 - negative flag, bit 2 - positive flag).\n\nOutput ports:\n    take_branch: A boolean signal indicating whether to take the branch.\n\nImplementation:\n    This module primarily utilizes combinational logic to determine the branch decision based on the current branch type and condition flags. On reset, the output should default to not taking the branch.\nGive me the complete code.\nmodule branch_control (\n    input clk,\n    input rst_n,\n    input [1:0] branch_type,\n    input [2:0] condition_flags,\n    output reg take_branch\n);"}, {"from": "gpt", "value": "module branch_control (\n    input clk,\n    input rst_n,\n    input [1:0] branch_type,\n    input [2:0] condition_flags,\n    output reg take_branch\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            take_branch <= 1'b0;\n        end else begin\n            case (branch_type)\n                2'b00: take_branch <= condition_flags[0]; // BEQ - take if zero flag is set\n                2'b01: take_branch <= ~condition_flags[0]; // BNE - take if zero flag is not set\n                2'b10: take_branch <= condition_flags[1]; // BLT - take if negative flag is set\n                2'b11: take_branch <= ~condition_flags[1]; // BGE - take if negative flag is not set\n                default: take_branch <= 1'b0;\n            endcase\n        end\n    end\n\nendmodule"}], "task_id": 28}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'enable', 'type': 'input port'}, {'id': 4, 'content': 'ready', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_input_weighting', 'type': 'submodule'}, {'id': 7, 'content': 'u_accumulation_control', 'type': 'submodule'}, {'id': 8, 'content': 'u_output_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 6, 3, 0, 1, 7, 8, 8], [6, 7, 7, 7, 7, 8, 8, 8, 4, 5]]\n, Design a Verilog module for a binary weighted 4-input summing accumulator. The module should accept 4-bit inputs and compute their binary weighted sum (i.e., each subsequent input is twice the value of the previous one). The system must have an enable signal to start accumulation over four consecutive clock cycles. After the fourth input is processed, output the sum and assert a ready signal for one clock cycle. \n\nModule name:\n    weighted_accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[3:0]: 4-bit input data.\n    enable: Input signal to start the accumulation process.\nOutput ports:\n    ready: Output signal indicating the availability of the result.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nInput Weighting Module: Computes the weighted value of each input.\nAccumulation Control Module: Manages the accumulation process over four cycles based on the enable signal.\nOutput Module: Outputs the accumulated result and generates the ready signal.\nGive me the complete code.\nmodule weighted_accu (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   data_in,\n    input               enable,\n    output              ready,\n    output      [9:0]   data_out\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\nmodule weighted_accu (\n    input               clk,\n    input               rst_n,\n    input       [3:0]   data_in,\n    input               enable,\n    output              ready,\n    output      [9:0]   data_out\n);\n\n    wire [9:0] weighted_data;\n    wire [9:0] accum_data;\n    wire start_accum, done;\n\n    // Instantiate the input weighting module\n    input_weighting u_input_weighting (\n        .data_in(data_in),\n        .weighted_data(weighted_data)\n    );\n\n    // Instantiate the accumulation control module\n    accumulation_control u_accumulation_control (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start_accum(start_accum),\n        .weighted_data(weighted_data),\n        .accum_data(accum_data),\n        .done(done)\n    );\n\n    // Instantiate the output module\n    output_module u_output_module (\n        .clk(clk),\n        .rst_n(rst_n),\n        .done(done),\n        .accum_data(accum_data),\n        .data_out(data_out),\n        .ready(ready)\n    );\n\n    assign start_accum = enable;\n\nendmodule\n\nmodule input_weighting (\n    input       [3:0]   data_in,\n    output reg  [9:0]   weighted_data\n);\n\n    always @* begin\n        case(data_in)\n            4'b0001: weighted_data = 10'd1;\n            4'b0010: weighted_data = 10'd2;\n            4'b0100: weighted_data = 10'd4;\n            4'b1000: weighted_data = 10'd8;\n            default: weighted_data = 10'd0;\n        endcase\n    end\n\nendmodule\n\nmodule accumulation_control (\n    input               clk,\n    input               rst_n,\n    input               start_accum,\n    input       [9:0]   weighted_data,\n    output reg  [9:0]   accum_data,\n    output reg          done\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            accum_data <= 0;\n            count <= 0;\n            done <= 0;\n        end\n        else if (start_accum) begin\n            if (count < 4) begin\n                accum_data <= accum_data + weighted_data;\n                count <= count + 1;\n                done <= 0;\n            end\n            if (count == 3) begin\n                done <= 1;\n            end\n        end\n        else begin\n            accum_data <= 0;\n            count <= 0;\n            done <= 0;\n        end\n    end\n\nendmodule\n\nmodule output_module (\n    input               clk,\n    input               rst_n,\n    input               done,\n    input       [9:0]   accum_data,\n    output reg  [9:0]   data_out,\n    output reg          ready\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n            ready <= 0;\n        end\n        else if (done) begin\n            data_out <= accum_data;\n            ready <= 1;\n        end\n        else begin\n            ready <= 0;\n        end\n    end\n\nendmodule"}], "task_id": 29}]