[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_15', 'type': 'output port'}, {'id': 3, 'content': 'CLK_3', 'type': 'output port'}, {'id': 4, 'content': 'div_15', 'type': 'submodule'}, {'id': 5, 'content': 'div_3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 5], [4, 4, 5, 5, 2, 3]]\n, Design a hierarchical Verilog module for a frequency divider that accepts a 60MHz input clock and outputs two different clock signals: 15MHz and 3MHz.\n\nModule name:\n    multi_freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_15: Output clock signal with a frequency of CLK_in divided by 4.\n    CLK_3: Output clock signal with a frequency of CLK_in divided by 20.\n\nImplementation:\nThe module uses two submodules:\n- clk_div_4 to generate the 15MHz clock by counting to 1 and toggling the output.\n- clk_div_20 to generate the 3MHz clock by counting to 9 and toggling the output.\nThe system resets all outputs to 0 when the RST is asserted. Otherwise, each submodule operates independently to produce the required output frequency based on the input clock signal.\nGive me the complete code.\nmodule multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);"}, {"from": "gpt", "value": "module multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_15_out;\n    wire clk_3_out;\n\n    clk_div_4 div_15 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    clk_div_20 div_3 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 1) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [4:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 9) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}], "task_id": 0}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'X_greater', 'type': 'output port'}, {'id': 3, 'content': 'X_equal', 'type': 'output port'}, {'id': 4, 'content': 'X_less', 'type': 'output port'}, {'id': 5, 'content': 'equality', 'type': 'submodule'}, {'id': 6, 'content': 'magnitude', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 6, 5, 5, 6, 5], [5, 5, 6, 6, 2, 2, 3, 4, 4]]\n, Develop a hierarchical 16-bit binary comparator in Verilog, which employs separate equality and magnitude comparison submodules.\n\nModule name:\n    binary_comparator_16bit\n\nInput ports:\n    X [15:0]: First 16-bit binary input.\n    Y [15:0]: Second 16-bit binary input.\nOutput ports:\n    X_greater: 1-bit output, high if X is greater than Y.\n    X_equal: 1-bit output, high if X is equal to Y.\n    X_less: 1-bit output, high if X is less than Y.\n\nImplementation:\nThe main module binary_comparator_16bit instantiates two submodules:\n1. equal_comparator_16bit: Checks if the two inputs are equal.\n2. magnitude_comparator_16bit: Determines if one input is greater than the other.\n\nThe outputs X_greater, X_equal, and X_less are exclusive, ensuring only one is high at any time based on the comparison.\nGive me the complete code.\nmodule binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);"}, {"from": "gpt", "value": "module binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);\n\n    wire equal_flag;\n    wire greater_flag;\n    wire less_flag;\n\n    equal_comparator_16bit equality(\n        .A(X),\n        .B(Y),\n        .equal(equal_flag)\n    );\n\n    magnitude_comparator_16bit magnitude(\n        .A(X),\n        .B(Y),\n        .greater(greater_flag),\n        .less(less_flag)\n    );\n\n    assign X_equal = equal_flag;\n    assign X_greater = greater_flag & ~equal_flag;\n    assign X_less = less_flag & ~equal_flag;\n\nendmodule\n\nmodule equal_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output equal\n);\n\n    assign equal = (A == B);\n\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output greater,\n    output less\n);\n\n    assign greater = (A > B);\n    assign less = (A < B);\n\nendmodule"}], "task_id": 1}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'X_greater_Y', 'type': 'output port'}, {'id': 3, 'content': 'X_equal_Y', 'type': 'output port'}, {'id': 4, 'content': 'X_less_Y', 'type': 'output port'}, {'id': 5, 'content': 'comp0', 'type': 'submodule'}, {'id': 6, 'content': 'comp1', 'type': 'submodule'}, {'id': 7, 'content': 'comp2', 'type': 'submodule'}, {'id': 8, 'content': 'comp3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1], [5, 5, 6, 6, 7, 7, 8, 8]]\n, Design a 16-bit arithmetic magnitude comparator module using hierarchical design in Verilog. The module will compare two 16-bit inputs to determine their magnitude relationship.\n\nModule name:\n    magnitude_comparator_16bit\n\nInput ports:\n    X [15:0]: First 16-bit input operand.\n    Y [15:0]: Second 16-bit input operand.\nOutput ports:\n    X_greater_Y: 1-bit output indicating if X is greater than Y.\n    X_equal_Y: 1-bit output indicating if X is equal to Y.\n    X_less_Y: 1-bit output indicating if X is less than Y.\n\nImplementation:\nComparison Logic: Compares two 16-bit numbers X and Y using hierarchical bit-by-bit comparison logic starting from the most significant bit.\nModular Design:\nThe main module (magnitude_comparator_16bit) instantiates four 4-bit comparator submodules (bitwise_comparator_4bit), each handling a portion of the input bits.\nThe outputs (X_greater_Y, X_equal_Y, X_less_Y) are driven by a sequential logic evaluation of the outputs from the 4-bit comparators, ensuring correct priority for higher significance bits.\nGive me the complete code.\nmodule magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);"}, {"from": "gpt", "value": "module magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    wire [3:0] greater;\n    wire [3:0] equal;\n    wire [3:0] less;\n\n    bitwise_comparator_4bit comp0 (\n        .A(X[3:0]),\n        .B(Y[3:0]),\n        .A_greater_B(greater[0]),\n        .A_equal_B(equal[0]),\n        .A_less_B(less[0])\n    );\n\n    bitwise_comparator_4bit comp1 (\n        .A(X[7:4]),\n        .B(Y[7:4]),\n        .A_greater_B(greater[1]),\n        .A_equal_B(equal[1]),\n        .A_less_B(less[1])\n    );\n\n    bitwise_comparator_4bit comp2 (\n        .A(X[11:8]),\n        .B(Y[11:8]),\n        .A_greater_B(greater[2]),\n        .A_equal_B(equal[2]),\n        .A_less_B(less[2])\n    );\n\n    bitwise_comparator_4bit comp3 (\n        .A(X[15:12]),\n        .B(Y[15:12]),\n        .A_greater_B(greater[3]),\n        .A_equal_B(equal[3]),\n        .A_less_B(less[3])\n    );\n\n    always @(*) begin\n        if (greater[3] || (equal[3] && greater[2]) || (equal[3] && equal[2] && greater[1]) || (equal[3] && equal[2] && equal[1] && greater[0])) begin\n            X_greater_Y = 1;\n            X_equal_Y = 0;\n            X_less_Y = 0;\n        end else if (equal[0] && equal[1] && equal[2] && equal[3]) begin\n            X_greater_Y = 0;\n            X_equal_Y = 1;\n            X_less_Y = 0;\n        end else begin\n            X_greater_Y = 0;\n            X_equal_Y = 0;\n            X_less_Y = 1;\n        end\n    end\n\nendmodule\n\nmodule bitwise_comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output A_greater_B,\n    output A_equal_B,\n    output A_less_B\n);\n    assign A_greater_B = (A > B);\n    assign A_equal_B = (A == B);\n    assign A_less_B = (A < B);\nendmodule"}], "task_id": 2}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Result', 'type': 'output port'}, {'id': 3, 'content': 'Overflow', 'type': 'output port'}, {'id': 4, 'content': 'lower_sub', 'type': 'submodule'}, {'id': 5, 'content': 'higher_sub', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Design a 16-bit subtractor module named sub_16bit that subtracts two 16-bit numbers and outputs the result along with an overflow flag. The subtraction should be executed using two instances of an 8-bit subtractor module named sub_8bit.\n\nModule name:\n    sub_16bit\n\nInput ports:\n    A[15:0]: 16-bit input operand A.\n    B[15:0]: 16-bit input operand B.\n\nOutput ports:\n    Result[15:0]: 16-bit output representing the difference of A and B.\n    Overflow: A flag indicating if an overflow occurred during the subtraction.\n\nImplementation:\nThe top module sub_16bit should utilize two instantiated sub_8bit modules to perform the subtraction of the lower and upper 8 bits separately. An overflow detection logic should be included to check if there is a mismatch between the borrow-out of the lower 8 bits and the borrow-out of the upper 8 bits, indicating an overflow.\nGive me the complete code.\nmodule sub_16bit(A, B, Result, Overflow);"}, {"from": "gpt", "value": "module sub_16bit(A, B, Result, Overflow);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Result;\n    output Overflow;\n\n    wire [7:0] low_result;\n    wire [7:0] high_result;\n    wire low_borrow_out;\n    wire high_borrow_out;\n    wire borrow_in;\n\n    // Lower 8 bits subtraction\n    sub_8bit lower_sub (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(low_result),\n        .B_out(low_borrow_out)\n    );\n\n    // Higher 8 bits subtraction with borrow in\n    sub_8bit higher_sub (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(high_result),\n        .B_out(high_borrow_out)\n    );\n\n    // Set borrow in for the higher 8 bits subtractor\n    assign borrow_in = low_borrow_out;\n\n    // Result concatenation\n    assign Result = {high_result, low_result};\n\n    // Overflow detection logic\n    assign Overflow = (low_borrow_out ^ high_borrow_out);\n\nendmodule\n\nmodule sub_8bit(A, B, D, B_out);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output B_out;\n\n    wire [7:0] B_complement;\n    wire borrow;\n\n    assign B_complement = ~B + 1;\n\n    adder_8bit adder_inst(\n        .A(A),\n        .B(B_complement),\n        .D(D),\n        .Cout(borrow)\n    );\n\n    assign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, D, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] D;\n    output Cout;\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Cout));\n\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\nendmodule"}], "task_id": 3}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_next_count_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_count_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[5, 2, 0, 4, 1, 5], [4, 4, 5, 5, 5, 3]]\n, Design a Verilog module named `mod10_counter`.\n\nFunction:\nA 4-bit counter that counts up from 0 to 9 in a cyclic manner and provides an enable control.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), resets the counter to 0.\n    - enable: Enable signal (1-bit), allows the counter to increment if high.\n\nOutput ports:\n    - count [3:0]: 4-bit output representing the current counter value.\n\nImplementation:\nThe module utilizes two submodules: next_count_logic and count_register.\n- The next_count_logic module calculates the next count value based on the current count and enable signal.\n- The count_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output cycles through values from 0 to 9.\nGive me the complete code.\nmodule mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);"}, {"from": "gpt", "value": "module mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the next count logic\n    next_count_logic u_next_count_logic (\n        .current_count(count),\n        .enable(enable),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    count_register u_count_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule next_count_logic (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            next_count = (current_count == 9) ? 0 : current_count + 1;\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule count_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0; \n        end else begin\n            current_count <= next_count; \n        end\n    end\n\nendmodule"}], "task_id": 4}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'data_in', 'type': 'input port'}, {'id': 1, 'content': 'shift_amt', 'type': 'input port'}, {'id': 2, 'content': 'shift_dir', 'type': 'input port'}, {'id': 3, 'content': 'data_out', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1], [3, 3, 3]]\n, Design a 32-bit barrel shifter in Verilog that can perform left and right circular shifts based on control signals. The module should have the capability to shift the input data by a specified number of positions ranging from 0 to 31.\n\nModule name:\n    barrel_shifter_32\n\nInput ports:\n    data_in: 32-bit input data to be shifted.\n    shift_amt: 5-bit input specifying the number of positions to shift.\n    shift_dir: 1-bit input determining the shift direction (0 for left, 1 for right).\n\nOutput ports:\n    data_out: 32-bit output data after the shift operation.\n\nImplementation:\nThe barrel shifter consists of a series of multiplexers that selectively route the bits of the input data to the output based on the shift amount and direction. A shift amount of zero results in no change to the input data.\nGive me the complete code.\nmodule barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);"}, {"from": "gpt", "value": "module barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);\n    wire [31:0] left_shift, right_shift;\n    \n    // Generate left circular shift outputs\n    assign left_shift = (data_in << shift_amt) | (data_in >> (32 - shift_amt));\n    \n    // Generate right circular shift outputs\n    assign right_shift = (data_in >> shift_amt) | (data_in << (32 - shift_amt));\n    \n    // MUX to select between left shift and right shift\n    assign data_out = shift_dir ? right_shift : left_shift;\n\nendmodule"}], "task_id": 5}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'data', 'type': 'input port'}, {'id': 1, 'content': 'shift_control', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'shift_left_module', 'type': 'submodule'}, {'id': 4, 'content': 'shift_right_module', 'type': 'submodule'}, {'id': 5, 'content': 'rotate_right_module', 'type': 'submodule'}, {'id': 6, 'content': 'output_selector', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 0, 4, 3, 5, 1, 6], [3, 3, 4, 4, 5, 5, 6, 6, 6, 6, 6, 2]]\n, Design a Verilog module named `memory_shifter`.\n\nFunction:\nThis module shifts or rotates a 16-bit memory block based on a 4-bit control signal.\n\nInput ports:\n- data [15:0]: 16-bit data input.\n- shift_control [3:0]: Control signal for determining the type and amount of shift. The higher two bits (shift_control[3:2]) determine the direction (00 for no shift, 01 for left shift, 10 for right shift, 11 for rotate right). The lower two bits (shift_control[1:0]) determine the number of positions (from 0 to 3 positions).\n\nOutput ports:\n- out [15:0]: 16-bit output after shifting.\n\nImplementation:\nThe memory shifter shifts or rotates the input `data` based on the value of `shift_control`. The shifting or rotating happens in stages, each controlled by the specific bits in `shift_control`. The module uses submodules to perform shifting and rotating, each capable of handling different types of operations (left shift, right shift, rotate right).\nGive me the complete code.\nmodule memory_shifter(data, shift_control, out);"}, {"from": "gpt", "value": "module memory_shifter(data, shift_control, out);\n  input [15:0] data;\n  input [3:0] shift_control;\n  output [15:0] out;\n  wire [15:0] shift_left_output, shift_right_output, rotate_right_output;\n  \n  shift_left #(.WIDTH(16), .SHIFT_BITS(2)) shift_left_module(\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .out(shift_left_output)\n  );\n  \n  shift_right #(.WIDTH(16), .SHIFT_BITS(2)) shift_right_module(\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .out(shift_right_output)\n  );\n  \n  rotate_right #(.WIDTH(16), .SHIFT_BITS(2)) rotate_right_module(\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .out(rotate_right_output)\n  );\n  \n  mux4x1 #(.WIDTH(16)) output_selector (\n    .in0(data),\n    .in1(shift_left_output),\n    .in2(shift_right_output),\n    .in3(rotate_right_output),\n    .sel(shift_control[3:2]),\n    .out(out)\n  );\n  \nendmodule\n\nmodule shift_left #(parameter WIDTH = 16, SHIFT_BITS = 2) (data, shift_amount, out);\n  input [WIDTH-1:0] data;\n  input [SHIFT_BITS-1:0] shift_amount;\n  output [WIDTH-1:0] out;\n  \n  assign out = data << shift_amount;\nendmodule\n\nmodule shift_right #(parameter WIDTH = 16, SHIFT_BITS = 2) (data, shift_amount, out);\n  input [WIDTH-1:0] data;\n  input [SHIFT_BITS-1:0] shift_amount;\n  output [WIDTH-1:0] out;\n  \n  assign out = data >> shift_amount;\nendmodule\n\nmodule rotate_right #(parameter WIDTH = 16, SHIFT_BITS = 2) (data, shift_amount, out);\n  input [WIDTH-1:0] data;\n  input [SHIFT_BITS-1:0] shift_amount;\n  output [WIDTH-1:0] out;\n  \n  assign out = (data >> shift_amount) | (data << (WIDTH - shift_amount));\nendmodule\n\nmodule mux4x1 #(parameter WIDTH = 16) (in0, in1, in2, in3, sel, out);\n  input [WIDTH-1:0] in0, in1, in2, in3;\n  input [1:0] sel;\n  output [WIDTH-1:0] out;\n  \n  assign out = (sel == 2'b00) ? in0 :\n               (sel == 2'b01) ? in1 :\n               (sel == 2'b10) ? in2 : in3;\nendmodule"}], "task_id": 6}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'control', 'type': 'input port'}, {'id': 4, 'content': 'result_valid', 'type': 'output port'}, {'id': 5, 'content': 'result_out', 'type': 'output port'}, {'id': 6, 'content': 'u_adder', 'type': 'submodule'}, {'id': 7, 'content': 'u_multiplier', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 7, 6], [6, 7, 5, 5]]\n, Develop a Verilog-based modular arithmetic system designed for 16-bit signed integers. This system should integrate an adder and multiplier submodule, with sequential operation control. Each cycle, the system either adds or multiplies two successive input data based on the control signal. The module must use pipelining to optimize performance, and include an output valid signal to indicate when the result is ready.\n\nModule name:\n    arithmetic_pipeline\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[15:0]: 16-bit signed input data.\n    control: Control signal to select operation (0 for addition, 1 for multiplication).\nOutput ports:\n    result_valid: Output signal set high when the result is ready.\n    result_out[31:0]: 32-bit output data, can either be sum or product of inputs.\n\nImplementation:\nThe design will incorporate two main submodules:\nAdder Module: Conducts the addition of two 16-bit signed integers.\nMultiplier Module: Performs the multiplication of two 16-bit signed integers.\nControl Logic Module: Decides whether to add or multiply based on the control signal and handles the result_valid signal.\nGive me the complete code.\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);\n\n    reg [15:0] data_buffer;\n    reg op_ready;\n    wire [31:0] add_result;\n    wire [31:0] mul_result;\n\n    // Instantiate the adder module\n    adder u_adder (\n        .a(data_buffer),\n        .b(data_in),\n        .sum(add_result)\n    );\n\n    // Instantiate the multiplier module\n    multiplier u_multiplier (\n        .a(data_buffer),\n        .b(data_in),\n        .product(mul_result)\n    );\n\n    // Control logic for operation selection and data buffering\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_buffer <= 0;\n            result_out <= 0;\n            result_valid <= 0;\n            op_ready <= 0;\n        end\n        else begin\n            data_buffer <= data_in; // Buffer the input data\n            op_ready <= 1; // Set ready after input is buffered\n            if (op_ready) begin\n                if (control == 0) // Addition\n                    result_out <= add_result;\n                else // Multiplication\n                    result_out <= mul_result;\n                result_valid <= 1; // Result is ready\n            end\n            else begin\n                result_valid <= 0; // Result is not ready\n            end\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n    assign product = a * b;\nendmodule"}], "task_id": 7}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_is_power_two_less_B', 'type': 'output port'}, {'id': 3, 'content': 'power_two_checker', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 0, 1], [3, 2, 2, 2]]\n, Design a 16-bit arithmetic comparator that checks if the first number is a power of two less than the second number. Create this using hierarchical design with a bit checker submodule and a main comparator module.\n\nModule name:\n    power_two_comparator_16bit\n\nInput ports:\n    A [15:0]: First 16-bit input operand (binary number to be checked if it's a power of two).\n    B [15:0]: Second 16-bit input operand (binary number to compare against).\nOutput ports:\n    A_is_power_two_less_B: 1-bit output indicating if A is a power of two and less than B.\n\nImplementation:\nThe module checks if A is a power of two by ensuring only one bit in A is set to 1. This is done using the bit checker submodule.\nIf A is a power of two, the comparator then checks if A is less than B.\nThe module outputs 1 if A is both a power of two and less than B; otherwise, it outputs 0.\nModular Design:\nThe main module (power_two_comparator_16bit) instantiates a submodule (is_power_two_16bit) which checks if a number is a power of two.\nThe outputs are directly used in the main module to produce the final comparison output.\nGive me the complete code.\nmodule power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);"}, {"from": "gpt", "value": "module power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);\n\n    wire power_two_flag;\n\n    // Instantiate the power-of-two checking submodule\n    is_power_two_16bit power_two_checker (\n        .in_number(A),\n        .is_power_two(power_two_flag)\n    );\n\n    // Determine if A is both a power of two and less than B\n    assign A_is_power_two_less_B = power_two_flag && (A < B);\n\nendmodule\n\nmodule is_power_two_16bit(\n    input [15:0] in_number,\n    output is_power_two\n);\n\n    // Check if only one bit is set in in_number\n    assign is_power_two = in_number && !(in_number & (in_number - 16'b1));\n\nendmodule"}], "task_id": 8}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'cla1', 'type': 'submodule'}, {'id': 6, 'content': 'cla2', 'type': 'submodule'}, {'id': 7, 'content': 'cla3', 'type': 'submodule'}, {'id': 8, 'content': 'cla4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 5, 1, 0, 1, 0, 6, 7, 1, 0, 8, 5, 6, 7, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Design a 32-bit carry lookahead adder using hierarchical modules.\n\nModule name:\n    carry_lookahead_adder_32bit\nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[31:0]: 32-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_lookahead_adder_32bit uses multiple 8-bit carry lookahead adder slices for higher speed arithmetic operations. It connects these slices hierarchically to propagate carries effectively across all 32 bits.\nGive me the complete code.\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);"}, {"from": "gpt", "value": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n    .a(a[7:0]), \n    .b(b[7:0]), \n    .cin(cin), \n    .sum(sum[7:0]), \n    .cout(carry[0])\n);\n\ncarry_lookahead_adder_8bit cla2(\n    .a(a[15:8]), \n    .b(b[15:8]), \n    .cin(carry[0]), \n    .sum(sum[15:8]), \n    .cout(carry[1])\n);\n\ncarry_lookahead_adder_8bit cla3(\n    .a(a[23:16]), \n    .b(b[23:16]), \n    .cin(carry[1]), \n    .sum(sum[23:16]), \n    .cout(carry[2])\n);\n\ncarry_lookahead_adder_8bit cla4(\n    .a(a[31:24]), \n    .b(b[31:24]), \n    .cin(carry[2]), \n    .sum(sum[31:24]), \n    .cout(cout)\n);\nendmodule\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [7:0] g, p;\nwire [8:0] c;\n\nassign g = a & b;\nassign p = a ^ b;\nassign c[0] = cin;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 8; i = i + 1) begin: carry_generate\n        assign c[i+1] = g[i] | (p[i] & c[i]);\n    end\nendgenerate\n\nassign sum = p ^ c[7:0];\nassign cout = c[8];\nendmodule"}], "task_id": 9}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'sel', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'u_xor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 3, 2, 3, 2, 5, 7, 6], [5, 5, 6, 6, 7, 7, 4, 4, 4]]\n, Design a Verilog module for a Combined Arithmetic Logic Unit (ALU) with three operations: addition, subtraction, and bitwise XOR for 16-bit integers. The module should be hierarchical, containing separate submodules for each operation.\n\nModule name:\n    combined_alu\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    sel: 2-bit input to select the operation (00 for addition, 01 for subtraction, 10 for XOR).\n    a: 16-bit input operand A.\n    b: 16-bit input operand B.\n\nOutput ports:\n    result: 16-bit output of the operation.\n\nImplementation:\nThe module includes:\nAdder Submodule:\n    This submodule performs addition of two 16-bit numbers.\nSubtractor Submodule:\n    This submodule performs subtraction between two 16-bit numbers.\nXOR Submodule:\n    This submodule performs bitwise XOR on two 16-bit numbers.\nThe main combined_alu module uses the sel signal to select which submodule's output to pass to the result based on the selected operation.\nGive me the complete code.\nmodule combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);"}, {"from": "gpt", "value": "module combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\nwire [15:0] sum;\nwire [15:0] difference;\nwire [15:0] xor_result;\n\nadder u_adder(\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor(\n    .a(a),\n    .b(b),\n    .difference(difference)\n);\n\nxor_module u_xor(\n    .a(a),\n    .b(b),\n    .xor_result(xor_result)\n);\n\nalways @(posedge clk) begin\n    case(sel)\n        2'b00: result <= sum;\n        2'b01: result <= difference;\n        2'b10: result <= xor_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}], "task_id": 10}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'instr', 'type': 'input port'}, {'id': 1, 'content': 'opcode', 'type': 'output port'}, {'id': 2, 'content': 'rs1', 'type': 'output port'}, {'id': 3, 'content': 'rs2', 'type': 'output port'}, {'id': 4, 'content': 'rd', 'type': 'output port'}, {'id': 5, 'content': 'func3', 'type': 'output port'}, {'id': 6, 'content': 'func7', 'type': 'output port'}, {'id': 7, 'content': 'imm', 'type': 'output port'}, {'id': 8, 'content': 'func_decoder', 'type': 'submodule'}, {'id': 9, 'content': 'registers', 'type': 'submodule'}, {'id': 10, 'content': 'immediates', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 9, 9, 9, 8, 8, 10], [8, 9, 10, 1, 2, 3, 4, 5, 6, 7]]\n, Design a RISC-V instruction decoder module that takes encoded instruction bits as input and separates them into various fields such as opcode, function codes, and immediate values based on the instruction type.\n\nModule name:\n    instr_decoder\n\nInput ports:\n    instr [31:0]: 32-bit input instruction from memory.\n\nOutput ports:\n    opcode [6:0]: 7-bit opcode, which determines the instruction type.\n    rs1 [4:0]: 5-bit source register 1 identifier.\n    rs2 [4:0]: 5-bit source register 2 identifier.\n    rd [4:0]: 5-bit destination register identifier.\n    func3 [2:0]: 3-bit function code, which refines the operation within an opcode.\n    func7 [6:0]: 7-bit function code, used for further specifying operations.\n    imm [31:0]: 32-bit immediate value, used for instructions requiring constants.\n\nImplementation:\n    The instruction decoder takes a 32-bit instruction and extracts relevant fields based on standard RISC-V encoding rules.\n    Opcodes are extracted directly from the first 7 bits.\n    Depending on the opcode, the module routes the instruction to appropriate submodules for decoding specific fields.\nGive me the complete code.\nmodule instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);"}, {"from": "gpt", "value": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n\n    // Decode the opcode directly from instruction\n    assign opcode = instr[6:0];\n\n    // Decode function codes and registers based on opcode\n    func_code_decoder func_decoder (\n        .instr(instr),\n        .func3(func3),\n        .func7(func7)\n    );\n\n    reg_decoder registers (\n        .instr(instr),\n        .rs1(rs1),\n        .rs2(rs2),\n        .rd(rd)\n    );\n\n    imm_decoder immediates (\n        .instr(instr),\n        .imm(imm)\n    );\n\nendmodule\n\nmodule func_code_decoder (\n    input [31:0] instr,\n    output [2:0] func3,\n    output [6:0] func7\n);\n    assign func3 = instr[14:12];\n    assign func7 = instr[31:25];\nendmodule\n\nmodule reg_decoder (\n    input [31:0] instr,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd\n);\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\n    assign rd = instr[11:7];\nendmodule\n\nmodule imm_decoder (\n    input [31:0] instr,\n    output reg [31:0] imm\n);\n    always @(*) begin\n        case (instr[6:0])\n            7'b0010011: imm = {{20{instr[31]}}, instr[31:20]}; // I-Type\n            7'b0100011: imm = {{20{instr[31]}}, instr[31:25], instr[11:7]}; // S-Type\n            default: imm = 32'b0;\n        endcase\n    end\nendmodule"}], "task_id": 11}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'load', 'type': 'input port'}, {'id': 3, 'content': 'shift_dir', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'count_out', 'type': 'output port'}, {'id': 6, 'content': 'u_shift_logic', 'type': 'submodule'}, {'id': 7, 'content': 'u_shift_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 7, 4, 0, 2, 1, 6, 7], [6, 6, 7, 7, 7, 7, 7, 5]]\n, Design a Verilog module for a 4-bit circular shift register counter with a dynamic shift direction based on control inputs.\n\nModule name:\n    dynamic_shift_counter\n\nFunction:\nA 4-bit counter that shifts either left or right based on control signals. Additionally, the counter can load a specific value to start with, making it versatile for different initial conditions.\n\nInput ports:\n    - clk: Clock signal (1-bit), used for synchronization.\n    - reset: Reset signal (1-bit), resets the counter to the initial value.\n    - load: Load signal (1-bit), loads a new value when high.\n    - shift_dir: Shift direction signal (1-bit), determines the direction of shift (0 for left, 1 for right).\n    - data_in: 4-bit input used to load new values into the counter.\n\nOutput ports:\n    - count_out: 4-bit output representing the current counter value.\n\nImplementation:\nThe module is structured into two submodules: shift_logic and shift_register.\n- The shift_logic module determines the next count value either by shifting left or right based on the current count and control signals.\n- The shift_register module updates the current count on the rising edge of the clock signal, resets it based on the reset condition, or loads a new value as per the load signal.\nThe count_out will reflect the circular shifted values or loaded values based on control signals.\nGive me the complete code.\nmodule dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);"}, {"from": "gpt", "value": "module dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the shift logic\n    shift_logic u_shift_logic (\n        .shift_dir(shift_dir),\n        .current_count(count_out),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    shift_register u_shift_register (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(data_in),\n        .next_count(next_count),\n        .current_count(count_out)\n    );\n\nendmodule\n\nmodule shift_logic (\n    input wire shift_dir,\n    input wire [3:0] current_count,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (shift_dir) begin\n            next_count = {current_count[0], current_count[3:1]};  // Shift right\n        end else begin\n            next_count = {current_count[2:0], current_count[3]};  // Shift left\n        end\n    end\n\nendmodule\n\nmodule shift_register (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 4'b0000; \n        end else if (load) begin\n            current_count <= data_in; \n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}], "task_id": 12}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'direction_control', 'type': 'submodule'}, {'id': 5, 'content': 'count_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 5], [4, 5, 5, 5, 3]]\n, Design a 4-bit up/down counter using Verilog with separate modules for counting and controlling count direction.\n\nModule name:\n    bidirectional_counter\n\nInput ports:\n    clk: Clock signal to trigger counting operations.\n    reset: Reset signal to set the counter to zero.\n    up_down: Control signal to specify count direction (1 for up, 0 for down).\n\nOutput ports:\n    count [3:0]: 4-bit output that shows the current count value.\n\nInternal logic:\nCounting Logic: A submodule performs the actual counting, increasing or decreasing based on the up_down control signal.\nReset Behavior: When the reset is high, the counter is reset to 0 (count = 4'b0000).\nCount Direction: Another submodule controls the direction of the count based on the up_down signal.\nModularity: The design consists of separate submodules for counting and direction control to enhance modularity and simplify debugging.\nGive me the complete code.\nmodule bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);"}, {"from": "gpt", "value": "module bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n    wire direction;\n\n    // Submodule for controlling count direction\n    count_direction_controller direction_control (\n        .up_down(up_down),\n        .direction(direction)\n    );\n\n    // Submodule for counting\n    counter count_module (\n        .clk(clk),\n        .reset(reset),\n        .direction(direction),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\n// Submodule for controlling count direction\nmodule count_direction_controller (\n    input wire up_down,\n    output wire direction\n);\n    assign direction = up_down;\nendmodule\n\n// Submodule for counting\nmodule counter (\n    input wire clk,\n    input wire reset,\n    input wire direction,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else begin\n            if (direction)\n                count <= count + 1;\n            else\n                count <= count - 1;\n        end\n    end\n\nendmodule"}], "task_id": 13}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_bcd_increment', 'type': 'submodule'}, {'id': 5, 'content': 'u_bcd_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[5, 0, 1, 4, 2, 5], [4, 5, 5, 5, 5, 3]]\n, Design a Verilog module for a 4-bit binary coded decimal (BCD) counter that can count from 0 to 9 repeatedly. The counter increments on every positive clock edge when enabled and resets to 0 when a reset signal is applied.\n\nModule name:\n    bcd_counter\n\nFunction:\nA 4-bit counter specifically designed to handle BCD values, useful for digital clock or calculator displays.\n\nInput ports:\n    - clk: Clock signal (1-bit), for synchronizing the counter.\n    - reset: Reset signal (1-bit), sets the counter value to 0 when active high.\n    - enable: Enable signal (1-bit), allows the counter to increment if high.\n\nOutput ports:\n    - count [3:0]: 4-bit output representing the current counter value in BCD format (0000 to 1001).\n\nImplementation:\nThe module is divided into two submodules: bcd_increment and bcd_register.\n- The bcd_increment module computes the next count based on the current count, only incrementing if the current value is less than 9 or resetting to 0 otherwise.\n- The bcd_register module holds the current BCD count, updating on the positive edge of the clock if the enable signal is active and not in a reset state.\nGive me the complete code.\nmodule bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);"}, {"from": "gpt", "value": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the BCD increment logic\n    bcd_increment u_bcd_increment (\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the BCD value\n    bcd_register u_bcd_register (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule bcd_increment (\n    input wire [3:0] current_count,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (current_count == 9) begin\n            next_count = 0; \n        end else begin\n            next_count = current_count + 1;\n        end\n    end\n\nendmodule\n\nmodule bcd_register (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0; \n        end else if (enable) begin\n            current_count <= next_count; \n        end\n    end\n\nendmodule"}], "task_id": 14}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'data_mem', 'type': 'input port'}, {'id': 3, 'content': 'ctrl_unit', 'type': 'input port'}, {'id': 4, 'content': 'result_reg', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory_access', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 3, 0, 3, 0, 5, 6, 0, 7, 2, 0, 8, 9], [5, 5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 4]]\n, Design a 5-stage pipeline Verilog module for performing arithmetic and logical operations. \n\nModule name:  \n    stagepipe5               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    data_mem[0:31]: 32x32-bit memory array representing the data memory for operands.\n    ctrl_unit[0:7]: 8x8-bit array for control signals that decide the operation type.\nOutput ports:\n    result_reg[31:0]: 32-bit output registering the result of the computation.\n\nImplementation:\nThe stagepipe5 module comprises five pipeline stages: Fetch, Decode, Execute, Memory access, and Writeback. The Fetch stage reads data from the data memory using the indices provided in the ctrl_unit. The Decode stage identifies the operation to be performed based on the control unit. The Execute stage performs the arithmetic or logical operation. The Memory Access stage optionally stores or modifies data in the data memory depending on the operation. The Writeback stage saves the result into the result register.\nGive me the complete code.\nmodule stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);"}, {"from": "gpt", "value": "// Define operations\n`define ADD 3'b000\n`define SUB 3'b001\n`define AND 3'b010\n`define OR  3'b011\n`define XOR 3'b100\n\nmodule stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);\nwire [31:0] fetched_data;\nwire [2:0] op_code;\nwire [31:0] execution_result;\nwire [31:0] memory_data;\n\nfetch_stage fetch(.clk(clk), .rst(rst), .data_mem(data_mem), .ctrl_unit(ctrl_unit), .fetched_data(fetched_data));\ndecode_stage decode(.clk(clk), .ctrl_unit(ctrl_unit), .op_code(op_code));\nexecute_stage execute(.clk(clk), .op_code(op_code), .fetched_data(fetched_data), .execution_result(execution_result));\nmemory_access_stage memory_access(.clk(clk), .data_mem(data_mem), .execution_result(execution_result), .memory_data(memory_data));\nwriteback_stage writeback(.clk(clk), .memory_data(memory_data), .result_reg(result_reg));\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output reg [31:0] fetched_data\n);\n    always @(posedge clk or posedge rst) begin\n        if(rst)\n            fetched_data <= 0;\n        else\n            fetched_data <= data_mem[ctrl_unit[0]];\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input [7:0] ctrl_unit [0:7],\n    output reg [2:0] op_code\n);\n    always @(posedge clk) begin\n        op_code <= ctrl_unit[1][2:0];\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input [2:0] op_code,\n    input [31:0] fetched_data,\n    output reg [31:0] execution_result\n);\n    always @(posedge clk) begin\n        case(op_code)\n            `ADD: execution_result <= fetched_data + fetched_data;\n            `SUB: execution_result <= fetched_data - fetched_data;\n            `AND: execution_result <= fetched_data & fetched_data;\n            `OR: execution_result <= fetched_data | fetched_data;\n            `XOR: execution_result <= fetched_data ^ fetched_data;\n            default: execution_result <= fetched_data;\n        endcase\n    end\nendmodule\n\nmodule memory_access_stage(\n    input clk,\n    input [31:0] data_mem [0:31],\n    input [31:0] execution_result,\n    output reg [31:0] memory_data\n);\n    always @(posedge clk) begin\n        memory_data <= execution_result;  // Simple pass-through for example\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input [31:0] memory_data,\n    output reg [31:0] result_reg\n);\n    always @(posedge clk) begin\n        result_reg <= memory_data;\n    end\nendmodule"}], "task_id": 15}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Product', 'type': 'output port'}, {'id': 3, 'content': 'mul0', 'type': 'submodule'}, {'id': 4, 'content': 'mul1', 'type': 'submodule'}, {'id': 5, 'content': 'mul2', 'type': 'submodule'}, {'id': 6, 'content': 'mul3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 5, 6, 4, 3], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Design a 16-bit multiplier using hierarchical Verilog with basic 4-bit multiplier submodules.\n\nModule name:\n    multiplier_16bit\n\nInput ports:\n    A [15:0]: First 16-bit input operand (binary number to multiply).\n    B [15:0]: Second 16-bit input operand (binary number to multiply).\nOutput ports:\n    Product [31:0]: 32-bit output representing the product of A and B.\n\nImplementation:\nMultiplication Logic: The module multiplies two 16-bit binary numbers A and B.\nSplit Inputs: Inputs A and B are each split into four 4-bit chunks.\nPartial Products: Each pair of 4-bit chunks from A and B is multiplied using 4-bit multiplier submodules, resulting in a partial product.\nSummation: Partial products are shifted appropriately and summed to produce the final 32-bit product.\nModular Design:\nThe main module (multiplier_16bit) instantiates four 4-bit multiplier submodules for each combination of chunks from A and B.\nGive me the complete code.\nmodule multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);"}, {"from": "gpt", "value": "module multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);\n    wire [15:0] pp0, pp1, pp2, pp3; \n\n    // Instantiate four 4-bit multipliers\n    multiplier_4bit mul0 (\n        .A(A[3:0]), \n        .B(B[3:0]), \n        .Product(pp0[15:0])\n    );\n    multiplier_4bit mul1 (\n        .A(A[7:4]), \n        .B(B[3:0]), \n        .Product(pp1[15:0])\n    );\n    multiplier_4bit mul2 (\n        .A(A[3:0]), \n        .B(B[7:4]), \n        .Product(pp2[15:0])\n    );\n    multiplier_4bit mul3 (\n        .A(A[7:4]), \n        .B(B[7:4]), \n        .Product(pp3[15:0])\n    );\n\n    // Summing up partial products with shifting\n    assign Product = (pp0 << 0) + (pp1 << 4) + (pp2 << 4) + (pp3 << 8);\n\nendmodule\n\nmodule multiplier_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output [15:0] Product\n);\n    // Simple 4-bit multiplier logic\n    assign Product = A * B;\nendmodule"}], "task_id": 16}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'CLK_200MHz', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'CLK_25MHz', 'type': 'output port'}, {'id': 3, 'content': 'CLK_5MHz', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1MHz', 'type': 'output port'}, {'id': 5, 'content': 'CLK_200kHz', 'type': 'output port'}, {'id': 6, 'content': 'div_25MHz', 'type': 'submodule'}, {'id': 7, 'content': 'div_5MHz', 'type': 'submodule'}, {'id': 8, 'content': 'div_1MHz', 'type': 'submodule'}, {'id': 9, 'content': 'div_200kHz', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 6, 7, 8, 9], [6, 6, 7, 7, 8, 8, 9, 9, 2, 3, 4, 5]]\n, Design a Verilog frequency divider named \"complex_freq_div\" that takes an input clock signal of 200MHz and produces four different output frequencies: 25MHz, 5MHz, 1MHz, and 0.2MHz. The design should feature a hierarchical structure with each frequency output implemented in a separate submodule.\n\nModule name:\n    complex_freq_div\n\nInput ports:\n    CLK_200MHz: Input clock signal\n    reset: Active-high reset signal\n\nOutput ports:\n    CLK_25MHz: Output clock signal with a frequency of CLK_200MHz divided by 8.\n    CLK_5MHz: Output clock signal with a frequency of CLK_200MHz divided by 40.\n    CLK_1MHz: Output clock signal with a frequency of CLK_200MHz divided by 200.\n    CLK_200kHz: Output clock signal with a frequency of CLK_200MHz divided by 1000.\n\nImplementation:\nEach frequency is generated using counters:\n- clk_div_8 generates CLK_25MHz by counting to 3 and toggling the output.\n- clk_div_40 generates CLK_5MHz by counting to 19 and toggling the output.\n- clk_div_200 generates CLK_1MHz by counting to 99 and toggling the output.\n- clk_div_1000 generates CLK_200kHz by counting to 499 and toggling the output.\nAll submodules reset their outputs and counters upon a positive edge of reset.\nGive me the complete code.\nmodule complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);"}, {"from": "gpt", "value": "module complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);\n\n    wire clk_25_out;\n    wire clk_5_out;\n    wire clk_1_out;\n    wire clk_200k_out;\n\n    clk_div_8 div_25MHz (\n        .CLK_in(CLK_200MHz),\n        .RST(reset),\n        .CLK_out(clk_25_out)\n    );\n\n    clk_div_40 div_5MHz (\n        .CLK_in(CLK_200MHz),\n        .RST(reset),\n        .CLK_out(clk_5_out)\n    );\n\n    clk_div_200 div_1MHz (\n        .CLK_in(CLK_200MHz),\n        .RST(reset),\n        .CLK_out(clk_1_out)\n    );\n\n    clk_div_1000 div_200kHz (\n        .CLK_in(CLK_200MHz),\n        .RST(reset),\n        .CLK_out(clk_200k_out)\n    );\n\n    assign CLK_25MHz = clk_25_out;\n    assign CLK_5MHz = clk_5_out;\n    assign CLK_1MHz = clk_1_out;\n    assign CLK_200kHz = clk_200k_out;\n\nendmodule\n\nmodule clk_div_8 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 3) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_40 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 19) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_200 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 99) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_1000 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [9:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 499) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}], "task_id": 17}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'mag_comp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 5, 5, 0, 5], [5, 5, 2, 2, 3, 4, 4]]\n, Design a 16-bit signed magnitude comparator module with hierarchical design in Verilog.\n\nModule name:\n    signed_magnitude_comparator_16bit\n\nInput ports:\n    A [15:0]: First 16-bit signed magnitude input (binary number to compare).\n    B [15:0]: Second 16-bit signed magnitude input (binary number to compare).\n\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: This module compares two 16-bit numbers represented in signed magnitude format. The most significant bit (MSB) represents the sign (0 for positive, 1 for negative).\nSign Check: First, signs are compared. If the signs differ, the output is determined directly by the signs.\nMagnitude Comparison: If signs are the same, the magnitudes (remaining 15 bits) are compared using a 15-bit unsigned magnitude comparator submodule.\nOutput Logic: Based on the sign and magnitude comparison, outputs are A_greater, A_equal, or A_less, which are mutually exclusive.\n\nModular Design:\nThe top module (signed_magnitude_comparator_16bit) instantiates a submodule (unsigned_magnitude_comparator_15bit) to compare the magnitude of the inputs if the signs are identical.\nGive me the complete code.\nmodule signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);"}, {"from": "gpt", "value": "module signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    wire [14:0] A_magnitude = A[14:0];\n    wire [14:0] B_magnitude = B[14:0];\n    wire A_sign = A[15];\n    wire B_sign = B[15];\n    wire magnitude_greater, magnitude_equal, magnitude_less;\n\n    // Instantiate the 15-bit unsigned magnitude comparator\n    unsigned_magnitude_comparator_15bit mag_comp (\n        .A(A_magnitude),\n        .B(B_magnitude),\n        .A_greater(magnitude_greater),\n        .A_equal(magnitude_equal),\n        .A_less(magnitude_less)\n    );\n\n    // Determine the comparison outputs based on sign and magnitude\n    always @(*) begin\n        if (A_sign != B_sign) begin\n            A_greater = ~A_sign;\n            A_less = A_sign;\n            A_equal = 1'b0;\n        end else begin\n            A_greater = magnitude_greater;\n            A_equal = magnitude_equal;\n            A_less = magnitude_less;\n        end\n    end\n\nendmodule\n\nmodule unsigned_magnitude_comparator_15bit(\n    input [14:0] A,   \n    input [14:0] B,   \n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    assign A_greater = A > B;\n    assign A_equal = A == B;\n    assign A_less = A < B;\n\nendmodule"}], "task_id": 18}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'direction', 'type': 'input port'}, {'id': 4, 'content': 'value', 'type': 'output port'}, {'id': 5, 'content': 'u_control_unit', 'type': 'submodule'}, {'id': 6, 'content': 'u_increment_decrement_logic', 'type': 'submodule'}, {'id': 7, 'content': 'u_register_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[7, 2, 3, 7, 6, 0, 5, 1, 7], [5, 5, 5, 6, 7, 7, 7, 7, 4]]\n, Module name:\n    bidirectional_circular_counter\n\nFunction:\nA 12-bit counter capable of counting upward or downward in a circular manner based on control signals, with an enable feature. The counting wraps around when it reaches the limits.\n\nInput ports:\n    - clk: Clock signal (1-bit), ensures the counter operates synchronously.\n    - reset: Reset signal (1-bit), resets the counter to a predefined value.\n    - enable: Enable signal (1-bit), allows the counter to operate when high.\n    - direction: Control signal (1-bit), if high the counter increments, if low it decrements.\n\nOutput ports:\n    - value [11:0]: 12-bit output showing the current value of the counter.\n\nImplementation:\nThis counter utilizes three submodules: control_unit, increment_decrement_logic, and register_unit.\n- The control_unit determines the counting operation based on direction and enable signals.\n- The increment_decrement_logic calculates the next value considering circular counting.\n- The register_unit stores the current value of the counter, updating on each clock cycle as permitted by the enable signal.\nThe output 'value' displays the present counter value, varying from 0 to 4095 in both directions depending on the control input.\nGive me the complete code.\nmodule bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);"}, {"from": "gpt", "value": "module bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);\n\n    wire [11:0] next_value;\n\n    // Instantiate the control logic\n    control_unit u_control_unit (\n        .enable(enable),\n        .direction(direction),\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Instantiate the logic for incrementing or decrementing\n    increment_decrement_logic u_increment_decrement_logic (\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Register to hold the current counter value\n    register_unit u_register_unit (\n        .clk(clk),\n        .reset(reset),\n        .next_value(next_value),\n        .current_value(value)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire enable,\n    input wire direction,\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @(*) begin\n        if (enable) begin\n            if (direction) begin\n                next_value = (current_value == 12'b1111_1111_1111) ? 12'b0 : current_value + 1;\n            end else begin\n                next_value = (current_value == 12'b0) ? 12'b1111_1111_1111 : current_value - 1;\n            end\n        end else begin\n            next_value = current_value;\n        end\n    end\n\nendmodule\n\nmodule increment_decrement_logic (\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @(*) begin\n        next_value = current_value; // This logic can be expanded or modified to include more complex functionality\n    end\n\nendmodule\n\nmodule register_unit (\n    input wire clk,\n    input wire reset,\n    input wire [11:0] next_value,\n    output reg [11:0] current_value\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_value <= 12'b0;\n        end else begin\n            current_value <= next_value;\n        end\n    end\n\nendmodule"}], "task_id": 19}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instruction', 'type': 'input port'}, {'id': 3, 'content': 'op_type', 'type': 'output port'}, {'id': 4, 'content': 'dest_reg', 'type': 'output port'}, {'id': 5, 'content': 'immediate', 'type': 'output port'}, {'id': 6, 'content': 'op_decoder', 'type': 'submodule'}, {'id': 7, 'content': 'dest_decoder', 'type': 'submodule'}, {'id': 8, 'content': 'imm_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 2, 0, 1, 2, 6, 7, 8], [6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 4, 5]]\n, Design a RISC-V instruction decoder module that receives an instruction and decodes it to determine the type of operation, destination register, and immediate value. This module will distribute the decoding task to several submodules to separate the decoding of the operation, destination register, and immediate values.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to reset the outputs.\n    instruction [31:0]: 32-bit instruction code.\n\nOutput ports:\n    op_type [6:0]: Decoded operation type.\n    dest_reg [4:0]: Decoded destination register.\n    immediate [31:0]: Decoded immediate value.\n\nImplementation:\n    The instruction decoder makes use of three submodules: decode_op, decode_dest, and decode_imm. \n    On the rising edge of the clock, if the reset signal is low, all outputs are reset to zero.\n    The decode_op submodule extracts and outputs the operation type from the instruction.\n    The decode_dest submodule extracts and outputs the destination register from the instruction.\n    The decode_imm submodule extracts and outputs the immediate value from the instruction.\n    Each submodule has its specific bit slicing logic based on the RISC-V standard instruction formats.\nGive me the complete code.\nmodule instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);"}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);\n\n    // Submodule instances\n    wire [6:0] op_wire;\n    wire [4:0] dest_wire;\n    wire [31:0] imm_wire;\n\n    decode_op op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .op_type(op_wire)\n    );\n\n    decode_dest dest_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .dest_reg(dest_wire)\n    );\n\n    decode_imm imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .immediate(imm_wire)\n    );\n\n    // Output assignments\n    assign op_type = op_wire;\n    assign dest_reg = dest_wire;\n    assign immediate = imm_wire;\n\nendmodule\n\n// Submodule for operation type decoding\nmodule decode_op (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] op_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) op_type <= 7'b0;\n        else op_type <= instruction[6:0];\n    end\nendmodule\n\n// Submodule for destination register decoding\nmodule decode_dest (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [4:0] dest_reg\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) dest_reg <= 5'b0;\n        else dest_reg <= instruction[11:7];\n    end\nendmodule\n\n// Submodule for immediate value decoding\nmodule decode_imm (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] immediate\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) immediate <= 32'b0;\n        else immediate <= { {20{instruction[31]}}, instruction[31:20] };\n    end\nendmodule"}], "task_id": 20}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'load', 'type': 'input port'}, {'id': 3, 'content': 'config_data', 'type': 'input port'}, {'id': 4, 'content': 'current_config', 'type': 'output port'}, {'id': 5, 'content': 'config_store', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 2, 1, 5], [5, 5, 5, 5, 4]]\n, Design a RISC-V Control Unit Configuration Register which will load a new configuration setting based on the specified control signal. The register is 32-bit wide, capable of storing multiple control settings for CPU behavior modification.\n\nModule name:\n    ctrl_unit_config_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst_n: Active low reset signal to reset the register.\n    load: Active high signal to load new data into the configuration register.\n    config_data [31:0]: 32-bit data input representing the new configuration setting.\n\nOutput ports:\n    current_config [31:0]: Outputs the currently stored configuration settings.\n\nImplementation:\n    The configuration register module contains a primary submodule handling the 32-bit register operations. On the rising edge of the clock, if the reset signal is low, the configuration register is reset to a default value of zero. If the load signal is active, the configuration register updates its content with the new configuration data. The current configuration data is then output continuously until updated.\nGive me the complete code.\nmodule ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);"}, {"from": "gpt", "value": "module ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);\n\n    // Submodule for configuration register storage\n    wire [31:0] config_register_out;\n\n    configuration_storage config_store (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load(load),\n        .data(config_data),\n        .config_out(config_register_out)\n    );\n\n    // Output assignment\n    assign current_config = config_register_out;\n\nendmodule\n\n// Submodule for configuration storage\nmodule configuration_storage (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] data,\n    output reg [31:0] config_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            config_out <= 32'd0; // Reset the configuration register\n        end else if (load) begin\n            config_out <= data; // Load new data into the configuration register\n        end\n    end\n\nendmodule"}], "task_id": 21}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'sub1', 'type': 'submodule'}, {'id': 4, 'content': 'sub2', 'type': 'submodule'}, {'id': 5, 'content': 'sub3', 'type': 'submodule'}, {'id': 6, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 5, 3, 4, 6], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Design and implement a 32-bit hierarchical carry-save subtractor (CSS) module in Verilog. \n\nModule name:\n    subtractor_32bit_css              \nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n\nImplementation:\nThe top module, subtractor_32bit_css, utilizes four 8-bit carry-save subtractor modules, each responsible for subtracting parts of the input operands and generating intermediate sums and carries, which are further processed to produce the final difference result.\nGive me the complete code.\nmodule subtractor_32bit_css(A, B, Diff);"}, {"from": "gpt", "value": "module subtractor_32bit_css(A, B, Diff);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n\n    wire [7:0] s1, s2, s3, s4;\n    wire [7:0] c1, c2, c3, c4;\n\n    css_subtractor sub1(.A(A[7:0]), .B(B[7:0]), .S(s1), .C(c1));\n    css_subtractor sub2(.A(A[15:8]), .B(B[15:8]), .S(s2), .C(c2));\n    css_subtractor sub3(.A(A[23:16]), .B(B[23:16]), .S(s3), .C(c3));\n    css_subtractor sub4(.A(A[31:24]), .B(B[31:24]), .S(s4), .C(c4));\n\n    assign Diff[7:0] = s1;\n    assign Diff[15:8] = s2 ^ c1;\n    assign Diff[23:16] = s3 ^ c2;\n    assign Diff[31:24] = s4 ^ c3;\nendmodule\n\nmodule css_subtractor(A, B, S, C);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] S;\n    output [7:0] C;\n\n    assign S = A ^ B; // Perform bitwise subtraction (sum in terms of addition)\n    assign C = (~A & B); // Carry generation\nendmodule"}], "task_id": 22}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'bss1', 'type': 'submodule'}, {'id': 5, 'content': 'bss2', 'type': 'submodule'}, {'id': 6, 'content': 'bss3', 'type': 'submodule'}, {'id': 7, 'content': 'bss4', 'type': 'submodule'}, {'id': 8, 'content': 'bss5', 'type': 'submodule'}, {'id': 9, 'content': 'bss6', 'type': 'submodule'}, {'id': 10, 'content': 'bss7', 'type': 'submodule'}, {'id': 11, 'content': 'bss8', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 5, 0, 1, 0, 1, 6, 7, 0, 1, 8, 0, 1, 9, 0, 1, 0, 1, 10, 8, 10, 5, 9, 11, 6, 7, 4, 11], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 2, 2, 2, 2, 2, 2, 2, 2, 3]]\n, Design a 32-bit cascaded borrow-save subtractor module for Verilog implementation.\n\nModule name:\n    sub_32bit_cascaded               \nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\nOutput ports:\n    D[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit_cascaded consists of eight instances of the 4-bit borrow-save subtractor block.\nGive me the complete code.\nmodule sub_32bit_cascaded(A, B, D, B_out);"}, {"from": "gpt", "value": "module sub_32bit_cascaded(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [6:0] borrow;\n\n    // Cascading eight 4-bit borrow-save subtractors\n    borrow_save_sub4 bss1 (.A(A[3:0]), .B(B[3:0]), .borrow_in(1'b0), .D(D[3:0]), .borrow_out(borrow[0]));\n    borrow_save_sub4 bss2 (.A(A[7:4]), .B(B[7:4]), .borrow_in(borrow[0]), .D(D[7:4]), .borrow_out(borrow[1]));\n    borrow_save_sub4 bss3 (.A(A[11:8]), .B(B[11:8]), .borrow_in(borrow[1]), .D(D[11:8]), .borrow_out(borrow[2]));\n    borrow_save_sub4 bss4 (.A(A[15:12]), .B(B[15:12]), .borrow_in(borrow[2]), .D(D[15:12]), .borrow_out(borrow[3]));\n    borrow_save_sub4 bss5 (.A(A[19:16]), .B(B[19:16]), .borrow_in(borrow[3]), .D(D[19:16]), .borrow_out(borrow[4]));\n    borrow_save_sub4 bss6 (.A(A[23:20]), .B(B[23:20]), .borrow_in(borrow[4]), .D(D[23:20]), .borrow_out(borrow[5]));\n    borrow_save_sub4 bss7 (.A(A[27:24]), .B(B[27:24]), .borrow_in(borrow[5]), .D(D[27:24]), .borrow_out(borrow[6]));\n    borrow_save_sub4 bss8 (.A(A[31:28]), .B(B[31:28]), .borrow_in(borrow[6]), .D(D[31:28]), .borrow_out(B_out));\nendmodule\n\nmodule borrow_save_sub4(A, B, borrow_in, D, borrow_out);\n    input [3:0] A, B;\n    input borrow_in;\n    output [3:0] D;\n    output borrow_out;\n\n    wire [3:0] borrow_internal;\n\n    assign borrow_internal[0] = (~A[0] & B[0]) | (borrow_in & (~A[0] | B[0]));\n    assign D[0] = A[0] ^ B[0] ^ borrow_in;\n    assign borrow_internal[1] = (~A[1] & B[1]) | (borrow_internal[0] & (~A[1] | B[1]));\n    assign D[1] = A[1] ^ B[1] ^ borrow_internal[0];\n    assign borrow_internal[2] = (~A[2] & B[2]) | (borrow_internal[1] & (~A[2] | B[2]));\n    assign D[2] = A[2] ^ B[2] ^ borrow_internal[1];\n    assign borrow_internal[3] = (~A[3] & B[3]) | (borrow_internal[2] & (~A[3] | B[3]));\n    assign D[3] = A[3] ^ B[3] ^ borrow_internal[2];\n    assign borrow_out = (~A[3] & B[3]) | (borrow_internal[3] & (~A[3] | B[3]));\nendmodule"}], "task_id": 23}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk_in', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'clk_60', 'type': 'output port'}, {'id': 3, 'content': 'clk_3', 'type': 'output port'}, {'id': 4, 'content': 'div_60', 'type': 'submodule'}, {'id': 5, 'content': 'div_3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5], [4, 4, 5, 5, 2, 3]]\n, Design a Verilog module for a frequency divider that takes a 120 MHz input clock and generates two output clocks at 60 MHz and 3 MHz. Employ a hierarchical design approach where each frequency generation is managed by a separate submodule.\n\nModule name:\n    hierarchical_freq_div\n\nInput ports:\n    clk_in: 120 MHz input clock signal\n    rst: Asynchronous reset signal\n\nOutput ports:\n    clk_60: 60 MHz output clock signal, which is clk_in divided by 2.\n    clk_3: 3 MHz output clock signal, which is clk_in divided by 40.\n\nImplementation:\nThe top module instantiates two submodules. The first submodule, clk_div_by_2, generates a 60 MHz clock by toggling the output on every positive edge of clk_in. The second submodule, clk_div_by_40, generates a 3 MHz clock using a counter to count up to 19 and then toggling the output.\n\nBoth submodules should be reset when rst is high. Upon the rst signal being deasserted, clk_div_by_2 immediately resumes toggling, while clk_div_by_40 resumes counting.\nGive me the complete code.\nmodule hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);"}, {"from": "gpt", "value": "module hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);\n\n    wire clk_60_out;\n    wire clk_3_out;\n\n    clk_div_by_2 div_60 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_60_out)\n    );\n\n    clk_div_by_40 div_3 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_3_out)\n    );\n\n    assign clk_60 = clk_60_out;\n    assign clk_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_by_2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\nmodule clk_div_by_40 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] counter;\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n            counter <= 0;\n        end else if (counter == 19) begin\n            clk_out <= ~clk_out;\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\nendmodule"}], "task_id": 24}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'Cout', 'type': 'output port'}, {'id': 5, 'content': 'lower_adder', 'type': 'submodule'}, {'id': 6, 'content': 'upper_adder0', 'type': 'submodule'}, {'id': 7, 'content': 'upper_adder1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 1, 0, 1, 0, 6, 5, 7, 5, 7, 6], [5, 5, 5, 6, 6, 7, 7, 3, 3, 3, 4, 4, 4]]\n, Design a Verilog module for a 32-bit carry-select adder.\n\nModule name:  \n    carry_select_adder_32bit               \nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    sum[31:0]: 32-bit output representing the sum of A and B.\n    Cout: Carry-out output.\n\nImplementation:\nIn the carry_select_adder_32bit module, implement two 16-bit adders that will be instantiated twice. The carry-out of the first 16-bit block will select which second block\u2019s result will be used.\nGive me the complete code.\nmodule carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);"}, {"from": "gpt", "value": "module carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);\n \n    wire [15:0] sum_lower;\n    wire [15:0] sum_upper0, sum_upper1;\n    wire cout_lower, cout_upper0, cout_upper1, sel;\n \n    // Instantiating the lower 16-bit adder\n    adder_16bit lower_adder (\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .Cin(Cin),\n        .sum(sum_lower),\n        .Cout(cout_lower)\n    );\n\n    // Two instances for the upper 16-bit adder for different carry in possibilities\n    adder_16bit upper_adder0 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(0),\n        .sum(sum_upper0),\n        .Cout(cout_upper0)\n    );\n\n    adder_16bit upper_adder1 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(1),\n        .sum(sum_upper1),\n        .Cout(cout_upper1)\n    );\n\n    // Select logic\n    assign sel = cout_lower;\n    assign sum[15:0] = sum_lower;\n    assign sum[31:16] = sel ? sum_upper1 : sum_upper0;\n    assign Cout = sel ? cout_upper1 : cout_upper0;\n\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    wire [7:0] s0, s1;\n    wire c0, c1, c2;\n \n    // Instantiate the lower 8-bit adder\n    add8 add8_inst1 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(s0),\n        .Co(c0)\n    );\n \n    // Instantiate the upper 8-bit adder with carry 0 and 1\n    add8 add8_inst2 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(0),\n        .y(s1),\n        .Co(c1)\n    );\n\n    add8 add8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(1),\n        .y(sum[15:8]),\n        .Co(c2)\n    );\n    assign sum[7:0] = s0;\n    assign Cout = c0 ? c2 : c1;\nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n    wire [3:0] s0, s1;\n    wire c0, c1, c2;\n \n    // Lower 4-bit adder\n    add4 add4_inst1 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(s0),\n        .Co(c0)\n    );\n \n    // Upper 4-bit adder with carry 0 and 1\n    add4 add4_inst2 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(0),\n        .y(s1),\n        .Co(c1)\n    );\n\n    add4 add4_inst3 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(1),\n        .y(y[7:4]),\n        .Co(c2)\n    );\n    assign y[3:0] = s0;\n    assign Co = c0 ? c2 : c1;\nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n    assign {Co, y} = a + b + Cin;\nendmodule"}], "task_id": 25}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op1', 'type': 'input port'}, {'id': 3, 'content': 'op2', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'ADD', 'type': 'submodule'}, {'id': 6, 'content': 'SUB', 'type': 'submodule'}, {'id': 7, 'content': 'MULT', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 3, 0, 2, 1, 3, 5, 6, 1, 0, 7], [5, 5, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 4]]\n, Design a Verilog module for a 3-stage arithmetic pipeline called `arith_pipeline3`. This module should perform a sequence of arithmetic operations (addition, subtraction, multiplication) on two 16-bit input operands.\n\nModule name:\n    arith_pipeline3\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op1[15:0]: 16-bit operand 1.\n    op2[15:0]: 16-bit operand 2.\nOutput ports:\n    result[31:0]: 32-bit result after multiplication.\n\nImplementation:\nIn the arith_pipeline3 module, three pipeline stages are instantiated: add_stage, sub_stage, mult_stage. The add_stage module adds the two inputs and forwards the result to the sub_stage. The sub_stage module subtracts the second input from the first input and passes the result to the mult_stage. The mult_stage multiplies the outputs from the add_stage and sub_stage to produce a final result. Each stage transfers data to the next stage at the rising edge of the clock, and the operations are pipelined for improved throughput.\nGive me the complete code.\nmodule arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);"}, {"from": "gpt", "value": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);\n\nwire [15:0] add_result, sub_result;\nwire [31:0] mul_result;\n\nadd_stage ADD(\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .y(add_result)\n);\n\nsub_stage SUB(\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .y(sub_result)\n);\n\nmult_stage MULT(\n    .clk(clk),\n    .rst(rst),\n    .a(add_result),\n    .b(sub_result),\n    .y(result)\n);\n\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] y\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            y <= 0;\n        else\n            y <= a + b;\n    end\nendmodule\n\nmodule sub_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] y\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            y <= 0;\n        else\n            y <= a - b;\n    end\nendmodule\n\nmodule mult_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] y\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            y <= 0;\n        else\n            y <= a * b;\n    end\nendmodule"}], "task_id": 26}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'Sum', 'type': 'output port'}, {'id': 4, 'content': 'Cout', 'type': 'output port'}, {'id': 5, 'content': 'adder0', 'type': 'submodule'}, {'id': 6, 'content': 'adder1', 'type': 'submodule'}, {'id': 7, 'content': 'adder2', 'type': 'submodule'}, {'id': 8, 'content': 'adder3', 'type': 'submodule'}, {'id': 9, 'content': 'adder4', 'type': 'submodule'}, {'id': 10, 'content': 'adder5', 'type': 'submodule'}, {'id': 11, 'content': 'adder6', 'type': 'submodule'}, {'id': 12, 'content': 'adder7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 0, 1, 6, 0, 1, 7, 0, 1, 8, 9, 0, 1, 10, 0, 1, 0, 1, 11, 9, 10, 12, 8, 7, 5, 11, 6, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Design a 64-bit ripple-carry adder using a hierarchical structure in Verilog. Name the top module `adder_64bit`. It should instantiate eight submodules, each responsible for adding 8 bits.\n\nModule name:  \n    adder_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    Sum[63:0]: 64-bit output representing the sum of A and B.\n    Cout: Carry-out output.\n\nImplementation:\nThe top module `adder_64bit` includes eight instances of the 8-bit adder submodule named `adder_8bit`.\nGive me the complete code.\nmodule adder_64bit(A, B, Cin, Sum, Cout);"}, {"from": "gpt", "value": "module adder_64bit(A, B, Cin, Sum, Cout);\n    input [63:0] A, B;\n    input Cin;\n    output [63:0] Sum;\n    output Cout;\n\n    wire [7:0] carry;\n    \n    adder_8bit adder0 (.A(A[7:0]), .B(B[7:0]), .Cin(Cin), .Sum(Sum[7:0]), .Cout(carry[0]));\n    adder_8bit adder1 (.A(A[15:8]), .B(B[15:8]), .Cin(carry[0]), .Sum(Sum[15:8]), .Cout(carry[1]));\n    adder_8bit adder2 (.A(A[23:16]), .B(B[23:16]), .Cin(carry[1]), .Sum(Sum[23:16]), .Cout(carry[2]));\n    adder_8bit adder3 (.A(A[31:24]), .B(B[31:24]), .Cin(carry[2]), .Sum(Sum[31:24]), .Cout(carry[3]));\n    adder_8bit adder4 (.A(A[39:32]), .B(B[39:32]), .Cin(carry[3]), .Sum(Sum[39:32]), .Cout(carry[4]));\n    adder_8bit adder5 (.A(A[47:40]), .B(B[47:40]), .Cin(carry[4]), .Sum(Sum[47:40]), .Cout(carry[5]));\n    adder_8bit adder6 (.A(A[55:48]), .B(B[55:48]), .Cin(carry[5]), .Sum(Sum[55:48]), .Cout(carry[6]));\n    adder_8bit adder7 (.A(A[63:56]), .B(B[63:56]), .Cin(carry[6]), .Sum(Sum[63:56]), .Cout(Cout));\nendmodule\n\nmodule adder_8bit(A, B, Cin, Sum, Cout);\n    input [7:0] A, B;\n    input Cin;\n    output [7:0] Sum;\n    output Cout;\n\n    wire [6:0] carry;\n\n    full_adder fa0 (.a(A[0]), .b(B[0]), .cin(Cin), .sum(Sum[0]), .cout(carry[0]));\n    full_adder fa1 (.a(A[1]), .b(B[1]), .cin(carry[0]), .sum(Sum[1]), .cout(carry[1]));\n    full_adder fa2 (.a(A[2]), .b(B[2]), .cin(carry[1]), .sum(Sum[2]), .cout(carry[2]));\n    full_adder fa3 (.a(A[3]), .b(B[3]), .cin(carry[2]), .sum(Sum[3]), .cout(carry[3]));\n    full_adder fa4 (.a(A[4]), .b(B[4]), .cin(carry[3]), .sum(Sum[4]), .cout(carry[4]));\n    full_adder fa5 (.a(A[5]), .b(B[5]), .cin(carry[4]), .sum(Sum[5]), .cout(carry[5]));\n    full_adder fa6 (.a(A[6]), .b(B[6]), .cin(carry[5]), .sum(Sum[6]), .cout(carry[6]));\n    full_adder fa7 (.a(A[7]), .b(B[7]), .cin(carry[6]), .sum(Sum[7]), .cout(Cout));\nendmodule\n\nmodule full_adder(a, b, cin, sum, cout);\n    input a, b, cin;\n    output sum, cout;\n\n    assign sum = a ^ b ^ cin;\n    assign cout = (a & b) | (b & cin) | (a & cin);\nendmodule"}], "task_id": 27}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'op_code', 'type': 'input port'}, {'id': 1, 'content': 'a', 'type': 'input port'}, {'id': 2, 'content': 'b', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'u_adder', 'type': 'submodule'}, {'id': 5, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 6, 'content': 'u_and', 'type': 'submodule'}, {'id': 7, 'content': 'u_or', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 2, 1, 2, 1, 2, 1, 6, 7, 5, 4], [4, 4, 5, 5, 6, 6, 7, 7, 3, 3, 3, 3]]\n, Implement a 16-bit arithmetic logic unit (ALU) with selective operation capabilities in Verilog. This ALU will perform addition, subtraction, bitwise AND, and bitwise OR based on a 2-bit opcode. Each operation should handle 16-bit operands.\n\nModule name:\n    alu\n\nInput ports:\n    op_code: 2-bit input to select the operation (00 for addition, 01 for subtraction, 10 for bitwise AND, 11 for bitwise OR).\n    a: 16-bit input operand A.\n    b: 16-bit input operand B.\n\nOutput ports:\n    result: 16-bit output of the computation.\n\nImplementation:\nSubmodules:\n    Adder:\n        This submodule performs 16-bit addition.\n    Subtractor:\n        This submodule performs 16-bit subtraction.\n    And:\n        This submodule performs a bitwise AND operation.\n    Or:\n        This submodule performs a bitwise OR operation.\nThe main alu module uses the op_code to select which submodule's output to pass to the result port based on the operation selected by op_code.\nGive me the complete code.\nmodule alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);"}, {"from": "gpt", "value": "module alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] sum, difference, and_result, or_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .difference(difference)\n);\n\nand_module u_and (\n    .a(a),\n    .b(b),\n    .and_output(and_result)\n);\n\nor_module u_or (\n    .a(a),\n    .b(b),\n    .or_output(or_result)\n);\n\nreg [15:0] output_reg;\nassign result = output_reg;\n\nalways @(*) begin\n    case(op_code)\n        2'b00: output_reg = sum;\n        2'b01: output_reg = difference;\n        2'b10: output_reg = and_result;\n        2'b11: output_reg = or_result;\n        default: output_reg = 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule and_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] and_output\n);\n    assign and_output = a & b;\nendmodule\n\nmodule or_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] or_output\n);\n    assign or_output = a | b;\nendmodule"}], "task_id": 28}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'add_mod', 'type': 'submodule'}, {'id': 8, 'content': 'sub_mod', 'type': 'submodule'}, {'id': 9, 'content': 'and_mod', 'type': 'submodule'}, {'id': 10, 'content': 'or_mod', 'type': 'submodule'}, {'id': 11, 'content': 'xor_mod', 'type': 'submodule'}, {'id': 12, 'content': 'slt_mod', 'type': 'submodule'}, {'id': 13, 'content': 'not_mod', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 7, 10, 13, 9, 8, 11, 12, 10, 7, 9, 13, 8, 11, 12, 2, 7, 8, 10, 7, 9, 13, 8, 11, 12], [7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6]]\n, Design a 16-bit Arithmetic Logic Unit (ALU) named `compact_alu` capable of performing basic arithmetic, bitwise, and set-less-than operations. This ALU will accept two 16-bit data inputs (a and b), a 4-bit operation code (op_code), and produce a 16-bit result (result) and three flags: zero, carry, and negative. The operations are encoded as follows:\n    \n    ADD: 4'b0000\n    SUB: 4'b0001\n    AND: 4'b0010\n    OR: 4'b0011\n    XOR: 4'b0100\n    SLT (Set if Less Than): 4'b0101\n    NOT: 4'b0110\n    \nThe ALU should handle carry for addition and subtraction. The zero flag should be high when the result is zero. The negative flag should be high when the result is negative (MSB = 1).\nGive me the complete code.\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [16:0] add_out;\nwire [16:0] sub_out;\nwire [15:0] and_out;\nwire [15:0] or_out;\nwire [15:0] xor_out;\nwire [15:0] slt_out;\nwire [15:0] not_out;\n\nadder_16bit add_mod(.a(a), .b(b), .sum(add_out));\nsubtractor_16bit sub_mod(.a(a), .b(b), .diff(sub_out));\nand_16bit and_mod(.a(a), .b(b), .out(and_out));\nor_16bit or_mod(.a(a), .b(b), .out(or_out));\nxor_16bit xor_mod(.a(a), .b(b), .out(xor_out));\nslt_16bit slt_mod(.a(a), .b(b), .out(slt_out));\nnot_16bit not_mod(.a(a), .out(not_out));\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_out[15:0];\n        4'b0001: result = sub_out[15:0];\n        4'b0010: result = and_out;\n        4'b0011: result = or_out;\n        4'b0100: result = xor_out;\n        4'b0101: result = slt_out;\n        4'b0110: result = not_out;\n        default: result = 16'bx;\n    endcase\nend\n\nassign zero = (result == 16'b0);\nassign carry = (op_code == 4'b0000) ? add_out[16] : (op_code == 4'b0001) ? sub_out[16] : 1'b0;\nassign negative = result[15];\n\nendmodule\n\nmodule adder_16bit(input [15:0] a, input [15:0] b, output [16:0] sum);\n    assign sum = {1'b0, a} + {1'b0, b};\nendmodule\n\nmodule subtractor_16bit(input [15:0] a, input [15:0] b, output [16:0] diff);\n    assign diff = {1'b0, a} - {1'b0, b};\nendmodule\n\nmodule and_16bit(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_16bit(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_16bit(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\nmodule slt_16bit(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = (a < b) ? 16'b1 : 16'b0;\nendmodule\n\nmodule not_16bit(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}], "task_id": 29}]