[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'error', 'type': 'output port'}, {'id': 7, 'content': 'u_adder', 'type': 'submodule'}, {'id': 8, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 9, 'content': 'u_and', 'type': 'submodule'}, {'id': 10, 'content': 'u_or', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 2, 3, 2, 3, 2, 3, 7, 9, 8, 10], [7, 7, 8, 8, 9, 9, 10, 10, 5, 5, 5, 5]]\n, Implement a modular Arithmetic Logic Unit (ALU) for 32-bit integers in Verilog. The top-level alu module should instantiate submodules for addition, subtraction, bitwise AND, and bitwise OR operations. The alu module uses these submodules to compute results based on an opcode.\n\nModule name:\n    alu\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, active high.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n    opcode: 4-bit operation code (00 for ADD, 01 for SUB, 10 for AND, 11 for OR).\n\nOutput ports:\n    result: 32-bit output resulting from the specified operation.\n    error: Error flag, high if an undefined opcode is provided.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule adds two 32-bit inputs.\nSubtractor Submodule:\nThis submodule subtracts the second 32-bit input from the first.\nAND Submodule:\nThis submodule performs a bitwise AND operation on two 32-bit inputs.\nOR Submodule:\nThis submodule performs a bitwise OR operation on two 32-bit inputs.\nThe main alu module uses the opcode to select the appropriate operation and set the outputs accordingly.\nGive me the complete code.\nmodule alu(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    input [3:0] opcode,\n    output reg [31:0] result,\n    output reg error\n);"}, {"from": "gpt", "value": "module alu(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    input [3:0] opcode,\n    output reg [31:0] result,\n    output reg error\n);\n\nwire [31:0] sum, difference, and_result, or_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(sum)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .difference(difference)\n);\n\n// Instantiating the and module\nand_module u_and (\n    .a(a),\n    .b(b),\n    .and_result(and_result)\n);\n\n// Instantiating the or module\nor_module u_or (\n    .a(a),\n    .b(b),\n    .or_result(or_result)\n);\n\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        result <= 0;\n        error <= 0;\n    end else begin\n        case(opcode)\n            4'b0000: result <= sum;\n            4'b0001: result <= difference;\n            4'b0010: result <= and_result;\n            4'b0011: result <= or_result;\n            default: begin\n                result <= 0;\n                error <= 1;\n            end\n        endcase\n    end\nend\n\nendmodule\n\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] and_result\n);\n    assign and_result = a & b;\nendmodule\n\nmodule or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] or_result\n);\n    assign or_result = a | b;\nendmodule\n"}], "task_id": "pe"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'u_count_logic', 'type': 'submodule'}, {'id': 4, 'content': 'u_output_logic', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 4], [3, 3, 4, 2]]\n, Design a Verilog module for a binary up-counter with a configurable count limit. The counter increases on every positive edge of the input clock and resets when the limit is reached or when reset is activated.\n\nModule name:\n    binary_up_counter\n\nInput ports:\n    clk: Clock input.\n    rst_n: Active low reset signal for the counter.\n\nOutput ports:\n    out: Current count value.\n\nImplementation:\nThe module counts from 0 up to a specified limit given by the parameter COUNT_LIMIT, which defaults to 8. It includes two submodules: `count_logic` that handles the counting mechanism, and `output_logic` that manages the output of the current count. `count_logic` increments the count on each clock's rising edge until the limit is reached, then resets to 0. `output_logic` provides the count value to the output port out. The active low reset signal rst_n resets the count to 0 immediately.\nGive me the complete code.\nmodule binary_up_counter(\n    input clk,\n    input rst_n,\n    output [3:0] out\n);"}, {"from": "gpt", "value": "module binary_up_counter(\n    input clk,\n    input rst_n,\n    output [3:0] out\n);\n    parameter COUNT_LIMIT = 8;\n\n    wire [3:0] count;\n    \n    // Instantiate counting logic\n    count_logic #(.COUNT_LIMIT(COUNT_LIMIT)) u_count_logic (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count)\n    );\n    \n    // Instantiate output logic\n    output_logic u_output_logic (\n        .count(count),\n        .out(out)\n    );\n\nendmodule\n\nmodule count_logic(\n    input clk,\n    input rst_n,\n    output reg [3:0] count\n);\n    parameter COUNT_LIMIT = 8;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else begin\n            if (count < COUNT_LIMIT - 1) begin\n                count <= count + 1;\n            end else begin\n                count <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule output_logic(\n    input [3:0] count,\n    output reg [3:0] out\n);\n    always @(*) begin\n        out = count;\n    end\nendmodule\n"}], "task_id": "freq_divbyodd"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'x', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'input port'}, {'id': 4, 'content': 'q', 'type': 'output port'}, {'id': 5, 'content': 'u_divider', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Divider Accumulator for 32-bit integers. In the da module, there are submodules for division and accumulation. The da module connects these submodules to perform the operations.\n\nModule name:\n    da\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    x: 32-bit input operand X.\n    y: 32-bit input operand Y (non-zero).\n\nOutput ports:\n    q: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nDivider Submodule:\nThis submodule takes two 32-bit inputs (x and y) and produces a 32-bit result of their division.\nAccumulator Submodule:\nThis submodule accumulates the division results into a register, current_value. It resets the value to 0 when rst is high and adds the new division result during each clock cycle when rst is low.\nThe main da module connects these submodules and drives the output q with the accumulated result.\nGive me the complete code.\nmodule da(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] q\n);"}, {"from": "gpt", "value": "module da(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] q\n);\n\n// Intermediate wire to hold the division result\nwire [31:0] div_result;\nwire [31:0] accumulated_value;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .result(div_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(div_result),\n    .current_value(accumulated_value)\n);\n\n// Assigning the accumulated value to the output\nassign q = accumulated_value;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] result\n);\n    assign result = x / y; // Simple division\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}], "task_id": "pe"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'en', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'd0', 'type': 'input port'}, {'id': 4, 'content': 'd1', 'type': 'input port'}, {'id': 5, 'content': 'd2', 'type': 'input port'}, {'id': 6, 'content': 'd3', 'type': 'input port'}, {'id': 7, 'content': 'out', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[4, 3, 5, 6], [7, 7, 7, 7]]\n, Implement a module for a 4-to-1 multiplexer with enable signal control.\n\nModule name:  \n    mux4to1               \nInput ports:\n    clk: Clock signal.\n    en: Enable signal, active high.\n    sel[1:0]: 2-bit select signal to choose one of the four inputs.\n    d0[7:0]: 8-bit input data D0.\n    d1[7:0]: 8-bit input data D1.\n    d2[7:0]: 8-bit input data D2.\n    d3[7:0]: 8-bit input data D3.\nOutput ports:\n    out[7:0]: 8-bit output data selected based on `sel`.\n\nImplementation:\nIn the mux4to1 module, four input data lines are conditionally passed to the output based on the select signals when enabled. If the enable signal is inactive, the output is forced to zero. This design uses two select lines and enables control, thus providing a conditional data path suitable for system multiplexing scenarios.\nGive me the complete code.\nmodule mux4to1 (\n    input clk,\n    input en,\n    input [1:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output reg [7:0] out\n);"}, {"from": "gpt", "value": "module mux4to1 (\n    input clk,\n    input en,\n    input [1:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    input [7:0] d3,\n    output reg [7:0] out\n);\n    always @(posedge clk) begin\n        if(en) begin\n            case(sel)\n                2'b00: out <= d0;\n                2'b01: out <= d1;\n                2'b10: out <= d2;\n                2'b11: out <= d3;\n            endcase\n        end\n        else begin\n            out <= 0;\n        end\n    end\nendmodule\n"}], "task_id": "systolic1x2"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'CLK', 'type': 'input port'}, {'id': 1, 'content': 'signal_in', 'type': 'input port'}, {'id': 2, 'content': 'rising_edge', 'type': 'output port'}, {'id': 3, 'content': 'falling_edge', 'type': 'output port'}, {'id': 4, 'content': 'red', 'type': 'submodule'}, {'id': 5, 'content': 'fed', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5], [4, 4, 5, 5, 2, 3]]\n, Design and implement a Verilog module for a signal edge detector that identifies both rising and falling edges of a binary input signal. The module should produce two distinct outputs indicating the occurrence of rising and falling edges respectively.\n\nModule name:\n    edge_detector\n\nInput ports:\n    CLK: Clock input\n    signal_in: Binary input signal\n\nOutput ports:\n    rising_edge: Output signal that is high for one cycle when a rising edge is detected on signal_in.\n    falling_edge: Output signal that is high for one cycle when a falling edge is detected on signal_in.\n\nImplementation:\nThe module uses two submodules:\n1. rising_edge_det detects rising edges by comparing the current signal state to the previous state.\n2. falling_edge_det detects falling edges using a similar comparison.\nBoth submodules update their states on the positive edge of the clock and reset outputs when reset signal is asserted.\nGive me the complete code.\nmodule edge_detector (\n    input CLK,\n    input signal_in,\n    output rising_edge,\n    output falling_edge\n);"}, {"from": "gpt", "value": "module edge_detector (\n    input CLK,\n    input signal_in,\n    output rising_edge,\n    output falling_edge\n);\n\n    // Submodule instances\n    wire rising_out;\n    wire falling_out;\n\n    rising_edge_det red (\n        .CLK(CLK),\n        .signal_in(signal_in),\n        .edge_detected(rising_out)\n    );\n\n    falling_edge_det fed (\n        .CLK(CLK),\n        .signal_in(signal_in),\n        .edge_detected(falling_out)\n    );\n\n    // Assign outputs\n    assign rising_edge = rising_out;\n    assign falling_edge = falling_out;\n\nendmodule\n\n// Submodule for detecting rising edges\nmodule rising_edge_det (\n    input CLK,\n    input signal_in,\n    output reg edge_detected\n);\n    reg previous_state;\n\n    always @(posedge CLK) begin\n        if (signal_in == 1'b1 && previous_state == 1'b0) begin\n            edge_detected <= 1'b1;\n        end else begin\n            edge_detected <= 1'b0;\n        end\n        previous_state <= signal_in;\n    end\nendmodule\n\n// Submodule for detecting falling edges\nmodule falling_edge_det (\n    input CLK,\n    input signal_in,\n    output reg edge_detected\n);\n    reg previous_state;\n\n    always @(posedge CLK) begin\n        if (signal_in == 1'b0 && previous_state == 1'b1) begin\n            edge_detected <= 1'b1;\n        end else begin\n            edge_detected <= 1'b0;\n        end\n        previous_state <= signal_in;\n    end\nendmodule\n"}], "task_id": "freq_div"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C_out', 'type': 'output port'}, {'id': 4, 'content': 'add1', 'type': 'submodule'}, {'id': 5, 'content': 'add2', 'type': 'submodule'}, {'id': 6, 'content': 'add3', 'type': 'submodule'}, {'id': 7, 'content': 'add4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 5, 0, 1, 6, 0, 7, 6, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}, {"from": "gpt", "value": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry out\n\n    wire c4, c8, c12;\n\n    // Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry out\n\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire g1, g2, g3, g4;  // Generate signals\n    wire c1, c2, c3;      // Internal carry signals\n\n    // Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry in\n    output S;             // Sum output\n    output C_out;         // Carry out\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | ((A | B) & C_in); // Carry out calculation\nendmodule\n"}], "task_id": "sub_16bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'bm0', 'type': 'submodule'}, {'id': 4, 'content': 'bm1', 'type': 'submodule'}, {'id': 5, 'content': 'bm2', 'type': 'submodule'}, {'id': 6, 'content': 'bm3', 'type': 'submodule'}, {'id': 7, 'content': 'bm4', 'type': 'submodule'}, {'id': 8, 'content': 'bm5', 'type': 'submodule'}, {'id': 9, 'content': 'bm6', 'type': 'submodule'}, {'id': 10, 'content': 'bm7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 10, 3, 6, 8, 5, 7, 4, 9], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of A and B.\n\nImplementation:\nThe top module mult_8bit calculates the product of inputs A and B using bit-wise AND and shift operations managed by an array of bitwise_mult modules. Each bitwise_mult module processes single bits from A and all bits of B, shifting its output based on its position relative to the least significant bit.\nGive me the complete code.\nmodule mult_8bit(A, B, P);"}, {"from": "gpt", "value": "module mult_8bit(A, B, P);\n    input [7:0] A;\n    input [7:0] B;\n    output [15:0] P;\n\n    wire [15:0] product[7:0];\n\n    // Instantiate bitwise multiplication modules\n    bitwise_mult bm0(.a(A[0]), .b(B), .product(product[0]));\n    bitwise_mult bm1(.a(A[1]), .b(B), .product(product[1]));\n    bitwise_mult bm2(.a(A[2]), .b(B), .product(product[2]));\n    bitwise_mult bm3(.a(A[3]), .b(B), .product(product[3]));\n    bitwise_mult bm4(.a(A[4]), .b(B), .product(product[4]));\n    bitwise_mult bm5(.a(A[5]), .b(B), .product(product[5]));\n    bitwise_mult bm6(.a(A[6]), .b(B), .product(product[6]));\n    bitwise_mult bm7(.a(A[7]), .b(B), .product(product[7]));\n\n    // Summing the partial products with shift\n    assign P = product[0] + (product[1] << 1) + (product[2] << 2) + (product[3] << 3) +\n               (product[4] << 4) + (product[5] << 5) + (product[6] << 6) + (product[7] << 7);\n\nendmodule\n\nmodule bitwise_mult(a, b, product);\n    input a;\n    input [7:0] b;\n    output [15:0] product;\n\n    // Calculate the partial product\n    assign product = a ? {8'b0, b} : 16'b0;\nendmodule\n"}], "task_id": "sub_8bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'clk_out', 'type': 'output port'}, {'id': 4, 'content': 'u_edge_counter', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_generator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 4, 0, 1, 5], [4, 4, 4, 5, 5, 5, 3]]\n, Design a Verilog module for a frequency divider that outputs a signal at half the frequency of the input clock. The system will utilize an active-high enable signal that allows the frequency division when high. The output should toggle with every two rising edges of the clock signal when enabled.\n\nModule name:\n    freq_divider\nInput ports:\n    clk: Clock input for the operation.\n    rst_n: Active-low reset signal.\n    enable: Input signal to control the division process.\nOutput ports:\n    clk_out: Output clock signal at half the frequency of the input clock.\n\nImplementation:\nThe design consists of the following submodules:\nToggle Control Module: Manages the state of the output clock based on the enable signal and input clock edges.\nEdge Counter Module: Counts the rising edges of the input clock when enabled to control the toggle state.\nOutput Generator Module: Generates the output clock signal based on the toggle state.\nGive me the complete code.\nmodule freq_divider (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    output              clk_out\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\nmodule freq_divider (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    output              clk_out\n);\n\n    wire toggle;\n\n    // Instantiate the edge counter module\n    edge_counter u_edge_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .enable(enable),\n        .toggle(toggle)\n    );\n\n    // Instantiate the output generator module\n    output_generator u_output_generator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .toggle(toggle),\n        .clk_out(clk_out)\n    );\n\nendmodule\n\nmodule edge_counter (\n    input               clk,\n    input               rst_n,\n    input               enable,\n    output reg          toggle\n);\n\n    reg [1:0] count;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n            toggle <= 0;\n        end\n        else if (enable) begin\n            if (count == 2'b01) begin\n                toggle <= ~toggle;\n                count <= 0;\n            end\n            else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule output_generator (\n    input               clk,\n    input               rst_n,\n    input               toggle,\n    output reg          clk_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_out <= 0;\n        end\n        else begin\n            clk_out <= toggle;\n        end\n    end\n\nendmodule\n"}], "task_id": "accu"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C_out', 'type': 'output port'}, {'id': 4, 'content': 'add1', 'type': 'submodule'}, {'id': 5, 'content': 'add2', 'type': 'submodule'}, {'id': 6, 'content': 'add3', 'type': 'submodule'}, {'id': 7, 'content': 'add4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 5, 1, 0, 6, 1, 0, 5, 6, 7, 4, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}, {"from": "gpt", "value": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry out\n\n    wire c4, c8, c12;\n\n    // Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry out\n\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire g1, g2, g3, g4;  // Generate signals\n    wire c1, c2, c3;      // Internal carry signals\n\n    // Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry in\n    output S;             // Sum output\n    output C_out;         // Carry out\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | ((A ^ B) & C_in); // Carry out calculation\nendmodule\n"}], "task_id": "sub_16bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'EQ', 'type': 'output port'}, {'id': 3, 'content': 'eq0', 'type': 'submodule'}, {'id': 4, 'content': 'eq1', 'type': 'submodule'}, {'id': 5, 'content': 'eq2', 'type': 'submodule'}, {'id': 6, 'content': 'eq3', 'type': 'submodule'}, {'id': 7, 'content': 'eq4', 'type': 'submodule'}, {'id': 8, 'content': 'eq5', 'type': 'submodule'}, {'id': 9, 'content': 'eq6', 'type': 'submodule'}, {'id': 10, 'content': 'eq7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 4, 9, 10, 3, 8, 6, 7], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Design a Verilog module for an 8-bit comparator that checks equality between two binary numbers using a modular approach.\n\nModule name:\n    eq_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    EQ: Output signal that is high (1) if A equals B, otherwise low (0).\n\nImplementation:\nThe top module eq_8bit breaks down the comparison task into bit-level comparisons using multiple eq_bit submodules, one for each bit. The output from these submodules is then combined in a logical AND operation to determine if all bits are equal, thus setting the EQ output accordingly.\nGive me the complete code.\nmodule eq_8bit(A, B, EQ);"}, {"from": "gpt", "value": "module eq_8bit(A, B, EQ);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output EQ;          // Output high if A equals B\n\n    wire [7:0] eq_bits;\n\n    // Bitwise equality checks\n    eq_bit eq0(.a(A[0]), .b(B[0]), .eq(eq_bits[0]));\n    eq_bit eq1(.a(A[1]), .b(B[1]), .eq(eq_bits[1]));\n    eq_bit eq2(.a(A[2]), .b(B[2]), .eq(eq_bits[2]));\n    eq_bit eq3(.a(A[3]), .b(B[3]), .eq(eq_bits[3]));\n    eq_bit eq4(.a(A[4]), .b(B[4]), .eq(eq_bits[4]));\n    eq_bit eq5(.a(A[5]), .b(B[5]), .eq(eq_bits[5]));\n    eq_bit eq6(.a(A[6]), .b(B[6]), .eq(eq_bits[6]));\n    eq_bit eq7(.a(A[7]), .b(B[7]), .eq(eq_bits[7]));\n\n    // Output is high only if all bits are equal\n    assign EQ = &eq_bits;\n\nendmodule\n\nmodule eq_bit(a, b, eq);\n    input a;       // Single bit input A\n    input b;       // Single bit input B\n    output eq;     // Output high if bits are equal\n\n    assign eq = (a == b);  // Equality check\n\nendmodule\n"}], "task_id": "sub_8bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'start', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'product', 'type': 'output port'}, {'id': 5, 'content': 'ready', 'type': 'output port'}, {'id': 6, 'content': 'u_partial_product_generator', 'type': 'submodule'}, {'id': 7, 'content': 'u_product_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 6, 1, 0, 7, 7], [6, 6, 7, 7, 7, 4, 5]]\n, Design a 32-bit binary multiplier that produces a 64-bit output based on two 32-bit inputs. The design should use a modular architecture, including a combinational logic module for partial product generation and a sequential logic module for accumulation of these partial products.\n\nModule name:\n    binary_multiplier\n\nFunction:\nA 32-bit binary multiplier that multiplies two 32-bit unsigned integers and outputs a 64-bit result, implemented with separate modules for partial product generation and result accumulation.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the multiplication steps.\n    - start: Start signal (1-bit), triggers the multiplication process.\n    - a [31:0]: First 32-bit input operand.\n    - b [31:0]: Second 32-bit input operand.\n\nOutput ports:\n    - product [63:0]: 64-bit output representing the multiplication result of inputs a and b.\n    - ready: Status signal (1-bit), indicates when the product is ready to be read.\n\nImplementation:\nThe binary_multiplier module consists of two submodules: partial_product_generator and product_accumulator.\n- The partial_product_generator module calculates partial products of the multiplicand and the multiplier.\n- The product_accumulator module sequentially accumulates these partial products to generate the final product, synchronized by the clock signal. The ready signal is asserted once the multiplication is complete.\nGive me the complete code.\nmodule binary_multiplier (\n    input wire clk,\n    input wire start,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [63:0] product,\n    output wire ready\n);"}, {"from": "gpt", "value": "module binary_multiplier (\n    input wire clk,\n    input wire start,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [63:0] product,\n    output wire ready\n);\n\n    wire [63:0] partial_product;\n    wire partial_product_valid;\n    wire accumulator_done;\n\n    // Instantiate the partial product generator\n    partial_product_generator u_partial_product_generator (\n        .a(a),\n        .b(b),\n        .partial_product(partial_product),\n        .valid(partial_product_valid)\n    );\n\n    // Instantiate the product accumulator\n    product_accumulator u_product_accumulator (\n        .clk(clk),\n        .start(start),\n        .partial_product(partial_product),\n        .valid(partial_product_valid),\n        .product(product),\n        .done(accumulator_done)\n    );\n\n    assign ready = accumulator_done;\n\nendmodule\n\nmodule partial_product_generator (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output reg [63:0] partial_product,\n    output reg valid\n);\n\n    always @(*) begin\n        // Compute partial products based on input operands\n        partial_product = a * b;  // Simplified partial product computation\n        valid = 1'b1;  // Always valid for simplified example\n    end\n\nendmodule\n\nmodule product_accumulator (\n    input wire clk,\n    input wire start,\n    input wire [63:0] partial_product,\n    input wire valid,\n    output reg [63:0] product,\n    output reg done\n);\n\n    always @(posedge clk) begin\n        if (start) begin\n            product <= 0; // Reset product at the start\n            done <= 1'b0;\n        end else if (valid) begin\n            product <= product + partial_product; // Accumulate partial products\n            done <= 1'b1; // Signal that accumulation is done\n        end\n    end\n\nendmodule\n"}], "task_id": "up_down_counter"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'carry_out', 'type': 'output port'}, {'id': 5, 'content': 'adder_instance', 'type': 'submodule'}, {'id': 6, 'content': 'subtractor_instance', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 5, 1, 6, 0, 5, 6], [5, 5, 6, 6, 3, 3, 3, 3, 4, 4]]\n, Implement a module for a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, and bitwise operations using multiple submodules for each specific operation.\n\nModule name:\n    alu_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand.\n    B [31:0]: Second 32-bit input operand.\n    op_code [2:0]: Operation code where:\n        000 = Addition\n        001 = Subtraction\n        010 = AND\n        011 = OR\n        100 = XOR\n\nOutput ports:\n    result [31:0]: 32-bit result of the operation.\n    carry_out: 1-bit output for carry (valid for addition and subtraction).\n\nImplementation:\nOperation Logic: The module performs the operation selected by the op_code on the two 32-bit binary numbers A and B.\nAdder and Subtractor Logic: Uses a 32-bit adder for addition, and a modified adder for subtraction by inverting B and setting carry_in for the adder.\nBitwise Logic: Performs AND, OR, XOR operations directly based on op_code.\nModular Design:\nThe main module (alu_32bit) instantiates the adder (adder_32bit), and the bitwise operations are implemented directly within the module.\nThe output (result, carry_out) depends on the op_code.\nGive me the complete code.\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [2:0] op_code,\n    output reg [31:0] result,\n    output reg carry_out\n);"}, {"from": "gpt", "value": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [2:0] op_code,\n    output reg [31:0] result,\n    output reg carry_out\n);\n\n    wire [31:0] sum, b_inv;\n    wire carry_sum, carry_inv;\n    \n    // Instantiate the 32-bit adder\n    adder_32bit adder_instance (\n        .A(A),\n        .B(B),\n        .carry_in(1'b0),\n        .sum(sum),\n        .carry_out(carry_sum)\n    );\n\n    // Inverter for B with carry in for subtraction\n    adder_32bit subtractor_instance (\n        .A(A),\n        .B(~B),\n        .carry_in(1'b1),\n        .sum(b_inv),\n        .carry_out(carry_inv)\n    );\n    \n    // ALU operation decoding\n    always @(*) begin\n        case(op_code)\n            3'b000: begin\n                result = sum;\n                carry_out = carry_sum;\n            end\n            3'b001: begin\n                result = b_inv;\n                carry_out = carry_inv;\n            end\n            3'b010: result = A & B;\n            3'b011: result = A | B;\n            3'b100: result = A ^ B;\n            default: begin\n                result = 32'b0;\n                carry_out = 1'b0;\n            end\n        endcase\n    end\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input carry_in,\n    output [31:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B + carry_in;\nendmodule\n"}], "task_id": "comparator_32bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'duty_cycle', 'type': 'input port'}, {'id': 3, 'content': 'pwm_out', 'type': 'output port'}, {'id': 4, 'content': 'u_pwm_ctrl', 'type': 'submodule'}, {'id': 5, 'content': 'u_pwm_gen', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 4, 1, 0, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, A pulse width modulator that generates a variable duty cycle output. The module controls the duty cycle based on a parameter and an input signal level.\n\nModule name:\n    pwm_variable_duty\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the PWM generator.\n    duty_cycle: 8-bit signal representing the desired duty cycle percentage.\n\nOutput ports:\n    pwm_out: PWM output signal with variable duty cycle.\n\nImplementation:\n\nThe module generates a PWM signal with a duty cycle determined by the parameter MAX_DUTY and the input signal duty_cycle. It includes two submodules: `pwm_controller` and `pwm_output_generator`. The `pwm_controller` manages the count logic to generate the necessary duty cycle. The `pwm_output_generator` produces the actual PWM output based on the count and the desired duty cycle. The duty cycle range is from 0 (always off) to MAX_DUTY (maximum on-time defined by MAX_DUTY parameter). The active low reset signal rst_n initializes the PWM generator settings.\nGive me the complete code.\nmodule pwm_variable_duty(\n    input clk,\n    input rst_n,\n    input [7:0] duty_cycle,\n    output pwm_out\n);"}, {"from": "gpt", "value": "module pwm_variable_duty(\n    input clk,\n    input rst_n,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n    parameter MAX_DUTY = 255;\n\n    wire pwm_signal;\n    wire [7:0] count;\n\n    // Instantiate the PWM controller submodule\n    pwm_controller #(.MAX_DUTY(MAX_DUTY)) u_pwm_ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .duty_cycle(duty_cycle),\n        .count(count)\n    );\n\n    // Instantiate the PWM output generator submodule\n    pwm_output_generator u_pwm_gen (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count),\n        .duty_cycle(duty_cycle),\n        .pwm_out(pwm_signal)\n    );\n\n    assign pwm_out = pwm_signal;\n\nendmodule\n\nmodule pwm_controller(\n    input clk,\n    input rst_n,\n    input [7:0] duty_cycle,\n    output reg [7:0] count\n);\n    parameter MAX_DUTY = 255;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else begin\n            if (count < MAX_DUTY) begin\n                count <= count + 1;\n            end else begin\n                count <= 0;\n            end\n        end\n    end\nendmodule\n\nmodule pwm_output_generator(\n    input clk,\n    input rst_n,\n    input [7:0] count,\n    input [7:0] duty_cycle,\n    output reg pwm_out\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            pwm_out <= 1'b0;\n        end else begin\n            if (count < duty_cycle) begin\n                pwm_out <= 1'b1;\n            end else begin\n                pwm_out <= 1'b0;\n            end\n        end\n    end\nendmodule\n"}], "task_id": "freq_divbyodd"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'data', 'type': 'input port'}, {'id': 1, 'content': 'parity', 'type': 'output port'}, {'id': 2, 'content': 'xr1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2], [2, 1]]\n, Design a Verilog module named `parity_generator` that calculates the even parity bit for a given 8-bit input. The module takes an 8-bit input and outputs a 1-bit even parity. Even parity is achieved when the number of '1's in the input data plus the parity bit results in an even number.\n\nModule name: \n    parity_generator\n\nFunction:\n    Generates an even parity bit for an 8-bit input, ensuring that the total count of '1's (including the parity bit) is even.\n\nInput ports:\n    data [7:0]: 8-bit input data for which the parity needs to be calculated.\n\nOutput ports:\n    parity: 1-bit output that represents the even parity bit.\n\nImplementation:\n    The `parity_generator` calculates the even parity by using XOR gates to add up all the bits of the input data `data`. The resultant bit will be 0 if the number of '1's in the input is even, and 1 if it is odd.\n    The `xor_reduce` submodule is used to XOR all the bits of the input and the result is directly used as the even parity output.\n    Each bit of the input data is sequentially XORed, and the final output gives the required parity bit.\nGive me the complete code.\nmodule parity_generator (data, parity);"}, {"from": "gpt", "value": "module parity_generator (data, parity);\n    input [7:0] data;\n    output parity;\n    \n    // XOR all bits of data to get even parity\n    xor_reduce   xr1 (.data(data), .result(parity));\n\nendmodule\n\nmodule xor_reduce(data, result);\n    input [7:0] data;\n    output result;\n    wire r1, r2, r3, r4, r5, r6, r7;\n    \n    xor (r1, data[0], data[1]);\n    xor (r2, data[2], data[3]);\n    xor (r3, r1, r2);\n    xor (r4, data[4], data[5]);\n    xor (r5, data[6], data[7]);\n    xor (r6, r4, r5);\n    xor (result, r3, r6);\n\nendmodule\n"}], "task_id": "barrel_shifter"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'x0', 'type': 'input port'}, {'id': 3, 'content': 'x1', 'type': 'input port'}, {'id': 4, 'content': 'x2', 'type': 'input port'}, {'id': 5, 'content': 'x3', 'type': 'input port'}, {'id': 6, 'content': 'y', 'type': 'input port'}, {'id': 7, 'content': 'p0', 'type': 'output port'}, {'id': 8, 'content': 'p1', 'type': 'output port'}, {'id': 9, 'content': 'p2', 'type': 'output port'}, {'id': 10, 'content': 'p3', 'type': 'output port'}, {'id': 11, 'content': 'me0', 'type': 'submodule'}, {'id': 12, 'content': 'me1', 'type': 'submodule'}, {'id': 13, 'content': 'me2', 'type': 'submodule'}, {'id': 14, 'content': 'me3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 6, 1, 2, 3, 0, 6, 1, 4, 0, 6, 1, 0, 6, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a 4x1 multiplier array using sequential logic.\n\nModule name:  \n    multiplier4x1               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    x0[15:0]: 16-bit input operand X0.\n    x1[15:0]: 16-bit input operand X1.\n    x2[15:0]: 16-bit input operand X2.\n    x3[15:0]: 16-bit input operand X3.\n    y[15:0]: 16-bit input operand Y.\nOutput ports:\n    p0[31:0]: 32-bit output representing the product of X0 and Y.\n    p1[31:0]: 32-bit output representing the product of X1 and Y.\n    p2[31:0]: 32-bit output representing the product of X2 and Y.\n    p3[31:0]: 32-bit output representing the product of X3 and Y.\n\nImplementation:\nIn the multiplier4x1 module, four Multiplier Elements (MEs) are instantiated. Each ME performs multiplication of its inputs. ME0 (me0) takes inputs x0 and y directly. Similarly, ME1 (me1) takes x1 and y, ME2 (me2) takes x2 and y, and ME3 (me3) takes x3 and y. Each ME independently computes the product of its respective X input and the common Y input. This configuration allows for parallel multiplication operations, enhancing computational throughput.\nGive me the complete code.\nmodule multiplier4x1(\n    input clk,\n    input rst,\n    input [15:0] x0,\n    input [15:0] x1,\n    input [15:0] x2,\n    input [15:0] x3,\n    input [15:0] y,\n    output [31:0] p0,\n    output [31:0] p1,\n    output [31:0] p2,\n    output [31:0] p3\n);"}, {"from": "gpt", "value": "module multiplier4x1(\n    input clk,\n    input rst,\n    input [15:0] x0,\n    input [15:0] x1,\n    input [15:0] x2,\n    input [15:0] x3,\n    input [15:0] y,\n    output [31:0] p0,\n    output [31:0] p1,\n    output [31:0] p2,\n    output [31:0] p3\n);\n// 4 Multiplier Elements\nME me0(.clk(clk), .rst(rst), .x(x0), .y(y), .p(p0));\nME me1(.clk(clk), .rst(rst), .x(x1), .y(y), .p(p1));\nME me2(.clk(clk), .rst(rst), .x(x2), .y(y), .p(p2));\nME me3(.clk(clk), .rst(rst), .x(x3), .y(y), .p(p3));\nendmodule\n\nmodule ME (\n    input clk,\n    input rst,\n    input [15:0] x,\n    input [15:0] y,\n    output reg [31:0] p\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            p <= 0;\n        else\n            p <= x * y;  // Perform multiplication\n    end\nendmodule"}], "task_id": "systolic1x4"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'operand_a', 'type': 'input port'}, {'id': 1, 'content': 'operand_b', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'zero_flag', 'type': 'output port'}, {'id': 5, 'content': 'carry_flag', 'type': 'output port'}, {'id': 6, 'content': 'mod_add', 'type': 'submodule'}, {'id': 7, 'content': 'mod_sub', 'type': 'submodule'}, {'id': 8, 'content': 'mod_and', 'type': 'submodule'}, {'id': 9, 'content': 'mod_or', 'type': 'submodule'}, {'id': 10, 'content': 'mod_xor', 'type': 'submodule'}, {'id': 11, 'content': 'mod_nor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 11, 9, 8, 10, 6, 7, 11, 9, 8, 10, 2, 6], [6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 5, 5]]\n, Design a Verilog module for a 16-bit microcontroller's arithmetic unit. This unit should support addition, subtraction, and bitwise operations (AND, OR, XOR, NOR) on two operands, `operand_a` and `operand_b`. Additionally, the control signal `opcode` determines the operation performed. The module should output the result of the operation and a set of flags: `zero_flag` to indicate a zero result, and `carry_flag` for overflow in addition.\n\nThe operations and their corresponding `opcode` values are:\n\n- ADD: `4'b0000`\n- SUB: `4'b0001`\n- AND: `4'b0010`\n- OR: `4'b0011`\n- XOR: `4'b0100`\n- NOR: `4'b0101`\n\nModule name:\n    basic_arithmetic_unit\n\nInput ports:\n    operand_a: a 16-bit input operand\n    operand_b: a 16-bit input operand\n    opcode: a 4-bit control signal to select the operation\n\nOutput ports:\n    result: a 16-bit output representing the operation result\n    zero_flag: a 1-bit output indicating whether the result is zero\n    carry_flag: a 1-bit output indicating overflow in addition\n\nImplementation:\nThe module is structured into submodules for arithmetic and logical operations. Each operation is encapsulated within its submodule for improved modularity. A multiplexer selects the result based on the `opcode`.\nGive me the complete code.\nmodule basic_arithmetic_unit(\n    input [15:0] operand_a,\n    input [15:0] operand_b,\n    input [3:0] opcode,\n    output [15:0] result,\n    output zero_flag,\n    output carry_flag\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule basic_arithmetic_unit(\n    input [15:0] operand_a,\n    input [15:0] operand_b,\n    input [3:0] opcode,\n    output [15:0] result,\n    output zero_flag,\n    output carry_flag\n);\n\n    // Submodule instances for operations\n    wire [15:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire add_carry, sub_borrow;\n\n    // Instantiate operation modules\n    adder mod_add(.a(operand_a), .b(operand_b), .result(add_result), .carry(add_carry));\n    subtractor mod_sub(.a(operand_a), .b(operand_b), .result(sub_result), .borrow(sub_borrow));\n    and_gate mod_and(.a(operand_a), .b(operand_b), .result(and_result));\n    or_gate mod_or(.a(operand_a), .b(operand_b), .result(or_result));\n    xor_gate mod_xor(.a(operand_a), .b(operand_b), .result(xor_result));\n    nor_gate mod_nor(.a(operand_a), .b(operand_b), .result(nor_result));\n\n    // Result and flag selection logic\n    reg [15:0] selected_result;\n    assign result = selected_result;\n    assign zero_flag = (selected_result == 16'b0);\n    assign carry_flag = (opcode == 4'b0000) ? add_carry : 1'b0;\n\n    always @(*) begin\n        case (opcode)\n            4'b0000: selected_result = add_result;\n            4'b0001: selected_result = sub_result;\n            4'b0010: selected_result = and_result;\n            4'b0011: selected_result = or_result;\n            4'b0100: selected_result = xor_result;\n            4'b0101: selected_result = nor_result;\n            default: selected_result = 16'bz;\n        endcase\n    end\n\nendmodule\n\n// Submodules for each operation\nmodule adder(input [15:0] a, input [15:0] b, output [15:0] result, output carry);\n    assign {carry, result} = a + b;\nendmodule\n\nmodule subtractor(input [15:0] a, input [15:0] b, output [15:0] result, output borrow);\n    assign {borrow, result} = a - b;\nendmodule\n\nmodule and_gate(input [15:0] a, input [15:0] b, output [15:0] result);\n    assign result = a & b;\nendmodule\n\nmodule or_gate(input [15:0] a, input [15:0] b, output [15:0] result);\n    assign result = a | b;\nendmodule\n\nmodule xor_gate(input [15:0] a, input [15:0] b, output [15:0] result);\n    assign result = a ^ b;\nendmodule\n\nmodule nor_gate(input [15:0] a, input [15:0] b, output [15:0] result);\n    assign result = ~(a | b);\nendmodule\n"}], "task_id": "alu"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'quotient', 'type': 'output port'}, {'id': 5, 'content': 'remainder', 'type': 'output port'}, {'id': 6, 'content': 'u_divider', 'type': 'submodule'}, {'id': 7, 'content': 'u_modulus', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 2, 3, 6, 7], [6, 6, 7, 7, 4, 5]]\n, Implement a modular Divider with Remainder for 32-bit unsigned integers. In the div_mod module, there are submodules for division and modulus. The div_mod module connects these submodules to perform the operations.\n\nModule name:\n    div_mod\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input dividend.\n    b: 32-bit input divisor.\n\nOutput ports:\n    quotient: 32-bit output representing the division result.\n    remainder: 32-bit output representing the modulus result.\n\nImplementation:\nThe module includes:\nDivider Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 32-bit quotient of their division.\nModulus Submodule:\nThis submodule takes the same inputs and calculates the remainder when a is divided by b, outputting this as a 32-bit result.\nThe main div_mod module connects these submodules and assigns their outputs to the respective output ports.\nGive me the complete code.\nmodule div_mod(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] quotient,\n    output [31:0] remainder\n);"}, {"from": "gpt", "value": "module div_mod(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] quotient,\n    output [31:0] remainder\n);\n\n// Intermediate wires to hold the division and remainder results\nwire [31:0] div_result;\nwire [31:0] mod_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .a(a),\n    .b(b),\n    .result(div_result)\n);\n\n// Instantiating the modulus module\nmodulus u_modulus (\n    .a(a),\n    .b(b),\n    .result(mod_result)\n);\n\n// Assigning the results to the outputs\nassign quotient = div_result;\nassign remainder = mod_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = b != 0 ? a / b : 0;\nendmodule\n\n// Modulus module\nmodule modulus(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = b != 0 ? a % b : 0;\nendmodule"}], "task_id": "pe"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'as0', 'type': 'submodule'}, {'id': 4, 'content': 'as1', 'type': 'submodule'}, {'id': 5, 'content': 'as2', 'type': 'submodule'}, {'id': 6, 'content': 'as3', 'type': 'submodule'}, {'id': 7, 'content': 'as4', 'type': 'submodule'}, {'id': 8, 'content': 'as5', 'type': 'submodule'}, {'id': 9, 'content': 'as6', 'type': 'submodule'}, {'id': 10, 'content': 'as7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 5, 10, 4, 7, 3, 8, 6, 9], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Implement a module of an 8-bit multiplier that adheres to modular design principles.\n\nModule name:\n    mul_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mul_8bit utilizes a series of add_shift_8bit modules for partial product generation and summation. Each add_shift_8bit module computes the sum and carries for one bit of the multiplier Y, shifting its outputs appropriately.\nGive me the complete code.\nmodule mul_8bit(X, Y, P);"}, {"from": "gpt", "value": "module mul_8bit(X, Y, P);\n    input [7:0] X;      // 8-bit input operand X\n    input [7:0] Y;      // 8-bit input operand Y\n    output [15:0] P;    // 16-bit output product\n\n    wire [15:0] pp0, pp1, pp2, pp3, pp4, pp5, pp6, pp7;   // Partial products\n\n    // Instantiate the partial product generator modules\n    add_shift_8bit as0(.A(X), .B(Y[0]), .P(pp0), .Shift(0));\n    add_shift_8bit as1(.A(X), .B(Y[1]), .P(pp1), .Shift(1));\n    add_shift_8bit as2(.A(X), .B(Y[2]), .P(pp2), .Shift(2));\n    add_shift_8bit as3(.A(X), .B(Y[3]), .P(pp3), .Shift(3));\n    add_shift_8bit as4(.A(X), .B(Y[4]), .P(pp4), .Shift(4));\n    add_shift_8bit as5(.A(X), .B(Y[5]), .P(pp5), .Shift(5));\n    add_shift_8bit as6(.A(X), .B(Y[6]), .P(pp6), .Shift(6));\n    add_shift_8bit as7(.A(X), .B(Y[7]), .P(pp7), .Shift(7));\n\n    // Sum all partial products to get the final product\n    assign P = pp0 + pp1 + pp2 + pp3 + pp4 + pp5 + pp6 + pp7;\n\nendmodule\n\nmodule add_shift_8bit(A, B, P, Shift);\n    input [7:0] A;      // 8-bit input operand A\n    input B;            // Single bit of input operand B\n    output [15:0] P;    // Partial product output\n    input [3:0] Shift;  // Shift amount for the partial product\n\n    wire [7:0] partial;\n\n    // Generate partial product\n    assign partial = (B) ? A : 8'b0;\n\n    // Shift left and assign to output\n    assign P = partial << Shift;\n\nendmodule"}], "task_id": "sub_8bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B32', 'type': 'output port'}, {'id': 4, 'content': 'BLS1', 'type': 'submodule'}, {'id': 5, 'content': 'BLS2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module for a 32-bit subtractor using the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:  \n    subtractor_32bit               \nInput ports:\n    X[32:1]: 32-bit minuend input X.\n    Y[32:1]: 32-bit subtrahend input Y.\nOutput ports:\n    D[32:1]: 32-bit output representing the difference of X and Y.\n    B32: Borrow-out output.\n\nImplementation:\nThe top module subtractor_32bit consists of two instances of the 16-bit BLS block you design.\nGive me the complete code.\nmodule subtractor_32bit(X, Y, D, B32);"}, {"from": "gpt", "value": "module subtractor_32bit(X, Y, D, B32);\n    input [32:1] X;\n    input [32:1] Y;\n    output [32:1] D;\n    output B32;\n\n    wire pb1, gb1, pb2, gb2;\n    wire b16;\n\n    BLS_16 BLS1(\n        .X(X[16:1]),\n        .Y(Y[16:1]),\n        .b0(0),\n        .D(D[16:1]),\n        .pb(pb1),\n        .gb(gb1)\n    );\n\n    BLS_16 BLS2(\n        .X(X[32:17]),\n        .Y(Y[32:17]),\n        .b0(b16),\n        .D(D[32:17]),\n        .pb(pb2),\n        .gb(gb2)\n    );\n\n    assign b16 = gb1 ^ (pb1 && 0), // b0 = 0\n           B32 = gb2 ^ (pb2 && b16);\nendmodule\n\nmodule BLS_16(X, Y, b0, D, pb, gb);\n    input [16:1] X;\n    input [16:1] Y;\n    input b0;\n    output [16:1] D;\n    output pb, gb;\n\n    wire b4, b8, b12;\n    wire Pm1, Gm1, Pm2, Gm2, Pm3, Gm3, Pm4, Gm4;\n\n    subtractor_4 subtr1(\n        .x(X[4:1]),\n        .y(Y[4:1]),\n        .b0(b0),\n        .b4(),\n        .D(D[4:1]),\n        .Gm(Gm1),\n        .Pm(Pm1)\n    );\n\n    subtractor_4 subtr2(\n        .x(X[8:5]),\n        .y(Y[8:5]),\n        .b0(b4),\n        .b4(),\n        .D(D[8:5]),\n        .Gm(Gm2),\n        .Pm(Pm2)\n    );\n\n    subtractor_4 subtr3(\n        .x(X[12:9]),\n        .y(Y[12:9]),\n        .b0(b8),\n        .b4(),\n        .D(D[12:9]),\n        .Gm(Gm3),\n        .Pm(Pm3)\n    );\n\n    subtractor_4 subtr4(\n        .x(X[16:13]),\n        .y(Y[16:13]),\n        .b0(b12),\n        .b4(),\n        .D(D[16:13]),\n        .Gm(Gm4),\n        .Pm(Pm4)\n    );\n\n    assign b4 = Gm1 ^ (Pm1 & b0),\n           b8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & b0),\n           b12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & b0);\n\n    assign pb = Pm1 & Pm2 & Pm3 & Pm4,\n           gb = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule subtractor_4(x, y, b0, b4, D, Gm, Pm);\n    input [4:1] x;\n    input [4:1] y;\n    input b0;\n    output b4, Gm, Pm;\n    output [4:1] D;\n\n    wire p1, p2, p3, p4, g1, g2, g3, g4;\n    wire b1, b2, b3;\n\n    subtractor subtr1(\n        .X(x[1]),\n        .Y(y[1]),\n        .Bin(b0),\n        .D(D[1]),\n        .Bout()\n    );\n\n    subtractor subtr2(\n        .X(x[2]),\n        .Y(y[2]),\n        .Bin(b1),\n        .D(D[2]),\n        .Bout()\n    );\n\n    subtractor subtr3(\n        .X(x[3]),\n        .Y(y[3]),\n        .Bin(b2),\n        .D(D[3]),\n        .Bout()\n    );\n\n    subtractor subtr4(\n        .X(x[4]),\n        .Y(y[4]),\n        .Bin(b3),\n        .D(D[4]),\n        .Bout()\n    );      \n\n    BLS BLS(\n        .b0(b0),\n        .b1(b1),\n        .b2(b2),\n        .b3(b3),\n        .b4(b4),\n        .p1(p1),\n        .p2(p2),\n        .p3(p3),\n        .p4(p4),\n        .g1(g1),\n        .g2(g2),\n        .g3(g3),\n        .g4(g4)\n    );\n\n    assign p1 = ~x[1] ^ y[1],\n           p2 = ~x[2] ^ y[2],\n           p3 = ~x[3] ^ y[3],\n           p4 = ~x[4] ^ y[4];\n\n    assign g1 = ~x[1] & y[1],\n           g2 = ~x[2] & y[2],\n           g3 = ~x[3] & y[3],\n           g4 = ~x[4] & y[4];\n\n    assign Pm = p1 & p2 & p3 & p4,\n           Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule BLS(b0, b1, b2, b3, b4, p1, p2, p3, p4, g1, g2, g3, g4);\n    input b0, g1, g2, g3, g4, p1, p2, p3, p4;\n    output b1, b2, b3, b4;\n\n    assign b1 = g1 ^ (p1 & b0),\n           b2 = g2 ^ (p2 & g1) ^ (p2 & p1 & b0),\n           b3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & b0),\n           b4 = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1) ^ (p4 & p3 & p2 & p1 & b0);\nendmodule\n\nmodule subtractor(X, Y, Bin, D, Bout);\n    input X, Y, Bin;\n    output D, Bout;\n\n    assign D = X ^ Y ^ Bin;\n    assign Bout = (~X & Y) | ((~X ^ Y) & Bin);\nendmodule\n"}], "task_id": "adder_32bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'x', 'type': 'input port'}, {'id': 1, 'content': 'y', 'type': 'input port'}, {'id': 2, 'content': 'bin', 'type': 'input port'}, {'id': 3, 'content': 'diff', 'type': 'output port'}, {'id': 4, 'content': 'bout', 'type': 'output port'}, {'id': 5, 'content': 'FS0', 'type': 'submodule'}, {'id': 6, 'content': 'FS1', 'type': 'submodule'}, {'id': 7, 'content': 'FS2', 'type': 'submodule'}, {'id': 8, 'content': 'FS3', 'type': 'submodule'}, {'id': 9, 'content': 'FS4', 'type': 'submodule'}, {'id': 10, 'content': 'FS5', 'type': 'submodule'}, {'id': 11, 'content': 'FS6', 'type': 'submodule'}, {'id': 12, 'content': 'FS7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 1, 0, 0, 1, 7, 8, 1, 0, 0, 9, 1, 0, 1, 10, 0, 1, 11, 9, 11, 8, 12, 10, 5, 7, 6, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module for an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    x[7:0]: 8-bit input operand X.\n    y[7:0]: 8-bit input operand Y.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of X minus Y.\n    bout: Borrow-out output.\n\nImplementation:\nThe module uses a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] x, y, \n    input bin, \n    output [7:0] diff, \n    output bout);"}, {"from": "gpt", "value": "module subtractor_8bit(\n    input [7:0] x, y, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] b;\n\n    full_subtractor FS0 (.x(x[0]), .y(y[0]), .bin(bin), .diff(diff[0]), .bout(b[0]));\n    full_subtractor FS1 (.x(x[1]), .y(y[1]), .bin(b[0]), .diff(diff[1]), .bout(b[1]));\n    full_subtractor FS2 (.x(x[2]), .y(y[2]), .bin(b[1]), .diff(diff[2]), .bout(b[2]));\n    full_subtractor FS3 (.x(x[3]), .y(y[3]), .bin(b[2]), .diff(diff[3]), .bout(b[3]));\n    full_subtractor FS4 (.x(x[4]), .y(y[4]), .bin(b[3]), .diff(diff[4]), .bout(b[4]));\n    full_subtractor FS5 (.x(x[5]), .y(y[5]), .bin(b[4]), .diff(diff[5]), .bout(b[5]));\n    full_subtractor FS6 (.x(x[6]), .y(y[6]), .bin(b[5]), .diff(diff[6]), .bout(b[6]));\n    full_subtractor FS7 (.x(x[7]), .y(y[7]), .bin(b[6]), .diff(diff[7]), .bout(b[7]));\n\n    assign bout = b[7]; \nendmodule\n\nmodule full_subtractor (input x, y, bin, output diff, bout);\n    assign {bout, diff} = x - y - bin;\nendmodule\n"}], "task_id": "adder_8bit"}]