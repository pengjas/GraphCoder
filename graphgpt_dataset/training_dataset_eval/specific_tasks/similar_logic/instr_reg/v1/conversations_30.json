[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl_flag', 'type': 'input port'}, {'id': 3, 'content': 'bus_data', 'type': 'input port'}, {'id': 4, 'content': 'reg1_out', 'type': 'output port'}, {'id': 5, 'content': 'reg2_out', 'type': 'output port'}, {'id': 6, 'content': 'reg1', 'type': 'submodule'}, {'id': 7, 'content': 'reg2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 6, 7], [6, 6, 6, 6, 7, 7, 7, 7, 4, 5]]\n, A data bus control module that processes and directs input signals across multiple registers based on control flags. The module captures data from a bus, storing it into appropriate registers, and extracts specific fields from the registers to be sent to output interfaces.\n\nModule name:\n    data_bus_control\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize all registers.\n    ctrl_flag [1:0]: Control flag determining the destination register for incoming data.\n    bus_data [15:0]: 16-bit data input from the data bus.\n\nOutput ports:\n    reg1_out [7:0]: Output from the first register representing the lower 8 bits of the bus data.\n    reg2_out [7:0]: Output from the second register representing the upper 8 bits of the bus data.\n\nImplementation:\n    The data bus control module utilizes two submodules, each responsible for storing parts of the bus data into different registers.\n    On the rising edge of the clock (clk), if the reset (rst) is active, all outputs are set to zero.\n    Based on the control flag (ctrl_flag):\n    If ctrl_flag is 2'b01, the bus data is split and stored into the first register (reg1).\n    If ctrl_flag is 2'b10, the bus data is split and stored into the second register (reg2).\n    The outputs reg1_out and reg2_out are derived from the bus data stored in reg1 and reg2 respectively, with reg1_out receiving the lower 8 bits and reg2_out the upper 8 bits.\nGive me the complete code.\nmodule data_bus_control (\n    input clk,\n    input rst,\n    input [1:0] ctrl_flag,\n    input [15:0] bus_data,\n    output [7:0] reg1_out,\n    output [7:0] reg2_out\n);"}, {"from": "gpt", "value": "module data_bus_control (\n    input clk,\n    input rst,\n    input [1:0] ctrl_flag,\n    input [15:0] bus_data,\n    output [7:0] reg1_out,\n    output [7:0] reg2_out\n);\n\n    // Submodule for register storage\n    wire [7:0] reg1_data, reg2_data;\n\n    register_storage reg1 (\n        .clk(clk),\n        .rst(rst),\n        .ctrl_flag(ctrl_flag),\n        .data_in(bus_data[7:0]), // Lower 8 bits of bus data\n        .data_out(reg1_data),\n        .ctrl_code(2'b01) // Control for first register\n    );\n\n    register_storage reg2 (\n        .clk(clk),\n        .rst(rst),\n        .ctrl_flag(ctrl_flag),\n        .data_in(bus_data[15:8]), // Upper 8 bits of bus data\n        .data_out(reg2_data),\n        .ctrl_code(2'b10) // Control for second register\n    );\n\n    // Output assignments\n    assign reg1_out = reg1_data;\n    assign reg2_out = reg2_data;\n\nendmodule\n\n// Submodule for register storage\nmodule register_storage (\n    input clk,\n    input rst,\n    input [1:0] ctrl_flag,\n    input [7:0] data_in,\n    output reg [7:0] data_out,\n    input [1:0] ctrl_code // Code to distinguish control flags\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (ctrl_flag == ctrl_code) begin\n                data_out <= data_in; // Capture incoming data if control code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 0}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'enable', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'data3', 'type': 'input port'}, {'id': 6, 'content': 'critical_data', 'type': 'output port'}, {'id': 7, 'content': 'sensor_type', 'type': 'output port'}, {'id': 8, 'content': 'sensor1', 'type': 'submodule'}, {'id': 9, 'content': 'sensor2', 'type': 'submodule'}, {'id': 10, 'content': 'sensor3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 3, 0, 4, 2, 1, 5, 0, 2, 1, 10, 9, 8], [8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 6, 6, 6]]\n, A control unit for handling multiple sensor inputs and processing them based on priority and type. The control unit will take sensor data from three different sources, decode the priority, and output the most critical sensor data along with its type.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the unit.\n    enable [2:0]: Control signal indicating the active sensor source (bitwise).\n    data1 [7:0], data2 [7:0], data3 [7:0]: 8-bit data inputs from three sensors.\n\nOutput ports:\n    critical_data [7:0]: The most critical sensor data.\n    sensor_type [1:0]: Indicator of the sensor type (00 for data1, 01 for data2, 10 for data3).\n\nImplementation:\n    The control unit is implemented using submodules, each responsible for storing data from different sensors.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the enable signal:\n    Data from the sensor which has its corresponding enable bit set to high is processed; if multiple bits are high, data from the lowest numbered sensor is selected.\n    The outputs critical_data and sensor_type are updated based on the selected sensor data.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [2:0] enable,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] critical_data,\n    output reg [1:0] sensor_type\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [2:0] enable,\n    input [7:0] data1,\n    input [7:0] data2,\n    input [7:0] data3,\n    output reg [7:0] critical_data,\n    output reg [1:0] sensor_type\n);\n\n    // Submodule for sensor data storage\n    wire [7:0] data1_out, data2_out, data3_out;\n\n    sensor_data_storage sensor1 (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable[0]),\n        .data(data1),\n        .data_out(data1_out)\n    );\n\n    sensor_data_storage sensor2 (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable[1]),\n        .data(data2),\n        .data_out(data2_out)\n    );\n\n    sensor_data_storage sensor3 (\n        .clk(clk),\n        .rst(rst),\n        .enable(enable[2]),\n        .data(data3),\n        .data_out(data3_out)\n    );\n\n    // Output logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            critical_data <= 8'd0;\n            sensor_type <= 2'b00;\n        end else begin\n            if (enable[0]) begin\n                critical_data <= data1_out;\n                sensor_type <= 2'b00;\n            end else if (enable[1]) begin\n                critical_data <= data2_out;\n                sensor_type <= 2'b01;\n            end else if (enable[2]) begin\n                critical_data <= data3_out;\n                sensor_type <= 2'b10;\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for sensor data storage\nmodule sensor_data_storage (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n        end else begin\n            if (enable) begin\n                data_out <= data; // Capture data if enabled\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 1}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'encoded_ins', 'type': 'input port'}, {'id': 3, 'content': 'control_signals', 'type': 'output port'}, {'id': 4, 'content': 'op_mode', 'type': 'output port'}, {'id': 5, 'content': 'immediate_value', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 2], [3, 4, 5]]\n, A decoder module designed to interpret CPU instructions and control signals. It receives encoded instruction signals from a central processing unit and outputs decoded control signals that direct data paths and operational modes based on the instruction content.\n\nModule name:\n    instruction_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    encoded_ins [15:0]: 16-bit encoded instruction from the CPU.\n\nOutput ports:\n    control_signals [7:0]: Decoded control signals for directing data paths.\n    op_mode [2:0]: Operation mode determined by bits of the instruction.\n    immediate_value [7:0]: Immediate value extracted from the instruction for immediate operations.\n\nImplementation:\n    The instruction decoder is implemented using register-based storage with synchronous reset and parameterized control for handling various instruction types.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all outputs are initialized to zero.\n    The decoded control signals and operation modes are based on specific bit ranges within the encoded_ins input.\n    The control_signals output is derived from specific patterns in encoded_ins, while the op_mode is determined by a designated segment of the instruction.\n    An immediate_value is extracted directly from a segment of encoded_ins when certain conditions in the control signals are met.\nGive me the complete code.\nmodule instruction_decoder (\n    input clk,\n    input rst,\n    input [15:0] encoded_ins,\n    output [7:0] control_signals,\n    output [2:0] op_mode,\n    output [7:0] immediate_value\n);"}, {"from": "gpt", "value": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [15:0] encoded_ins,\n    output [7:0] control_signals,\n    output [2:0] op_mode,\n    output [7:0] immediate_value\n);\n\n    // Register for control signals and operation mode\n    reg [7:0] control_reg;\n    reg [2:0] mode_reg;\n    reg [7:0] immediate_reg;\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            control_reg <= 8'd0;     // Reset control signals\n            mode_reg <= 3'd0;        // Reset operation mode\n            immediate_reg <= 8'd0;   // Reset immediate value\n        end else begin\n            // Decode control signals based on instruction pattern\n            control_reg <= encoded_ins[15:8]; // Example pattern for control signals\n            mode_reg <= encoded_ins[7:5];     // Operation mode segment\n            // Check for immediate operation condition (example condition)\n            if (control_reg[0] == 1'b1) begin\n                immediate_reg <= encoded_ins[7:0]; // Immediate value segment\n            end\n        end\n    end\n\n    // Output assignments\n    assign control_signals = control_reg;\n    assign op_mode = mode_reg;\n    assign immediate_value = immediate_reg;\n\nendmodule"}], "task_id": 2}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'ctrl', 'type': 'output port'}, {'id': 5, 'content': 'flag', 'type': 'output port'}, {'id': 6, 'content': 'buffer_out', 'type': 'output port'}, {'id': 7, 'content': 'direct_decoder', 'type': 'submodule'}, {'id': 8, 'content': 'buffer_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 3, 0, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, A data decoder module that interprets and separates incoming data into multiple control and status signals, facilitating subsequent processing in a CPU or control system. This module collects data from either direct input or a memory buffer, decoding into various flags and control bits based on a control signal.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    sel [1:0]: Selection signal determining the data source (0 for direct, 1 for buffer).\n    data_in [15:0]: 16-bit data input to be decoded.\n\nOutput ports:\n    ctrl [3:0]: Control signals extracted from data.\n    flag [3:0]: Status flags derived from data.\n    buffer_out [7:0]: Data from the buffer when sel is high.\n\nImplementation:\n    The data decoder is structured using two submodules, each tasked with processing data from the specified sources.\n    On the rising edge of the clock (clk), if the reset (rst) is active, all outputs are reset to zero.\n    Depending on the sel signal:\n    If sel is 2'b00, data is directly decoded from data_in into the first submodule (direct_decoder).\n    If sel is 2'b01, data is fetched from the buffer and processed in the second submodule (buffer_decoder).\n    If neither condition is met, the previous values in all outputs are maintained.\n    The outputs ctrl, flag, and buffer_out are determined by the respective submodules' processed data.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_in,\n    output [3:0] ctrl,\n    output [3:0] flag,\n    output [7:0] buffer_out\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_in,\n    output [3:0] ctrl,\n    output [3:0] flag,\n    output [7:0] buffer_out\n);\n\n    // Submodules for data decoding\n    wire [15:0] direct_out, buffer_out_wire;\n\n    decode_direct direct_decoder (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_in),\n        .decoded_out(direct_out),\n        .sel_code(2'b00) // Decode direct input\n    );\n\n    decode_buffer buffer_decoder (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_in),\n        .buffer_out(buffer_out_wire),\n        .sel_code(2'b01) // Process buffer data\n    );\n\n    // Output assignments\n    assign ctrl = direct_out[15:12]; // Extract top 4 bits as control signals\n    assign flag = direct_out[11:8];  // Next 4 bits as flags\n    assign buffer_out = buffer_out_wire[7:0]; // 8 bits from buffer output\n\nendmodule\n\n// Submodule for direct data decoding\nmodule decode_direct (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [15:0] decoded_out,\n    input [1:0] sel_code // Code for direct decoding\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_out <= 16'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                decoded_out <= data; // Decode if selection matches\n            end else begin\n                decoded_out <= decoded_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for buffer data processing\nmodule decode_buffer (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [7:0] buffer_out,\n    input [1:0] sel_code // Code for buffer processing\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            buffer_out <= 8'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                buffer_out <= data[7:0]; // Process buffer if selection matches\n            end else begin\n                buffer_out <= buffer_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 3}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'sensor1_data', 'type': 'input port'}, {'id': 4, 'content': 'sensor2_data', 'type': 'input port'}, {'id': 5, 'content': 'sensor3_data', 'type': 'input port'}, {'id': 6, 'content': 'valid', 'type': 'input port'}, {'id': 7, 'content': 'processed_data', 'type': 'output port'}, {'id': 8, 'content': 'data_valid', 'type': 'output port'}, {'id': 9, 'content': 'proc1', 'type': 'submodule'}, {'id': 10, 'content': 'proc2', 'type': 'submodule'}, {'id': 11, 'content': 'proc3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[6, 3, 0, 1, 6, 4, 0, 1, 6, 5, 0, 1, 11, 10, 9, 11, 10, 9], [9, 9, 9, 9, 10, 10, 10, 10, 11, 11, 11, 11, 7, 7, 7, 8, 8, 8]]\n, A multi-source data selector for capturing and processing sensor signals in an industrial control system. It selects data from multiple sensors and processes it based on priority and signal validity, using parameterized control.\n\nModule name:\n    sensor_data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    sel [1:0]: Control signal to select the sensor source.\n    sensor1_data [15:0]: 16-bit data from sensor 1.\n    sensor2_data [15:0]: 16-bit data from sensor 2.\n    sensor3_data [15:0]: 16-bit data from sensor 3.\n    valid [2:0]: Validity bits for each sensor data (1-valid, 0-invalid).\n\nOutput ports:\n    processed_data [15:0]: Processed output data based on the selected sensor.\n    data_valid: Indicates if the output data is valid.\n\nImplementation:\n    The module includes three submodules, each corresponding to a sensor data input.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the processed_data and data_valid are initialized to zero.\n    Based on the sel signal, the data from the corresponding sensor is selected if its valid bit is high:\n    If sel is 2'b00 and the first sensor's data is valid, data from sensor1_data is used.\n    If sel is 2'b01 and the second sensor's data is valid, data from sensor2_data is selected.\n    If sel is 2'b10 and the third sensor's data is valid, data from sensor3_data is used.\n    If no conditions are met, data_valid is set to 0 indicating no valid data.\n    The processed_data is possibly further processed within each submodule before being output.\nGive me the complete code.\nmodule sensor_data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] sensor1_data,\n    input [15:0] sensor2_data,\n    input [15:0] sensor3_data,\n    input [2:0] valid,\n    output reg [15:0] processed_data,\n    output reg data_valid\n);"}, {"from": "gpt", "value": "module sensor_data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] sensor1_data,\n    input [15:0] sensor2_data,\n    input [15:0] sensor3_data,\n    input [2:0] valid,\n    output reg [15:0] processed_data,\n    output reg data_valid\n);\n\n    // Submodules for each sensor data processing\n    wire [15:0] data1_out, data2_out, data3_out;\n\n    sensor_processor proc1 (\n        .clk(clk),\n        .rst(rst),\n        .data(sensor1_data),\n        .valid(valid[0]),\n        .data_out(data1_out)\n    );\n\n    sensor_processor proc2 (\n        .clk(clk),\n        .rst(rst),\n        .data(sensor2_data),\n        .valid(valid[1]),\n        .data_out(data2_out)\n    );\n\n    sensor_processor proc3 (\n        .clk(clk),\n        .rst(rst),\n        .data(sensor3_data),\n        .valid(valid[2]),\n        .data_out(data3_out)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            processed_data <= 16'd0;\n            data_valid <= 1'b0;\n        end else begin\n            case(sel)\n                2'b00: if (valid[0]) {processed_data, data_valid} <= {data1_out, 1'b1};\n                2'b01: if (valid[1]) {processed_data, data_valid} <= {data2_out, 1'b1};\n                2'b10: if (valid[2]) {processed_data, data_valid} <= {data3_out, 1'b1};\n                default: data_valid <= 1'b0;\n            endcase\n        end\n    end\nendmodule\n\nmodule sensor_processor (\n    input clk,\n    input rst,\n    input [15:0] data,\n    input valid,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0;\n        end else if (valid) begin\n            data_out <= data; // Process data if valid\n        end\n    end\nendmodule"}], "task_id": 4}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'dataA', 'type': 'input port'}, {'id': 4, 'content': 'dataB', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'tag', 'type': 'output port'}, {'id': 7, 'content': 'sourceA', 'type': 'submodule'}, {'id': 8, 'content': 'sourceB', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 3, 4, 2, 0, 1, 7, 2, 8, 7, 2, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, Design a multi-source data capture module for a digital communication system. It should accommodate two data sources and a control signal to select which source to use. Extract and deliver distinct data fields from each source.\n\nModule name:\n    multi_source_capture\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    select [1:0]: Control signal to select the data source (1 for Source A, 2 for Source B).\n    dataA [15:0]: 16-bit data input from Source A.\n    dataB [15:0]: 16-bit data input from Source B.\n\nOutput ports:\n    data_out [7:0]: 8-bit extracted data output.\n    tag [3:0]: 4-bit field extracted as a tag from the selected data source.\n\nImplementation:\n    The module utilizes two submodules, each responsible for processing data from one of the sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the select signal:\n    If select is 2'b01, data is fetched from the dataA input into the first submodule (process_source_A).\n    If select is 2'b10, data is fetched from the dataB input into the second submodule (process_source_B).\n    If neither condition is met, the previous values in both outputs are retained.\n    The outputs data_out and tag are derived from the outputs of the active submodule based on the select signal.\nGive me the complete code.\nmodule multi_source_capture (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] dataA,\n    input [15:0] dataB,\n    output [7:0] data_out,\n    output [3:0] tag\n);"}, {"from": "gpt", "value": "module multi_source_capture (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] dataA,\n    input [15:0] dataB,\n    output [7:0] data_out,\n    output [3:0] tag\n);\n\n    // Submodule outputs\n    wire [7:0] data_out_A, data_out_B;\n    wire [3:0] tag_A, tag_B;\n\n    // Submodule for Source A processing\n    source_processor sourceA (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(dataA),\n        .data_out(data_out_A),\n        .tag_out(tag_A),\n        .select_code(2'b01) // Process Source A\n    );\n\n    // Submodule for Source B processing\n    source_processor sourceB (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(dataB),\n        .data_out(data_out_B),\n        .tag_out(tag_B),\n        .select_code(2'b10) // Process Source B\n    );\n\n    // Output assignments based on select\n    assign data_out = (select == 2'b01) ? data_out_A : (select == 2'b10) ? data_out_B : 8'd0;\n    assign tag = (select == 2'b01) ? tag_A : (select == 2'b10) ? tag_B : 4'd0;\n\nendmodule\n\n// Submodule for processing each data source\nmodule source_processor (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data,\n    output reg [7:0] data_out,\n    output reg [3:0] tag_out,\n    input [1:0] select_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset outputs\n            tag_out <= 4'd0;\n        end else begin\n            if (select == select_code) begin\n                data_out <= data[15:8]; // Capture high 8 bits as data\n                tag_out <= data[3:0]; // Capture low 4 bits as tag\n            end else begin\n                data_out <= data_out; // Retain previous values\n                tag_out <= tag_out;\n            end\n        end\n    end\n\nendmodule"}], "task_id": 5}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'cmd', 'type': 'input port'}, {'id': 3, 'content': 'state', 'type': 'input port'}, {'id': 4, 'content': 'en_exec', 'type': 'output port'}, {'id': 5, 'content': 'en_mem', 'type': 'output port'}, {'id': 6, 'content': 'en_io', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 7, 7, 7], [7, 7, 4, 5, 6]]\n, Design a control unit for a microprocessor that processes control signals and outputs appropriate commands to other parts of the system. It should decode input commands from a control bus and produce multiple control signals based on the microprocessor's operational state and external inputs.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    cmd [3:0]: 4-bit command input representing different control operations.\n    state [1:0]: 2-bit input representing the current state of the microprocessor.\n\nOutput ports:\n    en_exec: Enable signal for the execution unit.\n    en_mem: Enable signal for the memory unit.\n    en_io: Enable signal for the I/O unit.\n\nImplementation:\n    The control unit decodes the input command and the microprocessor state to generate specific enable signals.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all output enable signals are set to zero.\n    The unit includes a submodule for decoding commands which outputs control flags based on the command and state inputs.\n    The flags are then used to set the respective enable signals for execution, memory, and I/O units.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [3:0] cmd,\n    input [1:0] state,\n    output reg en_exec,\n    output reg en_mem,\n    output reg en_io\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [3:0] cmd,\n    input [1:0] state,\n    output reg en_exec,\n    output reg en_mem,\n    output reg en_io\n);\n\n    // Submodule for command decoding\n    wire [2:0] control_flags;\n\n    command_decoder decoder (\n        .cmd(cmd),\n        .state(state),\n        .flags_out(control_flags)\n    );\n\n    // Control logic based on decoded flags\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            en_exec <= 1'b0;\n            en_mem <= 1'b0;\n            en_io <= 1'b0;\n        end else begin\n            en_exec <= control_flags[0];\n            en_mem <= control_flags[1];\n            en_io <= control_flags[2];\n        end\n    end\n\nendmodule\n\n// Submodule for decoding commands based on the microprocessor's state\nmodule command_decoder (\n    input [3:0] cmd,\n    input [1:0] state,\n    output reg [2:0] flags_out\n);\n\n    always @(*) begin\n        case (state)\n            2'b00: flags_out = 3'b000; // default state\n            2'b01: begin // Example state processing\n                case (cmd)\n                    4'b0001: flags_out = 3'b110; // Enable exec and mem\n                    4'b0010: flags_out = 3'b101; // Enable exec and io\n                    default: flags_out = 3'b000;\n                endcase\n            end\n            2'b10: begin\n                case (cmd)\n                    4'b0100: flags_out = 3'b011; // Enable mem and io\n                    default: flags_out = 3'b000;\n                endcase\n            end\n            default: flags_out = 3'b000;\n        endcase\n    end\n\nendmodule"}], "task_id": 6}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'field1', 'type': 'output port'}, {'id': 5, 'content': 'field2', 'type': 'output port'}, {'id': 6, 'content': 'status', 'type': 'output port'}, {'id': 7, 'content': 'dp1', 'type': 'submodule'}, {'id': 8, 'content': 'dp2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, Design a multi-source data capture unit in Verilog to selectively read and store data from different peripherals based on control signals, and output specific data fields after processing.\n\nModule name:\n    data_capture_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the unit.\n    select [2:0]: Control signal to select the data source (e.g., 3'b001 for sensor, 3'b010 for memory).\n    data_in [15:0]: 16-bit input data from peripherals.\n\nOutput ports:\n    field1 [7:0]: Extracted byte representing a processed high priority data field.\n    field2 [3:0]: Extracted nibble representing a secondary data field.\n    status [1:0]: Status bits indicating the processing results or error states.\n\nImplementation:\n    The data capture unit is implemented using two submodules, each responsible for capturing data from a designated set of peripherals.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all outputs are initialized to zero.\n    Based on the select signal:\n    If select is 3'b001 or 3'b010, the data is captured from the input data_in into the first submodule (data_processor1).\n    If select is 3'b100 or 3'b101, the data is captured from the data_in into the second submodule (data_processor2).\n    The outputs field1, field2, and status are derived from the processed data in the respective submodules.\nGive me the complete code.\nmodule data_capture_unit (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] field1,\n    output [3:0] field2,\n    output [1:0] status\n);"}, {"from": "gpt", "value": "module data_capture_unit (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] field1,\n    output [3:0] field2,\n    output [1:0] status\n);\n\n    // Submodule for data processing\n    wire [15:0] dp1_out, dp2_out;\n\n    data_processor dp1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(data_in),\n        .data_out(dp1_out),\n        .select_code(3'b001) // Priority peripherals\n    );\n\n    data_processor dp2 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(data_in),\n        .data_out(dp2_out),\n        .select_code(3'b100) // Secondary peripherals\n    );\n\n    // Output assignments\n    assign field1 = dp1_out[15:8]; // High byte, priority data\n    assign field2 = dp1_out[3:0];  // Low nibble, minor data\n    assign status = dp2_out[1:0];  // Status from secondary data source\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    input [2:0] select_code // Code to distinguish data sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= data_in; // Capture data if select code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 7}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'address', 'type': 'output port'}, {'id': 5, 'content': 'command', 'type': 'output port'}, {'id': 6, 'content': 'ext_decode', 'type': 'submodule'}, {'id': 7, 'content': 'int_decode', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 7, 2, 6, 7, 2, 6], [6, 6, 6, 6, 7, 7, 7, 7, 4, 4, 4, 5, 5, 5]]\n, A data decoder module designed to interface with a memory unit and a processing unit, decoding the memory addresses and control signals. It is responsible for decoding the input data based on the source specified by control signals and distributing it to multiple output channels.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    select [1:0]: Control signal to select the source of data (0 for external, 1 for internal memory).\n    data_in [15:0]: 16-bit input data that needs decoding.\n\nOutput ports:\n    address [7:0]: 8-bit address extracted from the data.\n    command [7:0]: 8-bit command field extracted from the data.\n\nImplementation:\n    The data decoder module utilizes internal submodules for processing different sources of data.\n    On the rising edge of the clock (clk), if the reset (rst) is active, the outputs address and command are reset to zero.\n    Based on the select signal:\n    If select is 2'b00, data is decoded from the external source submodule (ext_decode).\n    If select is 2'b01, data is decoded from the internal memory submodule (int_decode).\n    The outputs address and command are calculated based on the decoded outputs from the respective submodule.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output [7:0] address,\n    output [7:0] command\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output [7:0] address,\n    output [7:0] command\n);\n\n    // Submodule outputs\n    wire [7:0] address_ext, command_ext;\n    wire [7:0] address_int, command_int;\n\n    // Submodule for external data decoding\n    decode_module ext_decode (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .decoded_address(address_ext),\n        .decoded_command(command_ext),\n        .select_code(2'b00) // Decode from external source\n    );\n\n    // Submodule for internal data decoding\n    decode_module int_decode (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .decoded_address(address_int),\n        .decoded_command(command_int),\n        .select_code(2'b01) // Decode from internal memory\n    );\n\n    // Output assignments based on selected source\n    assign address = (select == 2'b00) ? address_ext : address_int;\n    assign command = (select == 2'b00) ? command_ext : command_int;\n\nendmodule\n\n// Submodule for decoding data\nmodule decode_module (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data,\n    output reg [7:0] decoded_address,\n    output reg [7:0] decoded_command,\n    input [1:0] select_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_address <= 8'd0; // Initialize address\n            decoded_command <= 8'd0; // Initialize command\n        end else begin\n            if (select == select_code) begin\n                decoded_address <= data[15:8]; // Decode address from high byte\n                decoded_command <= data[7:0];  // Decode command from low byte\n            end else begin\n                decoded_address <= decoded_address; // Retain previous values\n                decoded_command <= decoded_command;\n            end\n        end\n    end\n\nendmodule"}], "task_id": 8}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'exec_stage', 'type': 'input port'}, {'id': 3, 'content': 'instr', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'operand', 'type': 'output port'}, {'id': 6, 'content': 'opcode_dec', 'type': 'submodule'}, {'id': 7, 'content': 'operand_ext', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 2, 3, 0, 1, 2, 6, 2, 7, 2], [6, 6, 6, 6, 7, 7, 7, 7, 4, 4, 5, 5]]\n, A control unit module responsible for managing execution stages in a simple processor. This module determines the current stage based on control signals and processes instruction stages via submodules, dividing instruction into opcode and operand parts.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the control unit.\n    exec_stage [1:0]: Control signal indicating the current execution stage (00 for fetch, 01 for decode, 10 for execute).\n    instr [15:0]: 16-bit instruction input containing both operation and data.\n\nOutput ports:\n    opcode [3:0]: 4 bits representing the type of operation.\n    operand [11:0]: 12 bits representing the data or address.\n\nImplementation:\n    The control unit uses two submodules, one for decoding the opcode and the other for extracting the operand.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs opcode and operand are initialized to zero.\n    Based on the exec_stage signal:\n    If exec_stage is 2'b00, the instruction is fetched but not processed.\n    If exec_stage is 2'b01, the instruction is decoded into opcode and operand by corresponding submodules.\n    If exec_stage is 2'b10, the previous stage outputs are retained, preparing for execution.\n    The outputs opcode and operand are driven by the decoded results from submodules during the decode stage.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output [3:0] opcode,\n    output [11:0] operand\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output [3:0] opcode,\n    output [11:0] operand\n);\n\n    // Submodules for instruction processing\n    wire [3:0] opcode_out;\n    wire [11:0] operand_out;\n\n    opcode_decoder opcode_dec (\n        .clk(clk),\n        .rst(rst),\n        .exec_stage(exec_stage),\n        .instr(instr),\n        .opcode_out(opcode_out)\n    );\n\n    operand_extractor operand_ext (\n        .clk(clk),\n        .rst(rst),\n        .exec_stage(exec_stage),\n        .instr(instr),\n        .operand_out(operand_out)\n    );\n\n    // Output assignments\n    assign opcode = (exec_stage == 2'b01) ? opcode_out : 4'b0000;\n    assign operand = (exec_stage == 2'b01) ? operand_out : 12'b000000000000;\n\nendmodule\n\n// Submodule for opcode decoding\nmodule opcode_decoder (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output reg [3:0] opcode_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            opcode_out <= 4'd0; // Reset output\n        end else if (exec_stage == 2'b01) begin\n            opcode_out <= instr[15:12]; // Decode opcode from high bits\n        end\n    end\n\nendmodule\n\n// Submodule for operand extraction\nmodule operand_extractor (\n    input clk,\n    input rst,\n    input [1:0] exec_stage,\n    input [15:0] instr,\n    output reg [11:0] operand_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            operand_out <= 12'd0; // Reset output\n        end else if (exec_stage == 2'b01) begin\n            operand_out <= instr[11:0]; // Extract operand from low bits\n        end\n    end\n\nendmodule"}], "task_id": 9}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'src1', 'type': 'input port'}, {'id': 4, 'content': 'src2', 'type': 'input port'}, {'id': 5, 'content': 'output_data', 'type': 'output port'}, {'id': 6, 'content': 'hold1', 'type': 'submodule'}, {'id': 7, 'content': 'hold2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 0, 1, 4, 6, 7], [6, 6, 6, 7, 7, 7, 5, 5]]\n, A data selector module that selects and outputs data based on the specified control signals. It uses register-based storage to hold the current state of data inputs from two distinct sources and outputs the selected data synchronized with the clock signal.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear the registers.\n    sel [1:0]: Control signal for selecting the data source (0 for none, 1 for source 1, 2 for source 2).\n    src1 [7:0]: 8-bit data input from the first data source.\n    src2 [7:0]: 8-bit data input from the second data source.\n\nOutput ports:\n    output_data [7:0]: Output port to provide the selected data.\n\nImplementation:\n    The data selector is implemented using two submodules, each responsible for holding data from a particular source.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both data outputs are initialized to zero.\n    Based on the sel signal:\n    If sel is 2'b01, the data from the first submodule (data_holder1) is selected.\n    If sel is 2'b10, the data from the second submodule (data_holder2) is selected.\n    If sel is 2'b00, output_data is set to zero.\n    The output output_data is assigned the value from the selected submodule.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] output_data\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] src1,\n    input [7:0] src2,\n    output reg [7:0] output_data\n);\n\n    // Submodule instances for data holding\n    wire [7:0] data_out1, data_out2;\n\n    data_holder hold1 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(src1),\n        .data_out(data_out1)\n    );\n\n    data_holder hold2 (\n        .clk(clk),\n        .rst(rst),\n        .data_in(src2),\n        .data_out(data_out2)\n    );\n\n    // Output selection logic\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            output_data <= 8'd0; // Reset data output\n        end else begin\n            case (sel)\n                2'b01: output_data <= data_out1;\n                2'b10: output_data <= data_out2;\n                default: output_data <= 8'd0;\n            endcase\n        end\n    end\n\nendmodule\n\n// Submodule for data holding\nmodule data_holder (\n    input clk,\n    input rst,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset data output\n        end else begin\n            data_out <= data_in; // Hold incoming data\n        end\n    end\n\nendmodule"}], "task_id": 10}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sensor1', 'type': 'input port'}, {'id': 3, 'content': 'sensor2', 'type': 'input port'}, {'id': 4, 'content': 'control_enable', 'type': 'input port'}, {'id': 5, 'content': 'control_out', 'type': 'output port'}, {'id': 6, 'content': 'status_flags', 'type': 'output port'}, {'id': 7, 'content': 'sensor_proc1', 'type': 'submodule'}, {'id': 8, 'content': 'sensor_proc2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 4, 0, 3, 1, 4, 7, 8, 7, 8, 4], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 6, 6, 6]]\n, A register-based control system designed to manage signals from multiple sensors and adjust control outputs based on combined sensor inputs. It utilizes submodules to process each sensor's data, maintain state using registers, and output control signals after processing.\n\nModule name:\n    multi_sensor_controller\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    sensor1 [7:0]: 8-bit data input from the first sensor.\n    sensor2 [7:0]: 8-bit data input from the second sensor.\n    control_enable [1:0]: Control signal to enable processing for each sensor (1 for active).\n\nOutput ports:\n    control_out [2:0]: Control output signals derived from sensor inputs.\n    status_flags [1:0]: Status flags indicating the operational state.\n\nImplementation:\n    The multi_sensor_controller uses submodules, each processing the input from one sensor.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    When control_enable signals are active, corresponding sensor data is processed in the respective submodules.\n    Control outputs and status flags are updated based on the processed data from both submodules.\nGive me the complete code.\nmodule multi_sensor_controller (\n    input clk,\n    input rst,\n    input [7:0] sensor1,\n    input [7:0] sensor2,\n    input [1:0] control_enable,\n    output [2:0] control_out,\n    output [1:0] status_flags\n);"}, {"from": "gpt", "value": "module multi_sensor_controller (\n    input clk,\n    input rst,\n    input [7:0] sensor1,\n    input [7:0] sensor2,\n    input [1:0] control_enable,\n    output [2:0] control_out,\n    output [1:0] status_flags\n);\n\n    // Submodule for sensor data processing\n    wire [7:0] sensor1_processed, sensor2_processed;\n\n    sensor_processing sensor_proc1 (\n        .clk(clk),\n        .rst(rst),\n        .sensor_data(sensor1),\n        .process_enable(control_enable[0]),\n        .processed_data(sensor1_processed)\n    );\n\n    sensor_processing sensor_proc2 (\n        .clk(clk),\n        .rst(rst),\n        .sensor_data(sensor2),\n        .process_enable(control_enable[1]),\n        .processed_data(sensor2_processed)\n    );\n\n    // Output assignments\n    assign control_out = (sensor1_processed[7:5] & sensor2_processed[7:5]); // Combine and process control signals\n    assign status_flags[0] = control_enable[0] & (sensor1_processed != 8'd0); // Status flag for sensor 1\n    assign status_flags[1] = control_enable[1] & (sensor2_processed != 8'd0); // Status flag for sensor 2\n\nendmodule\n\n// Submodule for processing sensor data\nmodule sensor_processing (\n    input clk,\n    input rst,\n    input [7:0] sensor_data,\n    input process_enable,\n    output reg [7:0] processed_data\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            processed_data <= 8'd0; // Reset output\n        end else if (process_enable) begin\n            processed_data <= sensor_data; // Process and store data if enabled\n        end else begin\n            processed_data <= processed_data; // Retain previous value\n        end\n    end\n\nendmodule"}], "task_id": 11}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'carry_out', 'type': 'output port'}, {'id': 7, 'content': 'alu', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 3, 7, 7], [7, 7, 7, 5, 6]]\n, Design a multi-functional arithmetic logic unit (ALU) capable of performing different arithmetic and bitwise operations based on a control signal. The module should also include multiple data source inputs and register-based storage for intermediate results, using synchronous reset for initializing registers.\n\nModule name:\n    multi_func_alu\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize internal registers.\n    op_code [3:0]: Control signal to select the operation (e.g., add, subtract, and, or).\n    data1 [7:0], data2 [7:0]: Two 8-bit data inputs for arithmetic operations.\n\nOutput ports:\n    result [7:0]: The result of the selected ALU operation.\n    carry_out: Carry output for operations like addition and subtraction.\n\nImplementation:\n    The ALU uses a submodule for performing the arithmetic and bitwise operations.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the result and carry_out are initialized to zero.\n    Based on the op_code:\n    - 4'b0001: Perform addition of data1 and data2.\n    - 4'b0010: Perform subtraction of data1 from data2.\n    - 4'b0100: Perform bitwise AND of data1 and data2.\n    - 4'b1000: Perform bitwise OR of data1 and data2.\n    The results of these operations are stored in a register and outputted through result and carry_out, based on the operation performed.\nGive me the complete code.\nmodule multi_func_alu (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result,\n    output reg carry_out\n);"}, {"from": "gpt", "value": "module multi_func_alu (\n    input clk,\n    input rst,\n    input [3:0] op_code,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] result,\n    output reg carry_out\n);\n\n    // Submodule for ALU operations\n    wire [7:0] alu_result;\n    wire alu_carry;\n\n    alu_core alu (\n        .data1(data1),\n        .data2(data2),\n        .op_code(op_code),\n        .result(alu_result),\n        .carry_out(alu_carry)\n    );\n\n    // Result storage and output assignment\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n            carry_out <= 1'b0;\n        end else begin\n            result <= alu_result;\n            carry_out <= alu_carry;\n        end\n    end\n\nendmodule\n\n// Submodule for ALU core operations\nmodule alu_core (\n    input [7:0] data1,\n    input [7:0] data2,\n    input [3:0] op_code,\n    output reg [7:0] result,\n    output reg carry_out\n);\n\n    always @* begin\n        case(op_code)\n            4'b0001: {carry_out, result} = data1 + data2; // Addition\n            4'b0010: {carry_out, result} = data1 - data2; // Subtraction\n            4'b0100: result = data1 & data2; // Bitwise AND\n            4'b1000: result = data1 | data2; // Bitwise OR\n            default: result = 8'd0;\n        endcase\n    end\n\nendmodule"}], "task_id": 12}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl_bus', 'type': 'input port'}, {'id': 3, 'content': 'decode', 'type': 'output port'}, {'id': 4, 'content': 'exec_cmd', 'type': 'output port'}, {'id': 5, 'content': 'cpu_state', 'type': 'output port'}, {'id': 6, 'content': 'decoder', 'type': 'submodule'}, {'id': 7, 'content': 'executor', 'type': 'submodule'}, {'id': 8, 'content': 'state_manage', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 6, 0, 1, 7, 0, 1, 6, 7, 8], [6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 4, 5]]\n, Design a control unit for a CPU that manages instruction decoding and execution flow based on incoming command signals. This module should capture commands from a control bus, decode them into executable signals for different operational units, and manage the CPU state with register-based tracking.\n\nModule name:\n    cpu_control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    ctrl_bus [15:0]: 16-bit control bus input carrying command signals.\n\nOutput ports:\n    decode [3:0]: Signals representing decoded instruction types.\n    exec_cmd [7:0]: Execution commands for the CPU's operational units.\n    cpu_state [2:0]: Indicates the current state of the CPU.\n\nImplementation:\n    The CPU control unit uses multiple submodules for decoding and executing commands.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Commands from the ctrl_bus are first passed to a decoding submodule that translates them into discrete signals (decode).\n    Based on the decoded signals, another submodule generates specific execution commands (exec_cmd).\n    A third submodule tracks and updates the CPU state (cpu_state) based on command execution progress.\nGive me the complete code.\nmodule cpu_control_unit (\n    input clk,\n    input rst,\n    input [15:0] ctrl_bus,\n    output [3:0] decode,\n    output [7:0] exec_cmd,\n    output [2:0] cpu_state\n);"}, {"from": "gpt", "value": "module cpu_control_unit (\n    input clk,\n    input rst,\n    input [15:0] ctrl_bus,\n    output [3:0] decode,\n    output [7:0] exec_cmd,\n    output [2:0] cpu_state\n);\n\n    // Submodule for command decoding\n    wire [3:0] decoded_signals;\n    command_decoder decoder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl_bus(ctrl_bus),\n        .decoded_out(decoded_signals)\n    );\n\n    // Submodule for command execution\n    wire [7:0] execution_commands;\n    command_executor executor (\n        .clk(clk),\n        .rst(rst),\n        .decoded_signals(decoded_signals),\n        .exec_cmd_out(execution_commands)\n    );\n\n    // Submodule for CPU state management\n    wire [2:0] state_output;\n    state_tracker state_manage (\n        .clk(clk),\n        .rst(rst),\n        .executing_cmd(execution_commands),\n        .state_out(state_output)\n    );\n\n    // Output assignments\n    assign decode = decoded_signals;\n    assign exec_cmd = execution_commands;\n    assign cpu_state = state_output;\n\nendmodule\n\n// Submodule for command decoding\nmodule command_decoder (\n    input clk,\n    input rst,\n    input [15:0] ctrl_bus,\n    output reg [3:0] decoded_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decoded_out <= 4'd0; // Reset output\n        end else begin\n            // Decoding logic based on control bus\n            decoded_out <= ctrl_bus[15:12]; // Simple example of decoding\n        end\n    end\n\nendmodule\n\n// Submodule for executing commands\nmodule command_executor (\n    input clk,\n    input rst,\n    input [3:0] decoded_signals,\n    output reg [7:0] exec_cmd_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            exec_cmd_out <= 8'd0; // Reset output\n        end else begin\n            // Execution command logic based on decoded signals\n            exec_cmd_out <= {decoded_signals, 4'd0}; // Example: augment with zeroes\n        end\n    end\n\nendmodule\n\n// Submodule for state tracking\nmodule state_tracker (\n    input clk,\n    input rst,\n    input [7:0] executing_cmd,\n    output reg [2:0] state_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            state_out <= 3'd0; // Reset state\n        end else begin\n            // State update logic\n            state_out <= (executing_cmd[7:5] != 3'd0) ? 3'd1 : 3'd2; // Simplified state logic\n        end\n    end\n\nendmodule"}], "task_id": 13}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'src_sel', 'type': 'input port'}, {'id': 4, 'content': 'data_a', 'type': 'input port'}, {'id': 5, 'content': 'data_b', 'type': 'input port'}, {'id': 6, 'content': 'result_add', 'type': 'output port'}, {'id': 7, 'content': 'result_sub', 'type': 'output port'}, {'id': 8, 'content': 'df_a', 'type': 'submodule'}, {'id': 9, 'content': 'df_b', 'type': 'submodule'}, {'id': 10, 'content': 'add_module', 'type': 'submodule'}, {'id': 11, 'content': 'sub_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 3, 5, 1, 0, 3, 9, 1, 8, 2, 0, 9, 1, 8, 2, 0, 10, 11], [8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 6, 7]]\n, Design a data processor module that accepts binary data for arithmetic operations and decodes it based on operation code. The module should support addition and subtraction, handle data inputs from different sources, and provide output separately for each operation.\n\nModule name:\n    data_processor\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the processor.\n    op_code [1:0]: Control signal indicating the type of arithmetic operation (00 for addition, 01 for subtraction).\n    src_sel [1:0]: Control signal to select the source of data inputs (1 for internal register, 2 for external input).\n    data_a [7:0]: 8-bit data input A.\n    data_b [7:0]: 8-bit data input B.\n\nOutput ports:\n    result_add [7:0]: 8-bit result of the addition operation.\n    result_sub [7:0]: 8-bit result of the subtraction operation.\n\nImplementation:\n    The data processor is implemented using submodules for each arithmetic operation.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the op_code signal:\n    If op_code is 2'b00, the addition operation is triggered.\n    If op_code is 2'b01, the subtraction operation is performed.\n    Based on the src_sel signal, data inputs are fetched from either an internal register or an external source before processing.\n    The results from each operation are stored in separate outputs.\nGive me the complete code.\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [1:0] src_sel,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [7:0] result_add,\n    output [7:0] result_sub\n);"}, {"from": "gpt", "value": "module data_processor (\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [1:0] src_sel,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [7:0] result_add,\n    output [7:0] result_sub\n);\n\n    // Submodule for adder and subtractor\n    wire [7:0] data_a_int, data_b_int;\n\n    data_fetch df_a (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data_in(data_a),\n        .data_out(data_a_int)\n    );\n\n    data_fetch df_b (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data_in(data_b),\n        .data_out(data_b_int)\n    );\n\n    adder add_module (\n        .clk(clk),\n        .rst(rst),\n        .enable(op_code == 2'b00),\n        .data_a(data_a_int),\n        .data_b(data_b_int),\n        .result(result_add)\n    );\n\n    subtractor sub_module (\n        .clk(clk),\n        .rst(rst),\n        .enable(op_code == 2'b01),\n        .data_a(data_a_int),\n        .data_b(data_b_int),\n        .result(result_sub)\n    );\n\nendmodule\n\n// Submodule for data fetching\nmodule data_fetch (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset data\n        end else begin\n            data_out <= data_in; // Direct data assignment\n        end\n    end\n\nendmodule\n\n// Submodule for addition\nmodule adder (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n        end else if (enable) begin\n            result <= data_a + data_b;\n        end\n    end\n\nendmodule\n\n// Submodule for subtraction\nmodule subtractor (\n    input clk,\n    input rst,\n    input enable,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [7:0] result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            result <= 8'd0;\n        end else if (enable) begin\n            result <= data_a - data_b;\n        end\n    end\n\nendmodule"}], "task_id": 14}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'src_sel', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'data_A', 'type': 'output port'}, {'id': 5, 'content': 'data_B', 'type': 'output port'}, {'id': 6, 'content': 'data_C', 'type': 'output port'}, {'id': 7, 'content': 'sensor_A', 'type': 'submodule'}, {'id': 8, 'content': 'sensor_B', 'type': 'submodule'}, {'id': 9, 'content': 'sensor_C', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 0, 2, 3, 1, 0, 2, 3, 1, 0, 2, 7, 8, 9], [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 5, 6]]\n, A multi-source data capture unit for capturing and processing input data from multiple peripherals. This module should be able to distinguish between different data sources, capturing and storing data separately before processing. The processed outputs are then split into various bit-width fields for different uses.\n\nModule name:\n    data_capture_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the system.\n    src_sel [1:0]: Control signal indicating the source of data (0 for Sensor A, 1 for Sensor B, 2 for Sensor C).\n    data_in [15:0]: 16-bit data input from the selected peripheral.\n\nOutput ports:\n    data_A [3:0]: Processed data from Sensor A, 4 bits.\n    data_B [7:0]: Processed data from Sensor B, 8 bits.\n    data_C [15:0]: Raw data from Sensor C, 16 bits.\n\nImplementation:\n    The data capture unit uses three submodules to store and process data from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all data outputs are initialized to zero.\n    Depending on the src_sel signal:\n    If src_sel is 2'b00, data from data_in is captured by the first submodule (sensor_A_proc).\n    If src_sel is 2'b01, data from data_in is captured by the second submodule (sensor_B_proc).\n    If src_sel is 2'b10, data from data_in is captured by the third submodule (sensor_C_proc).\n    The outputs data_A, data_B, and data_C are derived from the processed or stored data in the respective submodules.\nGive me the complete code.\nmodule data_capture_unit (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [15:0] data_in,\n    output [3:0] data_A,\n    output [7:0] data_B,\n    output [15:0] data_C\n);"}, {"from": "gpt", "value": "module data_capture_unit (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [15:0] data_in,\n    output [3:0] data_A,\n    output [7:0] data_B,\n    output [15:0] data_C\n);\n\n    // Submodules for data processing\n    wire [15:0] sensor_A_out, sensor_B_out, sensor_C_out;\n\n    data_processor sensor_A (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data(data_in),\n        .data_out(sensor_A_out),\n        .sel_code(2'b00) // Data from Sensor A\n    );\n\n    data_processor sensor_B (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data(data_in),\n        .data_out(sensor_B_out),\n        .sel_code(2'b01) // Data from Sensor B\n    );\n\n    data_processor sensor_C (\n        .clk(clk),\n        .rst(rst),\n        .src_sel(src_sel),\n        .data(data_in),\n        .data_out(sensor_C_out),\n        .sel_code(2'b10) // Data from Sensor C\n    );\n\n    // Output assignments\n    assign data_A = sensor_A_out[3:0]; // Processed 4 bits from Sensor A\n    assign data_B = sensor_B_out[7:0]; // Processed 8 bits from Sensor B\n    assign data_C = sensor_C_out;      // Raw 16 bits from Sensor C\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] src_sel,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [1:0] sel_code // Code to distinguish data sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (src_sel == sel_code) begin\n                data_out <= data; // Capture data if source code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 15}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'data1', 'type': 'input port'}, {'id': 4, 'content': 'data2', 'type': 'input port'}, {'id': 5, 'content': 'out_data', 'type': 'output port'}, {'id': 6, 'content': 'select_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 4, 3, 6], [6, 6, 6, 5]]\n, A multiplexer for selecting data from multiple input sources to a central processing unit, controlled by a programmable select signal, and storing the output in a register for subsequent operations.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    sel [1:0]: Control signal to select data source.\n    data1 [7:0]: 8-bit data input from the first source.\n    data2 [7:0]: 8-bit data input from the second source.\n\nOutput ports:\n    out_data [7:0]: Selected data output stored in the register.\n\nImplementation:\n    The data selection is handled by a submodule that determines which data source to use based on the sel signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the output register (out_data) is initialized to zero.\n    The output out_data is updated with data from the selected source whenever there's a change in the selection or the input data.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] out_data\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] out_data\n);\n\n    // Submodule for selecting data\n    wire [7:0] selected_data;\n\n    data_mux select_unit (\n        .sel(sel),\n        .data1(data1),\n        .data2(data2),\n        .selected_output(selected_data)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out_data <= 8'd0; // Reset output\n        end else begin\n            out_data <= selected_data; // Update register with selected data\n        end\n    end\n\nendmodule\n\n// Submodule for data multiplexing\nmodule data_mux (\n    input [1:0] sel,\n    input [7:0] data1,\n    input [7:0] data2,\n    output reg [7:0] selected_output\n);\n\n    always @(*) begin\n        case (sel)\n            2'b01: selected_output = data1;\n            2'b10: selected_output = data2;\n            default: selected_output = 8'd0; // Default to zero if no valid selection\n        endcase\n    end\n\nendmodule"}], "task_id": 16}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'inst_data', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'operand1', 'type': 'output port'}, {'id': 6, 'content': 'operand2', 'type': 'output port'}, {'id': 7, 'content': 'dec1', 'type': 'submodule'}, {'id': 8, 'content': 'dec2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 1, 3, 2, 0, 1, 3, 8, 7, 2, 7, 8, 2, 8, 7, 2], [7, 7, 7, 7, 8, 8, 8, 8, 4, 4, 4, 5, 5, 5, 6, 6, 6]]\n, A multi-source instruction decoder for decoding operation codes (opcodes) from a central instruction registry that stores and parses inputs from various sources such as immediate values, memory, or peripherals. This module should include handling and storage of instructions with parameterized control over decoding behavior.\n\nModule name:\n    opcode_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the decoder.\n    fetch [1:0]: Control signal indicating the source of the instruction to be decoded.\n    inst_data [15:0]: 16-bit data input representing the complete instruction.\n\nOutput ports:\n    opcode [3:0]: Extracted 4-bit opcode indicating the type of operation.\n    operand1 [5:0]: Extracted 6-bit field, usually an address or an immediate value.\n    operand2 [5:0]: Extracted secondary 6-bit field, may represent an additional operand.\n\nImplementation:\n    The opcode_decoder utilizes submodules for handling the decoding from different instruction sources, synchronizing on the rising edge of the clock (clk).\n    If the reset (rst) signal is low, all outputs are initialized to zero.\n    The submodule responsible for decoding is selected based on the fetch signal:\n    If fetch is 2'b01, the instruction is decoded from immediate value source.\n    If fetch is 2'b10, the instruction is decoded from a memory source.\n    The outputs opcode, operand1, and operand2 are derived from the instruction data based on the active decoding path.\nGive me the complete code.\nmodule opcode_decoder (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] inst_data,\n    output [3:0] opcode,\n    output [5:0] operand1,\n    output [5:0] operand2\n);"}, {"from": "gpt", "value": "module opcode_decoder (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] inst_data,\n    output [3:0] opcode,\n    output [5:0] operand1,\n    output [5:0] operand2\n);\n\n    // Submodule for opcode decoding\n    wire [15:0] decode_out_immediate, decode_out_memory;\n\n    instruction_decode dec1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .inst_data(inst_data),\n        .decode_out(decode_out_immediate),\n        .fetch_code(2'b01) // Decode from immediate value\n    );\n\n    instruction_decode dec2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .inst_data(inst_data),\n        .decode_out(decode_out_memory),\n        .fetch_code(2'b10) // Decode from memory\n    );\n\n    // Output assignments based on active decode path\n    assign opcode = (fetch == 2'b01) ? decode_out_immediate[15:12] : decode_out_memory[15:12];\n    assign operand1 = (fetch == 2'b01) ? decode_out_immediate[11:6] : decode_out_memory[11:6];\n    assign operand2 = (fetch == 2'b01) ? decode_out_immediate[5:0] : decode_out_memory[5:0];\n\nendmodule\n\n// Submodule for instruction decoding\nmodule instruction_decode (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [15:0] inst_data,\n    output reg [15:0] decode_out,\n    input [1:0] fetch_code // Code to distinguish fetch sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            decode_out <= 16'd0; // Reset output\n        end else begin\n            if (fetch == fetch_code) begin\n                decode_out <= inst_data; // Use data if fetch code matches\n            end else begin\n                decode_out <= decode_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 17}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'reg1_data', 'type': 'output port'}, {'id': 5, 'content': 'reg2_data', 'type': 'output port'}, {'id': 6, 'content': 'reg3_data', 'type': 'output port'}, {'id': 7, 'content': 'reg1', 'type': 'submodule'}, {'id': 8, 'content': 'reg2', 'type': 'submodule'}, {'id': 9, 'content': 'reg3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 3, 2, 0, 1, 7, 8, 9], [7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 4, 5, 6]]\n, Design a data router module that directs input data to specified registers based on control signals. The module must accommodate data inputs from multiple sources and distribute them into distinct registers, with field separation for targeted processing.\n\nModule name:\n    data_router\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the router.\n    select [2:0]: Control signal determining the destination register (0 for reg1, 1 for reg2, etc.).\n    data_in [15:0]: 16-bit data input from external sources.\n\nOutput ports:\n    reg1_data [7:0]: Data directed to the first register.\n    reg2_data [7:0]: Data directed to the second register.\n    reg3_data [7:0]: Data directed to the third register.\n\nImplementation:\n    The data router uses three submodules, each handling data storage for a different register.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all data outputs are initialized to zero.\n    Based on the select signal:\n    If select is 3'b000, data_in's lower 8 bits are routed to the first submodule (reg1).\n    If select is 3'b001, data_in's upper 8 bits are routed to the second submodule (reg2).\n    If select is 3'b010, the entire 16 bits are stored into the third submodule (reg3).\n    Outputs reg1_data, reg2_data, and reg3_data retrieve their values from the data stored in the respective submodules.\nGive me the complete code.\nmodule data_router (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] reg1_data,\n    output [7:0] reg2_data,\n    output [7:0] reg3_data\n);"}, {"from": "gpt", "value": "module data_router (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data_in,\n    output [7:0] reg1_data,\n    output [7:0] reg2_data,\n    output [7:0] reg3_data\n);\n\n    // Submodules for register data storage\n    wire [7:0] reg1_out, reg2_out;\n    wire [15:0] reg3_out;\n\n    register_storage reg1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in[7:0]),\n        .data_out(reg1_out),\n        .select_code(3'b000) // Data for first register\n    );\n\n    register_storage reg2 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in[15:8]),\n        .data_out(reg2_out),\n        .select_code(3'b001) // Data for second register\n    );\n\n    register_storage reg3 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data(data_in),\n        .data_out(reg3_out),\n        .select_code(3'b010) // Data for third register\n    );\n\n    // Output assignments\n    assign reg1_data = reg1_out; // 8-bit data for first register\n    assign reg2_data = reg2_out; // 8-bit data for second register\n    assign reg3_data = reg3_out[7:0]; // Lower 8-bits of 16-bit data for third register\n\nendmodule\n\n// Submodule for register data storage\nmodule register_storage (\n    input clk,\n    input rst,\n    input [2:0] select,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [2:0] select_code // Code to distinguish select targets\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (select == select_code) begin\n                data_out <= data; // Capture data if select code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 18}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'read_write', 'type': 'input port'}, {'id': 3, 'content': 'src_select', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'op_complete', 'type': 'output port'}, {'id': 7, 'content': 'dp', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 3, 7, 4], [7, 7, 5, 5]]\n, Design a memory control module that manages read and write operations to memory. It utilizes control signals to select the source of data and the type of operation. This module includes a submodule for data processing that outputs the modified data based on operation type.\n\nModule name:\n    mem_ctrl\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the controller.\n    read_write: Control signal indicating operation type (0 for read, 1 for write).\n    src_select [1:0]: Control signal to choose the data source (00 from CPU, 01 from IO device).\n    data_in [15:0]: 16-bit input data to be written or read.\n\nOutput ports:\n    data_out [15:0]: 16-bit output data after read or process operation.\n    op_complete: Signal to indicate completion of the read/write operation.\n\nImplementation:\n    The memory control module includes a submodule for processing the data based on the type of operation.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the output data_out and the operation complete signal are initialized to zero.\n    Based on the read_write and src_select signals:\n    If read_write is 0, data is read from data_in directly to data_out.\n    If read_write is 1, the data is processed based on the source selected by src_select and the processed data is placed in data_out.\n    The operation complete signal is asserted once the data is ready in data_out.\nGive me the complete code.\nmodule mem_ctrl (\n    input clk,\n    input rst,\n    input read_write,\n    input [1:0] src_select,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output reg op_complete\n);"}, {"from": "gpt", "value": "module mem_ctrl (\n    input clk,\n    input rst,\n    input read_write,\n    input [1:0] src_select,\n    input [15:0] data_in,\n    output reg [15:0] data_out,\n    output reg op_complete\n);\n\n    // Submodule for data processing\n    wire [15:0] processed_data;\n\n    data_processor dp (\n        .data_in(data_in),\n        .src_select(src_select),\n        .processed_data(processed_data)\n    );\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0;\n            op_complete <= 1'b0;\n        end else begin\n            if (read_write == 1'b0) begin\n                data_out <= data_in; // Direct read operation\n                op_complete <= 1'b1;\n            end else if (read_write == 1'b1) begin\n                data_out <= processed_data; // Write processed data\n                op_complete <= 1'b1;\n            end else begin\n                op_complete <= 1'b0; // No operation\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input [15:0] data_in,\n    input [1:0] src_select,\n    output reg [15:0] processed_data\n);\n\n    always @(*) begin\n        case(src_select)\n            2'b00: processed_data = data_in + 1; // Simulate a simple processing for CPU data\n            2'b01: processed_data = data_in - 1; // Simulate a simple processing for IO device data\n            default: processed_data = data_in; // Default no processing\n        endcase\n    end\n\nendmodule"}], "task_id": 19}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'cmd', 'type': 'input port'}, {'id': 3, 'content': 'serial_data', 'type': 'input port'}, {'id': 4, 'content': 'operation', 'type': 'output port'}, {'id': 5, 'content': 'address', 'type': 'output port'}, {'id': 6, 'content': 'payload', 'type': 'output port'}, {'id': 7, 'content': 'ds', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 2, 7, 7], [7, 7, 7, 7, 4, 5, 6]]\n, Design a data decoder module that extracts and distributes control and data segments from a serial input stream. The module should decode signals based on the operational command received and store the data in register-based storage elements using synchronous reset. Each segment should be sent to its appropriate output after processing.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize outputs.\n    cmd [2:0]: Control signal dictating the operation mode.\n    serial_data [15:0]: 16-bit serial input data.\n\nOutput ports:\n    operation [2:0]: Operation mode extracted from the command.\n    address [7:0]: Address segment extracted from the data based on command.\n    payload [7:0]: Payload segment derived from the data according to the command.\n\nImplementation:\n    The data decoder module includes submodules responsible for splitting and storing the serial_data based on the cmd input.\n    On the rising edge of the clk, if the rst is active, all outputs are initialized to zero.\n    The submodule interprets the cmd and selectively stores parts of serial_data into two distinct outputs, address and payload.\n    Operation output directly reflects the cmd input to indicate the current mode of operation.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [2:0] cmd,\n    input [15:0] serial_data,\n    output [2:0] operation,\n    output [7:0] address,\n    output [7:0] payload\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [2:0] cmd,\n    input [15:0] serial_data,\n    output [2:0] operation,\n    output [7:0] address,\n    output [7:0] payload\n);\n\n    // Submodule for data separation\n    wire [7:0] addr_out, payload_out;\n\n    data_splitter ds (\n        .clk(clk),\n        .rst(rst),\n        .cmd(cmd),\n        .serial_data(serial_data),\n        .address_out(addr_out),\n        .payload_out(payload_out)\n    );\n\n    // Output assignments\n    assign operation = cmd;            // Direct assignment of command to operation\n    assign address = addr_out;         // Address extracted from serial_data\n    assign payload = payload_out;      // Payload extracted from serial_data\n\nendmodule\n\n// Submodule for splitting data\nmodule data_splitter (\n    input clk,\n    input rst,\n    input [2:0] cmd,\n    input [15:0] serial_data,\n    output reg [7:0] address_out,\n    output reg [7:0] payload_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            address_out <= 8'd0; // Reset address output\n            payload_out <= 8'd0; // Reset payload output\n        end else begin\n            case (cmd)\n                3'b001: begin\n                    address_out <= serial_data[15:8]; // High byte as address\n                    payload_out <= serial_data[7:0];  // Low byte as payload\n                end\n                3'b010: begin\n                    address_out <= serial_data[7:0];   // Low byte as address\n                    payload_out <= serial_data[15:8]; // High byte as payload\n                end\n                default: begin\n                    address_out <= 8'hFF; // Default or undefined command\n                    payload_out <= 8'hFF;\n                end\n            endcase\n        end\n    end\n\nendmodule"}], "task_id": 20}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'source1', 'type': 'input port'}, {'id': 4, 'content': 'source2', 'type': 'input port'}, {'id': 5, 'content': 'out1', 'type': 'output port'}, {'id': 6, 'content': 'out2', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[3, 4], [5, 6]]\n, A data selector module that selects and outputs data based on multiple control signals. It receives data from two sources and can selectively output either, both combined, or none based on control signals, ensuring data handling is synchronized with a system clock and reset conditions.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    select [1:0]: Control signal to determine the data output source (00 for none, 01 for source 1, 10 for source 2, 11 for both).\n    source1 [7:0]: 8-bit data input from the first data source.\n    source2 [7:0]: 8-bit data input from the second data source.\n\nOutput ports:\n    out1 [7:0]: Selected data output corresponding to source1.\n    out2 [7:0]: Selected data output corresponding to source2.\n\nImplementation:\n    The data selector module utilizes internal logic to determine which source to output based on the select signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    The select signal drives the output decision:\n    If select is 2'b01, the output from source1 is presented on out1, and out2 is zeroed.\n    If select is 2'b10, the output from source2 is presented on out2, and out1 is zeroed.\n    If select is 2'b11, both outputs out1 and out2 are filled with source1 and source2 data respectively.\n    If none of these conditions are met (select is 2'b00), both outputs are zeroed.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [7:0] source1,\n    input [7:0] source2,\n    output reg [7:0] out1,\n    output reg [7:0] out2\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [7:0] source1,\n    input [7:0] source2,\n    output reg [7:0] out1,\n    output reg [7:0] out2\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out1 <= 8'd0; // Initialize out1\n            out2 <= 8'd0; // Initialize out2\n        end else begin\n            case(select)\n                2'b01: begin\n                    out1 <= source1; // Output source1\n                    out2 <= 8'd0;\n                end\n                2'b10: begin\n                    out1 <= 8'd0;\n                    out2 <= source2; // Output source2\n                end\n                2'b11: begin\n                    out1 <= source1; // Output both\n                    out2 <= source2;\n                end\n                default: begin\n                    out1 <= 8'd0; // No output\n                    out2 <= 8'd0;\n                end\n            endcase\n        end\n    end\n\nendmodule"}], "task_id": 21}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'wr_en', 'type': 'input port'}, {'id': 3, 'content': 'rd_sel', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'reg0', 'type': 'submodule'}, {'id': 7, 'content': 'reg1', 'type': 'submodule'}, {'id': 8, 'content': 'reg2', 'type': 'submodule'}, {'id': 9, 'content': 'reg3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 2, 4, 0, 1, 2, 4, 0, 1, 2, 4, 0, 1, 2, 6, 7, 8, 9, 3], [6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 9, 9, 9, 9, 5, 5, 5, 5, 5]]\n, A register file module that manages read and write operations to an array of registers. It incorporates control logic to handle multiple data sources and outputs selected register data based on input control signals. \n\nModule name:\n    reg_file\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to clear all registers.\n    wr_en [3:0]: 4-bit write-enable signal, each bit corresponding to a register.\n    rd_sel [1:0]: 2-bit control signal to select which register's data to output.\n    data_in [15:0]: 16-bit data input to be written into the registers.\n\nOutput ports:\n    data_out [15:0]: 16-bit output data from the selected register.\n\nImplementation:\n    The register file module uses four submodules, each being a 16-bit register.\n    On the rising edge of the clock, if the reset signal is low, all registers are cleared.\n    If the write-enable (wr_en) for a particular register is high, the data is written to that register.\n    The output (data_out) is determined by the read select signal (rd_sel), which chooses from the four registers based on the value provided.\n    Registers retain their value if no write operation is specified for them during a clock cycle.\nGive me the complete code.\nmodule reg_file (\n    input clk,\n    input rst,\n    input [3:0] wr_en,\n    input [1:0] rd_sel,\n    input [15:0] data_in,\n    output [15:0] data_out\n);"}, {"from": "gpt", "value": "module reg_file (\n    input clk,\n    input rst,\n    input [3:0] wr_en,\n    input [1:0] rd_sel,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\n    // Submodules for each register\n    wire [15:0] reg_0_out, reg_1_out, reg_2_out, reg_3_out;\n\n    register_16bit reg0 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[0]),\n        .data_in(data_in),\n        .data_out(reg_0_out)\n    );\n\n    register_16bit reg1 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[1]),\n        .data_in(data_in),\n        .data_out(reg_1_out)\n    );\n\n    register_16bit reg2 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[2]),\n        .data_in(data_in),\n        .data_out(reg_2_out)\n    );\n\n    register_16bit reg3 (\n        .clk(clk),\n        .rst(rst),\n        .write_en(wr_en[3]),\n        .data_in(data_in),\n        .data_out(reg_3_out)\n    );\n\n    // Output assignment using multiplexer logic\n    assign data_out = (rd_sel == 2'b00) ? reg_0_out :\n                      (rd_sel == 2'b01) ? reg_1_out :\n                      (rd_sel == 2'b10) ? reg_2_out :\n                                           reg_3_out;\n\nendmodule\n\n// Submodule for 16-bit registers\nmodule register_16bit (\n    input clk,\n    input rst,\n    input write_en,\n    input [15:0] data_in,\n    output reg [15:0] data_out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Clear the register\n        end else if (write_en) begin\n            data_out <= data_in; // Write data if enabled\n        end\n    end\n\nendmodule"}], "task_id": 22}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'control_bits', 'type': 'output port'}, {'id': 6, 'content': 'payload', 'type': 'output port'}, {'id': 7, 'content': 'data_proc_A', 'type': 'submodule'}, {'id': 8, 'content': 'data_proc_B', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 3, 1, 2, 0, 1, 4, 2, 8, 7, 2, 8, 7], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data selector module that manages data streams from multiple peripherals based on the input control signals and splits the output based on data type, utilizing parameterized submodules.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    sel [1:0]: Control signal to select the data source (1 for Peripheral A, 2 for Peripheral B).\n    data_a [15:0]: 16-bit data input from Peripheral A.\n    data_b [15:0]: 16-bit data input from Peripheral B.\n\nOutput ports:\n    control_bits [3:0]: Control bits extracted from the selected data stream.\n    payload [11:0]: Main data payload extracted from the selected data stream.\n\nImplementation:\n    The data selector is implemented using two parameterized submodules, each storing and processing data from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, the outputs control_bits and payload are initialized to zero.\n    Depending on the sel signal:\n    If sel is 2'b01, data is fetched from data_a input into the first submodule (data_proc_A).\n    If sel is 2'b10, data is fetched from data_b input into the second submodule (data_proc_B).\n    If neither condition is met, the previous values of control_bits and payload are retained.\n    The outputs control_bits and payload are derived from the stored data in the respective submodules, with control_bits representing the highest 4 bits and payload representing the next 12 bits.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [3:0] control_bits,\n    output [11:0] payload\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    output [3:0] control_bits,\n    output [11:0] payload\n);\n\n    // Submodule for data processing\n    wire [15:0] data_proc_A_out, data_proc_B_out;\n\n    data_processor data_proc_A (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_a),\n        .data_out(data_proc_A_out),\n        .sel_code(2'b01) // Select Peripheral A\n    );\n\n    data_processor data_proc_B (\n        .clk(clk),\n        .rst(rst),\n        .sel(sel),\n        .data(data_b),\n        .data_out(data_proc_B_out),\n        .sel_code(2'b10) // Select Peripheral B\n    );\n\n    // Output assignments\n    assign control_bits = (sel == 2'b01) ? data_proc_A_out[15:12] : (sel == 2'b10) ? data_proc_B_out[15:12] : 4'd0;\n    assign payload = (sel == 2'b01) ? data_proc_A_out[11:0] : (sel == 2'b10) ? data_proc_B_out[11:0] : 12'd0;\n\nendmodule\n\n// Submodule for data processing\nmodule data_processor (\n    input clk,\n    input rst,\n    input [1:0] sel,\n    input [15:0] data,\n    output reg [15:0] data_out,\n    input [1:0] sel_code // Code to distinguish data source selection\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 16'd0; // Reset output\n        end else begin\n            if (sel == sel_code) begin\n                data_out <= data; // Capture data if selection code matches\n            end else begin\n                data_out <= data_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 23}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'basic_out', 'type': 'output port'}, {'id': 5, 'content': 'adv_out', 'type': 'output port'}, {'id': 6, 'content': 'selected_out', 'type': 'output port'}, {'id': 7, 'content': 'basic_proc', 'type': 'submodule'}, {'id': 8, 'content': 'adv_proc', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 3, 0, 1, 7, 8, 7, 8, 2], [7, 7, 7, 8, 8, 8, 4, 5, 6, 6, 6]]\n, A data dispatcher module designed to route data inputs to different processing units based on signal flags, and to output specific bits of the processed data. It captures inputs from multiple sources, processes the data via submodules, and selectively outputs processed fields based on control signals.\n\nModule name:\n    data_dispatcher\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the dispatcher.\n    ctrl [1:0]: Control signal indicating the processing path (0 for basic processing, 1 for advanced processing).\n    data_in [15:0]: 16-bit data input to be processed and routed.\n\nOutput ports:\n    basic_out [7:0]: Output from the basic processing submodule.\n    adv_out [15:0]: Output from the advanced processing submodule.\n    selected_out [7:0]: Output selected based on the ctrl signal.\n\nImplementation:\n    The data dispatcher uses two submodules: one for basic processing and another for advanced processing.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both outputs are initialized to zero.\n    Based on the ctrl signal:\n    If ctrl is 2'b00, data is routed to the basic processing submodule (basic_proc).\n    If ctrl is 2'b01, data is routed to the advanced processing submodule (adv_proc).\n    The selected_out output depends on the ctrl signal, either the lower byte from adv_proc or the full output from basic_proc is selected.\nGive me the complete code.\nmodule data_dispatcher (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [7:0] basic_out,\n    output [15:0] adv_out,\n    output [7:0] selected_out\n);"}, {"from": "gpt", "value": "module data_dispatcher (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [7:0] basic_out,\n    output [15:0] adv_out,\n    output [7:0] selected_out\n);\n\n    // Submodules for data processing\n    wire [7:0] basic_proc_out;\n    wire [15:0] adv_proc_out;\n\n    basic_processing basic_proc (\n        .clk(clk),\n        .rst(rst),\n        .data(data_in[7:0]),\n        .out(basic_proc_out)\n    );\n\n    advanced_processing adv_proc (\n        .clk(clk),\n        .rst(rst),\n        .data(data_in),\n        .out(adv_proc_out)\n    );\n\n    // Output assignment\n    assign basic_out = basic_proc_out;\n    assign adv_out = adv_proc_out;\n    assign selected_out = (ctrl == 2'b00) ? basic_proc_out : adv_proc_out[7:0];\n\nendmodule\n\n// Submodule for basic processing\nmodule basic_processing (\n    input clk,\n    input rst,\n    input [7:0] data,\n    output reg [7:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 8'd0; // Reset output\n        end else begin\n            out <= data; // Simple processing, direct pass-through\n        end\n    end\n\nendmodule\n\n// Submodule for advanced processing\nmodule advanced_processing (\n    input clk,\n    input rst,\n    input [15:0] data,\n    output reg [15:0] out\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out <= 16'd0; // Reset output\n        end else begin\n            out <= data + 16'd1; // Example processing, increment each bit\n        end\n    end\n\nendmodule"}], "task_id": 24}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'write_en', 'type': 'input port'}, {'id': 4, 'content': 'data_in', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}], \nedge_attrs: [], \nconnectivity: [[4], [5]]\n, A register file module that stores and outputs specific register values based on multiple control signals. It captures input data and decodes it into separate registers, which can then be read based on control logic. The module efficiently manages multiple data inputs and allows selective data reading.\n\nModule name:\n    reg_file\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize all registers.\n    sel [2:0]: Control signal to select which register to read (000 to 111 for eight registers).\n    write_en [7:0]: 8-bit signal where each bit enables writing to the corresponding register (bitwise).\n    data_in [7:0]: 8-bit data input for register storage.\n\nOutput ports:\n    data_out [7:0]: 8-bit output reflecting the data from the selected register.\n\nImplementation:\n    The register file contains eight registers, each capable of holding an 8-bit value. The registers are updated or maintained based on the write enable signal.\n    On the rising edge of the clock (clk), if the reset (rst) is asserted, all registers are initialized to zero.\n    Each register can independently capture data from the input based on its corresponding bit in the write_en signal.\n    The output, data_out, is determined by the sel signal, which selects one of the eight registers to read from.\nGive me the complete code.\nmodule reg_file (\n    input clk,\n    input rst,\n    input [2:0] sel,\n    input [7:0] write_en,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);"}, {"from": "gpt", "value": "module reg_file (\n    input clk,\n    input rst,\n    input [2:0] sel,\n    input [7:0] write_en,\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n\n    // Internal register array\n    reg [7:0] registers[7:0];\n\n    // Register write operations\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            registers[0] <= 8'd0;\n            registers[1] <= 8'd0;\n            registers[2] <= 8'd0;\n            registers[3] <= 8'd0;\n            registers[4] <= 8'd0;\n            registers[5] <= 8'd0;\n            registers[6] <= 8'd0;\n            registers[7] <= 8'd0;\n        end else begin\n            if (write_en[0]) registers[0] <= data_in;\n            if (write_en[1]) registers[1] <= data_in;\n            if (write_en[2]) registers[2] <= data_in;\n            if (write_en[3]) registers[3] <= data_in;\n            if (write_en[4]) registers[4] <= data_in;\n            if (write_en[5]) registers[5] <= data_in;\n            if (write_en[6]) registers[6] <= data_in;\n            if (write_en[7]) registers[7] <= data_in;\n        end\n    end\n\n    // Register read operations\n    always @(*) begin\n        case (sel)\n            3'd0: data_out = registers[0];\n            3'd1: data_out = registers[1];\n            3'd2: data_out = registers[2];\n            3'd3: data_out = registers[3];\n            3'd4: data_out = registers[4];\n            3'd5: data_out = registers[5];\n            3'd6: data_out = registers[6];\n            3'd7: data_out = registers[7];\n            default: data_out = 8'd0;\n        endcase\n    end\n\nendmodule"}], "task_id": 25}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'exec', 'type': 'input port'}, {'id': 3, 'content': 'instr', 'type': 'input port'}, {'id': 4, 'content': 'en_reg', 'type': 'output port'}, {'id': 5, 'content': 'addr_mem', 'type': 'output port'}, {'id': 6, 'content': 'ctrl_mem', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}, {'id': 8, 'content': 'mem_ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 0, 1, 2, 0, 1, 7, 7, 8], [7, 7, 7, 8, 8, 8, 4, 5, 6]]\n, A control unit module that manages the execution cycle of a CPU by using control signals to orchestrate data flow between registers and memory, utilizing submodules for specific task execution within the cycle.\n\nModule name:\n    control_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the module.\n    exec [1:0]: Control signal indicating the type of operation (1 for data fetch, 2 for execution).\n    instr [15:0]: 16-bit instruction code input indicating operations to perform.\n\nOutput ports:\n    en_reg [3:0]: Enables specific register based on decoded instruction.\n    addr_mem [7:0]: Memory address to be fetched or written to.\n    ctrl_mem: Control signal for memory read/write operations.\n\nImplementation:\n    The control unit is implemented using two submodules: one for decoding the instruction and another for generating memory control signals.\n    On the rising edge of the clock (clk), if the reset (rst) is low, all output controls are initialized to their default inactive states.\n    Based on the exec signal:\n    If exec is 2'b01, the instruction is decoded to determine the memory address and register enable signals.\n    If exec is 2'b10, control signals for memory operations (read or write) are generated based on the decoded instruction.\n    If neither condition is met, the previous states are retained.\n    The outputs en_reg, addr_mem, and ctrl_mem are derived from the stored data and controls in the respective submodules.\nGive me the complete code.\nmodule control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec,\n    input [15:0] instr,\n    output [3:0] en_reg,\n    output [7:0] addr_mem,\n    output ctrl_mem\n);"}, {"from": "gpt", "value": "module control_unit (\n    input clk,\n    input rst,\n    input [1:0] exec,\n    input [15:0] instr,\n    output [3:0] en_reg,\n    output [7:0] addr_mem,\n    output ctrl_mem\n);\n\n    // Submodules for decoding and control\n    wire [3:0] dec_out_reg;\n    wire [7:0] dec_out_mem;\n    wire dec_out_ctrl;\n\n    instruction_decoder decoder (\n        .clk(clk),\n        .rst(rst),\n        .instr(instr),\n        .out_reg(dec_out_reg),\n        .out_mem(dec_out_mem)\n    );\n\n    memory_control mem_ctrl (\n        .clk(clk),\n        .rst(rst),\n        .exec(exec),\n        .ctrl_signal(dec_out_ctrl)\n    );\n\n    // Output assignments\n    assign en_reg = dec_out_reg;  // Register enable output\n    assign addr_mem = dec_out_mem;  // Memory address output\n    assign ctrl_mem = dec_out_ctrl; // Memory control signal\n\nendmodule\n\n// Submodule for instruction decoding\nmodule instruction_decoder (\n    input clk,\n    input rst,\n    input [15:0] instr,\n    output reg [3:0] out_reg,\n    output reg [7:0] out_mem\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            out_reg <= 4'd0;\n            out_mem <= 8'd0;\n        end else begin\n            out_reg <= instr[11:8]; // Decode register enable bits\n            out_mem <= instr[7:0];  // Decode memory address\n        end\n    end\n\nendmodule\n\n// Submodule for memory control signal generation\nmodule memory_control (\n    input clk,\n    input rst,\n    input [1:0] exec,\n    output reg ctrl_signal\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ctrl_signal <= 1'b0; // Reset output\n        end else begin\n            if (exec == 2'b10) begin\n                ctrl_signal <= 1'b1; // Enable memory operation\n            end else begin\n                ctrl_signal <= 1'b0; // Disable memory operation\n            end\n        end\n    end\n\nendmodule"}], "task_id": 26}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'select', 'type': 'input port'}, {'id': 3, 'content': 'input_data1', 'type': 'input port'}, {'id': 4, 'content': 'input_data2', 'type': 'input port'}, {'id': 5, 'content': 'output_data', 'type': 'output port'}, {'id': 6, 'content': 'flags', 'type': 'output port'}, {'id': 7, 'content': 'process1', 'type': 'submodule'}, {'id': 8, 'content': 'process2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 4, 2, 0, 1, 8, 2, 7, 8, 2, 7], [7, 7, 7, 7, 8, 8, 8, 8, 5, 5, 5, 6, 6, 6]]\n, A data selector module designed to facilitate the control and distribution of data from multiple inputs to various output fields, tailored for different processing units in a computational system. It incorporates clock synchronization, reset capabilities, and specific select signals to decide from which input source to capture the data, preparing it for subsequent decoding or direct usage.\n\nModule name:\n    data_selector\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize outputs to a predefined state.\n    select [1:0]: Control signal to choose the data source.\n    input_data1 [15:0]: 16-bit data input from the first source.\n    input_data2 [15:0]: 16-bit data input from the second source.\n\nOutput ports:\n    output_data [7:0]: Selected 8-bit data to be used by other modules.\n    flags [3:0]: Status flags indicating specifics of the data selected (e.g., parity, validity).\n\nImplementation:\n    The data selector module includes submodules to handle data from each source independently.\n    On the rising edge of the clock (clk), or if the reset (rst) is active, the outputs are reset.\n    Depending on the select signal:\n    If select is 2'b01, data is fetched from input_data1 and passed through a processing submodule (process_data1).\n    If select is 2'b10, data is fetched from input_data2 and processed by another submodule (process_data2).\n    The output_data and flags are set based on the outputs from the active processing submodule.\nGive me the complete code.\nmodule data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] input_data1,\n    input [15:0] input_data2,\n    output [7:0] output_data,\n    output [3:0] flags\n);"}, {"from": "gpt", "value": "module data_selector (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] input_data1,\n    input [15:0] input_data2,\n    output [7:0] output_data,\n    output [3:0] flags\n);\n\n    // Wires for submodule outputs\n    wire [7:0] data1_processed, data2_processed;\n    wire [3:0] flags1, flags2;\n\n    // Submodule for first data source processing\n    data_processing process1 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(input_data1),\n        .data_out(data1_processed),\n        .flags_out(flags1),\n        .select_code(2'b01) // Process data from first source\n    );\n\n    // Submodule for second data source processing\n    data_processing process2 (\n        .clk(clk),\n        .rst(rst),\n        .select(select),\n        .data_in(input_data2),\n        .data_out(data2_processed),\n        .flags_out(flags2),\n        .select_code(2'b10) // Process data from second source\n    );\n\n    // Output assignment logic\n    assign output_data = (select == 2'b01) ? data1_processed : \n                         (select == 2'b10) ? data2_processed : 8'b00000000;\n    assign flags = (select == 2'b01) ? flags1 : \n                   (select == 2'b10) ? flags2 : 4'b0000;\n\nendmodule\n\n// Submodule for data processing\nmodule data_processing (\n    input clk,\n    input rst,\n    input [1:0] select,\n    input [15:0] data_in,\n    output reg [7:0] data_out,\n    output reg [3:0] flags_out,\n    input [1:0] select_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            data_out <= 8'd0; // Reset output\n            flags_out <= 4'b0000; // Reset flags\n        end else begin\n            if (select == select_code) begin\n                data_out <= data_in[7:0]; // Capture lower 8 bits\n                flags_out <= {1'b0, data_in[15], data_in[14], 1'b1}; // Example flag settings\n            end else begin\n                data_out <= data_out; // Retain previous value\n                flags_out <= flags_out; // Retain previous flags\n            end\n        end\n    end\n\nendmodule"}], "task_id": 27}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'result_high', 'type': 'output port'}, {'id': 6, 'content': 'result_low', 'type': 'output port'}, {'id': 7, 'content': 'arithm_ops', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 1, 4, 2, 0, 7, 7], [7, 7, 7, 7, 7, 5, 6]]\n, A data processing unit that manages arithmetic operations based on control signals and two data inputs. It accepts operation codes and directs the arithmetic results to specific outputs split for further usage.\n\nModule name:\n    data_processing_unit\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the data processing operations.\n    op_code [2:0]: Control signal determining the type of arithmetic operation (e.g., add, subtract).\n    data_a [7:0]: 8-bit data input representing the first operand.\n    data_b [7:0]: 8-bit data input representing the second operand.\n\nOutput ports:\n    result_high [3:0]: High 4 bits of the arithmetic result.\n    result_low [3:0]: Low 4 bits of the arithmetic result.\n\nImplementation:\n    The data processing unit utilizes submodules for different arithmetic operations, each parameterized by a unique operation code.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    The submodule responsible for the operation is triggered based on the op_code:\n    If op_code matches specific values, the corresponding operation is executed using data inputs data_a and data_b.\n    The outputs result_high and result_low are derived from the result of the operation performed by the selected submodule.\nGive me the complete code.\nmodule data_processing_unit (\n    input clk,\n    input rst,\n    input [2:0] op_code,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [3:0] result_high,\n    output [3:0] result_low\n);"}, {"from": "gpt", "value": "module data_processing_unit (\n    input clk,\n    input rst,\n    input [2:0] op_code,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output [3:0] result_high,\n    output [3:0] result_low\n);\n\n    // Wire to hold the output of arithmetic operations\n    wire [7:0] arithmetic_out;\n\n    // Submodule for arithmetic operations\n    arithmetic_operations arithm_ops (\n        .clk(clk),\n        .rst(rst),\n        .op_code(op_code),\n        .data_a(data_a),\n        .data_b(data_b),\n        .operation_result(arithmetic_out)\n    );\n\n    // Output assignments\n    assign result_high = arithmetic_out[7:4]; // High 4 bits of the result\n    assign result_low = arithmetic_out[3:0];  // Low 4 bits of the result\n\nendmodule\n\n// Submodule for arithmetic operations\nmodule arithmetic_operations (\n    input clk,\n    input rst,\n    input [2:0] op_code,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [7:0] operation_result\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            operation_result <= 8'd0; // Reset output\n        end else begin\n            case (op_code)\n                3'b000: operation_result <= data_a + data_b; // Addition\n                3'b001: operation_result <= data_a - data_b; // Subtraction\n                // More operations can be added here\n                default: operation_result <= operation_result; // Retain the previous value\n            endcase\n        end\n    end\n\nendmodule"}], "task_id": 28}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'data_in', 'type': 'input port'}, {'id': 4, 'content': 'opcode', 'type': 'output port'}, {'id': 5, 'content': 'imm_val', 'type': 'output port'}, {'id': 6, 'content': 'addr', 'type': 'output port'}, {'id': 7, 'content': 'imm_decoder', 'type': 'submodule'}, {'id': 8, 'content': 'addr_decoder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 0, 1, 3, 2, 0, 1, 3, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, Design a data decoder module in Verilog to decode input data based on control signals and extract various fields, which can be used for further data processing or control. This module should handle data from multiple sources and decode them into operation codes, immediate values, and addresses using parameterized submodules.\n\nModule name:\n    data_decoder\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the outputs.\n    ctrl [1:0]: Control signal to select the data source (1 for immediate data, 2 for address).\n    data_in [15:0]: 16-bit input data representing the instruction or data to be decoded.\n\nOutput ports:\n    opcode [3:0]: Upper 4 bits of the data, used as operation code.\n    imm_val [7:0]: Immediate value extracted from middle 8 bits of the data.\n    addr [3:0]: Lower 4 bits of the data, used as an address or identifier.\n\nImplementation:\n    The data decoder uses two submodules; each responsible for handling a specific type of data based on the control signal.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, all outputs are initialized to zero.\n    Based on the ctrl signal:\n    If ctrl is 2'b01, the data is passed to the immediate submodule (imm_decoder) for extracting the immediate value.\n    If ctrl is 2'b10, the data is passed to the address submodule (addr_decoder) for extracting the address.\n    The opcode, imm_val, and addr outputs are derived from the data in the respective submodules.\nGive me the complete code.\nmodule data_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [3:0] opcode,\n    output [7:0] imm_val,\n    output [3:0] addr\n);"}, {"from": "gpt", "value": "module data_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output [3:0] opcode,\n    output [7:0] imm_val,\n    output [3:0] addr\n);\n\n    // Submodules for data decoding\n    wire [7:0] imm_out;\n    wire [3:0] addr_out;\n\n    immediate_decoder imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data_in(data_in),\n        .imm_out(imm_out),\n        .ctrl_code(2'b01) // Control code for immediate data\n    );\n\n    address_decoder addr_decoder (\n        .clk(clk),\n        .rst(rst),\n        .ctrl(ctrl),\n        .data_in(data_in),\n        .addr_out(addr_out),\n        .ctrl_code(2'b10) // Control code for address data\n    );\n\n    // Output assignments\n    assign opcode = data_in[15:12];\n    assign imm_val = imm_out;\n    assign addr = addr_out;\n\nendmodule\n\n// Submodule for immediate value decoding\nmodule immediate_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output reg [7:0] imm_out,\n    input [1:0] ctrl_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            imm_out <= 8'd0; // Reset output\n        end else begin\n            if (ctrl == ctrl_code) begin\n                imm_out <= data_in[11:4]; // Extract immediate value\n            end else begin\n                imm_out <= imm_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule\n\n// Submodule for address decoding\nmodule address_decoder (\n    input clk,\n    input rst,\n    input [1:0] ctrl,\n    input [15:0] data_in,\n    output reg [3:0] addr_out,\n    input [1:0] ctrl_code\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            addr_out <= 4'd0; // Reset output\n        end else begin\n            if (ctrl == ctrl_code) begin\n                addr_out <= data_in[3:0]; // Extract address\n            end else begin\n                addr_out <= addr_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}], "task_id": 29}]