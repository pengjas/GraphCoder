[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, mode input, op1 input, op2 input, result output, u_adder submodule, u_subtractor submodule], \nconnectivity: [[4, 3, 4, 3, 2, 6, 7], [6, 6, 7, 7, 5, 5, 5]]\n, Implement a modular 32-bit Adder-Subtractor using Verilog. In the top module named `as_module`, instantiate submodules for addition and subtraction. The `as_module` orchestrates these submodules to perform either addition or subtraction based on a mode input.\n\nModule name:\n    as_module\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, high to reset, low otherwise.\n    mode: Operation mode, 0 for addition and 1 for subtraction.\n    op1: 32-bit input operand 1.\n    op2: 32-bit input operand 2.\n\nOutput ports:\n    result: 32-bit output, result of addition or subtraction.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule takes two 32-bit inputs (op1 and op2) and produces a 32-bit result of their addition.\nSubtractor Submodule:\nThis submodule subtracts the second 32-bit input (op2) from the first (op1) and outputs the 32-bit result.\nThe main as_module module uses the mode input to select and output the result from either the Adder or Subtractor submodule based on the operation mode.\nGive me the complete code.\nmodule as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);"}, {"from": "gpt", "value": "module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(op1),\n    .b(op2),\n    .sum(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(op1),\n    .b(op2),\n    .difference(sub_result)\n);\n\n// Selecting output based on mode\nassign result = (mode == 0) ? add_result : sub_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] difference\n);\n    assign difference = a - b;\nendmodule\n"}], "task_id": "pe_v_0"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, x input, y input, z input, quotient output, difference output, u_divider submodule, u_subtractor submodule], \nconnectivity: [[2, 3, 4, 7, 7, 8], [7, 7, 8, 8, 5, 6]]\n, Implement a modular 32-bit Integer Divider and Subtractor system using Verilog. The main module, named `ds`, should include submodules for division and subtraction. It connects these to perform the operations, handling 32-bit integers.\n\nModule name:\n    ds\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, high to reset, low otherwise.\n    x: 32-bit dividend input.\n    y: 32-bit divisor input.\n    z: 32-bit subtrahend input.\n\nOutput ports:\n    quotient: 32-bit output for the division result.\n    difference: 32-bit output for the subtraction result.\n\nImplementation:\nThe module includes:\nDivider Submodule:\nThis submodule takes two 32-bit inputs (x and y) and calculates the division, providing a 32-bit quotient.\nSubtractor Submodule:\nThis submodule takes the division result and a 32-bit input z, computing the subtraction (quotient - z) and outputting a 32-bit difference.\nThe main `ds` module integrates these submodules, outputting the results for quotient and difference.\nGive me the complete code.\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);"}, {"from": "gpt", "value": "module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n// Intermediate wires for outputs of submodules\nwire [31:0] division_result;\nwire [31:0] subtraction_result;\n\n// Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(division_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(division_result),\n    .b(z),\n    .result(subtraction_result)\n);\n\n// Assigning the results to the outputs\nassign quotient = division_result;\nassign difference = subtraction_result;\n\nendmodule\n\n// Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x / y;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n"}], "task_id": "pe_v_1"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, a input, b input, op_sel input, result output, u_adder submodule, u_subtractor submodule, u_and submodule, u_or submodule], \nconnectivity: [[1, 2, 1, 2, 1, 2, 1, 2, 7, 6, 8, 5], [5, 5, 6, 6, 7, 7, 8, 8, 4, 4, 4, 4]]\n, Design a modular Arithmetic Logic Unit (ALU) for 32-bit integers. The top module, alu_module, should integrate submodules for addition, subtraction, bitwise AND, and bitwise OR operations. The alu_module connects these submodules to perform the specified operation based on an operation selector input.\n\nModule name:\n    alu_module\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n    op_sel: 2-bit operation selector (00 for ADD, 01 for SUB, 10 for AND, 11 for OR).\n\nOutput ports:\n    result: 32-bit output representing the ALU operation result.\n\nImplementation:\nThe module includes:\nAdder Submodule:\n    This submodule takes two 32-bit inputs and provides a 32-bit output of their sum.\nSubtractor Submodule:\n    This submodule takes two 32-bit inputs and provides a 32-bit output of their difference.\nAND Submodule:\n    This submodule performs a bitwise AND operation on two 32-bit inputs to produce a 32-bit output.\nOR Submodule:\n    This submodule performs a bitwise OR operation on two 32-bit inputs to produce a 32-bit output.\nThe main alu_module uses the operation selector to choose which submodule's output to route to the main output result.\nGive me the complete code.\nmodule alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);"}, {"from": "gpt", "value": "module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n// Instantiate the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiate the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\n// Instantiate the and module\nand_module u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Instantiate the or module\nor_module u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\n// AND module\nmodule and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\n// OR module\nmodule or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule"}], "task_id": "pe_v_2"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, op_sel input, a input, b input, result output, u_adder submodule, u_bitwise_and submodule], \nconnectivity: [[2, 3, 2, 3, 1, 6, 5], [5, 5, 6, 6, 4, 4, 4]]\n, Implement a modular Arithmetic Logic Unit (ALU) for 32-bit integers, performing addition and bitwise AND operations. The top module, alu, connects the submodules for addition and bitwise AND operation. Each submodule handles one operation and outputs the result to the alu module, which then selects the output based on an operation select signal.\n\nModule name:\n    alu\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    op_sel: Operation select signal. 0 for addition, 1 for bitwise AND.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    result: 32-bit output representing the result of the selected operation.\n\nImplementation:\nAdder Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 32-bit result of their addition.\nAND Submodule:\nThis submodule performs a bitwise AND operation on two 32-bit inputs (a and b) and outputs the result.\nThe main alu module connects these submodules and selects the appropriate operation result based on the op_sel signal, driving the output result accordingly.\nGive me the complete code.\nmodule alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);"}, {"from": "gpt", "value": "module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n// Intermediate wires for submodule results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Selecting the result based on operation select input\nassign result = (op_sel == 0) ? add_result : and_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n"}], "task_id": "pe_v_3"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, mode input, a input, b input, result output, u_adder submodule, u_subtractor submodule], \nconnectivity: [[3, 4, 3, 4, 2, 6, 7], [6, 6, 7, 7, 5, 5, 5]]\n, Implement a modular Dual-mode Arithmetic Unit for 16-bit integers. In the dual_mode_arithmetic module, there are submodules for addition and subtraction. The dual_mode_arithmetic module selects either addition or subtraction based on the mode input.\n\nModule name:\n    dual_mode_arithmetic\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    mode: Mode selection signal. Defined as 0 for addition and 1 for subtraction.\n    a: 16-bit input operand A.\n    b: 16-bit input operand B.\n\nOutput ports:\n    result: 16-bit output representing the arithmetic result.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule takes two 16-bit inputs (a and b) and produces a 16-bit result of their addition.\nSubtractor Submodule:\nThis submodule subtracts the input B from input A and outputs a 16-bit result.\nThe main dual_mode_arithmetic module uses a multiplexer controlled by the mode input to select between the outputs of the adder and subtractor submodules and drives the output result accordingly.\nGive me the complete code.\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);"}, {"from": "gpt", "value": "module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n// Intermediate wires to hold the addition and subtraction results\nwire [15:0] add_result;\nwire [15:0] sub_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\n// Multiplexer to select output based on mode\nassign result = mode ? sub_result : add_result;\n\nendmodule\n\n// Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule"}], "task_id": "pe_v_4"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, product output, GPP0 submodule, GPP1 submodule, GPP2 submodule, GPP3 submodule, A4BS0 submodule, A4BS1 submodule, A4BS2 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 4, 3, 7, 5, 8, 6, 9], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 2]]\n, Implement a module of a 4-bit multiplier using a series of full adders in sequential logic.\n\nModule name:  \n    multiplier_4bit               \nInput ports:\n    a[3:0]: 4-bit input operand A.\n    b[3:0]: 4-bit input operand B.\nOutput ports:\n    product[7:0]: 8-bit output representing the product of A and B.\n\nImplementation:\nThe module utilizes a series of full adders and shift registers to perform the multiplication operation.\nGive me the complete code.\nmodule multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);"}, {"from": "gpt", "value": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [3:0] partial_products[3:0];\n    wire [7:0] sum[3:0];\n    \n    generate_partial_products GPP0 (.a(a), .b(b[0]), .partial_product(partial_products[0]));\n    generate_partial_products GPP1 (.a(a), .b(b[1]), .partial_product(partial_products[1]));\n    generate_partial_products GPP2 (.a(a), .b(b[2]), .partial_product(partial_products[2]));\n    generate_partial_products GPP3 (.a(a), .b(b[3]), .partial_product(partial_products[3]));\n\n    assign sum[0] = {4'b0, partial_products[0]};\n    \n    adder_4bit_with_shift A4BS0 (.a(sum[0]), .b({3'b0, partial_products[1], 1'b0}), .sum(sum[1]));\n    adder_4bit_with_shift A4BS1 (.a(sum[1]), .b({2'b0, partial_products[2], 2'b0}), .sum(sum[2]));\n    adder_4bit_with_shift A4BS2 (.a(sum[2]), .b({1'b0, partial_products[3], 3'b0}), .sum(sum[3]));\n\n    assign product = sum[3];\nendmodule\n\nmodule generate_partial_products(input [3:0] a, input b, output [3:0] partial_product);\n    assign partial_product = b ? a : 4'b0;\nendmodule\n\nmodule adder_4bit_with_shift(input [7:0] a, input [7:0] b, output [7:0] sum);\n    wire [8:0] carry;\n    assign {carry[0], sum[0]} = a[0] + b[0];\n    assign {carry[1], sum[1]} = a[1] + b[1] + carry[0];\n    assign {carry[2], sum[2]} = a[2] + b[2] + carry[1];\n    assign {carry[3], sum[3]} = a[3] + b[3] + carry[2];\n    assign {carry[4], sum[4]} = a[4] + b[4] + carry[3];\n    assign {carry[5], sum[5]} = a[5] + b[5] + carry[4];\n    assign {carry[6], sum[6]} = a[6] + b[6] + carry[5];\n    assign {carry[7], sum[7]} = a[7] + b[7] + carry[6];\nendmodule"}], "task_id": "adder_8bit_v_5"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, bin input, diff output, bout output, FS0 submodule, FS1 submodule, FS2 submodule, FS3 submodule, FS4 submodule, FS5 submodule, FS6 submodule, FS7 submodule], \nconnectivity: [[0, 2, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 0, 10, 1, 0, 11, 1, 8, 10, 12, 9, 5, 7, 6, 11, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A and B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);"}, {"from": "gpt", "value": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] btemp;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(btemp[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(btemp[0]), .diff(diff[1]), .bout(btemp[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(btemp[1]), .diff(diff[2]), .bout(btemp[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(btemp[2]), .diff(diff[3]), .bout(btemp[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(btemp[3]), .diff(diff[4]), .bout(btemp[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(btemp[4]), .diff(diff[5]), .bout(btemp[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(btemp[5]), .diff(diff[6]), .bout(btemp[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(btemp[6]), .diff(diff[7]), .bout(btemp[7]));\n\n    assign bout = btemp[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule\n"}], "task_id": "adder_8bit_v_6"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, bin input, diff output, bout output, S0 submodule, S1 submodule, S2 submodule, S3 submodule, S4 submodule, S5 submodule, S6 submodule, S7 submodule], \nconnectivity: [[0, 2, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 0, 10, 1, 0, 11, 1, 6, 11, 7, 8, 5, 9, 10, 12, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit subtractor using a series of 1-bit subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A and B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (1-bit subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);"}, {"from": "gpt", "value": "module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] borrow;\n\n    one_bit_subtractor S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    one_bit_subtractor S1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    one_bit_subtractor S2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    one_bit_subtractor S3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    one_bit_subtractor S4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    one_bit_subtractor S5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    one_bit_subtractor S6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    one_bit_subtractor S7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7]; \nendmodule\n\nmodule one_bit_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule"}], "task_id": "adder_8bit_v_7"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, bin input, diff output, bout output, FS0 submodule, FS1 submodule, FS2 submodule, FS3 submodule, FS4 submodule, FS5 submodule, FS6 submodule, FS7 submodule], \nconnectivity: [[0, 2, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 0, 10, 1, 0, 11, 1, 5, 7, 9, 12, 10, 11, 8, 6, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A from B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);"}, {"from": "gpt", "value": "module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] borrow;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = bin ? (a - b - 1) : (a - b);\nendmodule\n"}], "task_id": "adder_8bit_v_8"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, product output, SAA0 submodule, SAA1 submodule, SAA2 submodule, SAA3 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 4, 5, 3, 6], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Implement a module for a 4-bit multiplier using shift and add method in combinational logic.\n\nModule name:  \n    multiplier_4bit               \nInput ports:\n    a[3:0]: 4-bit input multiplicand.\n    b[3:0]: 4-bit input multiplier.\nOutput ports:\n    product[7:0]: 8-bit output representing the product of A and B.\n\nImplementation:\nThe module uses a series of bit-shifts and add operations controlled by the bits of the multiplier.\nGive me the complete code.\nmodule multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);"}, {"from": "gpt", "value": "module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] intermediate[3:0];\n\n    shift_and_add SAA0(.a(a), .b(b[0]), .product(intermediate[0]));\n    shift_and_add SAA1(.a(a), .b(b[1]), .product(intermediate[1]));\n    shift_and_add SAA2(.a(a), .b(b[2]), .product(intermediate[2]));\n    shift_and_add SAA3(.a(a), .b(b[3]), .product(intermediate[3]));\n\n    assign product = intermediate[0] + (intermediate[1] << 1) + (intermediate[2] << 2) + (intermediate[3] << 3);\n\nendmodule\n\nmodule shift_and_add(input [3:0] a, input b, output [7:0] product);\n    assign product = b ? {4'b0000, a} : 8'b00000000;\nendmodule"}], "task_id": "adder_8bit_v_9"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, control_signal input, count output, u_toggle_logic submodule, u_counter_logic submodule, u_counter_register submodule], \nconnectivity: [[1, 3, 5, 1, 4, 0, 5], [3, 4, 4, 5, 5, 5, 2]]\n, Design a 32-bit binary ripple counter that operates on an active-high signal and provides a toggle output every clock cycle. The counter should increase when the signal is high and reset when low.\n\nModule name: binary_ripple_counter\n\nFunction:\nA 32-bit binary ripple counter that toggles its count based on an external control signal. The counter increases with each clock pulse if the control signal is high; it resets to zero when the signal is low.\n\nInput ports:\n- clk: Clock signal (1-bit), used to synchronize the counting process.\n- control_signal: External control signal (1-bit), determines if the counter should count or reset.\n\nOutput ports:\n- count [31:0]: 32-bit output representing the current counter value.\n\nImplementation:\nThe module consists of three submodules: toggle_logic, counter_logic, and counter_register.\n- The toggle_logic module determines whether to toggle the count based on the control signal.\n- The counter_logic module calculates the next count value based on the current count and toggle conditions.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the control_signal condition.\nGive me the complete code.\nmodule binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);"}, {"from": "gpt", "value": "module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    // Instantiate the toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output reg toggle\n);\n\n    always @(*) begin\n        toggle = control_signal ? 1'b1 : 1'b0;\n    end\n\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    input wire [31:0] current_count,\n    output reg [31:0] next_count\n);\n\n    always @(*) begin\n        if (toggle) begin\n            next_count = current_count + 1;\n        end else begin\n            next_count = 32'b0;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] current_count\n);\n\n    always @(posedge clk) begin\n        if (control_signal == 1'b0) begin\n            current_count <= 32'b0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule\n"}], "task_id": "up_down_counter_v_10"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [op_code input, a input, b input, result output, zero output, u_adder submodule, u_subtractor submodule, u_and_logic submodule, u_or_logic submodule], \nconnectivity: [[1, 2, 1, 2, 1, 2, 1, 2, 7, 5, 0, 8, 6, 7, 5, 0, 8, 6], [5, 5, 6, 6, 7, 7, 8, 8, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]]\n, Design a 32-bit arithmetic logic unit (ALU) that can perform addition, subtraction, bitwise AND, OR operations based on a 2-bit control signal. The ALU should be implemented modularly with separate logic for each operation.\n\nModule name:\n    modular_alu\n\nFunction:\nA 32-bit ALU capable of performing selected arithmetic and logical operations determined by a control signal.\n\nInput ports:\n    - op_code: Control signal (2-bit), selects the operation to perform.\n    - a [31:0]: First operand (32-bit).\n    - b [31:0]: Second operand (32-bit).\n\nOutput ports:\n    - result [31:0]: 32-bit output, result of the ALU operation.\n    - zero: Output signal (1-bit), indicates if the result is zero.\n\nImplementation:\nThe module consists of four submodules: adder, subtractor, and_logic, or_logic.\n- The adder module performs addition of a and b.\n- The subtractor module performs subtraction of a from b.\n- The and_logic module performs bitwise AND operation on a and b.\n- The or_logic module performs bitwise OR operation on a and b.\nThe result output shows the outcome based on the operation selected by op_code, which can control adding, subtracting, bitwise AND or OR operations. The zero output indicates whether the result is zero.\nGive me the complete code.\nmodule modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);"}, {"from": "gpt", "value": "module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    // Instantiate the adder submodule\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum_result)\n    );\n\n    // Instantiate the subtractor submodule\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .sub(sub_result)\n    );\n\n    // Instantiate the AND logic submodule\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n\n    // Instantiate the OR logic submodule\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n\n    // Logic to select the output\n    assign result = (op_code == 2'b00) ? sum_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sub\n);\n    assign sub = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n"}], "task_id": "up_down_counter_v_11"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [op_code input, operand_a input, operand_b input, result output, zero output, u_adder submodule, u_subtractor submodule, u_and_bit submodule, u_or_bit submodule, u_xor_bit submodule], \nconnectivity: [[2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 5, 7, 9, 6, 8, 5, 7, 9, 6, 8], [5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]]\n, Design a 32-bit arithmetic logic unit (ALU) in Verilog that performs addition, subtraction, bitwise AND, OR, and XOR operations based on a 3-bit control input, structured with a top module and several submodules for handling specific operations.\n\nModule name:\n    multi_function_alu\n\nFunction:\nA 32-bit ALU that performs multiple arithmetic and logical operations determined by a control signal, with modular implementation.\n\nInput ports:\n    - op_code: Operation code (3-bit), selects the operation to perform (000 for ADD, 001 for SUB, 010 for AND, 011 for OR, 100 for XOR).\n    - operand_a [31:0]: First operand (32-bit).\n    - operand_b [31:0]: Second operand (32-bit).\n\nOutput ports:\n    - result [31:0]: 32-bit output of the selected operation.\n    - zero: Output signal (1-bit), high if the result is zero.\n\nImplementation:\nThe module consists of five submodules: adder, subtractor, and_bit, or_bit, and xor_bit.\n- The adder module calculates the sum of operand_a and operand_b.\n- The subtractor module calculates the difference between operand_a and operand_b.\n- The and_bit module performs bitwise AND on operand_a and operand_b.\n- The or_bit module performs bitwise OR on operand_a and operand_b.\n- The xor_bit module performs bitwise XOR on operand_a and operand_b.\nThe result is selected based on the op_code, and the zero flag is set if the result is zero.\nGive me the complete code.\nmodule multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);"}, {"from": "gpt", "value": "module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, difference, and_res, or_res, xor_res;\n    reg [31:0] alu_result;\n\n    // Instantiate adder\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    // Instantiate subtractor\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .difference(difference)\n    );\n\n    // Instantiate AND logic\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_res(and_res)\n    );\n\n    // Instantiate OR logic\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_res(or_res)\n    );\n\n    // Instantiate XOR logic\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_res(xor_res)\n    );\n\n    // Result selection logic\n    always @(*) begin\n        case(op_code)\n            3'b000: alu_result = sum;\n            3'b001: alu_result = difference;\n            3'b010: alu_result = and_res;\n            3'b011: alu_result = or_res;\n            3'b100: alu_result = xor_res;\n            default: alu_result = 32'b0;\n        endcase\n    end\n\n    assign result = alu_result;\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_res\n);\n    assign and_res = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_res\n);\n    assign or_res = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_res\n);\n    assign xor_res = a ^ b;\nendmodule\n"}], "task_id": "up_down_counter_v_12"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, op_code input, operand_a input, operand_b input, result output, u_adder submodule, u_subtractor submodule, u_bitwise_operator submodule], \nconnectivity: [[3, 2, 3, 2, 3, 2, 1, 6, 7, 5, 1], [5, 5, 6, 6, 7, 7, 7, 4, 4, 4, 4]]\n, Design a Verilog module for a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, bitwise AND, OR operations based on a control signal. Implement this using modular design with specific submodules handling different arithmetic and logical functions.\n\nModule name:\n    configurable_alu\n\nFunction:\nA 32-bit ALU that can perform addition, subtraction, bitwise AND, and OR operations, controlled by a 2-bit signal.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the operations.\n    - op_code: Operation code (2-bit), determines the operation to perform:\n        - 00: Addition\n        - 01: Subtraction\n        - 10: Bitwise AND\n        - 11: Bitwise OR\n    - operand_a [31:0]: First 32-bit operand.\n    - operand_b [31:0]: Second 32-bit operand.\n\nOutput ports:\n    - result [31:0]: 32-bit output representing the result of the ALU operation.\n\nImplementation:\nThe module includes three submodules: adder, subtractor, and bitwise_operator.\n- The adder module performs the addition of two 32-bit numbers.\n- The subtractor module performs the subtraction between two 32-bit numbers.\n- The bitwise_operator module handles both the AND and OR operations based on an internal control signal derived from op_code.\nThe result output depends on op_code and reflects the outcome of the operation performed by the relevant submodule.\nGive me the complete code.\nmodule configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);"}, {"from": "gpt", "value": "module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_or_result;\n\n    // Instantiate adder submodule\n    adder u_adder (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(add_result)\n    );\n\n    // Instantiate subtractor submodule\n    subtractor u_subtractor (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(sub_result)\n    );\n\n    // Instantiate bitwise operator submodule\n    bitwise_operator u_bitwise_operator (\n        .op_code(op_code[0]),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(and_or_result)\n    );\n\n    // Result logic based on operation code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    and_or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule bitwise_operator (\n    input wire op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = (op_code) ? (operand_a | operand_b) : (operand_a & operand_b);\nendmodule\n"}], "task_id": "up_down_counter_v_13"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [X input, Y input, P output, GP0 submodule, GP1 submodule, GP2 submodule, GP3 submodule, GP4 submodule, GP5 submodule, GP6 submodule, GP7 submodule], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 4, 7, 9, 8, 5, 3, 6, 10], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_8bit combines the products from multiple instances of the gen_product module, which calculates partial products. Each gen_product module handles the multiplication operation for one bit of Y with all bits of X and accumulates the results using shift and add methodology.\nGive me the complete code.\nmodule mult_8bit(X, Y, P);"}, {"from": "gpt", "value": "module mult_8bit(X, Y, P);\n    input [7:0] X;    // 8-bit input operand X\n    input [7:0] Y;    // 8-bit input operand Y\n    output [15:0] P;  // 16-bit output representing the product X * Y\n\n    wire [15:0] products[0:7];  // Intermediate products for each bit of Y\n\n    // Instantiate gen_product modules for each bit of Y\n    gen_product GP0(.X(X), .Y_bit(Y[0]), .Shift(0), .Product(products[0]));\n    gen_product GP1(.X(X), .Y_bit(Y[1]), .Shift(1), .Product(products[1]));\n    gen_product GP2(.X(X), .Y_bit(Y[2]), .Shift(2), .Product(products[2]));\n    gen_product GP3(.X(X), .Y_bit(Y[3]), .Shift(3), .Product(products[3]));\n    gen_product GP4(.X(X), .Y_bit(Y[4]), .Shift(4), .Product(products[4]));\n    gen_product GP5(.X(X), .Y_bit(Y[5]), .Shift(5), .Product(products[5]));\n    gen_product GP6(.X(X), .Y_bit(Y[6]), .Shift(6), .Product(products[6]));\n    gen_product GP7(.X(X), .Y_bit(Y[7]), .Shift(7), .Product(products[7]));\n\n    // Sum all partial products to form the final product\n    assign P = products[0] + products[1] + products[2] + products[3] +\n               products[4] + products[5] + products[6] + products[7];\n\nendmodule\n\nmodule gen_product(X, Y_bit, Shift, Product);\n    input [7:0] X;     // 8-bit input operand X\n    input Y_bit;       // Single bit of input operand Y\n    input [2:0] Shift; // Shift amount for partial product alignment\n    output [15:0] Product; // Output partial product\n\n    // Calculate partial product\n    wire [7:0] partial_product = X & {8{Y_bit}};\n\n    // Shift partial product to align according to bit position\n    assign Product = partial_product << Shift;\n\nendmodule\n"}], "task_id": "sub_8bit_v_14"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [X input, Y input, P output, AS0 submodule, AS1 submodule, AS2 submodule, AS3 submodule, AS4 submodule, AS5 submodule, AS6 submodule, AS7 submodule], \nconnectivity: [[1, 0, 1, 3, 0, 1, 4, 0, 1, 5, 0, 1, 6, 0, 7, 1, 0, 8, 1, 0, 1, 9, 0, 10], [3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 2]]\n, Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_8bit uses a series of add_shift modules to perform the multiplication operation through repeated additions based on the shifting method. Each add_shift module is responsible for conditionally adding the multiplicand X shifted left by a specific number of positions to an accumulator based on a corresponding bit in the multiplier Y.\n\nGive me the complete code.\nGive me the complete code.\nmodule mult_8bit(X, Y, P);"}, {"from": "gpt", "value": "module mult_8bit(X, Y, P);\n    input [7:0] X;      // 8-bit input operand X\n    input [7:0] Y;      // 8-bit input operand Y\n    output [15:0] P;    // 16-bit output representing the product X * Y\n\n    wire [15:0] product[0:7]; // Partial products from each stage\n\n    // Instantiate add_shift modules for each bit in Y\n    add_shift AS0(.X(X), .shift(0), .Y_bit(Y[0]), .partial_sum(16'b0), .P(product[0]));\n    add_shift AS1(.X(X), .shift(1), .Y_bit(Y[1]), .partial_sum(product[0]), .P(product[1]));\n    add_shift AS2(.X(X), .shift(2), .Y_bit(Y[2]), .partial_sum(product[1]), .P(product[2]));\n    add_shift AS3(.X(X), .shift(3), .Y_bit(Y[3]), .partial_sum(product[2]), .P(product[3]));\n    add_shift AS4(.X(X), .shift(4), .Y_bit(Y[4]), .partial_sum(product[3]), .P(product[4]));\n    add_shift AS5(.X(X), .shift(5), .Y_bit(Y[5]), .partial_sum(product[4]), .P(product[5]));\n    add_shift AS6(.X(X), .shift(6), .Y_bit(Y[6]), .partial_sum(product[5]), .P(product[6]));\n    add_shift AS7(.X(X), .shift(7), .Y_bit(Y[7]), .partial_sum(product[6]), .P(product[7]));\n\n    // Assign the final product\n    assign P = product[7];\n\nendmodule\n\nmodule add_shift(X, shift, Y_bit, partial_sum, P);\n    input [7:0] X;         // Multiplicand\n    input [2:0] shift;     // Shift amount\n    input Y_bit;           // Specific bit of multiplier Y\n    input [15:0] partial_sum; // Partial sum input\n    output [15:0] P;       // Output partial product\n\n    wire [15:0] shifted_X;\n\n    // Shift X left by 'shift' positions\n    assign shifted_X = X << shift;\n\n    // Conditional addition based on Y_bit\n    assign P = Y_bit ? partial_sum + shifted_X : partial_sum;\n\nendmodule"}], "task_id": "sub_8bit_v_15"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [X input, Y input, P output, add1 submodule, add2 submodule, add3 submodule], \nconnectivity: [[1, 0, 3, 1, 0, 1, 4, 0, 5], [3, 3, 4, 4, 4, 5, 5, 5, 2]]\n, Implement a module of a 4-bit multiplier using a series of adders and shift operations.\n\nModule name:\n    mul_4bit\n\nInput ports:\n    X[3:0]: 4-bit input operand X.\n    Y[3:0]: 4-bit input operand Y.\n\nOutput ports:\n    P[7:0]: 8-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mul_4bit performs multiplication by using bitwise AND operations and shifts to construct partial products, which are then added using an adder_8bit module. The adder_8bit module is composed of full_adder modules to handle the addition of each bit.\nGive me the complete code.\nmodule mul_4bit(X, Y, P);"}, {"from": "gpt", "value": "module mul_4bit(X, Y, P);\n    input [3:0] X;    // 4-bit input operand X\n    input [3:0] Y;    // 4-bit input operand Y\n    output [7:0] P;   // 8-bit output product\n\n    wire [7:0] pp0, pp1, pp2, pp3; // partial products\n    wire [7:0] sum1, sum2, sum3;   // intermediate sums\n    wire cout1, cout2, cout3;      // carry outputs from adders\n\n    // Generate partial products\n    assign pp0 = Y[0] ? {4'b0000, X} : 8'b00000000;\n    assign pp1 = Y[1] ? {3'b000, X, 1'b0} : 8'b00000000;\n    assign pp2 = Y[2] ? {2'b00, X, 2'b00} : 8'b00000000;\n    assign pp3 = Y[3] ? {1'b0, X, 3'b000} : 8'b00000000;\n\n    // Add partial products\n    adder_8bit add1(.A(pp0), .B(pp1), .D(sum1), .Cout(cout1));\n    adder_8bit add2(.A(sum1), .B(pp2), .D(sum2), .Cout(cout2));\n    adder_8bit add3(.A(sum2), .B(pp3), .D(P), .Cout(cout3));\n\nendmodule\n\nmodule adder_8bit(A, B, D, Cout);\n    input [7:0] A;     // 8-bit input operand A\n    input [7:0] B;     // 8-bit input operand B\n    output [7:0] D;    // 8-bit output representing the sum\n    output Cout;       // Carry out\n\n    wire [7:0] sum;    // Intermediate sum values\n    wire [7:0] carry;  // Intermediate carry values\n\n    // Instantiate full adders\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Cout));\n\n    // Assign the sum to output\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;       // Input A\n    input B;       // Input B\n    input Cin;     // Carry input\n    output Sum;    // Sum output\n    output Cout;   // Carry output\n\n    assign Sum = A ^ B ^ Cin;                  // Sum calculation\n    assign Cout = (A & B) | (Cin & (A ^ B));  // Carry calculation\nendmodule\n"}], "task_id": "sub_8bit_v_16"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [X input, Y input, P output, adder_0 submodule, adder_1 submodule, adder_2 submodule], \nconnectivity: [[1, 0, 3, 1, 0, 4, 1, 0, 5], [3, 3, 4, 4, 4, 5, 5, 5, 2]]\n, Implement a module of a 4-bit multiplier using a combination of adders and shift registers.\n\nModule name:\n    mult_4bit\n\nInput ports:\n    X[3:0]: 4-bit input multiplicand X.\n    Y[3:0]: 4-bit input multiplier Y.\n\nOutput ports:\n    P[7:0]: 8-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_4bit utilizes a series of shift and add operations implemented through adder_4bit modules. Each adder_4bit module handles the addition based on the shifted value of X and the bit value of Y.\nGive me the complete code.\nmodule mult_4bit(X, Y, P);"}, {"from": "gpt", "value": "module mult_4bit(X, Y, P);\n    input [3:0] X;      // 4-bit input multiplicand X\n    input [3:0] Y;      // 4-bit input multiplier Y\n    output [7:0] P;     // 8-bit output product\n\n    wire [3:0] partial_product_0, partial_product_1, partial_product_2, partial_product_3;\n    wire [7:0] sum_0, sum_1, sum_2;\n\n    // Generate partial products\n    assign partial_product_0 = Y[0] ? X : 4'b0000;\n    assign partial_product_1 = Y[1] ? X : 4'b0000;\n    assign partial_product_2 = Y[2] ? X : 4'b0000;\n    assign partial_product_3 = Y[3] ? X : 4'b0000;\n\n    // Shift partial products\n    wire [7:0] shift_partial_1 = {partial_product_1, 1'b0};\n    wire [7:0] shift_partial_2 = {partial_product_2, 2'b00};\n    wire [7:0] shift_partial_3 = {partial_product_3, 3'b000};\n\n    // Add partial products\n    adder_4bit adder_0(\n        .A({4'b0000, partial_product_0}),\n        .B(shift_partial_1),\n        .D(sum_0)\n    );\n    adder_4bit adder_1(\n        .A(sum_0),\n        .B(shift_partial_2),\n        .D(sum_1)\n    );\n    adder_4bit adder_2(\n        .A(sum_1),\n        .B(shift_partial_3),\n        .D(P)\n    );\n\nendmodule\n\nmodule adder_4bit(A, B, D);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output sum\n\n    assign D = A + B;   // Simple bitwise addition\n\nendmodule\n"}], "task_id": "sub_8bit_v_17"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, op_code input, operand_a input, operand_b input, result output, adder submodule, subtractor submodule, and_logical submodule, or_logical submodule], \nconnectivity: [[3, 2, 3, 2, 3, 2, 3, 2, 5, 8, 6, 7], [5, 5, 6, 6, 7, 7, 8, 8, 4, 4, 4, 4]]\n, Design and implement a Verilog module for a simple 4-bit arithmetic logic unit (ALU) with basic operations including addition, subtraction, AND, OR operations.\n\nModule name:  \n    simple_alu4bit               \nInput ports:\n    clk: Clock signal.\n    op_code[1:0]: 2-bit operation selector.\n    operand_a[3:0]: 4-bit input operand A.\n    operand_b[3:0]: 4-bit input operand B.\nOutput ports:\n    result[3:0]: 4-bit output result of the ALU operation.\n\nImplementation:\nThe simple_alu4bit module consists of four primary operational stages: adder, subtractor, and_logical, or_logical. Each stage is implemented as a separate submodule that performs the specific arithmetic or logical operation based on the op_code input. The adder stage computes the sum of operand_a and operand_b. The subtractor stage computes the difference between operand_a and operand_b. The and_logical stage performs a bitwise AND operation, and the or_logical stage performs a bitwise OR operation. The result from the appropriate submodule is selected based on the op_code and output through the result port.\nGive me the complete code.\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);"}, {"from": "gpt", "value": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] add_result;\nwire [3:0] sub_result;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder_stage adder(.operand_a(operand_a), .operand_b(operand_b), .result(add_result));\nsubtractor_stage subtractor(.operand_a(operand_a), .operand_b(operand_b), .result(sub_result));\nand_stage and_logical(.operand_a(operand_a), .operand_b(operand_b), .result(and_result));\nor_stage or_logical(.operand_a(operand_a), .operand_b(operand_b), .result(or_result));\n\nalways @(posedge clk) begin\n    case(op_code)\n        `ADD_OP: result <= add_result;\n        `SUB_OP: result <= sub_result;\n        `AND_OP: result <= and_result;\n        `OR_OP: result <= or_result;\n        default: result <= 0;\n    endcase\nend\nendmodule\n\nmodule adder_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule and_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule or_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule"}], "task_id": "stagepipe3_v_18"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, op input, result output, adder submodule, subtractor submodule, and_op submodule, or_op submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 5, 4, 7, 6], [4, 4, 5, 5, 6, 6, 7, 7, 3, 3, 3, 3]]\n, Implement a module for a simple 4-bit arithmetic logic unit (ALU) that performs addition, subtraction, bitwise AND, and bitwise OR based on a 2-bit operation selector.\n\nModule name:  \n    simple_alu               \nInput ports:\n    a[3:0]: 4-bit input operand.\n    b[3:0]: 4-bit input operand.\n    op[1:0]: 2-bit operation selector where 00 is ADD, 01 is SUBTRACT, 10 is AND, and 11 is OR.\nOutput ports:\n    result[3:0]: 4-bit output result of the ALU operation.\n\nImplementation:\nThe simple_alu module instantiates four submodules: adder, subtractor, and_module, and or_module. Each submodule performs a specific operation based on the operation selector 'op'. The adder module calculates the sum of a and b. The subtractor module calculates the difference between a and b. The and_module performs a bitwise AND operation, and the or_module performs a bitwise OR operation. The output of each submodule is connected to a multiplexer, which selects the final result based on 'op'.\nGive me the complete code.\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);"}, {"from": "gpt", "value": "module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum;\nwire [3:0] diff;\nwire [3:0] and_res;\nwire [3:0] or_res;\n\nadder_module adder(.a(a), .b(b), .sum(sum));\nsubtractor_module subtractor(.a(a), .b(b), .diff(diff));\nand_module and_op(.a(a), .b(b), .and_res(and_res));\nor_module or_op(.a(a), .b(b), .or_res(or_res));\n\nalways @(*) begin\n    case(op)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_res;\n        2'b11: result = or_res;\n    endcase\nend\nendmodule\n\nmodule adder_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_res\n);\nassign and_res = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_res\n);\nassign or_res = a | b;\nendmodule"}], "task_id": "stagepipe3_v_19"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, op_code input, data_a input, data_b input, result output, zero output, decoder submodule, manager submodule], \nconnectivity: [[3, 4, 2, 7, 0, 1, 8, 8], [7, 7, 7, 8, 8, 8, 5, 6]]\n, Implement a module for a 4-bit arithmetic logic unit (ALU) with basic arithmetic and logical operations.\n\nModule name:  \n    simple_alu               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op_code[1:0]: 2-bit operation code to specify the ALU operation.\n    data_a[3:0]: 4-bit input operand A.\n    data_b[3:0]: 4-bit input operand B.\nOutput ports:\n    result[3:0]: 4-bit output resulting from the specified ALU operation.\n    zero: Output high when result is zero.\n\nImplementation:\nIn the simple_alu module, the basic arithmetic operations (addition, subtraction) and logical operations (AND, OR) are supported. The op_decoder submodule interprets the op_code and triggers the corresponding operation in the arithmetic_logic submodule. The result_manager submodule checks the result from arithmetic_logic and outputs a zero flag if the result is zero.\nGive me the complete code.\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);"}, {"from": "gpt", "value": "`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR  2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] operation_result;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(operation_result)\n);\n\nresult_manager manager (\n    .clk(clk),\n    .rst(rst),\n    .operation_result(operation_result),\n    .final_result(result),\n    .zero_flag(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @* begin\n        case(op_code)\n            `ADD: result = data_a + data_b;\n            `SUB: result = data_a - data_b;\n            `AND: result = data_a & data_b;\n            `OR: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input clk,\n    input rst,\n    input [3:0] operation_result,\n    output reg [3:0] final_result,\n    output reg zero_flag\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            final_result <= 0;\n            zero_flag <= 1'b1;\n        end else begin\n            final_result <= operation_result;\n            zero_flag <= (operation_result == 0);\n        end\n    end\nendmodule"}], "task_id": "stagepipe3_v_20"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, opcode input, data_a input, data_b input, result output, valid output, add_module submodule, sub_module submodule, mul_module submodule, div_module submodule], \nconnectivity: [[3, 4, 3, 4, 3, 4, 3, 4, 10, 8, 7, 9, 10], [7, 7, 8, 8, 9, 9, 10, 10, 5, 5, 5, 5, 6]]\n, Implement a module for a basic 4-function arithmetic unit that computes add, subtract, multiply, and divide operations based on opcode input.\n\nModule name:  \n    arithmetic_unit               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    opcode[1:0]: 2-bit input specifying the operation (00-add, 01-subtract, 10-multiply, 11-divide).\n    data_a[7:0]: 8-bit input operand A.\n    data_b[7:0]: 8-bit input operand B.\nOutput ports:\n    result[15:0]: 16-bit output result of the arithmetic operation.\n    valid: Output flag indicating if the result is valid (e.g., not a division by zero).\n\nImplementation:\nIn the arithmetic_unit module, four different arithmetic operation stages (adder, subtractor, multiplier, divider) are instantiated. The operation to be performed is selected based on the opcode input. The adder module performs addition, the subtractor performs subtraction, the multiplier carries out multiplication, and the divider handles division, including setting the valid flag to 0 when division by zero is attempted. The result from the selected operation stage is output through the result port.\nGive me the complete code.\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);"}, {"from": "gpt", "value": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\nwire div_valid;\n\nadder add_module (.a(data_a), .b(data_b), .result(add_result));\nsubtractor sub_module (.a(data_a), .b(data_b), .result(sub_result));\nmultiplier mul_module (.a(data_a), .b(data_b), .result(mul_result));\ndivider div_module (.a(data_a), .b(data_b), .result(div_result), .valid(div_valid));\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        result <= 0;\n        valid <= 1;\n    end else begin\n        case(opcode)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= sub_result;\n            `MUL_OP: result <= mul_result;\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= div_valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 1;\n            end\n        endcase\n    end\nend\nendmodule\n\n// Arithmetic operation submodules\nmodule adder(input [7:0] a, input [7:0] b, output [15:0] result);\nassign result = a + b;\nendmodule\n\nmodule subtractor(input [7:0] a, input [7:0] b, output [15:0] result);\nassign result = a - b;\nendmodule\n\nmodule multiplier(input [7:0] a, input [7:0] b, output [15:0] result);\nassign result = a * b;\nendmodule\n\nmodule divider(input [7:0] a, input [7:0] b, output [15:0] result, output valid);\nassign result = (b != 0) ? (a / b) : 0;\nassign valid = (b != 0);\nendmodule"}], "task_id": "stagepipe3_v_21"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, gt output, lt output, eq output, bc0 submodule, bc1 submodule, bc2 submodule, bc3 submodule], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 8, 5, 6, 7, 8, 5, 6, 8, 5, 7], [5, 5, 6, 6, 7, 7, 8, 8, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]]\n, Design a 4-bit magnitude comparator that takes two 4-bit binary numbers and outputs whether the first number is greater than, less than, or equal to the second number.\n\nModule name: \n    magnitude_comparator\n\nFunction:\n    This module compares two 4-bit numbers and outputs three signals indicating whether the first number (A) is greater than, less than, or equal to the second number (B).\n\nInput ports:\n    A [3:0]: 4-bit input representing the first number.\n    B [3:0]: 4-bit input representing the second number.\n\nOutput ports:\n    gt: Output signal that is high if A > B.\n    lt: Output signal that is high if A < B.\n    eq: Output signal that is high if A == B.\n\nImplementation:\n    The magnitude_comparator uses submodules to compare each bit of A and B starting from the most significant bit. The comparison logic determines if A is greater than, less than, or equal to B by cascading comparisons from the highest bit to the lowest bit.\n    - If the higher significant bit of A is greater than B, then A is greater regardless of the lower bits.\n    - If the higher significant bit of A is less than B, then A is less regardless of the lower bits.\n    - If bits are equal, the comparison continues to the next lower bit.\n\n    A series of `bit_compare` submodules are instantiated for bit-by-bit comparison, providing intermediate signals for greater than, less than, or equal conditions that are then used to determine the final output.\nGive me the complete code.\nmodule magnitude_comparator (A, B, gt, lt, eq);"}, {"from": "gpt", "value": "module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3;\n    wire lt0, lt1, lt2, lt3;\n    wire eq0, eq1, eq2, eq3;\n\n    // Bit-by-bit comparison\n    bit_compare bc0 (A[3], B[3], gt3, lt3, eq3);\n    bit_compare bc1 (A[2], B[2], gt2, lt2, eq2);\n    bit_compare bc2 (A[1], B[1], gt1, lt1, eq1);\n    bit_compare bc3 (A[0], B[0], gt0, lt0, eq0);\n\n    // Output determination\n    assign gt = gt3 | (eq3 & gt2) | (eq3 & eq2 & gt1) | (eq3 & eq2 & eq1 & gt0);\n    assign lt = lt3 | (eq3 & lt2) | (eq3 & eq2 & lt1) | (eq3 & eq2 & eq1 & lt0);\n    assign eq = eq3 & eq2 & eq1 & eq0;\n\nendmodule\n\nmodule bit_compare(a, b, gt, lt, eq);\n    input a, b;\n    output gt, lt, eq;\n\n    assign gt = a & ~b;\n    assign lt = ~a & b;\n    assign eq = a ~^ b; // XOR for equality check\nendmodule\n"}], "task_id": "barrel_shifter_v_22"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, op input, result output, carry_borrow output, and_unit submodule, or_unit submodule, add_unit submodule, sub_unit submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 2, 8, 5, 7, 6, 7, 2, 8], [5, 5, 6, 6, 7, 7, 8, 8, 3, 3, 3, 3, 3, 4, 4, 4]]\n, Design a 4-bit arithmetic logic unit (ALU) that performs bitwise AND, bitwise OR, addition, and subtraction based on a 2-bit operation selector. The ALU takes two 4-bit inputs and outputs the 4-bit result along with a carry or borrow flag.\n\nModule name: \n    simple_alu\n\nFunction:\n    A 4-bit ALU which can perform bitwise AND, bitwise OR, addition, and subtraction. The operation is determined by a 2-bit control signal.\n\nInput ports:\n    a [3:0]: 4-bit input operand A.\n    b [3:0]: 4-bit input operand B.\n    op [1:0]: 2-bit control signal to select the operation:\n              00 - bitwise AND\n              01 - bitwise OR\n              10 - addition\n              11 - subtraction\n\nOutput ports:\n    result [3:0]: 4-bit result of the operation.\n    carry_borrow: Carry out for addition and borrow flag for subtraction.\n\nImplementation:\n    The ALU operations are handled based on the `op` signal:\n    - 00: Performs bitwise AND using a series of AND gates.\n    - 01: Performs bitwise OR using a series of OR gates.\n    - 10: Performs addition using a 4-bit adder that also provides a carry output.\n    - 11: Performs subtraction using a 4-bit subtractor, where the borrow out is considered.\n    Each operation type is implemented in its own submodule: `bitwise_and`, `bitwise_or`, `adder_4bit`, and `subtractor_4bit`.\nGive me the complete code.\nmodule simple_alu(a, b, op, result, carry_borrow);"}, {"from": "gpt", "value": "module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n    wire [3:0] w_and, w_or, w_add, w_sub;\n    wire c_add, b_sub;\n\n    bitwise_and and_unit(a, b, w_and);\n    bitwise_or or_unit(a, b, w_or);\n    adder_4bit add_unit(a, b, w_add, c_add);\n    subtractor_4bit sub_unit(a, b, w_sub, b_sub);\n\n    assign result = (op == 2'b00) ? w_and :\n                    (op == 2'b01) ? w_or :\n                    (op == 2'b10) ? w_add :\n                    w_sub;\n                    \n    assign carry_borrow = (op == 2'b10) ? c_add : b_sub;\n\nendmodule\n\nmodule bitwise_and(input [3:0] a, input [3:0] b, output [3:0] out);\n    assign out = a & b;\nendmodule\n\nmodule bitwise_or(input [3:0] a, input [3:0] b, output [3:0] out);\n    assign out = a | b;\nendmodule\n\nmodule adder_4bit(input [3:0] a, input [3:0] b, output [3:0] sum, output carry);\n    assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_4bit(input [3:0] a, input [3:0] b, output [3:0] diff, output borrow);\n    assign {borrow, diff} = {1'b0, a} - {1'b0, b};\nendmodule\n"}], "task_id": "barrel_shifter_v_23"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [in input, code output, valid output, cb7 submodule, cb6 submodule, cb5 submodule, cb4 submodule, cb3 submodule, cb2 submodule, cb1 submodule, cb0 submodule], \nconnectivity: [[0, 0, 0, 0, 0, 0, 0, 0, 10, 9, 7, 6, 3, 8, 4, 5, 0], [3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1, 1, 1, 2]]\n, Design a Priority Encoder in Verilog, which encodes an 8-bit input into a 3-bit output code corresponding to the highest order '1' found in the input.\n\nModule name: \n    priority_encoder\n\nFunction:\n    An 8-bit Priority Encoder which scans the input from the most significant bit (MSB) to least significant bit (LSB). It outputs a 3-bit binary code representing the position of the highest order bit that is set to '1'. If no bits are set, an additional 'valid' output is set to '0'.\n\nInput ports:\n    in [7:0]: 8-bit input where each bit will be scanned to find the highest order '1'.\n\nOutput ports:\n    code [2:0]: 3-bit output code indicating the position of the first '1' from MSB.\n    valid: Output signal that indicates if the output code is valid (i.e., at least one '1' is present in the input).\n\nImplementation:\n    The priority encoder checks each bit of the input starting from the MSB using a series of conditional checks and logic gates. If a '1' is detected, the corresponding binary code for the position is set at the output. The output 'valid' is set to '1' if any '1' is detected across all bits; otherwise, it remains '0'.\n    The process involves using multiple instances of a `check_bit` submodule, which determines if the current inspected bit is '1' and if it is the highest order '1' found so far based on priority logic.\nGive me the complete code.\nmodule priority_encoder(in, code, valid);"}, {"from": "gpt", "value": "module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [7:0] found;\n\n    // Instance for each bit checking\n    check_bit cb7 (.in(in[7]), .found(found[7]));\n    check_bit cb6 (.in(in[6]), .found(found[6]));\n    check_bit cb5 (.in(in[5]), .found(found[5]));\n    check_bit cb4 (.in(in[4]), .found(found[4]));\n    check_bit cb3 (.in(in[3]), .found(found[3]));\n    check_bit cb2 (.in(in[2]), .found(found[2]));\n    check_bit cb1 (.in(in[1]), .found(found[1]));\n    check_bit cb0 (.in(in[0]), .found(found[0]));\n\n    assign valid = |in;  // valid is high if any bit in 'in' is high\n    assign code = found[7] ? 3'b111 :\n                  found[6] ? 3'b110 :\n                  found[5] ? 3'b101 :\n                  found[4] ? 3'b100 :\n                  found[3] ? 3'b011 :\n                  found[2] ? 3'b010 :\n                  found[1] ? 3'b001 :\n                  found[0] ? 3'b000 : 3'b000;\n\nendmodule\n\nmodule check_bit(in, found);\n    input in;\n    output found;\n    assign found = in;  // This module will output '1' if input is '1'\nendmodule\n"}], "task_id": "barrel_shifter_v_24"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [temp_sensor input, smoke_sensor input, alarm_out output, comp_temp submodule, or_gate submodule], \nconnectivity: [[0, 1, 3, 4], [3, 4, 4, 2]]\n, Design a digital alarm system using Verilog, which sets off an alarm based on predefined temperature and smoke sensor inputs. This system consists of an 8-bit temperature sensor input and a 1-bit smoke detector signal. An alarm is triggered if the temperature is above a threshold or if smoke is detected.\n\nModule name: \n    alarm_system\n\nFunction:\n    A digital alarm system that monitors signals from an 8-bit temperature sensor and a 1-bit smoke detector. The system triggers a 1-bit alarm output when the temperature exceeds a specified threshold or if smoke is detected.\n\nInput ports:\n    temp_sensor [7:0]: 8-bit input from the temperature sensor.\n    smoke_sensor [0]: 1-bit input indicating smoke detection.\n\nOutput ports:\n    alarm_out [0]: 1-bit output that triggers the alarm.\n\nImplementation:\n    The alarm system evaluates the inputs from the temperature sensor and the smoke detector. If the temperature value exceeds a pre-set threshold, or if the smoke detector signal is high, the alarm is triggered.\n    The system utilizes comparison logic to check if the temperature is above the threshold and a logical OR operation to evaluate the condition of either temperature or smoke triggering the alarm.\n    - The `compare_temp` submodule compares the 8-bit temperature input against a predefined threshold.\n    - The `or_logic` submodule takes the output from `compare_temp` and the smoke detector input to perform an OR operation, determining the final alarm state.\nGive me the complete code.\nmodule alarm_system (temp_sensor, smoke_sensor, alarm_out);"}, {"from": "gpt", "value": "module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input  [7:0] temp_sensor;\n    input  smoke_sensor;\n    output alarm_out;\n    wire temp_high;\n\n    // Instance of temperature comparison\n    compare_temp  comp_temp (.temp_in(temp_sensor), .temp_high(temp_high));\n\n    // Instance of OR logic to determine alarm state\n    or_logic  or_gate (.temp_high(temp_high), .smoke_signal(smoke_sensor), .alarm_out(alarm_out));\nendmodule\n\nmodule compare_temp(temp_in, temp_high);\n    input [7:0] temp_in;\n    output temp_high;\n    // Temperature threshold for comparison\n    parameter THRESHOLD = 8'h5A; // example threshold value (90 in decimal)\n    \n    assign temp_high = (temp_in > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic(temp_high, smoke_signal, alarm_out);\n    input temp_high, smoke_signal;\n    output alarm_out;\n    \n    assign alarm_out = temp_high | smoke_signal;\nendmodule\n"}], "task_id": "barrel_shifter_v_25"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, S output, C_out output, add1 submodule, add2 submodule, add3 submodule, add4 submodule], \nconnectivity: [[1, 0, 4, 1, 0, 1, 5, 0, 6, 1, 0, 7, 4, 6, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder using the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}, {"from": "gpt", "value": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry out\n\n    wire c4, c8, c12;\n\n    // Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry out\n\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire g1, g2, g3, g4;  // Generate signals\n    wire c1, c2, c3;      // Internal carry signals\n\n    // Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry in\n    output S;             // Sum output\n    output C_out;         // Carry out\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | ((A ^ B) & C_in); // Carry out calculation\nendmodule\n"}], "task_id": "sub_16bit_v_26"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, S output, C_out output, add1 submodule, add2 submodule, add3 submodule, add4 submodule], \nconnectivity: [[1, 0, 1, 4, 0, 5, 1, 0, 6, 1, 0, 5, 7, 6, 4, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit carry lookahead adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}, {"from": "gpt", "value": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry out\n\n    wire c4, c8, c12;\n\n    // Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry out\n\n    wire g1, g2, g3, g4;  // Generate signals\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire c1, c2, c3;      // Internal carry signals\n\n    // Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry in\n    output S;             // Sum output\n    output C_out;         // Carry out\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | ((A ^ B) & C_in); // Carry out calculation\nendmodule\n"}], "task_id": "sub_16bit_v_27"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [X input, Y input, P output, gen1 submodule, gen2 submodule], \nconnectivity: [[0, 1, 4, 3], [3, 4, 2, 2]]\n, Implement a module for a 16-bit parity generator which computes the even parity for two 8-bit inputs using a two-level hierarchical design.\n\nModule name:\n    parity_16bit               \nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\nOutput ports:\n    P: Single output representing the even parity of the combined 16 bits of X and Y.\n\nImplementation:\nThe top module parity_16bit consists of instances of 8-bit parity generator blocks, followed by a final parity computation of their outputs.\nGive me the complete code.\nmodule parity_16bit(X, Y, P);"}, {"from": "gpt", "value": "module parity_16bit(X, Y, P);\n    input [7:0] X;        // 8-bit input X\n    input [7:0] Y;        // 8-bit input Y\n    output P;             // Output parity\n\n    wire P_X, P_Y;\n\n    // Instantiate 8-bit parity generators\n    parity_8 gen1(\n        .data(X),\n        .parity(P_X)\n    );\n\n    parity_8 gen2(\n        .data(Y),\n        .parity(P_Y)\n    );\n\n    // Final parity calculation to combine parities from X and Y\n    assign P = P_X ^ P_Y;\n\nendmodule\n\nmodule parity_8(data, parity);\n    input [7:0] data;     // 8-bit data input\n    output parity;        // Output parity\n\n    assign parity = ^data; // XOR of all bits to calculate even parity\n\nendmodule\n"}], "task_id": "sub_16bit_v_28"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, S output, C_out output, add1 submodule, add2 submodule, add3 submodule, add4 submodule], \nconnectivity: [[1, 0, 1, 4, 0, 1, 5, 0, 1, 6, 0, 6, 4, 7, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}, {"from": "gpt", "value": "module add_16bit(A, B, S, C_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] S;      // 16-bit sum output\n    output C_out;         // Carry out\n\n    wire c4, c8, c12;\n\n    // Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input C_in;           // Carry in\n    output [4:1] S;       // 4-bit sum output\n    output C_out;         // Carry out\n\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire g1, g2, g3, g4;  // Generate signals\n    wire c1, c2, c3;      // Internal carry signals\n\n    // Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              // Input A\n    input B;              // Input B\n    input C_in;           // Carry in\n    output S;             // Sum output\n    output C_out;         // Carry out\n\n    assign S = A ^ B ^ C_in; // Sum calculation\n    assign C_out = (A & B) | ((A | B) & C_in); // Carry out calculation\nendmodule\n"}], "task_id": "sub_16bit_v_29"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a0 input, a1 input, a2 input, a3 input, b0 input, b1 input, b2 input, b3 input, sum0 output, sum1 output, sum2 output, sum3 output, au0 submodule, au1 submodule, au2 submodule, au3 submodule], \nconnectivity: [[0, 4, 5, 1, 6, 2, 3, 7, 12, 13, 14, 15], [12, 12, 13, 13, 14, 14, 15, 15, 8, 9, 10, 11]]\n, Implement a module of a parallel adder with 1x4 configuration in combinational logic.\n\nModule name:  \n    parallel_adder1x4               \nInput ports:\n    a0[7:0]: 8-bit input operand A0.\n    a1[7:0]: 8-bit input operand A1.\n    a2[7:0]: 8-bit input operand A2.\n    a3[7:0]: 8-bit input operand A3.\n    b0[7:0]: 8-bit input operand B0.\n    b1[7:0]: 8-bit input operand B1.\n    b2[7:0]: 8-bit input operand B2.\n    b3[7:0]: 8-bit input operand B3.\nOutput ports:\n    sum0[8:0]: 9-bit output representing the sum of A0 and B0.\n    sum1[8:0]: 9-bit output representing the sum of A1 and B1.\n    sum2[8:0]: 9-bit output representing the sum of A2 and B2.\n    sum3[8:0]: 9-bit output representing the sum of A3 and B3.\n\nImplementation:\nIn the parallel_adder1x4 module, four Adder Units (AU) are instantiated. Each AU performs the addition of its corresponding pair of inputs. AU0 (au0) computes the sum of inputs a0 and b0. AU1 (au1) computes the sum of inputs a1 and b1. AU2 (au2) computes the sum of inputs a2 and b2. AU3 (au3) computes the sum of inputs a3 and b3. Each AU outputs a result with a carry bit, which accommodates the possibility of overflow in binary addition. This arrangement ensures independent, simultaneous operations, promoting efficiency in operations such as vector addition.\nGive me the complete code.\nmodule parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);"}, {"from": "gpt", "value": "module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    // 4 AUs\n    AU au0(.a(a0), .b(b0), .sum(sum0));\n    AU au1(.a(a1), .b(b1), .sum(sum1));\n    AU au2(.a(a2), .b(b2), .sum(sum2));\n    AU au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AU(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule"}], "task_id": "systolic1x4_v_30"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, x0 input, x1 input, y0 input, y1 input, p0 output, p1 output, p2 output, p3 output, mult0 submodule, mult1 submodule, mult2 submodule, mult3 submodule], \nconnectivity: [[4, 0, 1, 2, 4, 3, 0, 1, 5, 0, 1, 2, 3, 5, 0, 1, 10, 11, 12, 13], [10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 6, 7, 8, 9]]\n, Design and implement a Verilog module for a 2x2 multiplier matrix using a row-wise computation method.\n\nModule name:  \n    matrix_multiplier2x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    x0[7:0]: 8-bit input operand X0.\n    x1[7:0]: 8-bit input operand X1.\n    y0[7:0]: 8-bit input operand Y0.\n    y1[7:0]: 8-bit input operand Y1.\nOutput ports:\n    p0[15:0]: 16-bit output representing the product of X0 and Y0.\n    p1[15:0]: 16-bit output representing the product of X1 and Y0.\n    p2[15:0]: 16-bit output representing the product of X0 and Y1.\n    p3[15:0]: 16-bit output representing the product of X1 and Y1.\n\nImplementation:\nIn the matrix_multiplier2x2 module, four multiplier units are instantiated, each performing multiplication of its designated pair of input operands. The first multiplier (mult0) processes x0 and y0 directly to compute p0. The second multiplier (mult1) processes x1 and y0 to compute p1. Similarly, mult2 multiplies x0 and y1 to compute p2, and mult3 multiplies x1 and y1 to compute p3. This arrangement allows for parallel computation of the matrix products, enhancing performance for applications requiring matrix operations.\nGive me the complete code.\nmodule matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);"}, {"from": "gpt", "value": "module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n    // Instantiate multiplier units\n    multiplier mult0(.clk(clk), .rst(rst), .a(x0), .b(y0), .result(p0));\n    multiplier mult1(.clk(clk), .rst(rst), .a(x1), .b(y0), .result(p1));\n    multiplier mult2(.clk(clk), .rst(rst), .a(x0), .b(y1), .result(p2));\n    multiplier mult3(.clk(clk), .rst(rst), .a(x1), .b(y1), .result(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= a * b;\n        end\n    end\nendmodule\n"}], "task_id": "systolic1x4_v_31"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [en input, rot_dir input, in_data input, out_data output, lr submodule, rr submodule], \nconnectivity: [[2, 2, 1, 0, 2, 5, 4], [4, 5, 3, 3, 3, 3, 3]]\n, Implement a module of a cyclic data rotator with a 4-bit configuration utilizing combinational logic.\n\nModule name:  \n    cyclic_rotator4              \nInput ports:\n    en: Enable signal, active high.\n    rot_dir: Rotation direction, 1 for left, 0 for right.\n    in_data[3:0]: 4-bit input data to rotate.\nOutput ports:\n    out_data[3:0]: 4-bit output data after rotation.\n\nImplementation:\nIn the cyclic_rotator4 module, two submodules are instantiated for each rotation direction: left_rotate and right_rotate. Based on the rot_dir input, the respective rotation submodule is activated to perform a one-bit position shift either to the left or right. The left_rotate submodule performs a cyclic shift to the left (e.g., 1001 becomes 0011), and the right_rotate submodule performs a cyclic shift to the right (e.g., 1001 becomes 1100). Each submodule uses bitwise concatenation and slicing to achieve the rotation. The top module uses a multiplexer controlled by the rot_dir input to select between the outputs of these two submodules, sending the result to the out_data output.\nGive me the complete code.\nmodule cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);"}, {"from": "gpt", "value": "module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n\nwire [3:0] left_rotated_data;\nwire [3:0] right_rotated_data;\n\nleft_rotate lr(\n    .data(in_data),\n    .rotated_data(left_rotated_data)\n);\n\nright_rotate rr(\n    .data(in_data),\n    .rotated_data(right_rotated_data)\n);\n\nassign out_data = (en) ? ((rot_dir) ? left_rotated_data : right_rotated_data) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  output [3:0] rotated_data\n);\n  assign rotated_data = {data[2:0], data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] rotated_data\n);\n  assign rotated_data = {data[0], data[3:1]};\nendmodule\n"}], "task_id": "systolic1x4_v_32"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, mode input, enable input, count output, counter_inst submodule], \nconnectivity: [[2, 3, 0, 1, 5], [5, 5, 5, 5, 4]]\n, Implement a module for a dual-mode counter that can operate in both up and down counting modes controlled by an external signal.\n\nModule name:  \n    dual_mode_counter               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    mode: Mode selection signal (0 for up-counting, 1 for down-counting).\n    enable: Counter enable signal.\nOutput ports:\n    count[7:0]: 8-bit output representing the current count value.\n\nImplementation:\nIn the dual_mode_counter module, a Counter submodule is instantiated. The Counter operates differently based on the mode signal. In up-counting mode, the count value increments each clock cycle when enable is high. In down-counting mode, the count decrements each cycle when enable is high. The count value is reset to zero when the reset signal is asserted.\nGive me the complete code.\nmodule dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);"}, {"from": "gpt", "value": "module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] next_count;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(next_count)\n  );\n  assign count = next_count;\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end\n    else if (enable) begin\n      if (mode == 0)  // 0 for up-counting\n        count <= count + 1;\n      else            // 1 for down-counting\n        count <= count - 1;\n    end\n  end\nendmodule\n"}], "task_id": "systolic1x2_v_33"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, reset input, d0 input, d1 input, load0 input, load1 input, q0 output, q1 output, latch0 submodule, latch1 submodule], \nconnectivity: [[2, 4, 0, 1, 5, 3, 0, 1, 8, 9], [8, 8, 8, 8, 9, 9, 9, 9, 6, 7]]\n, Design a Verilog module for a dual-latch system with separate input triggers.\n\nModule name:  \n    dual_latch_system               \nInput ports:\n    clk: Clock signal.\n    reset: Reset signal, active high.\n    d0[7:0]: 8-bit input data for first latch.\n    d1[7:0]: 8-bit input data for second latch.\n    load0: Load signal for first latch, active high.\n    load1: Load signal for second latch, active high.\nOutput ports:\n    q0[7:0]: 8-bit output from the first latch.\n    q1[7:0]: 8-bit output from the second latch.\n\nImplementation:\nIn the dual_latch_system module, two separate latches (latch0 and latch1) are instantiated. Each latch captures the input data when its respective load signal is asserted. The first latch (latch0) captures data from d0 on a positive edge of load0. The second latch (latch1) captures data from d1 on a positive edge of load1. Reset functionality is common for both latches, resetting their outputs to zero when the reset signal is active.\nGive me the complete code.\nmodule dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);"}, {"from": "gpt", "value": "module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    Latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(q0)\n    );\n    Latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(q1)\n    );\nendmodule\n\nmodule Latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 0;\n        end else if (load) begin\n            q <= d;\n        end\n    end\nendmodule\n"}], "task_id": "systolic1x2_v_34"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, load0 input, load1 input, data0 input, data1 input, shift0 input, shift1 input, out0 output, out1 output, sr0 submodule, sr1 submodule], \nconnectivity: [[0, 1, 6, 2, 4, 7, 0, 1, 3, 5, 10, 11], [10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 9]]\n, Design a Verilog module implementing a dual shift register system with individual load and shift control.\n\nModule name:\ndual_shift_register\n\nInput ports:\nclk: Clock signal.\nrst: Reset signal, active high.\nload0: Load control signal for shift register 0.\nload1: Load control signal for shift register 1.\ndata0[7:0]: 8-bit input data for shift register 0.\ndata1[7:0]: 8-bit input data for shift register 1.\nshift0: Shift control signal for shift register 0.\nshift1: Shift control signal for shift register 1.\n\nOutput ports:\nout0[7:0]: 8-bit output from shift register 0.\nout1[7:0]: 8-bit output from shift register 1.\n\nImplementation:\nThe dual_shift_register module consists of two distinct submodules, each being a shift register. Shift register 0 (sr0) loads data from data0 when load0 is high, otherwise it shifts its contents to the right when shift0 is high. Similarly, shift register 1 (sr1) operates with data1, load1, and shift1 signals.\nGive me the complete code.\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);"}, {"from": "gpt", "value": "module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    ShiftRegister sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n    ShiftRegister sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule ShiftRegister (\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= out >> 1; // shift right operation\n    end\nendmodule"}], "task_id": "systolic1x2_v_35"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [X input, Y input, Sum output, Carry_out output, adder0 submodule, adder1 submodule, adder2 submodule, adder3 submodule], \nconnectivity: [[1, 0, 4, 1, 0, 5, 1, 0, 6, 1, 0, 5, 4, 6, 7, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a 32-bit adder using submodules with multiple bit-level full adders in combinational logic.\n\nModule name:\n    adder_32bit\n\nInput ports:\n    X [31:0]: First 32-bit input operand (binary number to add).\n    Y [31:0]: Second 32-bit input operand (binary number to add).\nOutput ports:\n    Sum [31:0]: 32-bit output representing the sum of X and Y.\n    Carry_out: 1-bit output indicating the carry out of the addition.\n\nImplementation:\nAddition Logic: The module adds two 32-bit binary numbers X and Y using combinational logic.\nA carry propagation is handled, starting from the least significant bit to the most significant bit.\nCarry Generation: The full adder generates a carry which is passed to the next higher bit.\nModular Design:\nThe main module (adder_32bit) instantiates four 8-bit adder submodules (adder_8bit), each handling 8 bits of the input operands.\nThe outputs (Sum and Carry_out) are calculated through the cascading carries between submodules.\nGive me the complete code.\nmodule adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);"}, {"from": "gpt", "value": "module adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);\n\n    wire [3:0] carry;   // Internal carry wires between submodules\n\n    // Instantiate the four 8-bit adders\n    adder_8bit adder0 (\n        .a(X[7:0]),\n        .b(Y[7:0]),\n        .cin(1'b0),\n        .sum(Sum[7:0]),\n        .cout(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .a(X[15:8]),\n        .b(Y[15:8]),\n        .cin(carry[0]),\n        .sum(Sum[15:8]),\n        .cout(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .a(X[23:16]),\n        .b(Y[23:16]),\n        .cin(carry[1]),\n        .sum(Sum[23:16]),\n        .cout(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .a(X[31:24]),\n        .b(Y[31:24]),\n        .cin(carry[2]),\n        .sum(Sum[31:24]),\n        .cout(Carry_out)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a,    // 8-bit part of the first operand\n    input [7:0] b,    // 8-bit part of the second operand\n    input cin,        // Carry input from the previous stage\n    output [7:0] sum, // Sum output of this stage\n    output cout       // Carry output of this stage\n);\n\n    // Logic to perform bit-wise addition\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n"}], "task_id": "comparator_32bit_v_36"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, Cin input, Sum output, Cout output, add0 submodule, add1 submodule, add2 submodule, add3 submodule], \nconnectivity: [[1, 2, 0, 5, 1, 0, 1, 6, 0, 1, 7, 0, 5, 8, 7, 6, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Design a 32-bit adder using Verilog, incorporating a set of 8-bit submodules for the addition process. Each submodule should perform 8-bit addition with carry in and carry out.\n\nModule name:\n    adder_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand for addition.\n    B [31:0]: Second 32-bit input operand for addition.\n    Cin: Carry input for the least significant bit addition.\nOutput ports:\n    Sum [31:0]: 32-bit output sum of A and B.\n    Cout: Carry output from the most significant bit addition.\n\nImplementation:\nAddition Logic: The module adds two 32-bit numbers A and B by using cascaded 8-bit adder submodules that handle carry propagation.\nModular Design: The main module (adder_32bit) instantiates four 8-bit adder submodules (adder_8bit). Carry outputs of each submodule are chained to the carry inputs of the next higher submodule, starting from the least significant to the most significant.\nGive me the complete code.\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);"}, {"from": "gpt", "value": "module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire C1, C2, C3;\n\n    adder_8bit add0 (\n        .a(A[7:0]),\n        .b(B[7:0]),\n        .cin(Cin),\n        .sum(Sum[7:0]),\n        .cout(C1)\n    );\n\n    adder_8bit add1 (\n        .a(A[15:8]),\n        .b(B[15:8]),\n        .cin(C1),\n        .sum(Sum[15:8]),\n        .cout(C2)\n    );\n\n    adder_8bit add2 (\n        .a(A[23:16]),\n        .b(B[23:16]),\n        .cin(C2),\n        .sum(Sum[23:16]),\n        .cout(C3)\n    );\n\n    adder_8bit add3 (\n        .a(A[31:24]),\n        .b(B[31:24]),\n        .cin(C3),\n        .sum(Sum[31:24]),\n        .cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n"}], "task_id": "comparator_32bit_v_37"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, op input, result output, carry_out output, add_inst submodule, sub_inst submodule, and_inst submodule], \nconnectivity: [[1, 0, 1, 0, 1, 0, 7, 5, 2, 6, 5, 2, 6], [5, 5, 6, 6, 7, 7, 3, 3, 3, 3, 4, 4, 4]]\n, Implement a module of a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, and bitwise AND operation using submodules for each function in combinational logic.\n\nModule name:\n    alu_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand.\n    B [31:0]: Second 32-bit input operand.\n    op [1:0]: Operation selector where 00 = addition, 01 = subtraction, 10 = AND.\n\nOutput ports:\n    result [31:0]: 32-bit output result of the selected operation.\n    carry_out: 1-bit output for carry (relevant in addition and subtraction).\n\nImplementation:\nOperational Logic: The ALU selects between addition, subtraction, and AND operations based on the operation selector 'op'.\nAdder and subtractor modules handle arithmetic operations, generating both result and carry/borrow outputs.\nAND operation is handled by a separate bitwise AND submodule.\nThe top module (alu_32bit) instantiates these submodules and uses multiplexing logic to choose the correct output based on the operation selected.\nGive me the complete code.\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);"}, {"from": "gpt", "value": "module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] and_result;\n    wire sum_carry_out;\n    wire diff_borrow_out;\n\n    // Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .sum(sum),\n        .carry_out(sum_carry_out)\n    );\n\n    // Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow_out(diff_borrow_out)\n    );\n\n    // Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .and_result(and_result)\n    );\n\n    // Multiplexer for selecting operation result\n    assign result = (op == 2'b00) ? sum :\n                    (op == 2'b01) ? diff :\n                    (op == 2'b10) ? and_result : 32'bx;\n\n    // Multiplexer for carry output\n    assign carry_out = (op == 2'b00) ? sum_carry_out :\n                       (op == 2'b01) ? diff_borrow_out : 1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow_out\n);\n    assign {borrow_out, diff} = A - B;\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n"}], "task_id": "comparator_32bit_v_38"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, sel input, d0 input, d1 input, d2 input, data_out output, mux0 submodule, mux1 submodule, mux2 submodule], \nconnectivity: [[1, 2, 0, 3, 1, 0, 1, 0, 4, 7, 6, 1, 8], [6, 6, 6, 7, 7, 7, 8, 8, 8, 5, 5, 5, 5]]\n, A data multiplexer module designed to select and output data based on priority control signals. The module segregates input data streams and channels them through specific paths based on control signals, utilizing submodules for the multiplexing process.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    sel [2:0]: Selection signal determining the active data input path (0 for path1, 1 for path2, and so forth).\n    d0 [7:0]: 8-bit data input from path 0.\n    d1 [7:0]: 8-bit data input from path 1.\n    d2 [7:0]: 8-bit data input from path 2.\n\nOutput ports:\n    data_out [7:0]: 8-bit data output reflecting the selected input data.\n\nImplementation:\n    The data multiplexer utilizes three submodules, each handling one data input path.\n    Based on the selection signal sel:\n    - If sel is 3'b000, data is fetched from the first path (mux_path0).\n    - If sel is 3'b001, data is fetched from the second path (mux_path1).\n    - If sel is 3'b010, data is fetched from the third path (mux_path2).\n    The output data_out is assigned the output from the active submodule based on the selection signal.\nGive me the complete code.\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);"}, {"from": "gpt", "value": "module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    // Submodule for data paths\n    wire [7:0] path0_out, path1_out, path2_out;\n\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel),\n        .data(d0),\n        .path_out(path0_out),\n        .sel_code(3'b000) // Path 0 selection code\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel),\n        .data(d1),\n        .path_out(path1_out),\n        .sel_code(3'b001) // Path 1 selection code\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel),\n        .data(d2),\n        .path_out(path2_out),\n        .sel_code(3'b010) // Path 2 selection code\n    );\n\n    // Output assignment using a multiplexer logic\n    assign data_out = (sel == 3'b000) ? path0_out :\n                      (sel == 3'b001) ? path1_out :\n                      (sel == 3'b010) ? path2_out : 8'd0;\n\nendmodule\n\n// Submodule for handling each data path\nmodule mux_path (\n    input clk,\n    input [2:0] sel,\n    input [7:0] data,\n    output reg [7:0] path_out,\n    input [2:0] sel_code // Path selection code\n);\n\n    always @(posedge clk) begin\n        if (sel == sel_code) begin\n            path_out <= data; // Pass data if selection matches\n        end else begin\n            path_out <= path_out; // Retain previous value\n        end\n    end\n\nendmodule"}], "task_id": "instr_reg_v_39"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, sel input, in0 input, in1 input, in2 input, in3 input, out output, hold0 submodule, hold1 submodule, hold2 submodule, hold3 submodule], \nconnectivity: [[2, 1, 0, 0, 1, 3, 4, 1, 0, 1, 0, 5, 10, 1, 8, 9, 7], [7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 6, 6, 6, 6, 6]]\n, A data multiplexer module designed to route data from multiple inputs to a single output based on a control signal. This module uses submodules for handling data from various sources, aggregating the selected data into a single output channel for downstream processing.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    sel [1:0]: Control signal to select the input source.\n    in0 [7:0]: 8-bit data from input source 0.\n    in1 [7:0]: 8-bit data from input source 1.\n    in2 [7:0]: 8-bit data from input source 2.\n    in3 [7:0]: 8-bit data from input source 3.\n\nOutput ports:\n    out [7:0]: The selected 8-bit data output.\n\nImplementation:\n    The data multiplexer is implemented using four submodules, each responsible for holding data from a distinct source.\n    On the rising edge of the clock (clk), if the sel signal selects an input, the corresponding submodule outputs its stored data to the main output.\n    Each submodule reacts to changes in the input data when the selection signal matches its specific code, otherwise it retains the previous value.\n    The output port out directly reflects the data from the selected submodule.\nGive me the complete code.\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);"}, {"from": "gpt", "value": "module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] out0, out1, out2, out3;\n\n    data_holder hold0 (\n        .clk(clk),\n        .data(in0),\n        .out(out0),\n        .sel_code(2'b00),\n        .sel(sel)\n    );\n\n    data_holder hold1 (\n        .clk(clk),\n        .data(in1),\n        .out(out1),\n        .sel_code(2'b01),\n        .sel(sel)\n    );\n\n    data_holder hold2 (\n        .clk(clk),\n        .data(in2),\n        .out(out2),\n        .sel_code(2'b10),\n        .sel(sel)\n    );\n\n    data_holder hold3 (\n        .clk(clk),\n        .data(in3),\n        .out(out3),\n        .sel_code(2'b11),\n        .sel(sel)\n    );\n\n    // Output assignment based on selection\n    assign out = (sel == 2'b00) ? out0 :\n                 (sel == 2'b01) ? out1 :\n                 (sel == 2'b10) ? out2 :\n                 out3;\n\nendmodule\n\n// Submodule for holding data\nmodule data_holder (\n    input clk,\n    input [7:0] data,\n    output reg [7:0] out,\n    input [1:0] sel_code,\n    input [1:0] sel\n);\n\n    always @(posedge clk) begin\n        if (sel == sel_code) begin\n            out <= data; // Load data if selected\n        end else begin\n            out <= out; // Maintain current data if not selected\n        end\n    end\n\nendmodule"}], "task_id": "instr_reg_v_40"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, duty_cycle input, freq input, pwm_out output, pc submodule, ps submodule], \nconnectivity: [[2, 0, 2, 0, 4, 1, 5], [4, 4, 5, 5, 5, 5, 3]]\n, Design and implement a pulse width modulation (PWM) signal generator in Verilog, which uses adjustable duty cycle and frequency settings. The design consists of a submodule for maintaining the PWM count and another submodule for generating the PWM signal based on the count and settings.\n\nModule Name:\n    pwm_generator\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] duty_cycle: Specifies the duty cycle percentage of the PWM signal.\n    [7:0] freq: Frequency control, setting the PWM signal frequency.\n\nOutput Ports:\n    pwm_out: Pulse width modulated output signal.\n\nInternal Modules:\n    PWM Counter Module (pwm_counter)\n    Functionality: Maintains the PWM cycle count and resets based on the frequency.\n    Input Ports:\n    clk: Clock signal.\n    reset: Signal to reset the counter.\n    [7:0] freq: Frequency setting for PWM cycle.\n    Output Ports:\n    [15:0] count: Current PWM cycle count.\n    \n    PWM Signal Generator Module (pwm_signal)\n    Functionality: Generates the PWM output signal based on the current count and duty cycle settings.\n    Input Ports:\n    clk: Clock signal.\n    [15:0] count: Current count from the pwm_counter.\n    [7:0] duty_cycle: Duty cycle percentage.\n    [7:0] freq: Frequency setting for PWM cycle.\n    Output Ports:\n    pwm_out: PWM output signal.\n\nImplementation:\nPWM Counter Operation: The pwm_counter module increments the count on each rising edge of clk. When the count reaches (freq - 1), it resets to 0.\nPWM Signal Generation: The pwm_signal module produces a high output on pwm_out when the count is less than (freq * duty_cycle / 100), otherwise low. The pulse width is adjusted according to duty_cycle.\nGive me the complete code.\nmodule pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);"}, {"from": "gpt", "value": "module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] pwm_count;\n    wire reset;\n\n    // Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(pwm_count)\n    );\n\n    // Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(pwm_count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\n    // Reset logic\n    assign reset = (freq == 0);\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count >= freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle / 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule"}], "task_id": "square_wave_v_41"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, duty_cycle input, pwm_out output, duty_ctrl submodule, pulse_gen submodule], \nconnectivity: [[0, 1, 3, 0, 4], [3, 3, 4, 4, 2]]\n, Design a pulse width modulation (PWM) controller using Verilog that adjusts the duty cycle of the output PWM signal based on an 8-bit input control value. The system includes submodules for pulse generation and duty cycle control.\n\nModule Name:\n    pwm_controller\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] duty_cycle: Control value defining the duty cycle of the PWM signal.\n\nOutput Ports:\n    pwm_out: PWM output signal.\n\nInternal Modules:\n    Pulse Generator Module (pulse_gen)\n    Functionality: Generates pulses based on the current duty cycle setting.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] duty_cycle: 8-bit value determining pulse width.\n    Output Ports:\n    pwm_out: PWM output signal.\n\n    Duty Cycle Controller Module (duty_ctrl)\n    Functionality: Manages the adjustment of the duty cycle based on input control.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] duty_cycle: 8-bit control input.\n    Output Ports:\n    [7:0] adjusted_duty: Adjusted duty cycle setting.\n\nImplementation:\nPulse Generation: The pulse_gen module outputs high or low signals on pwm_out based on comparison between an internal counter and the adjusted_duty value.\nDuty Cycle Adjustment: The duty_ctrl module produces an adjusted duty cycle which dynamically changes the output pulse width by modifying internal settings according to the input duty_cycle value.\nGive me the complete code.\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);"}, {"from": "gpt", "value": "module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    // Instance of Duty Cycle Controller\n    duty_cycle_controller duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    // Instance of Pulse Generator\n    pulse_generator pulse_gen (\n        .clk(clk),\n        .adjusted_duty(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_cycle_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle; // Placeholder for more complex logic if needed\n    end\n\nendmodule\n\nmodule pulse_generator(\n    input clk,\n    input [7:0] adjusted_duty,\n    output reg pwm_out\n);\n    reg [7:0] counter = 0;\n\n    always @(posedge clk) begin\n        if (counter < adjusted_duty)\n            pwm_out <= 1;\n        else\n            pwm_out <= 0;\n\n        counter <= (counter == 255) ? 0 : counter + 1;\n    end\n\nendmodule\n"}], "task_id": "square_wave_v_42"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, equal output, comp8_inst1 submodule, comp8_inst2 submodule, comp8_inst3 submodule, comp8_inst4 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 5, 4, 6, 3], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Design and implement a 32-bit comparator module in Verilog which uses hierarchical structure with 8-bit comparator submodules.\n\nModule name:  \n    comparator_32bit               \nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\nOutput ports:\n    equal: Output signal that is high when A equals B.\n\nImplementation:\nThe comparator_32bit module should utilize four instances of an 8-bit comparator submodule. Each submodule compares corresponding sections of the inputs and the results are combined to produce the final output.\nGive me the complete code.\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);"}, {"from": "gpt", "value": "module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n\n    wire [3:0] equal_parts;\n\n    compare8 comp8_inst1 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_parts[3])\n    );\n\n    compare8 comp8_inst2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_parts[2])\n    );\n\n    compare8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_parts[1])\n    );\n\n    compare8 comp8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_parts[0])\n    );\n\n    assign equal = &(equal_parts);\n\nendmodule\n\nmodule compare8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n\n    assign equal = (a == b);\n\nendmodule\n"}], "task_id": "adder_16bit_v_43"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [x input, y input, prod output, mult8_inst1 submodule, mult8_inst2 submodule, mult8_inst3 submodule, mult8_inst4 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 6, 3, 4, 5], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Design a 32-bit binary multiplier using combinational logic that multiplies two 16-bit binary numbers.\n\nModule name:  \n    multiplier_32bit               \nInput ports:\n    x[15:0]: 16-bit input operand X.\n    y[15:0]: 16-bit input operand Y.\nOutput ports:\n    prod[31:0]: 32-bit output representing the product of X and Y.\n\nImplementation:\nIn the multiplier_32bit module, you will need to design a smaller bit-width multiplier (8-bit multiplier), which will be instantiated multiple times.\nGive me the complete code.\nmodule multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);"}, {"from": "gpt", "value": "module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [15:0] p1, p2, p3, p4;\n    wire [23:0] temp1, temp2, temp3, temp4;\n\n    mult8 mult8_inst1 (\n        .a(x[7:0]),\n        .b(y[7:0]),\n        .p(p1)\n    );\n\n    mult8 mult8_inst2 (\n        .a(x[7:0]),\n        .b(y[15:8]),\n        .p(p2)\n    );\n\n    mult8 mult8_inst3 (\n        .a(x[15:8]),\n        .b(y[7:0]),\n        .p(p3)\n    );\n\n    mult8 mult8_inst4 (\n        .a(x[15:8]),\n        .b(y[15:8]),\n        .p(p4)\n    );\n\n    assign temp1 = {8'b0, p1};\n    assign temp2 = {p2, 8'b0};\n    assign temp3 = {p3, 8'b0};\n    assign temp4 = {p4, 16'b0};\n\n    assign prod = temp1 + temp2 + temp3 + temp4;\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [15:0] p\n);\n\n    wire [15:0] partial [7:0];\n\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : bit_multiply\n            assign partial[i] = (b[i] ? (a << i) : 16'b0);\n        end\n    endgenerate\n\n    assign p = partial[0] + partial[1] + partial[2] + partial[3] + partial[4] + partial[5] + partial[6] + partial[7];\n\nendmodule\n"}], "task_id": "adder_16bit_v_44"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [din input, dout output, br1 submodule, br2 submodule], \nconnectivity: [[0, 2, 3], [2, 3, 1]]\n, Design a Verilog top-level module named `bitwise_reverse8` that includes a module `bit_reverse` to reverse the order of bits in an 8-bit input. The top module should instantiate two separate `bit_reverse` modules. The first module reverses the input data `din`, and the second module reverses the output of the first module, effectively returning the original order but through two stages of processing.\n\nModule name:\n    bitwise_reverse8\n\nInput ports:\n    din [7:0]: 8-bit data input whose bits are to be reversed.\n\nOutput ports:\n    dout [7:0]: 8-bit output data, which is the twice reversed input data (original order restored).\n\nImplementation:\nThe top module, `bitwise_reverse8`, instantiates two `bit_reverse` modules. The first module reverses the bits of the input `din`, and the second module reverses the bits of the output from the first module. This design demonstrates bit manipulation and module instantiation for creating a data flow through multiple processing stages.\nGive me the complete code.\nmodule bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);"}, {"from": "gpt", "value": "module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] temp;\n\n    // Instantiating the first bit reversing module\n    bit_reverse br1 (\n        .data_in(din),\n        .data_out(temp)\n    );\n\n    // Instantiating the second bit reversing module\n    bit_reverse br2 (\n        .data_in(temp),\n        .data_out(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(*) begin\n        data_out[0] = data_in[7];\n        data_out[1] = data_in[6];\n        data_out[2] = data_in[5];\n        data_out[3] = data_in[4];\n        data_out[4] = data_in[3];\n        data_out[5] = data_in[2];\n        data_out[6] = data_in[1];\n        data_out[7] = data_in[0];\n    end\nendmodule\n"}], "task_id": "shift8_v_45"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, ctrl input, sum output, adder submodule], \nconnectivity: [[0, 1, 4], [4, 4, 3]]\n, Design a Verilog module named `adder_selector` that performs an 8-bit addition of two input numbers (a, b). The module should also have a submodule that decides if the result should be output directly or zeroed based on a control signal (ctrl). If ctrl is high, output the result of the addition; if ctrl is low, output zero.\n\nModule name:\n    adder_selector\n\nInput ports:\n    a [7:0]: 8-bit input representing the first number.\n    b [7:0]: 8-bit input representing the second number.\n    ctrl: Control signal that determines the output behavior.\n\nOutput ports:\n    sum [7:0]: The 8-bit output which is either the sum of a and b or zero based on the ctrl signal.\n\nImplementation:\nThe top_module `adder_selector` contains an instance of an 8-bit adder `my_adder8` and uses a conditional statement in always block to decide the output based on ctrl signal. It sets the output `sum` to either the result of the addition or zero.\nGive me the complete code.\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);"}, {"from": "gpt", "value": "module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] adder_out;\n\n    // Instantiating the 8-bit adder\n    my_adder8 adder (.a(a), .b(b), .sum(adder_out));\n\n    // Conditional output logic based on ctrl signal\n    always @(*) begin\n        if (ctrl)\n            sum = adder_out;\n        else\n            sum = 8'b0;\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b; // Simple addition\nendmodule\n"}], "task_id": "shift8_v_46"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [CLK_in input, RST input, PWM_25 output, PWM_50 output, PWM_75 output, pwm_module_25 submodule, pwm_module_50 submodule, pwm_module_75 submodule], \nconnectivity: [[1, 0, 1, 0, 1, 0, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular pulse width modulator (PWM) that generates three different duty cycles from a base clock of 100MHz. The three output signals should have duty cycles of 25%, 50%, and 75%.\n\nModule name:\n    pwm_gen\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    PWM_25: Output PWM signal with a duty cycle of 25%.\n    PWM_50: Output PWM signal with a duty cycle of 50%.\n    PWM_75: Output PWM signal with a duty cycle of 75%.\n\nImplementation:\nThe module uses three submodules to generate the required PWM signals:\npwm_25 generates the PWM signal with a 25% duty cycle by comparing a running counter to a fixed threshold.\npwm_50 generates the PWM signal with a 50% duty cycle by comparing a running counter to a fixed threshold.\npwm_75 generates the PWM signal with a 75% duty cycle by comparing a running counter to a fixed threshold.\nEach submodule increments its counter on every positive edge of CLK_in or resets it when RST is active. If RST is asserted, the PWM outputs are set to 0. Otherwise, the counters are compared to their respective thresholds to set the PWM outputs.\nGive me the complete code.\nmodule pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);"}, {"from": "gpt", "value": "module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire pwm_25_out;\n    wire pwm_50_out;\n    wire pwm_75_out;\n\n    pwm_25 pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_50 pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_75 pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    // Assign outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n// Submodule for 25% duty cycle PWM generation\nmodule pwm_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt < 25)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n\n            cnt <= (cnt == 99) ? 0 : cnt + 1;\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle PWM generation\nmodule pwm_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt < 50)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n\n            cnt <= (cnt == 99) ? 0 : cnt + 1;\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle PWM generation\nmodule pwm_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt < 75)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n\n            cnt <= (cnt == 99) ? 0 : cnt + 1;\n        end\n    end\nendmodule\n"}], "task_id": "freq_div_v_47"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [CLK_in input, RST input, PWM_25 output, PWM_50 output, PWM_75 output, pwm_duty_25 submodule, pwm_duty_50 submodule, pwm_duty_75 submodule], \nconnectivity: [[1, 0, 1, 0, 1, 0, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular pulse width modulator (PWM) that generates three distinct PWM signals based on a fixed 100MHz input clock. The module should produce PWM signals with 25%, 50%, and 75% duty cycles.\n\nModule name:\n    pwm_generator\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    PWM_25: PWM output with a 25% duty cycle.\n    PWM_50: PWM output with a 50% duty cycle.\n    PWM_75: PWM output with a 75% duty cycle.\n\nImplementation:\nThe module uses three submodules to generate the required PWM signals:\npwm_25 generates the PWM signal with a 25% duty cycle.\npwm_50 generates the PWM signal with a 50% duty cycle.\npwm_75 generates the PWM signal with a 75% duty cycle.\nEach submodule counts clock cycles to determine the duration of the high and low states of the output, resetting the count either when it reaches the full cycle count or when RST is active. If RST is asserted, all PWM outputs are reset to 0.\nGive me the complete code.\nmodule pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);"}, {"from": "gpt", "value": "module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    // Submodule instances\n    wire pwm_25_out;\n    wire pwm_50_out;\n    wire pwm_75_out;\n\n    pwm_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    // Assign outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n// Submodule for 25% duty cycle PWM generation\nmodule pwm_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 1'b0;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            PWM_out <= (cnt < 25) ? 1'b1 : 1'b0;\n            if (cnt >= 99) cnt <= 0;\n        end\n    end\nendmodule\n\n// Submodule for 50% duty cycle PWM generation\nmodule pwm_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 1'b0;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            PWM_out <= (cnt < 50) ? 1'b1 : 1'b0;\n            if (cnt >= 99) cnt <= 0;\n        end\n    end\nendmodule\n\n// Submodule for 75% duty cycle PWM generation\nmodule pwm_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 1'b0;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            PWM_out <= (cnt < 75) ? 1'b1 : 1'b0;\n            if (cnt >= 99) cnt <= 0;\n        end\n    end\nendmodule\n"}], "task_id": "freq_div_v_48"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, pwm_out output, u_counter submodule, u_comparator submodule], \nconnectivity: [[0, 1, 3, 4], [3, 3, 4, 2]]\n, A pulse width modulator (PWM) that controls the output pulse width based on an adjustable duty cycle. The module generates PWM signals with a duty cycle value provided as a parameter.\n\nModule name:\n    pwm_controller\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the PWM generator.\n\nOutput ports:\n    pwm_out: PWM output signal.\n\nImplementation:\n\nThe module generates a PWM signal with a duty cycle defined by the parameter DUTY_CYCLE, which defaults to 50%.\nIt consists of two submodules: `counter` which is a simple up-counter, and `comparator` that compares the counter value to the duty cycle threshold. \nThe `counter` counts up to a MAX_COUNT value and resets, providing a basis for PWM period.\nThe `comparator` outputs a high signal when the counter value is less than the duty cycle threshold, thus controlling the duty cycle of the PWM.\nThe active low reset signal rst_n initializes the counter.\nGive me the complete code.\nmodule pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);"}, {"from": "gpt", "value": "module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    // Parameters for PWM configuration\n    parameter DUTY_CYCLE = 50; // 50% duty cycle\n    parameter MAX_COUNT = 100; // Full cycle count\n\n    wire [6:0] count_value; // assuming 7-bit for 100 max count\n    wire pwm_signal;\n\n    // Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count_value)\n    );\n\n    // Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE), .MAX_COUNT(MAX_COUNT)) u_comparator (\n        .count(count_value),\n        .pwm(pwm_signal)\n    );\n\n    // Assign the comparator output to the PWM output\n    assign pwm_out = pwm_signal;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [6:0] count\n);\n    parameter MAX_COUNT = 100;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else begin\n            if (count >= MAX_COUNT - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule comparator(\n    input [6:0] count,\n    output reg pwm\n);\n    parameter DUTY_CYCLE = 50;\n    parameter MAX_COUNT = 100;\n\n    always @(*) begin\n        if (count < (MAX_COUNT * DUTY_CYCLE / 100)) begin\n            pwm = 1'b1;\n        end else begin\n            pwm = 1'b0;\n        end\n    end\nendmodule\n"}], "task_id": "freq_divbyodd_v_49"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, multc input, y output, msb output, lsb output, zero output, mult_signed submodule, mult_unsigned submodule], \nconnectivity: [[0, 1, 0, 1, 2, 7, 8, 2, 7, 8, 2, 7, 8, 2, 7, 8], [7, 7, 8, 8, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]]\n, Design a modular multiplier for a 32-bit processor using Verilog. The input operands a and b are both 32-bit, and the operation to be executed is defined by the signal multc, which selects between signed and unsigned multiplication. The 64-bit output y outputs the result of the operation, with the msb and lsb outputs indicating the most and least significant bits of the result respectively. The zero output indicates if the result is zero.\n\nThe operations and their corresponding opcodes are:\n- MULT (signed multiplication): 1'b0\n- MULTU (unsigned multiplication): 1'b1\n\nModule name:\nmultiplier\n\nInput ports:\na: a 32-bit input operand\nb: a 32-bit input operand\nmultc: a 1-bit control signal for selecting the operation type\n\nOutput ports:\ny: a 64-bit output representing the result of the multiplication\nmsb: a 32-bit output representing the most significant bits of the result\nlsb: a 32-bit output representing the least significant bits of the result\nzero: a 1-bit output indicating whether the result is zero\n\nImplementation:\nThe module incorporates submodules for both signed and unsigned multiplication, selecting the result based on the multc control signal.\nGive me the complete code.\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\nwire [63:0] mult_signed_result, mult_unsigned_result;\n\n// Instantiate multiplication operations\nsigned_mult mult_signed(.a(a), .b(b), .result(mult_signed_result));\nunsigned_mult mult_unsigned(.a(a), .b(b), .result(mult_unsigned_result));\n\n// Result selection based on multc\nassign y = (multc == 1'b0) ? mult_signed_result : mult_unsigned_result;\nassign msb = y[63:32];\nassign lsb = y[31:0];\nassign zero = (y == 64'b0);\n\nendmodule\n\n// Submodules definition\nmodule signed_mult(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = $signed(a) * $signed(b);\nendmodule\n\nmodule unsigned_mult(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n"}], "task_id": "alu_v_50"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, en input, count_out output, overflow output, u_count_control submodule, u_overflow_detection submodule], \nconnectivity: [[0, 2, 1, 5, 5, 6], [5, 5, 5, 6, 3, 4]]\n, Design a modular Verilog system for a 4-bit binary up-counter with asynchronous reset and enable control. The system increments the count on each rising edge of the clock if the enable signal is high. When the asynchronous reset is activated (active high), the counter resets to zero. The final count should be displayed continuously on the output port with an overflow flag indicating when the counter wraps around from the maximum count back to zero.\n\nModule name:\n    binary_up_counter\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Asynchronous reset signal (active high).\n    en: Enable signal to control the counting.\nOutput ports:\n    count_out[3:0]: 4-bit output displaying the current count.\n    overflow: Output signal that indicates an overflow condition (set high on wrap-around).\n\nImplementation:\nThe design consists of the following submodules:\n1. Count Control Module: Manages the count increment and initializes count on reset.\n2. Overflow Detection Module: Detects and outputs an overflow condition when the counter wraps around.\nGive me the complete code.\nmodule binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\nmodule binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire wrap_around;\n\n    // Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count),\n        .wrap_around(wrap_around)\n    );\n\n    // Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .wrap_around(wrap_around),\n        .overflow(overflow)\n    );\n\n    assign count_out = count;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg [3:0]   count,\n    output              wrap_around\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n        end\n        else if (en) begin\n            if (count == 4'b1111) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign wrap_around = (count == 4'b1111) && en;\n\nendmodule\n\nmodule overflow_detection (\n    input               wrap_around,\n    output reg          overflow\n);\n\n    always @(posedge wrap_around) begin\n        overflow <= 1'b1;\n    end\n\n    always @(negedge wrap_around) begin\n        overflow <= 1'b0;\n    end\n\nendmodule\n"}], "task_id": "accu_v_51"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, op_code input, operand_a input, operand_b input, result output, add submodule, subtract submodule, bitwise_and submodule, bitwise_or submodule], \nconnectivity: [[4, 3, 4, 3, 4, 3, 4, 3, 7, 9, 6, 8], [6, 6, 7, 7, 8, 8, 9, 9, 5, 5, 5, 5]]\n, Implement a simple arithmetic logic unit (ALU) that performs four functions: addition, subtraction, bitwise AND, and bitwise OR operations based on a 2-bit control input.\n\nModule name:\n    simple_alu\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op_code[1:0]: Control signal to choose the operation (00 for addition, 01 for subtraction, 10 for AND, 11 for OR).\n    operand_a[31:0]: 32-bit input operand A.\n    operand_b[31:0]: 32-bit input operand B.\nOutput ports:\n    result[31:0]: 32-bit result of the operation.\n\nImplementation:\nIn the simple_alu module, four operations are instantiated: add, subtract, bitwise_and, and bitwise_or. The add module performs addition of operand_a and operand_b. The subtract module performs subtraction of operand_b from operand_a. The bitwise_and module performs a bitwise AND operation between operand_a and operand_b. The bitwise_or module performs a bitwise OR operation between operand_a and operand_b. The selected result from these operations is output based on the op_code input.\nGive me the complete code.\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);"}, {"from": "gpt", "value": "`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\n// Operation results\nwire [31:0] res_add, res_sub, res_and, res_or;\n\n// Instantiate operation modules\nadd_operation add(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_add)\n);\n\nsubtract_operation subtract(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_sub)\n);\n\nand_operation bitwise_and(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_and)\n);\n\nor_operation bitwise_or(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_or)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= res_add;\n            `SUB_OP: result <= res_sub;\n            `AND_OP: result <= res_and;\n            `OR_OP: result <= res_or;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\n// Addition module\nmodule add_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a + b;\nendmodule\n\n// Subtraction module\nmodule subtract_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a - b;\nendmodule\n\n// AND operation module\nmodule and_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a & b;\nendmodule\n\n// OR operation module\nmodule or_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a | b;\nendmodule"}], "task_id": "stagepipe5_v_52"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, eq output, gt output, lt output, comp_slice1 submodule, comp_slice2 submodule, comp_slice3 submodule, comp_slice4 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 7, 8, 6, 5, 7, 8, 6, 5, 7, 8, 6, 5], [5, 5, 6, 6, 7, 7, 8, 8, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]]\n, Implement a module of a 16-bit comparator using combinational logic that outputs equality, greater than, and less than signals.\n\nModule name:\n    comparator_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\nOutput ports:\n    eq: Output signal that is high if A equals B.\n    gt: Output signal that is high if A is greater than B.\n    lt: Output signal that is high if A is less than B.\n\nImplementation:\nThe comparator_16bit is built using multiple 4-bit comparator slices. Each 4-bit comparator slice outputs local equality, greater than, and less than signals. These outputs are then combined in a hierarchical manner to deduce the overall relationship between the 16-bit inputs A and B.\nGive me the complete code.\nmodule comparator_16bit(a, b, eq, gt, lt);"}, {"from": "gpt", "value": "`timescale 1ns / 1ns\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_local, gt_local, lt_local;\n\ncomparator_4bit_slice comp_slice1(\n.a(a[3:0]),\n.b(b[3:0]),\n.eq(eq_local[0]),\n.gt(gt_local[0]),\n.lt(lt_local[0]));\n\ncomparator_4bit_slice comp_slice2(\n.a(a[7:4]),\n.b(b[7:4]),\n.eq(eq_local[1]),\n.gt(gt_local[1]),\n.lt(lt_local[1]));\n\ncomparator_4bit_slice comp_slice3(\n.a(a[11:8]),\n.b(b[11:8]),\n.eq(eq_local[2]),\n.gt(gt_local[2]),\n.lt(lt_local[2]));\n\ncomparator_4bit_slice comp_slice4(\n.a(a[15:12]),\n.b(b[15:12]),\n.eq(eq_local[3]),\n.gt(gt_local[3]),\n.lt(lt_local[3]));\n\nassign eq = &eq_local;\nassign gt = |(gt_local & ~(|lt_local));\nassign lt = |(lt_local & ~(|gt_local));\nendmodule\n\nmodule comparator_4bit_slice(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_bit, gt_bit, lt_bit;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 4; i = i + 1) begin : comp_bits\n        assign eq_bit[i] = (a[i] == b[i]);\n        assign gt_bit[i] = (a[i] & ~b[i]);\n        assign lt_bit[i] = (~a[i] & b[i]);\n    end\nendgenerate\n\nassign eq = &eq_bit;\nassign gt = |(gt_bit & ~(|lt_bit));\nassign lt = |(lt_bit & ~(|gt_bit));\nendmodule\n"}], "task_id": "adder_16bit_csa_v_53"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, Bin input, D output, Bout output, SUB1 submodule, SUB2 submodule, SUB3 submodule, SUB4 submodule], \nconnectivity: [[2, 1, 0, 1, 5, 0, 1, 6, 0, 7, 1, 0, 7, 6, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 32-bit binary subtractor that employs a series of 8-bit subtractor blocks to perform the operation, and handles borrow-in and borrow-out.\n\nModule name:  \n    subtractor_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\n    Bin: Borrow-in input.\nOutput ports:\n    D[32:1]: 32-bit output representing the difference of A minus B.\n    Bout: Borrow-out output.\n\nImplementation:\nThe top module subtractor_32bit consists of several instances of the 8-bit subtractor block you design.\nGive me the complete code.\nmodule subtractor_32bit(A, B, Bin, D, Bout);"}, {"from": "gpt", "value": "module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [3:0] b;\n\n    subtractor_8 SUB1(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bin),\n        .D(D[8:1]),\n        .Bout(b[0])\n    );\n\n    subtractor_8 SUB2(\n        .A(A[16:9]),\n        .B(B[16:9]),\n        .Bin(b[0]),\n        .D(D[16:9]),\n        .Bout(b[1])\n    );\n\n    subtractor_8 SUB3(\n        .A(A[24:17]),\n        .B(B[24:17]),\n        .Bin(b[1]),\n        .D(D[24:17]),\n        .Bout(b[2])\n    );\n\n    subtractor_8 SUB4(\n        .A(A[32:25]),\n        .B(B[32:25]),\n        .Bin(b[2]),\n        .D(D[32:25]),\n        .Bout(b[3])\n    );\n\n    assign Bout = b[3];\nendmodule\n\nmodule subtractor_8(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n\n    wire [7:0] borrow;\n\n    full_subtractor FS1(.a(A[1]), .b(B[1]), .bin(Bin), .d(D[1]), .bout(borrow[0]));\n    full_subtractor FS2(.a(A[2]), .b(B[2]), .bin(borrow[0]), .d(D[2]), .bout(borrow[1]));\n    full_subtractor FS3(.a(A[3]), .b(B[3]), .bin(borrow[1]), .d(D[3]), .bout(borrow[2]));\n    full_subtractor FS4(.a(A[4]), .b(B[4]), .bin(borrow[2]), .d(D[4]), .bout(borrow[3]));\n    full_subtractor FS5(.a(A[5]), .b(B[5]), .bin(borrow[3]), .d(D[5]), .bout(borrow[4]));\n    full_subtractor FS6(.a(A[6]), .b(B[6]), .bin(borrow[4]), .d(D[6]), .bout(borrow[5]));\n    full_subtractor FS7(.a(A[7]), .b(B[7]), .bin(borrow[5]), .d(D[7]), .bout(borrow[6]));\n    full_subtractor FS8(.a(A[8]), .b(B[8]), .bin(borrow[6]), .d(D[8]), .bout(Bout));\nendmodule\n\nmodule full_subtractor(a, b, bin, d, bout);\n    input a, b, bin;\n    output d, bout;\n\n    assign d = a ^ b ^ bin;\n    assign bout = (~a & b) | (bin & (~a ^ b));\nendmodule\n"}], "task_id": "adder_32bit_v_54"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, reset input, count output, u0 submodule, u1 submodule, u2 submodule], \nconnectivity: [[0, 1, 0, 3, 1, 4, 0, 3, 1, 4, 3, 5], [3, 3, 4, 4, 4, 5, 5, 5, 5, 2, 2, 2]]\n, Design a binary counter module that increments the count by one on every rising edge of the clock, using three T flip-flops configured to toggle their state. The counter should reset to zero when the reset input is high.\n\nModule name:\n    binary_counter\n\nInput ports:\n    clk: Clock signal for synchronization.\n    reset: Reset signal to reset the counter to zero.\n\nOutput ports:\n    count: 3-bit output reflecting the current count value.\n\nImplementation:\nThe binary counter consists of three instances of the provided T flip-flop module (my_tff). Each flip-flop's output represents a bit of the binary count. The first T flip-flop toggles on every clock cycle. Each subsequent T flip-flop toggles when all lower-order bits are high. A synchronous reset is applied to each flip-flop.\nGive me the complete code.\nmodule binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);"}, {"from": "gpt", "value": "module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2; // Intermediate toggle signals\n\n    // Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .toggle(1'b1), .reset(reset), .q(count[0]));   // Least Significant Bit\n    my_tff u1 (.clk(clk), .toggle(count[0]), .reset(reset), .q(count[1]));\n    my_tff u2 (.clk(clk), .toggle(count[0] & count[1]), .reset(reset), .q(count[2]));  // Most Significant Bit\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input toggle,\n    input reset,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (toggle)\n            q <= ~q;\n    end\nendmodule\n"}], "task_id": "shift_reg_v_55"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, reset input, out output, init submodule, increment submodule], \nconnectivity: [[1, 0, 3, 1, 4], [3, 4, 4, 4, 2]]\n, Implement a modular 4-bit binary up counter with synchronous reset functionality.\n\nModule name:\n    binary_up_counter\n\nInput ports:\n    clk: Clock signal that drives the counting.\n    reset: Synchronous reset signal to set the counter to zero.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current count value.\n\nInternal logic:\nCount Initialization: A submodule initializes the counter to zero when the reset signal is asserted.\nCount Increment: Another submodule handles the increment operation of the counter, increasing the count by one on each rising edge of the clock signal, unless the reset is asserted.\n\nModularity: The design consists of separate submodules for initialization and counting, promoting better organization and code reusability.\nReset Behavior: When reset is high, the counter is set to zero (out = 4'b0000).\nGive me the complete code.\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);"}, {"from": "gpt", "value": "module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    wire [3:0] current_state;\n\n    // Submodule for count initialization\n    count_init init (\n        .reset(reset),\n        .current_state(current_state)\n    );\n\n    // Submodule for count increment\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .current_state_in(current_state),\n        .current_state_out(out)\n    );\n\nendmodule\n\n// Submodule for count initialization\nmodule count_init (\n    input wire reset,\n    output reg [3:0] current_state\n);\n\n    always @ (posedge reset) begin\n        current_state <= 4'b0000;\n    end\n\nendmodule\n\n// Submodule for count increment\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] current_state_in,\n    output reg [3:0] current_state_out\n);\n\n    always @ (posedge clk) begin\n        if (reset)\n            current_state_out <= 4'b0000;\n        else\n            current_state_out <= current_state_in + 1'b1;\n    end\n\nendmodule\n"}], "task_id": "ring_counter_v_56"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, reset input, up_down input, count output, u_counter_logic submodule, u_counter_register submodule], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);"}], "task_id": "up_down_counter"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, reset input, out output, init submodule, transition submodule], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);"}], "task_id": "ring_counter"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [rst_n input, clk input, valid_count input, out output, u_counter_logic submodule, u_output_register submodule], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);"}], "task_id": "counter_12"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, Q output, reg_inst submodule, logic_inst submodule], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);"}], "task_id": "JC_counter"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [CLK_in input, RST input, CLK_50 output, CLK_10 output, CLK_1 output, clk_div_50 submodule, clk_div_10 submodule, clk_div_1 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);"}], "task_id": "freq_div"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, clk_div output, u_counter submodule, u_clk_average submodule, u_clk_adjustment submodule], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);"}], "task_id": "freq_divbyfrac"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, clk_div output, u_pos_counter submodule, u_neg_counter submodule], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);"}], "task_id": "freq_divbyodd"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, clk_div output, u_counter submodule, u_clk_divider submodule], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);"}], "task_id": "freq_divbyeven"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, aluc input, r output, zero output, carry output, negative output, overflow output, flag output, add submodule, addu submodule, sub submodule, and1 submodule, or1 submodule, xor1 submodule, nor1 submodule, slt_inst submodule, sltu_inst submodule, sll submodule, srl submodule, sra submodule, lui_inst submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);"}], "task_id": "alu"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, a input, b input, c output, u_multiplier submodule, u_accumulator submodule], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);"}], "task_id": "pe"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, fetch input, data input, ins output, ad1 output, ad2 output, ins1 submodule, ins2 submodule], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);"}], "task_id": "instr_reg"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, freq input, wave_out output, cnt submodule, wg submodule], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);"}], "task_id": "square_wave"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, wave output, state_inst submodule, wave_inst submodule], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);"}], "task_id": "signal_generator"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, d input, sel input, q output, u0 submodule, u1 submodule, u2 submodule], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);"}], "task_id": "shift8"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, d input, q output, u0 submodule, u1 submodule, u2 submodule], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);"}], "task_id": "shift_reg"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [in input, ctrl input, out output, ins_17 submodule, ins_16 submodule, ins_15 submodule, ins_14 submodule, ins_13 submodule, ins_12 submodule, ins_11 submodule, ins_10 submodule, ins_27 submodule, ins_26 submodule, ins_25 submodule, ins_24 submodule, ins_23 submodule, ins_22 submodule, ins_21 submodule, ins_20 submodule, ins_07 submodule, ins_06 submodule, ins_05 submodule, ins_04 submodule, ins_03 submodule, ins_02 submodule, ins_01 submodule, ins_00 submodule], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);"}], "task_id": "barrel_shifter"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, a0 input, a1 input, b0 input, c0 output, c1 output, pe0 submodule, pe1 submodule], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);"}], "task_id": "systolic1x2"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, instr_mem input, reg_file input, res_reg_file output, fetch submodule, decode submodule, execute submodule, memory submodule, writeback submodule], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);"}], "task_id": "stagepipe5"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, a0 input, a1 input, a2 input, a3 input, b0 input, c0 output, c1 output, c2 output, c3 output, pe0 submodule, pe1 submodule, pe2 submodule, pe3 submodule], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);"}], "task_id": "systolic1x4"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, instr_mem input, reg_file input, out_reg_file output, fetch submodule, execute submodule, writeback submodule], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);"}], "task_id": "stagepipe3"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, data_in input, valid_in input, valid_out output, data_out output, u_counter submodule, u_data_accumulator submodule, u_valid_output submodule], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);"}], "task_id": "accu"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst input, dividend input, divisor input, sign input, opn_valid input, res_ready input, res_valid output, result output, abs_dividend submodule, neg_divisor_mod submodule, ctrl submodule, res_mgmt submodule], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);"}], "task_id": "radix2_div"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, result output, odd output, prep submodule, div_op submodule], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);"}], "task_id": "div_32bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, result output, odd output, ctrl submodule], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);"}], "task_id": "div_16bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, D output, B_out output, adder_inst submodule], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);"}], "task_id": "sub_8bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, Diff output, B_out output, S1 submodule, S2 submodule], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);"}], "task_id": "sub_32bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, D output, B_out output, sub0 submodule, sub1 submodule], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);"}], "task_id": "sub_64bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, D output, B_out output, sub1 submodule, sub2 submodule, sub3 submodule, sub4 submodule], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);"}], "task_id": "sub_16bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, A_greater output, A_equal output, A_less output, sub_inst submodule], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);"}], "task_id": "comparator_32bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [A input, B input, S output, C32 output, CLA1 submodule, CLA2 submodule], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);"}], "task_id": "adder_32bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, cin input, sum output, cout output, rca1 submodule, csa_slice1 submodule, csa_slice2 submodule, csa_slice3 submodule], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);"}], "task_id": "adder_16bit_csa"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, Cin input, y output, Co output, add8_inst1 submodule, add8_inst2 submodule], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);"}], "task_id": "adder_16bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [a input, b input, cin input, sum output, cout output, FA0 submodule, FA1 submodule, FA2 submodule, FA3 submodule, FA4 submodule, FA5 submodule, FA6 submodule, FA7 submodule], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);"}], "task_id": "adder_8bit"}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [clk input, rst_n input, start input, ain input, bin input, yout output, done output, ctrl submodule, reg_unit submodule, mul_unit submodule], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);"}], "task_id": "multi_16bit"}]