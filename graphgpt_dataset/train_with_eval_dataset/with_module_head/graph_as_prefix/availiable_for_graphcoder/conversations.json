[{"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);"}, {"from": "gpt", "value": "module up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);\n\n    wire [15:0] next_count;\n\n    // Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .clk(clk),\n        .reset(reset),\n        .up_down(up_down),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count value\n    counter_register u_counter_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule counter_logic (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    input wire [15:0] current_count,\n    output reg [15:0] next_count\n);\n\n    always @(*) begin\n        if (reset) begin\n            next_count = 16'b0; \n        end else begin\n            if (up_down) begin\n                // Increment the counter if up_down is high\n                if (current_count == 16'b1111_1111_1111_1111) begin\n                    next_count = 16'b0; \n                end else begin\n                    next_count = current_count + 1; \n                end\n            end else begin\n                // Decrement the counter if up_down is low\n                if (current_count == 16'b0) begin\n                    next_count = 16'b1111_1111_1111_1111; \n                end else begin\n                    next_count = current_count - 1; \n                end\n            end\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire reset,\n    input wire [15:0] next_count,\n    output reg [15:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 16'b0; \n        end else begin\n            current_count <= next_count; \n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);"}, {"from": "gpt", "value": "module ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);\n\n    wire [7:0] state;\n\n    // Submodule for state initialization\n    state_init init (\n        .clk(clk),\n        .reset(reset),\n        .state(state)\n    );\n\n    // Submodule for state transition\n    state_transition transition (\n        .clk(clk),\n        .reset(reset),\n        .state_in(state),\n        .state_out(out)\n    );\n\nendmodule\n\n// Submodule for state initialization\nmodule state_init (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] state\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset)\n            state <= 8'b0000_0001; \n    end\n\nendmodule\n\n// Submodule for state transition\nmodule state_transition (\n    input wire clk,\n    input wire reset,\n    input wire [7:0] state_in,\n    output reg [7:0] state_out\n);\n\n    always @ (posedge clk) begin\n        if (!reset)\n            state_out <= {state_in[6:0], state_in[7]}; \n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\n// Main counter module\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);\n\n    // Internal signal for counting\n    wire [3:0] count_value;\n\n    // Instance of the counter logic module\n    counter_logic u_counter_logic (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value)\n    );\n\n    // Instance of the output register module\n    output_register u_output_register (\n        .rst_n(rst_n),\n        .clk(clk),\n        .valid_count(valid_count),\n        .count_value(count_value),\n        .out(out)\n    );\n\nendmodule\n\n// Counter logic module\nmodule counter_logic (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output reg [3:0] count_value\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count_value <= 4'b0000;\n        end else if (valid_count) begin\n            if (count_value == 4'd11) begin\n                count_value <= 4'b0000;\n            end else begin\n                count_value <= count_value + 1;\n            end\n        end\n    end\n\nendmodule\n\n// Output register module\nmodule output_register (\n    input rst_n,\n    input clk,\n    input valid_count,\n    input [3:0] count_value,\n    output reg [3:0] out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            out <= 4'b0000;\n        end else if (valid_count) begin\n            out <= count_value;\n        end else begin\n            out <= out; // Pause the count when valid_count is invalid\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ns\n\n// Main module for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);\n    wire [63:0] Q_internal;\n\n    // Instance of the register module\n    JC_register reg_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_internal)\n    );\n\n    // Instance of the logic module to determine the next state\n    JC_logic logic_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .Q(Q_internal),\n        .Q_next(Q)\n    );\n\nendmodule\n\n// Submodule for the register to store the current state of the counter\nmodule JC_register(\n    input                clk,\n    input                rst_n,\n    output reg [63:0]   Q\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) \n            Q <= 64'd0;\n    end\nendmodule\n\n// Submodule for the logic that determines the next state of the counter\nmodule JC_logic(\n    input                clk,\n    input                rst_n,\n    input [63:0]        Q,\n    output reg [63:0]   Q_next\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) \n            Q_next <= 64'd0;\n        else if (!Q[0]) \n            Q_next <= {1'b1, Q[63:1]};\n        else \n            Q_next <= {1'b0, Q[63:1]};\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);"}, {"from": "gpt", "value": "module freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);\n\n    // Submodule instances\n    wire clk_50_out;\n    wire clk_10_out;\n    wire clk_1_out;\n\n    clk_div_2 clk_div_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_50_out)\n    );\n\n    clk_div_10 clk_div_10 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_10_out)\n    );\n\n    clk_div_100 clk_div_1 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_1_out)\n    );\n\n    // Assign outputs\n    assign CLK_50 = clk_50_out;\n    assign CLK_10 = clk_10_out;\n    assign CLK_1 = clk_1_out;\n\nendmodule\n\n// Submodule for 50 MHz clock generation\nmodule clk_div_2 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n        end else begin\n            CLK_out <= ~CLK_out;\n        end\n    end\nendmodule\n\n// Submodule for 10 MHz clock generation\nmodule clk_div_10 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 4) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\n// Submodule for 1 MHz clock generation\nmodule clk_div_100 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 1'b0;\n            cnt <= 0;\n        end else if (cnt == 49) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);"}, {"from": "gpt", "value": "module freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);\n    // Parameter for fractional division factor\n    parameter MUL2_DIV_CLK = 7;\n\n    // Internal wires for clock signals\n    wire clk_ave;\n    wire clk_adjust;\n\n    // Instantiate the counter submodule\n    counter #(MUL2_DIV_CLK) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt)\n    );\n\n    // Instantiate the average clock generator submodule\n    clk_average u_clk_average (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt),\n        .clk_ave(clk_ave)\n    );\n\n    // Instantiate the clock adjustment submodule\n    clk_adjustment u_clk_adjustment (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt),\n        .clk_adjust(clk_adjust)\n    );\n\n    // Final output: OR the adjusted and averaged clock signals\n    assign clk_div = clk_adjust | clk_ave;\n\nendmodule\n\n// Counter submodule\nmodule counter #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_value <= 4'b0;\n        end else if (cnt_value == MUL2_DIV_CLK - 1) begin\n            cnt_value <= 4'b0;\n        end else begin\n            cnt_value <= cnt_value + 1'b1;\n        end\n    end\nendmodule\n\n// Clock Average Generator submodule\nmodule clk_average #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    input [3:0] cnt,\n    output reg clk_ave\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_ave <= 1'b0;\n        end else if (cnt == 0) begin\n            clk_ave <= 1'b1;  // First cycle: 4 source clock cycles\n        end else if (cnt == (MUL2_DIV_CLK / 2) + 1) begin\n            clk_ave <= 1'b1;  // Second cycle: 3 source clock cycles\n        end else begin\n            clk_ave <= 1'b0;\n        end\n    end\nendmodule\n\n// Clock Adjustment submodule\nmodule clk_adjustment #(parameter MUL2_DIV_CLK = 7)(\n    input clk,\n    input rst_n,\n    input [3:0] cnt,\n    output reg clk_adjust\n);\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_adjust <= 1'b0;\n        end else if (cnt == 1) begin\n            clk_adjust <= 1'b1;  // Adjust clock signal\n        end else if (cnt == (MUL2_DIV_CLK / 2) + 1) begin\n            clk_adjust <= 1'b1;  // Adjust clock signal again\n        end else begin\n            clk_adjust <= 1'b0;\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);"}, {"from": "gpt", "value": "module freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    // Parameter for the odd divisor\n    parameter NUM_DIV = 5;\n\n    wire clk_div1, clk_div2;\n    wire [2:0] cnt1, cnt2; // 3-bit counters\n\n    // Instantiate the positive edge counter\n    pos_edge_counter #(.NUM_DIV(NUM_DIV)) u_pos_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt1),\n        .clk_div(clk_div1)\n    );\n\n    // Instantiate the negative edge counter\n    neg_edge_counter #(.NUM_DIV(NUM_DIV)) u_neg_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt(cnt2),\n        .clk_div(clk_div2)\n    );\n\n    // Combine the divided clocks\n    assign clk_div = clk_div1 | clk_div2;\n\nendmodule\n\nmodule pos_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 1'b1; // Initial state\n        end else begin\n            if (cnt < NUM_DIV - 1) begin\n                cnt <= cnt + 1'b1;\n            end else begin\n                cnt <= 0;\n            end\n            \n            if (cnt < NUM_DIV / 2) begin\n                clk_div <= 1'b1;\n            end else begin\n                clk_div <= 1'b0;\n            end\n        end\n    end\nendmodule\n\nmodule neg_edge_counter(\n    input clk,\n    input rst_n,\n    output reg [2:0] cnt,\n    output reg clk_div\n);\n    parameter NUM_DIV = 5;\n\n    always @(negedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt <= 0;\n            clk_div <= 1'b1; // Initial state\n        end else begin\n            if (cnt < NUM_DIV - 1) begin\n                cnt <= cnt + 1'b1;\n            end else begin\n                cnt <= 0;\n            end\n            \n            if (cnt < NUM_DIV / 2) begin\n                clk_div <= 1'b1;\n            end else begin\n                clk_div <= 1'b0;\n            end\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);"}, {"from": "gpt", "value": "module freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);\n    // Parameter for division factor\n    parameter NUM_DIV = 6;\n\n    // Internal wire for the counter value\n    wire [3:0] cnt_value;\n    // Internal wire for the divided clock signal\n    wire clk_div_internal;\n\n    // Instantiate the counter submodule\n    counter #(NUM_DIV) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value)\n    );\n\n    // Instantiate the clock divider submodule\n    clk_divider u_clk_divider (\n        .clk(clk),\n        .rst_n(rst_n),\n        .cnt_value(cnt_value),\n        .clk_div(clk_div_internal)\n    );\n\n    // Assign the internal divided clock to the output\n    assign clk_div = clk_div_internal;\n\nendmodule\n\n// Counter submodule\nmodule counter #(parameter NUM_DIV = 6)(\n    input clk,\n    input rst_n,\n    output reg [3:0] cnt_value\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            cnt_value <= 4'd0;\n        end else if (cnt_value < NUM_DIV / 2 - 1) begin\n            cnt_value <= cnt_value + 1'b1;\n        end else begin\n            cnt_value <= 4'd0;\n        end\n    end\nendmodule\n\n// Clock divider submodule\nmodule clk_divider(\n    input clk,\n    input rst_n,\n    input [3:0] cnt_value,\n    output reg clk_div\n);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            clk_div <= 1'b0;\n        end else if (cnt_value == 0) begin\n            clk_div <= ~clk_div;\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);"}, {"from": "gpt", "value": "`timescale 1ns / 1ps\n\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);\n\n    // Submodule instances\n    wire [32:0] add_result, sub_result, and_result, or_result, xor_result, nor_result;\n    wire [31:0] slt_result, sltu_result, sll_result, srl_result, sra_result, lui_result;\n\n    // Instantiate arithmetic operations\n    adder add(.a(a), .b(b), .result(add_result));\n    adder_unsigned addu(.a(a), .b(b), .result(add_result));\n    subtractor sub(.a(a), .b(b), .result(sub_result));\n    and_gate and1(.a(a), .b(b), .result(and_result));\n    or_gate or1(.a(a), .b(b), .result(or_result));\n    xor_gate xor1(.a(a), .b(b), .result(xor_result));\n    nor_gate nor1(.a(a), .b(b), .result(nor_result));\n\n    // Instantiate comparison operations\n    slt slt_inst(.a(a), .b(b), .result(slt_result));\n    sltu sltu_inst(.a(a), .b(b), .result(sltu_result));\n\n    // Instantiate shift operations\n    shift_left sll(.a(b), .shift_amount(a), .result(sll_result));\n    shift_right srl(.a(b), .shift_amount(a), .result(srl_result));\n    shift_arithmetic sra(.a(b), .shift_amount(a), .result(sra_result));\n    lui_module lui_inst(.a(a), .result(lui_result));\n\n    // Result selection based on aluc\n    reg [31:0] res;\n    assign r = res;\n\n    always @(*) begin\n        case (aluc)\n            6'b100000: res = add_result[31:0];   // ADD\n            6'b100001: res = add_result[31:0];   // ADDU\n            6'b100010: res = sub_result[31:0];   // SUB\n            6'b100011: res = sub_result[31:0];   // SUBU\n            6'b100100: res = and_result[31:0];   // AND\n            6'b100101: res = or_result[31:0];    // OR\n            6'b100110: res = xor_result[31:0];   // XOR\n            6'b100111: res = nor_result[31:0];   // NOR\n            6'b101010: res = slt_result;          // SLT\n            6'b101011: res = sltu_result;         // SLTU\n            6'b000000: res = sll_result;          // SLL\n            6'b000010: res = srl_result;          // SRL\n            6'b000011: res = sra_result;          // SRA\n            6'b000100: res = sll_result;          // SLLV\n            6'b000110: res = srl_result;          // SRLV\n            6'b000111: res = sra_result;          // SRAV\n            6'b001111: res = lui_result;          // LUI\n            default: res = 32'bz;                 // Default case\n        endcase\n    end\n\n    // Flags generation\n    assign zero = (res == 32'b0);\n    assign carry = add_result[32]; // Example for carry detection\n    assign negative = res[31];\n    assign overflow = (add_result[32] ^ add_result[31]) ? 1'b1 : 1'b0; // Adjust according to operations\n    assign flag = (aluc == 6'b101010) ? (a < b) : (aluc == 6'b101011) ? (a < b) : 1'bz;\n\nendmodule\n\n// Submodules definition\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [32:0] result\n);\n    assign result = {1'b0, a} + {1'b0, b}; // 33-bit result for carry\nendmodule\n\nmodule adder_unsigned(\n    input [31:0] a,\n    input [31:0] b,\n    output [32:0] result\n);\n    assign result = {1'b0, a} + {1'b0, b}; // 33-bit result for carry\nendmodule\n\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [32:0] result\n);\n    assign result = {1'b0, a} - {1'b0, b}; // 33-bit result for borrow\nendmodule\n\nmodule and_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule\n\nmodule xor_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a ^ b;\nendmodule\n\nmodule nor_gate(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = ~(a | b);\nendmodule\n\nmodule slt(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = (a < b) ? 1 : 0;\nendmodule\n\nmodule sltu(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = (a < b) ? 1 : 0;\nendmodule\n\nmodule shift_left(\n    input [31:0] a,\n    input [31:0] shift_amount,\n    output [31:0] result\n);\n    assign result = a << shift_amount;\nendmodule\n\nmodule shift_right(\n    input [31:0] a,\n    input [31:0] shift_amount,\n    output [31:0] result\n);\n    assign result = a >> shift_amount;\nendmodule\n\nmodule shift_arithmetic(\n    input [31:0] a,\n    input [31:0] shift_amount,\n    output [31:0] result\n);\n    assign result = $signed(a) >>> shift_amount;\nendmodule\n\nmodule lui_module(\n    input [31:0] a,\n    output [31:0] result\n);\n    assign result = {a[15:0], 16'b0};\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);"}, {"from": "gpt", "value": "module pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);\n\n// Intermediate wire to hold the multiplication result\nwire [63:0] mult_result;\nwire [31:0] accumulated_value;\n\n// Instantiating the multiplier module\nmultiplier u_multiplier (\n    .a(a),\n    .b(b),\n    .result(mult_result)\n);\n\n// Instantiating the accumulator module\naccumulator u_accumulator (\n    .clk(clk),\n    .rst(rst),\n    .new_value(mult_result[31:0]), // Take lower 32 bits for accumulation\n    .current_value(accumulated_value)\n);\n\n// Assigning the accumulated value to the output\nassign c = accumulated_value;\n\nendmodule\n\n// Multiplier module\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n\n// Accumulator module\nmodule accumulator(\n    input clk,\n    input rst,\n    input [31:0] new_value,\n    output reg [31:0] current_value\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_value <= 0;\n        end else begin\n            current_value <= current_value + new_value;\n        end\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);"}, {"from": "gpt", "value": "module instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);\n\n    // Submodule for instruction storage\n    wire [7:0] ins_p1_out, ins_p2_out;\n\n    instruction_storage ins1 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p1_out),\n        .fetch_code(2'b01) // Fetch from register\n    );\n\n    instruction_storage ins2 (\n        .clk(clk),\n        .rst(rst),\n        .fetch(fetch),\n        .data(data),\n        .ins_out(ins_p2_out),\n        .fetch_code(2'b10) // Fetch from RAM/ROM\n    );\n\n    // Output assignments\n    assign ins = ins_p1_out[7:5]; // High 3 bits, instructions\n    assign ad1 = ins_p1_out[4:0];  // Low 5 bits, register address\n    assign ad2 = ins_p2_out;        // Full 8-bit data from second source\n\nendmodule\n\n// Submodule for instruction storage\nmodule instruction_storage (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output reg [7:0] ins_out,\n    input [1:0] fetch_code // Code to distinguish fetch sources\n);\n\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            ins_out <= 8'd0; // Reset output\n        end else begin\n            if (fetch == fetch_code) begin\n                ins_out <= data; // Capture data if fetch code matches\n            end else begin\n                ins_out <= ins_out; // Retain previous value\n            end\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);"}, {"from": "gpt", "value": "module square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);\n\n    wire count_enable;\n    wire [7:0] count_value;\n\n    // Instance of counter module\n    counter cnt (\n        .clk(clk),\n        .enable(count_enable),\n        .freq(freq),\n        .count(count_value)\n    );\n\n    // Instance of wave generator module\n    wave_generator wg (\n        .clk(clk),\n        .count(count_value),\n        .freq(freq),\n        .wave_out(wave_out)\n    );\n\n    // Control logic for enabling the counter\n    assign count_enable = (freq > 0);\n\nendmodule\n\nmodule counter(\n    input clk,\n    input enable,\n    input [7:0] freq,\n    output reg [7:0] count\n);\n\n    initial begin\n        count = 0;\n    end\n\n    always @(posedge clk) begin\n        if (enable) begin\n            if (count == freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule wave_generator(\n    input clk,\n    input [7:0] count,\n    input [7:0] freq,\n    output reg wave_out\n);\n\n    initial begin\n        wave_out = 0;\n    end\n\n    always @(posedge clk) begin\n        if (count == freq - 1) begin\n            wave_out <= ~wave_out;\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);"}, {"from": "gpt", "value": "module signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);\n\n    wire [1:0] state;\n    reg [4:0] wave_reg;\n\n    // State Control Module\n    state_control state_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .wave(wave_reg),\n        .state(state)\n    );\n\n    // Waveform Generation Module\n    waveform_gen wave_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .state(state),\n        .wave(wave_reg)\n    );\n\n    assign wave = wave_reg;\n\nendmodule\n\n// State Control Module\nmodule state_control (\n    input clk,\n    input rst_n,\n    input [4:0] wave,\n    output reg [1:0] state\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            state <= 2'b00;\n        end else begin\n            case (state)\n                2'b00:\n                    if (wave == 5'b11111) // 31\n                        state <= 2'b01;\n                2'b01:\n                    if (wave == 5'b00000) // 0\n                        state <= 2'b00;\n            endcase\n        end\n    end\n\nendmodule\n\n// Waveform Generation Module\nmodule waveform_gen (\n    input clk,\n    input rst_n,\n    input [1:0] state,\n    output reg [4:0] wave\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            wave <= 5'b0;\n        end else begin\n            case (state)\n                2'b00:\n                    wave <= wave + 1;\n                2'b01:\n                    wave <= wave - 1;\n            endcase\n        end\n    end\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);"}, {"from": "gpt", "value": "module shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);\n    wire [7:0] q0, q1, q2;\n\n    // Instantiating three D flip-flops\n    my_dff8 u0 ( .clk(clk), .d(d), .q(q0) );\n    my_dff8 u1 ( .clk(clk), .d(q0), .q(q1) );\n    my_dff8 u2 ( .clk(clk), .d(q1), .q(q2) );\n\n    // Multiplexer to select output based on sel\n    always @(*) begin\n        case(sel)\n            2'b00: q = d;      // No delay\n            2'b01: q = q0;     // 1 cycle delay\n            2'b10: q = q1;     // 2 cycles delay\n            2'b11: q = q2;     // 3 cycles delay\n            default: q = 8'b0; // Default case\n        endcase\n    end\nendmodule\n\nmodule my_dff8 (\n    input clk,\n    input [7:0] d,\n    output reg [7:0] q\n);\n    always @(posedge clk) begin\n        q <= d; // D flip-flop behavior\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);"}, {"from": "gpt", "value": "module shift_reg (\n    input clk,\n    input d,\n    output q\n);\n    wire q0, q1; // Intermediate outputs from flip-flops\n\n    // Instantiate three D flip-flops\n    my_dff u0 (.clk(clk), .d(d), .q(q0));   // First flip-flop\n    my_dff u1 (.clk(clk), .d(q0), .q(q1));  // Second flip-flop\n    my_dff u2 (.clk(clk), .d(q1), .q(q));    // Third flip-flop\n\nendmodule\n\nmodule my_dff (\n    input clk,\n    input d,\n    output reg q\n);\n    always @(posedge clk) begin\n        q <= d; // On the rising edge of clk, assign d to q\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);"}, {"from": "gpt", "value": "module barrel_shifter (in, ctrl, out);\n  input  [7:0] in;\n  input [2:0] ctrl;\n  output [7:0] out;\n  wire [7:0] x,y;\n \n//4bit shift right\nmux2X1  ins_17 (.in0(in[7]),.in1(1'b0),.sel(ctrl[2]),.out(x[7]));\nmux2X1  ins_16 (.in0(in[6]),.in1(1'b0),.sel(ctrl[2]),.out(x[6]));\nmux2X1  ins_15 (.in0(in[5]),.in1(1'b0),.sel(ctrl[2]),.out(x[5]));\nmux2X1  ins_14 (.in0(in[4]),.in1(1'b0),.sel(ctrl[2]),.out(x[4]));\nmux2X1  ins_13 (.in0(in[3]),.in1(in[7]),.sel(ctrl[2]),.out(x[3]));\nmux2X1  ins_12 (.in0(in[2]),.in1(in[6]),.sel(ctrl[2]),.out(x[2]));\nmux2X1  ins_11 (.in0(in[1]),.in1(in[5]),.sel(ctrl[2]),.out(x[1]));\nmux2X1  ins_10 (.in0(in[0]),.in1(in[4]),.sel(ctrl[2]),.out(x[0]));\n \n//2 bit shift right\n \nmux2X1  ins_27 (.in0(x[7]),.in1(1'b0),.sel(ctrl[1]),.out(y[7]));\nmux2X1  ins_26 (.in0(x[6]),.in1(1'b0),.sel(ctrl[1]),.out(y[6]));\nmux2X1  ins_25 (.in0(x[5]),.in1(x[7]),.sel(ctrl[1]),.out(y[5]));\nmux2X1  ins_24 (.in0(x[4]),.in1(x[6]),.sel(ctrl[1]),.out(y[4]));\nmux2X1  ins_23 (.in0(x[3]),.in1(x[5]),.sel(ctrl[1]),.out(y[3]));\nmux2X1  ins_22 (.in0(x[2]),.in1(x[4]),.sel(ctrl[1]),.out(y[2]));\nmux2X1  ins_21 (.in0(x[1]),.in1(x[3]),.sel(ctrl[1]),.out(y[1]));\nmux2X1  ins_20 (.in0(x[0]),.in1(x[2]),.sel(ctrl[1]),.out(y[0]));\n \n//1 bit shift right\nmux2X1  ins_07 (.in0(y[7]),.in1(1'b0),.sel(ctrl[0]),.out(out[7]));\nmux2X1  ins_06 (.in0(y[6]),.in1(y[7]),.sel(ctrl[0]),.out(out[6]));\nmux2X1  ins_05 (.in0(y[5]),.in1(y[6]),.sel(ctrl[0]),.out(out[5]));\nmux2X1  ins_04 (.in0(y[4]),.in1(y[5]),.sel(ctrl[0]),.out(out[4]));\nmux2X1  ins_03 (.in0(y[3]),.in1(y[4]),.sel(ctrl[0]),.out(out[3]));\nmux2X1  ins_02 (.in0(y[2]),.in1(y[3]),.sel(ctrl[0]),.out(out[2]));\nmux2X1  ins_01 (.in0(y[1]),.in1(y[2]),.sel(ctrl[0]),.out(out[1]));\nmux2X1  ins_00 (.in0(y[0]),.in1(y[1]),.sel(ctrl[0]),.out(out[0]));\n\nendmodule\n\nmodule mux2X1( in0,in1,sel,out);\ninput in0,in1;\ninput sel;\noutput out;\nassign out=(sel)?in1:in0;\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);"}, {"from": "gpt", "value": "module systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);\n  reg [15:0] b1;\n  PE pe0 (\n    .clk(clk),\n    .rst(rst),\n    .a(a0),\n    .b(b0),\n    .c(c0)\n  );\n  PE pe1 (\n    .clk(clk),\n    .rst(rst),\n    .a(a1),\n    .b(b1),\n    .c(c1)\n  );\n  always@(posedge clk or posedge rst) begin\n    if(rst) begin\n      b1 <= 0;\n    end\n    else begin\n      b1 <= b0; // pass b0 to next PE\n    end\n  end\n  \nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);"}, {"from": "gpt", "value": "// Instruction types\n`define ADD_INST 2'b00\n`define SUB_INST 2'b01\n\n// Pipeline stages\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);\n\n// Pipeline signals\nwire [31:0] inst, pc, op1, op2, result, mem_data;\nwire [4:0] rs1, rs2, rd, rd1, rd2;\nwire [1:0] op;\n\nfetch_stage fetch (.clk(clk), .inst(inst), .rst(rst), .instr_mem_in(instr_mem));\ndecode_stage decode (\n  .clk(clk),\n  .inst(inst),\n  .rs1(rs1),\n  .rs2(rs2),\n  .op(op),\n  .rd(rd)\n);\nexecute_stage execute (\n  .clk(clk),\n  .rs1(rs1),\n  .rs2(rs2),\n  .reg_file(reg_file),\n  .op(op),\n  .result(result),\n  .rdin1(rd),\n  .rdout1(rd1)\n);\nmemory_stage memory(.clk(clk), .alu_result(result), .mem_data(mem_data), .rdin2(rd1), .rdout2(rd2));\nwriteback_stage writeback (\n  .clk(clk),\n  .mem_data(mem_data),\n  .rd(rd2),\n  .reg_file(res_reg_file)\n);\nendmodule\n\nmodule fetch_stage(\n  input clk,\n  output reg [31:0] inst,\n  input [31:0] instr_mem_in [0:31],\n  input rst\n);\n  reg [31:0] pc;\n  // Fetch logic\n  always @(posedge clk or posedge rst) begin\n    // Fetch next instruction\n    if(rst)\n    \tbegin\n    \tpc <= 0;\n    \tinst <= 0;\n    \tend\n    else \n    \tbegin\n    \tinst <= instr_mem_in[pc>>2];\n    \tpc <= pc + 4;\n    \tend\n  end\nendmodule\nmodule decode_stage(\n  input clk,\n  input [31:0] inst,\n  output reg [4:0] rs1,\n  output reg [4:0] rs2,\n  output reg [1:0] op,\n  output reg [4:0] rd\n\n);\n  always @(posedge clk) begin\n    rs1 <= inst[29:25];\n    rs2 <= inst[24:20];\n    op <= inst[31:30];\n    rd <= inst[4:0];\n  end\nendmodule\nmodule execute_stage(\n  input clk,\n  input [4:0] rs1,\n  input [4:0] rs2,\n  input [31:0] reg_file [0:31],\n  input [1:0] op,\n  output reg [31:0] result,\n  input [4:0] rdin1,//\n  output reg [4:0] rdout1//\n);\n\n  always @(posedge clk) begin\n    case(op)\n      `ADD_INST: begin\n        result<= reg_file[rs1] + reg_file[rs2];\n      end\n      `SUB_INST: begin\n        result<= reg_file[rs1] - reg_file[rs2];\n      end\n      default: begin\n        result <= 0;\n      end\n    endcase\n    rdout1<=rdin1;//\n  end\nendmodule\n\nmodule memory_stage(\n  input clk,\n  input [31:0] alu_result,\n  output reg [31:0] mem_data,\n  input [4:0] rdin2,//\n  output reg [4:0] rdout2//\n);\n  always @(posedge clk) begin\n    mem_data <= alu_result; // Read memory\n    rdout2<=rdin2;//\n  end\nendmodule\n\nmodule writeback_stage(\n  input clk,\n  input [31:0] mem_data,\n  input [4:0] rd,\n  output reg [31:0] reg_file[0:31]\n);\n  always @(posedge clk) begin\n     reg_file[rd] <= mem_data; // Writeback\n  end\nendmodule\n"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);"}, {"from": "gpt", "value": "module systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);\nreg [15:0] b1, b2, b3;\n// 4 PEs\nPE pe0(.clk(clk), .rst(rst), .a(a0), .b(b0), .c(c0));\nPE pe1(.clk(clk), .rst(rst), .a(a1), .b(b1), .c(c1));\nPE pe2(.clk(clk), .rst(rst), .a(a2), .b(b2), .c(c2));\nPE pe3(.clk(clk), .rst(rst), .a(a3), .b(b3), .c(c3));\n// Cascade b connections \nalways@(posedge clk or posedge rst) begin\n  if (rst) begin\n    b1 <= 0;\n    b2 <= 0;\n    b3 <= 0;\n  end\n  else begin\n    b1 <= b0; // pass b0 to next PE\n    b2 <= b1;\n    b3 <= b2;\n  end\nend\nendmodule\n\nmodule PE (\n  input clk,\n  input rst,\n  input [15:0] a,\n  input [15:0] b,\n  output[31:0] c\n);\n  reg [31:0] r;\n  always @(posedge clk or posedge rst) begin\n    if (rst)\n      r <= 0;\n    else\n      r <= r + (a * b);\n  end\n  assign c = r;\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);"}, {"from": "gpt", "value": "// Instruction types\n`define ADD_INST 2'b00\n`define SUB_INST 2'b01\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);\nwire [31:0] inst;\nwire [31:0] result;\n\nfetch_stage fetch (.clk(clk), .inst(inst), .rst(rst), .instr_mem_in(instr_mem));\nexecute_stage execute (\n  .clk(clk),\n  .inst(inst),\n  .reg_file(reg_file),\n  .result(result)\n);\nwriteback_stage writeback (\n  .clk(clk),\n  .result(result),\n  .reg_file(out_reg_file)\n);\nendmodule\n\n  \n// Pipeline stages \nmodule fetch_stage(\n  input clk,\n  output reg [31:0] inst,\n  input [31:0] instr_mem_in [0:31],\n  input rst\n);\n  reg [31:0] pc;\n  // Fetch logic\n  always @(posedge clk or posedge rst) begin\n    // Fetch next instruction\n    if(rst)\n    \tbegin\n    \tpc <= 0;\n    \tinst <= 0;\n    \tend\n    else \n    \tbegin\n    \tinst <= instr_mem_in[pc>>2];\n    \tpc <= pc + 4;\n    \tend\n  end\nendmodule\nmodule execute_stage(\n  input clk,\n  input [31:0] inst,\n  input [31:0] reg_file [0:31],\n  output reg [31:0] result\n);\n\n  // Decode and read operands\n  always @(posedge clk) begin\n    case(inst[31:30])\n      `ADD_INST: begin\n        result<= reg_file[inst[29:25]]+reg_file[inst[24:20]];\n      end\n      `SUB_INST: begin\n        result <= reg_file[inst[29:25]]-reg_file[inst[24:20]];\n      end\n      default: begin\n        result <= 0;\n      end\n    endcase\n  end\nendmodule \nmodule writeback_stage(\n  input clk,\n  input [31:0] result,\n  // Writeback\n  output reg [31:0] reg_file \n);\n  always @(posedge clk) begin\n    reg_file <= result;\n  end\nendmodule\n"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);\n\n    wire [2:0] count;\n    wire add_cnt;\n    wire end_cnt;\n    wire ready_add;\n    wire [9:0] data_out_reg;\n\n    // Instantiate the counter module\n    counter u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .add_cnt(add_cnt),\n        .end_cnt(end_cnt),\n        .count(count)\n    );\n\n    // Instantiate the data accumulation module\n    data_accumulator u_data_accumulator (\n        .clk(clk),\n        .rst_n(rst_n),\n        .data_in(data_in),\n        .add_cnt(add_cnt),\n\t\t.count(count),\n        .data_out(data_out_reg)\n    );\n\n    // Instantiate the valid output module\n    valid_output u_valid_output (\n        .clk(clk),\n        .rst_n(rst_n),\n        .end_cnt(end_cnt),\n        .valid_out(valid_out)\n    );\n\n    assign add_cnt = ready_add;\n    assign end_cnt = ready_add && (count == 'd4);\n    assign ready_add = valid_in;\n    assign data_out = data_out_reg;\n\nendmodule\n\nmodule counter (\n    input               clk,\n    input               rst_n,\n    input               add_cnt,\n    input               end_cnt,\n    output reg [2:0]   count\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end\n        else if (end_cnt||count=='d4) begin\n            count <= 0;\n        end\n        else if (add_cnt) begin\n            count <= count + 1;\n        end\n    end\n\nendmodule\n\nmodule data_accumulator (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               add_cnt,\n\tinput \t\t[2:0]  count,\n    output reg [9:0]   data_out\n);\n\n    reg [9:0] data_out_reg;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out_reg <= 0;\n        end\n        else if (add_cnt && (count == 'd0)) begin\n            data_out_reg <= data_in;\n        end\n        else if (add_cnt) begin\n            data_out_reg <= data_out_reg + data_in;\n        end\n    end\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_out <= 0;\n        end\n        else begin\n            data_out <= data_out_reg;\n        end\n    end\n\nendmodule\n\n\nmodule valid_output (\n    input               clk,\n    input               rst_n,\n    input               end_cnt,\n    output reg         valid_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            valid_out <= 0;\n        end\n        else \n            valid_out <= end_cnt;\n    end\n\nendmodule\n"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);"}, {"from": "gpt", "value": "`timescale 1ns/1ps\n\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);\n\n    wire [7:0] dividend_abs;\n    wire [8:0] neg_divisor;\n    wire [15:0] sr;\n    wire [8:0] mux_result;\n    wire co;\n    wire [3:0] cnt;\n    wire start_cnt;\n\n    // Instantiate modules\n    abs_value abs_dividend (\n        .sign(sign),\n        .value(dividend),\n        .abs_value(dividend_abs)\n    );\n\n    neg_value neg_divisor_mod (\n        .sign(sign),\n        .value(divisor),\n        .neg_value(neg_divisor)\n    );\n\n    divider_control ctrl (\n        .clk(clk),\n        .rst(rst),\n        .opn_valid(opn_valid),\n        .start_cnt(start_cnt),\n        .cnt(cnt),\n        .sr(sr),\n        .dividend_abs(dividend_abs),\n        .neg_divisor(neg_divisor),\n        .result(result),\n        .mux_result(mux_result),\n        .co(co)\n    );\n\n    // Result management\n    result_management res_mgmt (\n        .clk(clk),\n        .rst(rst),\n        .cnt(cnt),\n        .res_valid(res_valid),\n        .res_ready(res_ready)\n    );\n\nendmodule\n\n// Module to compute absolute value of dividend\nmodule abs_value(\n    input wire sign,\n    input wire [7:0] value,\n    output wire [7:0] abs_value\n);\n    assign abs_value = (sign & value[7]) ? ~value + 1'b1 : value;\nendmodule\n\n// Module to compute negative value of divisor\nmodule neg_value(\n    input wire sign,\n    input wire [7:0] value,\n    output wire [8:0] neg_value\n);\n    assign neg_value = (sign & value[7]) ? {1'b1, value} : ~{1'b0, value} + 1'b1;\nendmodule\n\n// Module for the control logic of the division process\nmodule divider_control(\n    input wire clk,\n    input wire rst,\n    input wire opn_valid,\n    output reg start_cnt,\n    output reg [3:0] cnt,\n    output reg [15:0] sr,\n    input wire [7:0] dividend_abs,\n    input wire [8:0] neg_divisor,\n    output wire [15:0] result,\n    output wire [8:0] mux_result,\n    output wire co\n);\n    \n    always @(posedge clk) begin\n        if (rst) begin\n            sr <= 0;\n            cnt <= 0;\n            start_cnt <= 1'b0;\n        end else if (~start_cnt & opn_valid) begin\n            cnt <= 1;\n            start_cnt <= 1'b1;\n            sr <= {7'b0, dividend_abs, 1'b0}; \n        end else if (start_cnt) begin\n            if (cnt[3]) begin\n                cnt <= 0;\n                start_cnt <= 1'b0;\n                sr[15:8] <= mux_result[7:0]; // Update quotient\n                sr[0] <= co; // Update remainder\n            end else begin\n                cnt <= cnt + 1;\n                sr <= {mux_result[6:0], sr[7:1], co, 1'b0}; // Shift and update\n            end\n        end\n    end\n\n    assign {co, mux_result} = {1'b0, sr[15:8]} + neg_divisor; // Addition to check carry\n\n    assign result = {sr[15:8], sr[7:0]}; // Concatenate remainder and quotient\n\nendmodule\n\n// Module to manage result validity\nmodule result_management(\n    input wire clk,\n    input wire rst,\n    input wire [3:0] cnt,\n    output reg res_valid,\n    input wire res_ready\n);\n    always @(posedge clk) begin\n        res_valid <= rst ? 1'b0 :\n                     cnt[3] ? 1'b1 :\n                     res_ready ? 1'b0 : res_valid;\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);"}, {"from": "gpt", "value": "module div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);\n\n// Internal signals\nwire [63:0] tmp_a; // For holding the shifted dividend\nwire [63:0] tmp_b; // For holding the shifted divisor\nreg [31:0] quotient; // To hold the final quotient\nreg [31:0] remainder; // To hold the final remainder\n\n// Instantiate the preparatory module\nprep_dividend prep (\n    .A(A),\n    .B(B),\n    .tmp_a(tmp_a),\n    .tmp_b(tmp_b)\n);\n\n// Division operation module\ndiv_operation div_op (\n    .tmp_a(tmp_a),\n    .tmp_b(tmp_b),\n    .quotient(quotient),\n    .remainder(remainder)\n);\n\n// Assign outputs\nassign result = quotient;\nassign odd = remainder;\n\nendmodule\n\n// Module to prepare the dividend and divisor\nmodule prep_dividend(\n    input wire [31:0] A,\n    input wire [15:0] B,\n    output reg [63:0] tmp_a,\n    output reg [63:0] tmp_b\n);\n\nalways @(*) begin\n    tmp_a = {32'b0, A}; // Concatenate 32 zeros with A\n    tmp_b = {B, 32'b0}; // Concatenate B with 32 zeros\nend\n\nendmodule\n\n// Division operation module\nmodule div_operation(\n    input wire [63:0] tmp_a,\n    input wire [63:0] tmp_b,\n    output reg [31:0] quotient,\n    output reg [31:0] remainder\n);\n\ninteger i;\n\nalways @(*) begin\n    quotient = 0;\n    remainder = tmp_a; // Start with the full dividend\n\n    for (i = 0; i < 32; i = i + 1) begin\n        remainder = remainder << 1; // Shift left\n        if (remainder >= tmp_b) begin\n            remainder = remainder - tmp_b; // Subtract divisor\n            quotient = quotient | (1 << (31 - i)); // Set the quotient bit\n        end\n    end\nend\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);"}, {"from": "gpt", "value": "module div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);\n\n    wire [15:0] quotient;\n    wire [15:0] remainder;\n\n    // Instantiate the control module\n    control_unit ctrl (\n        .A(A),\n        .B(B),\n        .quotient(quotient),\n        .remainder(remainder)\n    );\n\n    // Assign outputs\n    assign result = quotient;\n    assign odd = remainder;\n\nendmodule\n\nmodule control_unit (\n    input wire [15:0] A,\n    input wire [7:0] B,\n    output reg [15:0] quotient,\n    output reg [15:0] remainder\n);\n    reg [31:0] tmp_a;\n    reg [31:0] tmp_b;\n    integer i;\n\n    always @(*) begin\n        // Initialize temporary variables\n        tmp_a = {16'b0, A};        // Concatenate A to a 32-bit value\n        tmp_b = {B, 16'b0};        // Concatenate B to a 32-bit value\n        quotient = 0;              // Reset quotient\n        remainder = 0;             // Reset remainder\n\n        // Division algorithm\n        for (i = 0; i < 16; i = i + 1) begin\n            tmp_a = tmp_a << 1;    // Shift left to process the next bit\n            if (tmp_a >= tmp_b) begin\n                tmp_a = tmp_a - tmp_b; // Subtract divisor from dividend\n                quotient[i] = 1;        // Set quotient bit to 1\n            end else begin\n                quotient[i] = 0;        // Set quotient bit to 0\n            end\n        end\n\n        remainder = tmp_a[31:16]; // Assign remainder from the higher bits of tmp_a\n    end\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);"}, {"from": "gpt", "value": "module sub_8bit(A, B, D, B_out);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the difference A - B\n    output B_out;       // Borrow output\n\n    wire [7:0] B_complement;\n    wire borrow;\n\n    // Generate 2's complement of B\n    assign B_complement = ~B + 1;\n\n    // Instantiate the adder module to perform A + (~B + 1)\n    adder_8bit adder_inst(\n        .A(A),\n        .B(B_complement),\n        .D(D),\n        .Cout(borrow)\n    );\n\n    // Borrow output logic\n    assign B_out = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, D, Cout);\n    input [7:0] A;      // 8-bit input operand A\n    input [7:0] B;      // 8-bit input operand B\n    output [7:0] D;     // 8-bit output representing the sum\n    output Cout;        // Carry out (borrow in this case)\n\n    wire [7:0] sum;\n    wire carry[0:7];    // Intermediate carry wires\n\n    // Full adder instances\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Cout));\n\n    // Assign the sum to output\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;       // Input A\n    input B;       // Input B\n    input Cin;     // Carry input\n    output Sum;    // Sum output\n    output Cout;   // Carry output\n\n    assign Sum = A ^ B ^ Cin;                  // Sum calculation\n    assign Cout = (A & B) | (Cin & (A ^ B));  // Carry calculation\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);"}, {"from": "gpt", "value": "module sub_32bit(A, B, Diff, B_out);\n    input [31:0] A;  // 32-bit input operand A\n    input [31:0] B;  // 32-bit input operand B\n    output [31:0] Diff; // 32-bit output representing the difference A - B\n    output B_out;    // Borrow-out output \n\n    wire [15:0] B_neg; // Negated B for 1's complement\n    wire borrow1, borrow2;\n\n    // Negate B (1's complement)\n    assign B_neg = ~B[15:0];\n\n    // First 16-bit subtractor instance\n    subtractor_16 S1(\n        .A(A[15:0]),\n        .B(B_neg),\n        .Borrow_in(1'b1), // Setting Borrow_in to 1 for 1's complement subtraction\n        .Diff(Diff[15:0]),\n        .Borrow_out(borrow1)\n    );\n\n    // Second 16-bit subtractor instance\n    subtractor_16 S2(\n        .A(A[31:16]),\n        .B(~B[31:16]),\n        .Borrow_in(borrow1),\n        .Diff(Diff[31:16]),\n        .Borrow_out(borrow2)\n    );\n\n    // Final borrow output\n    assign B_out = borrow2;\n\nendmodule\n\nmodule subtractor_16(A, B, Borrow_in, Diff, Borrow_out);\n    input [15:0] A;         // 16-bit input operand A\n    input [15:0] B;         // 16-bit input operand B\n    input Borrow_in;        // Borrow input\n    output [15:0] Diff;     // 16-bit output representing the difference A - B\n    output Borrow_out;      // Borrow output\n\n    wire [15:0] B_complement; // 1's complement of B\n    wire [15:0] temp_diff;    // Temporary difference\n    wire borrow;              // Intermediate borrow\n\n    // Compute 1's complement of B\n    assign B_complement = ~B;\n\n    // Full subtractor logic: Diff = A - B + Borrow_in\n    assign {borrow, temp_diff} = A + B_complement + Borrow_in;\n\n    // Assign outputs\n    assign Diff = temp_diff;\n    assign Borrow_out = borrow;\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);"}, {"from": "gpt", "value": "module sub_64bit(A, B, D, B_out);\n    input [63:0] A;         // 64-bit input operand A\n    input [63:0] B;         // 64-bit input operand B\n    output [63:0] D;        // 64-bit output representing the difference A - B\n    output B_out;           // Borrow-out output\n\n    wire borrow32;          // Borrow output from the lower 32 bits\n\n    // Instantiate two 32-bit subtractors\n    subtractor_32bit sub0 (\n        .A(A[31:0]),\n        .B(B[31:0]),\n        .D(D[31:0]),\n        .borrow_out(borrow32)\n    );\n\n    subtractor_32bit sub1 (\n        .A(A[63:32]),\n        .B(B[63:32]),\n        .D(D[63:32]),\n        .borrow_out(B_out)\n    );\n\n    // Handle borrow from the lower 32-bit subtractor\n    assign B_out = borrow32;\n\nendmodule\n\nmodule subtractor_32bit(A, B, D, borrow_out);\n    input [31:0] A;         // 32-bit input operand A\n    input [31:0] B;         // 32-bit input operand B\n    output [31:0] D;        // 32-bit output representing the difference A - B\n    output borrow_out;      // Borrow-out output\n\n    wire borrow16;          // Borrow output from the lower 16 bits\n\n    // Instantiate two 16-bit subtractors\n    subtractor_16bit sub0 (\n        .A(A[15:0]),\n        .B(B[15:0]),\n        .D(D[15:0]),\n        .borrow_out(borrow16)\n    );\n\n    subtractor_16bit sub1 (\n        .A(A[31:16]),\n        .B(B[31:16]),\n        .D(D[31:16]),\n        .borrow_out(borrow_out)\n    );\n\n    // Handle borrow from the lower 16-bit subtractor\n    assign borrow_out = borrow_out | borrow16;\n\nendmodule\n\nmodule subtractor_16bit(A, B, D, borrow_out);\n    input [15:0] A;         // 16-bit input operand A\n    input [15:0] B;         // 16-bit input operand B\n    output [15:0] D;        // 16-bit output representing the difference A - B\n    output borrow_out;      // Borrow-out output\n\n    wire borrow8;           // Borrow output from the lower 8 bits\n\n    // Instantiate two 8-bit subtractors\n    subtractor_8bit sub0 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .D(D[7:0]),\n        .borrow_out(borrow8)\n    );\n\n    subtractor_8bit sub1 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .D(D[15:8]),\n        .borrow_out(borrow_out)\n    );\n\n    // Handle borrow from the lower 8-bit subtractor\n    assign borrow_out = borrow_out | borrow8;\n\nendmodule\n\nmodule subtractor_8bit(A, B, D, borrow_out);\n    input [7:0] A;          // 8-bit input operand A\n    input [7:0] B;          // 8-bit input operand B\n    output [7:0] D;         // 8-bit output representing the difference A - B\n    output borrow_out;      // Borrow-out output\n\n    wire [7:0] B_in;        // Inverted B for subtraction\n    wire borrow;            // Borrow signal\n\n    assign B_in = ~B;       // Invert B for subtraction\n    assign {borrow_out, D} = A + B_in + 1; // Perform A - B\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);"}, {"from": "gpt", "value": "module sub_16bit(A, B, D, B_out);\n    input [16:1] A;       // 16-bit input A\n    input [16:1] B;       // 16-bit input B\n    output [16:1] D;      // 16-bit difference output\n    output B_out;         // Borrow out\n\n    wire b4, b8, b12;\n\n    // Instantiate 4-bit subtractors\n    subtractor_4 sub1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .B_in(0),\n        .D(D[4:1]),\n        .B_out(b4)\n    );\n\n    subtractor_4 sub2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .B_in(b4),\n        .D(D[8:5]),\n        .B_out(b8)\n    );\n\n    subtractor_4 sub3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .B_in(b8),\n        .D(D[12:9]),\n        .B_out(b12)\n    );\n\n    subtractor_4 sub4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .B_in(b12),\n        .D(D[16:13]),\n        .B_out(B_out)\n    );\nendmodule\n\nmodule subtractor_4(A, B, B_in, D, B_out);\n    input [4:1] A;        // 4-bit input A\n    input [4:1] B;        // 4-bit input B\n    input B_in;           // Borrow in\n    output [4:1] D;       // 4-bit difference output\n    output B_out;         // Borrow out\n\n    wire p1, p2, p3, p4;  // Propagate signals\n    wire g1, g2, g3, g4;  // Generate signals\n    wire b1, b2, b3;      // Internal borrow signals\n\n    // Instantiate full subtractors for each bit\n    full_subtractor fs1(\n        .A(A[1]),\n        .B(B[1]),\n        .B_in(B_in),\n        .D(D[1]),\n        .B_out(b1)\n    );\n\n    full_subtractor fs2(\n        .A(A[2]),\n        .B(B[2]),\n        .B_in(b1),\n        .D(D[2]),\n        .B_out(b2)\n    );\n\n    full_subtractor fs3(\n        .A(A[3]),\n        .B(B[3]),\n        .B_in(b2),\n        .D(D[3]),\n        .B_out(b3)\n    );\n\n    full_subtractor fs4(\n        .A(A[4]),\n        .B(B[4]),\n        .B_in(b3),\n        .D(D[4]),\n        .B_out(B_out)\n    );\n\n    // Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = ~A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = ~A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = ~A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = ~A[4] & B[4];\n\nendmodule\n\nmodule full_subtractor(A, B, B_in, D, B_out);\n    input A;              // Input A\n    input B;              // Input B\n    input B_in;           // Borrow in\n    output D;             // Difference output\n    output B_out;         // Borrow out\n\n    assign D = A ^ B ^ B_in; // Difference calculation\n    assign B_out = (~A & B) | ((~A | B) & B_in); // Borrow out calculation\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);"}, {"from": "gpt", "value": "module comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);\n\n    wire [31:0] diff;  \n    wire cout;       \n\n    // Instantiate the 32-bit subtractor\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .cout(cout)\n    );\n\n    // Determine the comparison outputs\n    assign A_greater = (~cout && diff != 32'b0);\n    assign A_equal = (A == B);\n    assign A_less = cout;\n\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,   // First operand\n    input [31:0] B,   // Second operand\n    output [31:0] diff, // Difference output\n    output cout       // Carry output (borrow for subtraction)\n);\n\n    // Perform the subtraction\n    assign {cout, diff} = A - B;\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);"}, {"from": "gpt", "value": "module adder_32bit(A,B,S,C32);\n     input [32:1] A;\n     input [32:1] B;\n     output [32:1] S;\n     output C32;\n\n     wire px1,gx1,px2,gx2;\n     wire c16;\n\n  CLA_16 CLA1(\n      .A(A[16:1]),\n        .B(B[16:1]),\n        .c0(0),\n        .S(S[16:1]),\n        .px(px1),\n        .gx(gx1)\n    );\n\n  CLA_16 CLA2(\n        .A(A[32:17]),\n          .B(B[32:17]),\n          .c0(c16),\n          .S(S[32:17]),\n          .px(px2),\n          .gx(gx2)\n    );\n\n  assign c16 = gx1 ^ (px1 && 0), //c0 = 0\n         C32 = gx2 ^ (px2 && c16);\nendmodule\n\nmodule CLA_16(A,B,c0,S,px,gx);\n    input [16:1] A;\n    input [16:1] B;\n    input c0;\n    output gx,px;\n    output [16:1] S;\n\n    wire c4,c8,c12;\n    wire Pm1,Gm1,Pm2,Gm2,Pm3,Gm3,Pm4,Gm4;\n\n    adder_4 adder1(\n         .x(A[4:1]),\n          .y(B[4:1]),\n          .c0(c0),\n          .c4(),\n          .F(S[4:1]),\n          .Gm(Gm1),\n          .Pm(Pm1)\n    );\n\n    adder_4 adder2(\n         .x(A[8:5]),\n          .y(B[8:5]),\n          .c0(c4),\n          .c4(),\n          .F(S[8:5]),\n          .Gm(Gm2),\n          .Pm(Pm2)\n    );\n\n    adder_4 adder3(\n         .x(A[12:9]),\n          .y(B[12:9]),\n          .c0(c8),\n          .c4(),\n          .F(S[12:9]),\n          .Gm(Gm3),\n          .Pm(Pm3)\n    );\n\n    adder_4 adder4(\n         .x(A[16:13]),\n          .y(B[16:13]),\n          .c0(c12),\n          .c4(),\n          .F(S[16:13]),\n          .Gm(Gm4),\n          .Pm(Pm4)\n    );\n\n    assign   c4 = Gm1 ^ (Pm1 & c0),\n             c8 = Gm2 ^ (Pm2 & Gm1) ^ (Pm2 & Pm1 & c0),\n             c12 = Gm3 ^ (Pm3 & Gm2) ^ (Pm3 & Pm2 & Gm1) ^ (Pm3 & Pm2 & Pm1 & c0);\n\n    assign  px = Pm1 & Pm2 & Pm3 & Pm4,\n            gx = Gm4 ^ (Pm4 & Gm3) ^ (Pm4 & Pm3 & Gm2) ^ (Pm4 & Pm3 & Pm2 & Gm1);\nendmodule\n\nmodule adder_4(x,y,c0,c4,F,Gm,Pm);\n      input [4:1] x;\n      input [4:1] y;\n      input c0;\n      output c4,Gm,Pm;\n      output [4:1] F;\n\n      wire p1,p2,p3,p4,g1,g2,g3,g4;\n      wire c1,c2,c3;\n      adder adder1(\n                 .X(x[1]),\n                     .Y(y[1]),\n                     .Cin(c0),\n                     .F(F[1]),\n                     .Cout()\n                );\n\n      adder adder2(\n                 .X(x[2]),\n                     .Y(y[2]),\n                     .Cin(c1),\n                     .F(F[2]),\n                     .Cout()\n                );  \n\n      adder adder3(\n                 .X(x[3]),\n                     .Y(y[3]),\n                     .Cin(c2),\n                     .F(F[3]),\n                     .Cout()\n                );\n\n      adder adder4(\n                 .X(x[4]),\n                     .Y(y[4]),\n                     .Cin(c3),\n                     .F(F[4]),\n                     .Cout()\n                );      \n\n        CLA CLA(\n            .c0(c0),\n            .c1(c1),\n            .c2(c2),\n            .c3(c3),\n            .c4(c4),\n            .p1(p1),\n            .p2(p2),\n            .p3(p3),\n            .p4(p4),\n            .g1(g1),\n            .g2(g2),\n            .g3(g3),\n            .g4(g4)\n        );\n\n\n\n  assign   p1 = x[1] ^ y[1],      \n           p2 = x[2] ^ y[2],\n           p3 = x[3] ^ y[3],\n           p4 = x[4] ^ y[4];\n\n  assign   g1 = x[1] & y[1],\n           g2 = x[2] & y[2],\n           g3 = x[3] & y[3],\n           g4 = x[4] & y[4];\n\n  assign Pm = p1 & p2 & p3 & p4,\n         Gm = g4 ^ (p4 & g3) ^ (p4 & p3 & g2) ^ (p4 & p3 & p2 & g1);\nendmodule\n\nmodule CLA(c0,c1,c2,c3,c4,p1,p2,p3,p4,g1,g2,g3,g4);\n\n     input c0,g1,g2,g3,g4,p1,p2,p3,p4;\n     output c1,c2,c3,c4;\n\n     assign c1 = g1 ^ (p1 & c0),\n            c2 = g2 ^ (p2 & g1) ^ (p2 & p1 & c0),\n            c3 = g3 ^ (p3 & g2) ^ (p3 & p2 & g1) ^ (p3 & p2 & p1 & c0),\n            c4 = g4^(p4&g3)^(p4&p3&g2)^(p4&p3&p2&g1)^(p4&p3&p2&p1&c0);\nendmodule\n\nmodule adder(X,Y,Cin,F,Cout);\n\n  input X,Y,Cin;\n  output F,Cout;\n\n  assign F = X ^ Y ^ Cin;\n  assign Cout = (X ^ Y) & Cin | X & Y;\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);"}, {"from": "gpt", "value": "`timescale 1ns / 1ns\n\nmodule adder_16bit_csa(a, b, cin, sum, cout);\ninput [15:0] a,b;\ninput cin;\noutput [15:0] sum;\noutput cout;\n\nwire [2:0] c;\n\nripple_carry_4_bit rca1(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(cin),\n.sum(sum[3:0]),\n.cout(c[0]));\n\n// first 4-bit by ripple_carry_adder\ncarry_select_adder_4bit_slice csa_slice1(\n.a(a[7:4]),\n.b(b[7:4]),\n.cin(c[0]),\n.sum(sum[7:4]),\n.cout(c[1]));\n\ncarry_select_adder_4bit_slice csa_slice2(\n.a(a[11:8]),\n.b(b[11:8]),\n.cin(c[1]),\n.sum(sum[11:8]), \n.cout(c[2]));\n\ncarry_select_adder_4bit_slice csa_slice3(\n.a(a[15:12]),\n.b(b[15:12]),\n.cin(c[2]),\n.sum(sum[15:12]),\n.cout(cout));\nendmodule\n\n//////////////////////////////////////\n//4-bit Carry Select Adder Slice\n//////////////////////////////////////\n\nmodule carry_select_adder_4bit_slice(a, b, cin, sum, cout);\ninput [3:0] a,b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire [3:0] s0,s1;\nwire c0,c1;\n\nripple_carry_4_bit rca1(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(1'b0),\n.sum(s0[3:0]),\n.cout(c0));\n\nripple_carry_4_bit rca2(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(1'b1),\n.sum(s1[3:0]),\n.cout(c1));\n\nmux2X1 #(4) ms0(\n.in0(s0[3:0]),\n.in1(s1[3:0]),\n.sel(cin),\n.out(sum[3:0]));\n\nmux2X1 #(1) mc0(\n.in0(c0),\n.in1(c1),\n.sel(cin),\n.out(cout));\nendmodule\n\n/////////////////////\n//2X1 Mux\n/////////////////////\n\nmodule mux2X1( in0,in1,sel,out);\nparameter width=16; \ninput [width-1:0] in0,in1;\ninput sel;\noutput [width-1:0] out;\nassign out=(sel)?in1:in0;\nendmodule\n\n\n/////////////////////////////////\n//4-bit Ripple Carry Adder\n/////////////////////////////////\nmodule ripple_carry_4_bit(a, b, cin, sum, cout);\ninput [3:0] a,b;\ninput cin;\noutput [3:0] sum;\noutput cout;\n\nwire c1,c2,c3;\n\nfull_adder fa0(\n.a(a[0]),\n.b(b[0]),\n.cin(cin),\n.sum(sum[0]),\n.cout(c1));\n\nfull_adder fa1(\n.a(a[1]),\n.b(b[1]),\n.cin(c1),\n.sum(sum[1]),\n.cout(c2));\n\nfull_adder fa2(\n.a(a[2]),\n.b(b[2]),\n.cin(c2),\n.sum(sum[2]),\n.cout(c3));\n\nfull_adder fa3(\n.a(a[3]),\n.b(b[3]),\n.cin(c3),\n.sum(sum[3]),\n.cout(cout));\nendmodule\n\n/////////////////////\n//1bit Full Adder\n/////////////////////\n\nmodule full_adder(a,b,cin,sum, cout);\ninput a,b,cin;\noutput sum, cout;\n\nwire x,y,z;\n\nhalf_adder h1(.a(a), .b(b), .sum(x), .cout(y));\nhalf_adder h2(.a(x), .b(cin), .sum(sum), .cout(z));\nor or_1(cout,z,y);\nendmodule\n\n//////////////////////\n// 1 bit Half Adder\n//////////////////////\n\nmodule half_adder( a,b, sum, cout );\ninput a,b;\noutput sum, cout;\nxor xor_1 (sum,a,b);\nand and_1 (cout,a,b);\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);"}, {"from": "gpt", "value": "module adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add8 add8_inst1 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .Cin(Co_temp), \n        .y(y[15:8]),\n        .Co(Co)\n    );\n \n    add8 add8_inst2 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .Cin(Cin),\n        .y(y[7:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    input wire Cin,\n    output wire [7:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add4 add4_inst1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .Cin(Co_temp),\n        .y(y[7:4]),\n        .Co(Co)\n    );\n \n    add4 add4_inst2 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .Cin(Cin),\n        .y(y[3:0]),\n        .Co(Co_temp)\n    );\n \nendmodule\n\nmodule add4 (\n    input wire [3:0] a,\n    input wire [3:0] b,\n    input wire Cin,\n    output wire [3:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n \n    add2 add2_inst1 (\n        .a(a[3:2]),\n        .b(b[3:2]),\n        .Cin(Co_temp),\n        .y(y[3:2]),\n        .Co(Co)\n    );\n \n    add2 add2_inst2 (\n        .a(a[1:0]),\n        .b(b[1:0]),\n        .Cin(Cin),\n        .y(y[1:0]),\n        .Co(Co_temp)\n    ); \n \nendmodule\n\nmodule add2 (\n    input wire [1:0] a,\n    input wire [1:0] b,\n    input wire Cin,\n    output wire [1:0] y,\n    output wire Co\n);\n \n    wire Co_temp;\n\n    add1 add1_inst1 (\n        .a(a[1]),\n        .b(b[1]),\n        .Cin(Co_temp),\n        .y(y[1]),\n        .Co(Co)\n    );\n \n    add1 add1_inst2 (\n        .a(a[0]),\n        .b(b[0]),\n        .Cin(Cin),\n        .y(y[0]),\n        .Co(Co_temp)\n    );\n         \nendmodule\n\nmodule add1 (\n    input wire a,\n    input wire b,\n    input wire Cin,\n    output wire y,\n    output wire Co\n);\n    assign y = ((~a) & (~b) & Cin | (~a) & b & (~Cin) | a & (~b) & (~Cin) | (a & b & Cin));\n    assign Co = ((~a & b & Cin) | (a & ~b & Cin) | (a & b & ~Cin) | (a & b & Cin));\n\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);"}, {"from": "gpt", "value": "module adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);\n    \n    wire [8:0] c;\n\n    full_adder FA0 (.a(a[0]), .b(b[0]), .cin(cin), .sum(sum[0]), .cout(c[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .cin(c[0]), .sum(sum[1]), .cout(c[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .cin(c[1]), .sum(sum[2]), .cout(c[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .cin(c[2]), .sum(sum[3]), .cout(c[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .cin(c[3]), .sum(sum[4]), .cout(c[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .cin(c[4]), .sum(sum[5]), .cout(c[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .cin(c[5]), .sum(sum[6]), .cout(c[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .cin(c[6]), .sum(sum[7]), .cout(c[7]));\n\n    assign cout = c[7]; \nendmodule\n\nmodule full_adder (input a, b, cin, output sum, cout);\n    assign {cout, sum} = a + b + cin;\nendmodule"}]}, {"conversations": [{"from": "human", "value": "Given a submodules interconnection graph: \n<graph>\n, \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);"}, {"from": "gpt", "value": "module multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);\n\n    // Internal wires and registers\n    wire [15:0] areg;\n    wire [15:0] breg;\n    wire [31:0] yout_r;\n    wire done_r;\n    wire [4:0] i;\n\n    // Instantiate the control unit\n    control_unit ctrl (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .i(i),\n        .done(done_r)\n    );\n\n    // Instantiate the register unit\n    register_unit reg_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .ain(ain),\n        .bin(bin),\n        .i(i),\n        .areg(areg),\n        .breg(breg),\n        .yout_r(yout_r)\n    );\n\n    // Instantiate the multiplier unit\n    multiplier_unit mul_unit (\n        .clk(clk),\n        .rst_n(rst_n),\n        .start(start),\n        .i(i),\n        .areg(areg),\n        .breg(breg),\n        .yout_r(yout_r)\n    );\n\n    // Output assignments\n    assign done = done_r;\n    assign yout = yout_r;\n\nendmodule\n\n// Control Unit\nmodule control_unit (\n    input clk,\n    input rst_n,\n    input start,\n    output reg [4:0] i,\n    output reg done\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            i <= 5'd0;\n            done <= 1'b0;\n        end\n        else if (start && i < 5'd17) begin\n            i <= i + 1'b1;\n        end\n        else if (!start) begin\n            i <= 5'd0;\n        end\n\n        // Update done flag\n        if (i == 5'd16) done <= 1'b1;    // Multiplication completion\n        else if (i == 5'd17) done <= 1'b0; // Reset flag\n    end\n\nendmodule\n\n// Register Unit\nmodule register_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [15:0] ain,\n    input [15:0] bin,\n    input [4:0] i,\n    output reg [15:0] areg,\n    output reg [15:0] breg,\n    output reg [31:0] yout_r\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            areg <= 16'h0000;\n            breg <= 16'h0000;\n            yout_r <= 32'h00000000;\n        end\n        else if (start) begin\n            if (i == 5'd0) begin\n                areg <= ain;  // Store multiplicand\n                breg <= bin;  // Store multiplier\n            end\n        end\n    end\n\nendmodule\n\n// Multiplier Unit\nmodule multiplier_unit (\n    input clk,\n    input rst_n,\n    input start,\n    input [4:0] i,\n    input [15:0] areg,\n    input [15:0] breg,\n    output reg [31:0] yout_r\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            yout_r <= 32'h00000000;\n        end\n        else if (start) begin\n            if (i > 5'd0 && i < 5'd17) begin\n                if (areg[i-1]) \n                    yout_r <= yout_r + ({16'h0000, breg} << (i-1)); // Accumulate and shift\n            end\n        end\n    end\n\nendmodule"}]}]