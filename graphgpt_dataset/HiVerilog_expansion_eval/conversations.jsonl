{"Instruction":"Implement a modular 32-bit Adder-Subtractor using Verilog. In the top module named `as_module`, instantiate submodules for addition and subtraction. The `as_module` orchestrates these submodules to perform either addition or subtraction based on a mode input.\n\nModule name:\n    as_module\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, high to reset, low otherwise.\n    mode: Operation mode, 0 for addition and 1 for subtraction.\n    op1: 32-bit input operand 1.\n    op2: 32-bit input operand 2.\n\nOutput ports:\n    result: 32-bit output, result of addition or subtraction.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule takes two 32-bit inputs (op1 and op2) and produces a 32-bit result of their addition.\nSubtractor Submodule:\nThis submodule subtracts the second 32-bit input (op2) from the first (op1) and outputs the 32-bit result.\nThe main as_module module uses the mode input to select and output the result from either the Adder or Subtractor submodule based on the operation mode.\nGive me the complete code.","Response":"module as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\n\n\/\/ Instantiating the adder module\nadder u_adder (\n    .a(op1),\n    .b(op2),\n    .sum(add_result)\n);\n\n\/\/ Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(op1),\n    .b(op2),\n    .difference(sub_result)\n);\n\n\/\/ Selecting output based on mode\nassign result = (mode == 0) ? add_result : sub_result;\n\nendmodule\n\n\/\/ Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\n\/\/ Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] difference\n);\n    assign difference = a - b;\nendmodule\n","task_id":"pe_v_0"}
{"Instruction":"Implement a modular 32-bit Integer Divider and Subtractor system using Verilog. The main module, named `ds`, should include submodules for division and subtraction. It connects these to perform the operations, handling 32-bit integers.\n\nModule name:\n    ds\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, high to reset, low otherwise.\n    x: 32-bit dividend input.\n    y: 32-bit divisor input.\n    z: 32-bit subtrahend input.\n\nOutput ports:\n    quotient: 32-bit output for the division result.\n    difference: 32-bit output for the subtraction result.\n\nImplementation:\nThe module includes:\nDivider Submodule:\nThis submodule takes two 32-bit inputs (x and y) and calculates the division, providing a 32-bit quotient.\nSubtractor Submodule:\nThis submodule takes the division result and a 32-bit input z, computing the subtraction (quotient - z) and outputting a 32-bit difference.\nThe main `ds` module integrates these submodules, outputting the results for quotient and difference.\nGive me the complete code.","Response":"module ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);\n\n\/\/ Intermediate wires for outputs of submodules\nwire [31:0] division_result;\nwire [31:0] subtraction_result;\n\n\/\/ Instantiating the divider module\ndivider u_divider (\n    .x(x),\n    .y(y),\n    .quotient(division_result)\n);\n\n\/\/ Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(division_result),\n    .b(z),\n    .result(subtraction_result)\n);\n\n\/\/ Assigning the results to the outputs\nassign quotient = division_result;\nassign difference = subtraction_result;\n\nendmodule\n\n\/\/ Divider module\nmodule divider(\n    input [31:0] x,\n    input [31:0] y,\n    output [31:0] quotient\n);\n    assign quotient = x \/ y;\nendmodule\n\n\/\/ Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n","task_id":"pe_v_1"}
{"Instruction":"Design a modular Arithmetic Logic Unit (ALU) for 32-bit integers. The top module, alu_module, should integrate submodules for addition, subtraction, bitwise AND, and bitwise OR operations. The alu_module connects these submodules to perform the specified operation based on an operation selector input.\n\nModule name:\n    alu_module\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n    op_sel: 2-bit operation selector (00 for ADD, 01 for SUB, 10 for AND, 11 for OR).\n\nOutput ports:\n    result: 32-bit output representing the ALU operation result.\n\nImplementation:\nThe module includes:\nAdder Submodule:\n    This submodule takes two 32-bit inputs and provides a 32-bit output of their sum.\nSubtractor Submodule:\n    This submodule takes two 32-bit inputs and provides a 32-bit output of their difference.\nAND Submodule:\n    This submodule performs a bitwise AND operation on two 32-bit inputs to produce a 32-bit output.\nOR Submodule:\n    This submodule performs a bitwise OR operation on two 32-bit inputs to produce a 32-bit output.\nThe main alu_module uses the operation selector to choose which submodule's output to route to the main output result.\nGive me the complete code.","Response":"module alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);\n\nwire [31:0] add_result;\nwire [31:0] sub_result;\nwire [31:0] and_result;\nwire [31:0] or_result;\n\n\/\/ Instantiate the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n\/\/ Instantiate the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\n\/\/ Instantiate the and module\nand_module u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n\/\/ Instantiate the or module\nor_module u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\nalways @(posedge clk) begin\n    case(op_sel)\n        2'b00: result <= add_result;\n        2'b01: result <= sub_result;\n        2'b10: result <= and_result;\n        2'b11: result <= or_result;\n        default: result <= 32'b0;\n    endcase\nend\n\nendmodule\n\n\/\/ Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n\/\/ Subtractor module\nmodule subtractor(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a - b;\nendmodule\n\n\/\/ AND module\nmodule and_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n\n\/\/ OR module\nmodule or_module(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a | b;\nendmodule","task_id":"pe_v_2"}
{"Instruction":"Implement a modular Arithmetic Logic Unit (ALU) for 32-bit integers, performing addition and bitwise AND operations. The top module, alu, connects the submodules for addition and bitwise AND operation. Each submodule handles one operation and outputs the result to the alu module, which then selects the output based on an operation select signal.\n\nModule name:\n    alu\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    op_sel: Operation select signal. 0 for addition, 1 for bitwise AND.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    result: 32-bit output representing the result of the selected operation.\n\nImplementation:\nAdder Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 32-bit result of their addition.\nAND Submodule:\nThis submodule performs a bitwise AND operation on two 32-bit inputs (a and b) and outputs the result.\nThe main alu module connects these submodules and selects the appropriate operation result based on the op_sel signal, driving the output result accordingly.\nGive me the complete code.","Response":"module alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n\n\/\/ Intermediate wires for submodule results\nwire [31:0] add_result;\nwire [31:0] and_result;\n\n\/\/ Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n\/\/ Instantiating the AND module\nbitwise_and u_bitwise_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n\/\/ Selecting the result based on operation select input\nassign result = (op_sel == 0) ? add_result : and_result;\n\nendmodule\n\n\/\/ Adder module\nmodule adder(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a + b;\nendmodule\n\n\/\/ Bitwise AND module\nmodule bitwise_and(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\n    assign result = a & b;\nendmodule\n","task_id":"pe_v_3"}
{"Instruction":"Implement a modular Dual-mode Arithmetic Unit for 16-bit integers. In the dual_mode_arithmetic module, there are submodules for addition and subtraction. The dual_mode_arithmetic module selects either addition or subtraction based on the mode input.\n\nModule name:\n    dual_mode_arithmetic\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    mode: Mode selection signal. Defined as 0 for addition and 1 for subtraction.\n    a: 16-bit input operand A.\n    b: 16-bit input operand B.\n\nOutput ports:\n    result: 16-bit output representing the arithmetic result.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule takes two 16-bit inputs (a and b) and produces a 16-bit result of their addition.\nSubtractor Submodule:\nThis submodule subtracts the input B from input A and outputs a 16-bit result.\nThe main dual_mode_arithmetic module uses a multiplexer controlled by the mode input to select between the outputs of the adder and subtractor submodules and drives the output result accordingly.\nGive me the complete code.","Response":"module dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\n\/\/ Intermediate wires to hold the addition and subtraction results\nwire [15:0] add_result;\nwire [15:0] sub_result;\n\n\/\/ Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n\/\/ Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\n\/\/ Multiplexer to select output based on mode\nassign result = mode ? sub_result : add_result;\n\nendmodule\n\n\/\/ Adder module\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n\/\/ Subtractor module\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule","task_id":"pe_v_4"}
{"Instruction":"Implement a module of a 4-bit multiplier using a series of full adders in sequential logic.\n\nModule name:  \n    multiplier_4bit               \nInput ports:\n    a[3:0]: 4-bit input operand A.\n    b[3:0]: 4-bit input operand B.\nOutput ports:\n    product[7:0]: 8-bit output representing the product of A and B.\n\nImplementation:\nThe module utilizes a series of full adders and shift registers to perform the multiplication operation.\nGive me the complete code.","Response":"module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [3:0] partial_products[3:0];\n    wire [7:0] sum[3:0];\n    \n    generate_partial_products GPP0 (.a(a), .b(b[0]), .partial_product(partial_products[0]));\n    generate_partial_products GPP1 (.a(a), .b(b[1]), .partial_product(partial_products[1]));\n    generate_partial_products GPP2 (.a(a), .b(b[2]), .partial_product(partial_products[2]));\n    generate_partial_products GPP3 (.a(a), .b(b[3]), .partial_product(partial_products[3]));\n\n    assign sum[0] = {4'b0, partial_products[0]};\n    \n    adder_4bit_with_shift A4BS0 (.a(sum[0]), .b({3'b0, partial_products[1], 1'b0}), .sum(sum[1]));\n    adder_4bit_with_shift A4BS1 (.a(sum[1]), .b({2'b0, partial_products[2], 2'b0}), .sum(sum[2]));\n    adder_4bit_with_shift A4BS2 (.a(sum[2]), .b({1'b0, partial_products[3], 3'b0}), .sum(sum[3]));\n\n    assign product = sum[3];\nendmodule\n\nmodule generate_partial_products(input [3:0] a, input b, output [3:0] partial_product);\n    assign partial_product = b ? a : 4'b0;\nendmodule\n\nmodule adder_4bit_with_shift(input [7:0] a, input [7:0] b, output [7:0] sum);\n    wire [8:0] carry;\n    assign {carry[0], sum[0]} = a[0] + b[0];\n    assign {carry[1], sum[1]} = a[1] + b[1] + carry[0];\n    assign {carry[2], sum[2]} = a[2] + b[2] + carry[1];\n    assign {carry[3], sum[3]} = a[3] + b[3] + carry[2];\n    assign {carry[4], sum[4]} = a[4] + b[4] + carry[3];\n    assign {carry[5], sum[5]} = a[5] + b[5] + carry[4];\n    assign {carry[6], sum[6]} = a[6] + b[6] + carry[5];\n    assign {carry[7], sum[7]} = a[7] + b[7] + carry[6];\nendmodule","task_id":"adder_8bit_v_5"}
{"Instruction":"Implement a module of an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A and B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.","Response":"module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] btemp;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(btemp[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(btemp[0]), .diff(diff[1]), .bout(btemp[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(btemp[1]), .diff(diff[2]), .bout(btemp[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(btemp[2]), .diff(diff[3]), .bout(btemp[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(btemp[3]), .diff(diff[4]), .bout(btemp[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(btemp[4]), .diff(diff[5]), .bout(btemp[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(btemp[5]), .diff(diff[6]), .bout(btemp[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(btemp[6]), .diff(diff[7]), .bout(btemp[7]));\n\n    assign bout = btemp[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule\n","task_id":"adder_8bit_v_6"}
{"Instruction":"Implement a module of an 8-bit subtractor using a series of 1-bit subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A and B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (1-bit subtractors) to perform the subtraction operation.\nGive me the complete code.","Response":"module subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);\n\n    wire [8:0] borrow;\n\n    one_bit_subtractor S0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    one_bit_subtractor S1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    one_bit_subtractor S2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    one_bit_subtractor S3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    one_bit_subtractor S4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    one_bit_subtractor S5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    one_bit_subtractor S6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    one_bit_subtractor S7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7]; \nendmodule\n\nmodule one_bit_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = a - b - bin;\nendmodule","task_id":"adder_8bit_v_7"}
{"Instruction":"Implement a module of an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A from B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.","Response":"module subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);\n\n    wire [8:0] borrow;\n\n    full_subtractor FS0 (.a(a[0]), .b(b[0]), .bin(bin), .diff(diff[0]), .bout(borrow[0]));\n    full_subtractor FS1 (.a(a[1]), .b(b[1]), .bin(borrow[0]), .diff(diff[1]), .bout(borrow[1]));\n    full_subtractor FS2 (.a(a[2]), .b(b[2]), .bin(borrow[1]), .diff(diff[2]), .bout(borrow[2]));\n    full_subtractor FS3 (.a(a[3]), .b(b[3]), .bin(borrow[2]), .diff(diff[3]), .bout(borrow[3]));\n    full_subtractor FS4 (.a(a[4]), .b(b[4]), .bin(borrow[3]), .diff(diff[4]), .bout(borrow[4]));\n    full_subtractor FS5 (.a(a[5]), .b(b[5]), .bin(borrow[4]), .diff(diff[5]), .bout(borrow[5]));\n    full_subtractor FS6 (.a(a[6]), .b(b[6]), .bin(borrow[5]), .diff(diff[6]), .bout(borrow[6]));\n    full_subtractor FS7 (.a(a[7]), .b(b[7]), .bin(borrow[6]), .diff(diff[7]), .bout(borrow[7]));\n\n    assign bout = borrow[7];\nendmodule\n\nmodule full_subtractor (input a, b, bin, output diff, bout);\n    assign {bout, diff} = bin ? (a - b - 1) : (a - b);\nendmodule\n","task_id":"adder_8bit_v_8"}
{"Instruction":"Implement a module for a 4-bit multiplier using shift and add method in combinational logic.\n\nModule name:  \n    multiplier_4bit               \nInput ports:\n    a[3:0]: 4-bit input multiplicand.\n    b[3:0]: 4-bit input multiplier.\nOutput ports:\n    product[7:0]: 8-bit output representing the product of A and B.\n\nImplementation:\nThe module uses a series of bit-shifts and add operations controlled by the bits of the multiplier.\nGive me the complete code.","Response":"module multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);\n\n    wire [7:0] intermediate[3:0];\n\n    shift_and_add SAA0(.a(a), .b(b[0]), .product(intermediate[0]));\n    shift_and_add SAA1(.a(a), .b(b[1]), .product(intermediate[1]));\n    shift_and_add SAA2(.a(a), .b(b[2]), .product(intermediate[2]));\n    shift_and_add SAA3(.a(a), .b(b[3]), .product(intermediate[3]));\n\n    assign product = intermediate[0] + (intermediate[1] << 1) + (intermediate[2] << 2) + (intermediate[3] << 3);\n\nendmodule\n\nmodule shift_and_add(input [3:0] a, input b, output [7:0] product);\n    assign product = b ? {4'b0000, a} : 8'b00000000;\nendmodule","task_id":"adder_8bit_v_9"}
{"Instruction":"Design a 32-bit binary ripple counter that operates on an active-high signal and provides a toggle output every clock cycle. The counter should increase when the signal is high and reset when low.\n\nModule name: binary_ripple_counter\n\nFunction:\nA 32-bit binary ripple counter that toggles its count based on an external control signal. The counter increases with each clock pulse if the control signal is high; it resets to zero when the signal is low.\n\nInput ports:\n- clk: Clock signal (1-bit), used to synchronize the counting process.\n- control_signal: External control signal (1-bit), determines if the counter should count or reset.\n\nOutput ports:\n- count [31:0]: 32-bit output representing the current counter value.\n\nImplementation:\nThe module consists of three submodules: toggle_logic, counter_logic, and counter_register.\n- The toggle_logic module determines whether to toggle the count based on the control signal.\n- The counter_logic module calculates the next count value based on the current count and toggle conditions.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the control_signal condition.\nGive me the complete code.","Response":"module binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);\n\n    wire toggle;\n    wire [31:0] next_count;\n\n    \/\/ Instantiate the toggle logic\n    toggle_logic u_toggle_logic (\n        .control_signal(control_signal),\n        .toggle(toggle)\n    );\n\n    \/\/ Instantiate the counter logic\n    counter_logic u_counter_logic (\n        .toggle(toggle),\n        .current_count(count),\n        .next_count(next_count)\n    );\n\n    \/\/ Instantiate the register to hold the count value\n    counter_register u_counter_register (\n        .clk(clk),\n        .control_signal(control_signal),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule toggle_logic (\n    input wire control_signal,\n    output reg toggle\n);\n\n    always @(*) begin\n        toggle = control_signal ? 1'b1 : 1'b0;\n    end\n\nendmodule\n\nmodule counter_logic (\n    input wire toggle,\n    input wire [31:0] current_count,\n    output reg [31:0] next_count\n);\n\n    always @(*) begin\n        if (toggle) begin\n            next_count = current_count + 1;\n        end else begin\n            next_count = 32'b0;\n        end\n    end\n\nendmodule\n\nmodule counter_register (\n    input wire clk,\n    input wire control_signal,\n    input wire [31:0] next_count,\n    output reg [31:0] current_count\n);\n\n    always @(posedge clk) begin\n        if (control_signal == 1'b0) begin\n            current_count <= 32'b0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule\n","task_id":"up_down_counter_v_10"}
{"Instruction":"Design a 32-bit arithmetic logic unit (ALU) that can perform addition, subtraction, bitwise AND, OR operations based on a 2-bit control signal. The ALU should be implemented modularly with separate logic for each operation.\n\nModule name:\n    modular_alu\n\nFunction:\nA 32-bit ALU capable of performing selected arithmetic and logical operations determined by a control signal.\n\nInput ports:\n    - op_code: Control signal (2-bit), selects the operation to perform.\n    - a [31:0]: First operand (32-bit).\n    - b [31:0]: Second operand (32-bit).\n\nOutput ports:\n    - result [31:0]: 32-bit output, result of the ALU operation.\n    - zero: Output signal (1-bit), indicates if the result is zero.\n\nImplementation:\nThe module consists of four submodules: adder, subtractor, and_logic, or_logic.\n- The adder module performs addition of a and b.\n- The subtractor module performs subtraction of a from b.\n- The and_logic module performs bitwise AND operation on a and b.\n- The or_logic module performs bitwise OR operation on a and b.\nThe result output shows the outcome based on the operation selected by op_code, which can control adding, subtracting, bitwise AND or OR operations. The zero output indicates whether the result is zero.\nGive me the complete code.","Response":"module modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_result;\n    wire [31:0] or_result;\n\n    \/\/ Instantiate the adder submodule\n    adder u_adder (\n        .a(a),\n        .b(b),\n        .sum(sum_result)\n    );\n\n    \/\/ Instantiate the subtractor submodule\n    subtractor u_subtractor (\n        .a(a),\n        .b(b),\n        .sub(sub_result)\n    );\n\n    \/\/ Instantiate the AND logic submodule\n    and_logic u_and_logic (\n        .a(a),\n        .b(b),\n        .and_out(and_result)\n    );\n\n    \/\/ Instantiate the OR logic submodule\n    or_logic u_or_logic (\n        .a(a),\n        .b(b),\n        .or_out(or_result)\n    );\n\n    \/\/ Logic to select the output\n    assign result = (op_code == 2'b00) ? sum_result :\n                    (op_code == 2'b01) ? sub_result :\n                    (op_code == 2'b10) ? and_result :\n                    or_result;\n\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sub\n);\n    assign sub = a - b;\nendmodule\n\nmodule and_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_out\n);\n    assign and_out = a & b;\nendmodule\n\nmodule or_logic (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_out\n);\n    assign or_out = a | b;\nendmodule\n","task_id":"up_down_counter_v_11"}
{"Instruction":"Design a 32-bit arithmetic logic unit (ALU) in Verilog that performs addition, subtraction, bitwise AND, OR, and XOR operations based on a 3-bit control input, structured with a top module and several submodules for handling specific operations.\n\nModule name:\n    multi_function_alu\n\nFunction:\nA 32-bit ALU that performs multiple arithmetic and logical operations determined by a control signal, with modular implementation.\n\nInput ports:\n    - op_code: Operation code (3-bit), selects the operation to perform (000 for ADD, 001 for SUB, 010 for AND, 011 for OR, 100 for XOR).\n    - operand_a [31:0]: First operand (32-bit).\n    - operand_b [31:0]: Second operand (32-bit).\n\nOutput ports:\n    - result [31:0]: 32-bit output of the selected operation.\n    - zero: Output signal (1-bit), high if the result is zero.\n\nImplementation:\nThe module consists of five submodules: adder, subtractor, and_bit, or_bit, and xor_bit.\n- The adder module calculates the sum of operand_a and operand_b.\n- The subtractor module calculates the difference between operand_a and operand_b.\n- The and_bit module performs bitwise AND on operand_a and operand_b.\n- The or_bit module performs bitwise OR on operand_a and operand_b.\n- The xor_bit module performs bitwise XOR on operand_a and operand_b.\nThe result is selected based on the op_code, and the zero flag is set if the result is zero.\nGive me the complete code.","Response":"module multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);\n\n    wire [31:0] sum, difference, and_res, or_res, xor_res;\n    reg [31:0] alu_result;\n\n    \/\/ Instantiate adder\n    adder u_adder (\n        .a(operand_a),\n        .b(operand_b),\n        .sum(sum)\n    );\n\n    \/\/ Instantiate subtractor\n    subtractor u_subtractor (\n        .a(operand_a),\n        .b(operand_b),\n        .difference(difference)\n    );\n\n    \/\/ Instantiate AND logic\n    and_bit u_and_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .and_res(and_res)\n    );\n\n    \/\/ Instantiate OR logic\n    or_bit u_or_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .or_res(or_res)\n    );\n\n    \/\/ Instantiate XOR logic\n    xor_bit u_xor_bit (\n        .a(operand_a),\n        .b(operand_b),\n        .xor_res(xor_res)\n    );\n\n    \/\/ Result selection logic\n    always @(*) begin\n        case(op_code)\n            3'b000: alu_result = sum;\n            3'b001: alu_result = difference;\n            3'b010: alu_result = and_res;\n            3'b011: alu_result = or_res;\n            3'b100: alu_result = xor_res;\n            default: alu_result = 32'b0;\n        endcase\n    end\n\n    assign result = alu_result;\n    assign zero = (result == 32'b0);\n\nendmodule\n\nmodule adder (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule and_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] and_res\n);\n    assign and_res = a & b;\nendmodule\n\nmodule or_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] or_res\n);\n    assign or_res = a | b;\nendmodule\n\nmodule xor_bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] xor_res\n);\n    assign xor_res = a ^ b;\nendmodule\n","task_id":"up_down_counter_v_12"}
{"Instruction":"Design a Verilog module for a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, bitwise AND, OR operations based on a control signal. Implement this using modular design with specific submodules handling different arithmetic and logical functions.\n\nModule name:\n    configurable_alu\n\nFunction:\nA 32-bit ALU that can perform addition, subtraction, bitwise AND, and OR operations, controlled by a 2-bit signal.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the operations.\n    - op_code: Operation code (2-bit), determines the operation to perform:\n        - 00: Addition\n        - 01: Subtraction\n        - 10: Bitwise AND\n        - 11: Bitwise OR\n    - operand_a [31:0]: First 32-bit operand.\n    - operand_b [31:0]: Second 32-bit operand.\n\nOutput ports:\n    - result [31:0]: 32-bit output representing the result of the ALU operation.\n\nImplementation:\nThe module includes three submodules: adder, subtractor, and bitwise_operator.\n- The adder module performs the addition of two 32-bit numbers.\n- The subtractor module performs the subtraction between two 32-bit numbers.\n- The bitwise_operator module handles both the AND and OR operations based on an internal control signal derived from op_code.\nThe result output depends on op_code and reflects the outcome of the operation performed by the relevant submodule.\nGive me the complete code.","Response":"module configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n\n    wire [31:0] add_result;\n    wire [31:0] sub_result;\n    wire [31:0] and_or_result;\n\n    \/\/ Instantiate adder submodule\n    adder u_adder (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(add_result)\n    );\n\n    \/\/ Instantiate subtractor submodule\n    subtractor u_subtractor (\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(sub_result)\n    );\n\n    \/\/ Instantiate bitwise operator submodule\n    bitwise_operator u_bitwise_operator (\n        .op_code(op_code[0]),\n        .operand_a(operand_a),\n        .operand_b(operand_b),\n        .result(and_or_result)\n    );\n\n    \/\/ Result logic based on operation code\n    assign result = (op_code == 2'b00) ? add_result :\n                    (op_code == 2'b01) ? sub_result :\n                    and_or_result;\n\nendmodule\n\nmodule adder (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor (\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule bitwise_operator (\n    input wire op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);\n    assign result = (op_code) ? (operand_a | operand_b) : (operand_a & operand_b);\nendmodule\n","task_id":"up_down_counter_v_13"}
{"Instruction":"Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_8bit combines the products from multiple instances of the gen_product module, which calculates partial products. Each gen_product module handles the multiplication operation for one bit of Y with all bits of X and accumulates the results using shift and add methodology.\nGive me the complete code.","Response":"module mult_8bit(X, Y, P);\n    input [7:0] X;    \/\/ 8-bit input operand X\n    input [7:0] Y;    \/\/ 8-bit input operand Y\n    output [15:0] P;  \/\/ 16-bit output representing the product X * Y\n\n    wire [15:0] products[0:7];  \/\/ Intermediate products for each bit of Y\n\n    \/\/ Instantiate gen_product modules for each bit of Y\n    gen_product GP0(.X(X), .Y_bit(Y[0]), .Shift(0), .Product(products[0]));\n    gen_product GP1(.X(X), .Y_bit(Y[1]), .Shift(1), .Product(products[1]));\n    gen_product GP2(.X(X), .Y_bit(Y[2]), .Shift(2), .Product(products[2]));\n    gen_product GP3(.X(X), .Y_bit(Y[3]), .Shift(3), .Product(products[3]));\n    gen_product GP4(.X(X), .Y_bit(Y[4]), .Shift(4), .Product(products[4]));\n    gen_product GP5(.X(X), .Y_bit(Y[5]), .Shift(5), .Product(products[5]));\n    gen_product GP6(.X(X), .Y_bit(Y[6]), .Shift(6), .Product(products[6]));\n    gen_product GP7(.X(X), .Y_bit(Y[7]), .Shift(7), .Product(products[7]));\n\n    \/\/ Sum all partial products to form the final product\n    assign P = products[0] + products[1] + products[2] + products[3] +\n               products[4] + products[5] + products[6] + products[7];\n\nendmodule\n\nmodule gen_product(X, Y_bit, Shift, Product);\n    input [7:0] X;     \/\/ 8-bit input operand X\n    input Y_bit;       \/\/ Single bit of input operand Y\n    input [2:0] Shift; \/\/ Shift amount for partial product alignment\n    output [15:0] Product; \/\/ Output partial product\n\n    \/\/ Calculate partial product\n    wire [7:0] partial_product = X & {8{Y_bit}};\n\n    \/\/ Shift partial product to align according to bit position\n    assign Product = partial_product << Shift;\n\nendmodule\n","task_id":"sub_8bit_v_14"}
{"Instruction":"Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_8bit uses a series of add_shift modules to perform the multiplication operation through repeated additions based on the shifting method. Each add_shift module is responsible for conditionally adding the multiplicand X shifted left by a specific number of positions to an accumulator based on a corresponding bit in the multiplier Y.\n\nGive me the complete code.\nGive me the complete code.","Response":"module mult_8bit(X, Y, P);\n    input [7:0] X;      \/\/ 8-bit input operand X\n    input [7:0] Y;      \/\/ 8-bit input operand Y\n    output [15:0] P;    \/\/ 16-bit output representing the product X * Y\n\n    wire [15:0] product[0:7]; \/\/ Partial products from each stage\n\n    \/\/ Instantiate add_shift modules for each bit in Y\n    add_shift AS0(.X(X), .shift(0), .Y_bit(Y[0]), .partial_sum(16'b0), .P(product[0]));\n    add_shift AS1(.X(X), .shift(1), .Y_bit(Y[1]), .partial_sum(product[0]), .P(product[1]));\n    add_shift AS2(.X(X), .shift(2), .Y_bit(Y[2]), .partial_sum(product[1]), .P(product[2]));\n    add_shift AS3(.X(X), .shift(3), .Y_bit(Y[3]), .partial_sum(product[2]), .P(product[3]));\n    add_shift AS4(.X(X), .shift(4), .Y_bit(Y[4]), .partial_sum(product[3]), .P(product[4]));\n    add_shift AS5(.X(X), .shift(5), .Y_bit(Y[5]), .partial_sum(product[4]), .P(product[5]));\n    add_shift AS6(.X(X), .shift(6), .Y_bit(Y[6]), .partial_sum(product[5]), .P(product[6]));\n    add_shift AS7(.X(X), .shift(7), .Y_bit(Y[7]), .partial_sum(product[6]), .P(product[7]));\n\n    \/\/ Assign the final product\n    assign P = product[7];\n\nendmodule\n\nmodule add_shift(X, shift, Y_bit, partial_sum, P);\n    input [7:0] X;         \/\/ Multiplicand\n    input [2:0] shift;     \/\/ Shift amount\n    input Y_bit;           \/\/ Specific bit of multiplier Y\n    input [15:0] partial_sum; \/\/ Partial sum input\n    output [15:0] P;       \/\/ Output partial product\n\n    wire [15:0] shifted_X;\n\n    \/\/ Shift X left by 'shift' positions\n    assign shifted_X = X << shift;\n\n    \/\/ Conditional addition based on Y_bit\n    assign P = Y_bit ? partial_sum + shifted_X : partial_sum;\n\nendmodule","task_id":"sub_8bit_v_15"}
{"Instruction":"Implement a module of a 4-bit multiplier using a series of adders and shift operations.\n\nModule name:\n    mul_4bit\n\nInput ports:\n    X[3:0]: 4-bit input operand X.\n    Y[3:0]: 4-bit input operand Y.\n\nOutput ports:\n    P[7:0]: 8-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mul_4bit performs multiplication by using bitwise AND operations and shifts to construct partial products, which are then added using an adder_8bit module. The adder_8bit module is composed of full_adder modules to handle the addition of each bit.\nGive me the complete code.","Response":"module mul_4bit(X, Y, P);\n    input [3:0] X;    \/\/ 4-bit input operand X\n    input [3:0] Y;    \/\/ 4-bit input operand Y\n    output [7:0] P;   \/\/ 8-bit output product\n\n    wire [7:0] pp0, pp1, pp2, pp3; \/\/ partial products\n    wire [7:0] sum1, sum2, sum3;   \/\/ intermediate sums\n    wire cout1, cout2, cout3;      \/\/ carry outputs from adders\n\n    \/\/ Generate partial products\n    assign pp0 = Y[0] ? {4'b0000, X} : 8'b00000000;\n    assign pp1 = Y[1] ? {3'b000, X, 1'b0} : 8'b00000000;\n    assign pp2 = Y[2] ? {2'b00, X, 2'b00} : 8'b00000000;\n    assign pp3 = Y[3] ? {1'b0, X, 3'b000} : 8'b00000000;\n\n    \/\/ Add partial products\n    adder_8bit add1(.A(pp0), .B(pp1), .D(sum1), .Cout(cout1));\n    adder_8bit add2(.A(sum1), .B(pp2), .D(sum2), .Cout(cout2));\n    adder_8bit add3(.A(sum2), .B(pp3), .D(P), .Cout(cout3));\n\nendmodule\n\nmodule adder_8bit(A, B, D, Cout);\n    input [7:0] A;     \/\/ 8-bit input operand A\n    input [7:0] B;     \/\/ 8-bit input operand B\n    output [7:0] D;    \/\/ 8-bit output representing the sum\n    output Cout;       \/\/ Carry out\n\n    wire [7:0] sum;    \/\/ Intermediate sum values\n    wire [7:0] carry;  \/\/ Intermediate carry values\n\n    \/\/ Instantiate full adders\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(1'b0), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Cout));\n\n    \/\/ Assign the sum to output\n    assign D = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;       \/\/ Input A\n    input B;       \/\/ Input B\n    input Cin;     \/\/ Carry input\n    output Sum;    \/\/ Sum output\n    output Cout;   \/\/ Carry output\n\n    assign Sum = A ^ B ^ Cin;                  \/\/ Sum calculation\n    assign Cout = (A & B) | (Cin & (A ^ B));  \/\/ Carry calculation\nendmodule\n","task_id":"sub_8bit_v_16"}
{"Instruction":"Implement a module of a 4-bit multiplier using a combination of adders and shift registers.\n\nModule name:\n    mult_4bit\n\nInput ports:\n    X[3:0]: 4-bit input multiplicand X.\n    Y[3:0]: 4-bit input multiplier Y.\n\nOutput ports:\n    P[7:0]: 8-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_4bit utilizes a series of shift and add operations implemented through adder_4bit modules. Each adder_4bit module handles the addition based on the shifted value of X and the bit value of Y.\nGive me the complete code.","Response":"module mult_4bit(X, Y, P);\n    input [3:0] X;      \/\/ 4-bit input multiplicand X\n    input [3:0] Y;      \/\/ 4-bit input multiplier Y\n    output [7:0] P;     \/\/ 8-bit output product\n\n    wire [3:0] partial_product_0, partial_product_1, partial_product_2, partial_product_3;\n    wire [7:0] sum_0, sum_1, sum_2;\n\n    \/\/ Generate partial products\n    assign partial_product_0 = Y[0] ? X : 4'b0000;\n    assign partial_product_1 = Y[1] ? X : 4'b0000;\n    assign partial_product_2 = Y[2] ? X : 4'b0000;\n    assign partial_product_3 = Y[3] ? X : 4'b0000;\n\n    \/\/ Shift partial products\n    wire [7:0] shift_partial_1 = {partial_product_1, 1'b0};\n    wire [7:0] shift_partial_2 = {partial_product_2, 2'b00};\n    wire [7:0] shift_partial_3 = {partial_product_3, 3'b000};\n\n    \/\/ Add partial products\n    adder_4bit adder_0(\n        .A({4'b0000, partial_product_0}),\n        .B(shift_partial_1),\n        .D(sum_0)\n    );\n    adder_4bit adder_1(\n        .A(sum_0),\n        .B(shift_partial_2),\n        .D(sum_1)\n    );\n    adder_4bit adder_2(\n        .A(sum_1),\n        .B(shift_partial_3),\n        .D(P)\n    );\n\nendmodule\n\nmodule adder_4bit(A, B, D);\n    input [7:0] A;      \/\/ 8-bit input operand A\n    input [7:0] B;      \/\/ 8-bit input operand B\n    output [7:0] D;     \/\/ 8-bit output sum\n\n    assign D = A + B;   \/\/ Simple bitwise addition\n\nendmodule\n","task_id":"sub_8bit_v_17"}
{"Instruction":"Design and implement a Verilog module for a simple 4-bit arithmetic logic unit (ALU) with basic operations including addition, subtraction, AND, OR operations.\n\nModule name:  \n    simple_alu4bit               \nInput ports:\n    clk: Clock signal.\n    op_code[1:0]: 2-bit operation selector.\n    operand_a[3:0]: 4-bit input operand A.\n    operand_b[3:0]: 4-bit input operand B.\nOutput ports:\n    result[3:0]: 4-bit output result of the ALU operation.\n\nImplementation:\nThe simple_alu4bit module consists of four primary operational stages: adder, subtractor, and_logical, or_logical. Each stage is implemented as a separate submodule that performs the specific arithmetic or logical operation based on the op_code input. The adder stage computes the sum of operand_a and operand_b. The subtractor stage computes the difference between operand_a and operand_b. The and_logical stage performs a bitwise AND operation, and the or_logical stage performs a bitwise OR operation. The result from the appropriate submodule is selected based on the op_code and output through the result port.\nGive me the complete code.","Response":"`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);\nwire [3:0] add_result;\nwire [3:0] sub_result;\nwire [3:0] and_result;\nwire [3:0] or_result;\n\nadder_stage adder(.operand_a(operand_a), .operand_b(operand_b), .result(add_result));\nsubtractor_stage subtractor(.operand_a(operand_a), .operand_b(operand_b), .result(sub_result));\nand_stage and_logical(.operand_a(operand_a), .operand_b(operand_b), .result(and_result));\nor_stage or_logical(.operand_a(operand_a), .operand_b(operand_b), .result(or_result));\n\nalways @(posedge clk) begin\n    case(op_code)\n        `ADD_OP: result <= add_result;\n        `SUB_OP: result <= sub_result;\n        `AND_OP: result <= and_result;\n        `OR_OP: result <= or_result;\n        default: result <= 0;\n    endcase\nend\nendmodule\n\nmodule adder_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a + operand_b;\nendmodule\n\nmodule subtractor_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a - operand_b;\nendmodule\n\nmodule and_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a & operand_b;\nendmodule\n\nmodule or_stage(\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output [3:0] result\n);\n    assign result = operand_a | operand_b;\nendmodule","task_id":"stagepipe3_v_18"}
{"Instruction":"Implement a module for a simple 4-bit arithmetic logic unit (ALU) that performs addition, subtraction, bitwise AND, and bitwise OR based on a 2-bit operation selector.\n\nModule name:  \n    simple_alu               \nInput ports:\n    a[3:0]: 4-bit input operand.\n    b[3:0]: 4-bit input operand.\n    op[1:0]: 2-bit operation selector where 00 is ADD, 01 is SUBTRACT, 10 is AND, and 11 is OR.\nOutput ports:\n    result[3:0]: 4-bit output result of the ALU operation.\n\nImplementation:\nThe simple_alu module instantiates four submodules: adder, subtractor, and_module, and or_module. Each submodule performs a specific operation based on the operation selector 'op'. The adder module calculates the sum of a and b. The subtractor module calculates the difference between a and b. The and_module performs a bitwise AND operation, and the or_module performs a bitwise OR operation. The output of each submodule is connected to a multiplexer, which selects the final result based on 'op'.\nGive me the complete code.","Response":"module simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);\nwire [3:0] sum;\nwire [3:0] diff;\nwire [3:0] and_res;\nwire [3:0] or_res;\n\nadder_module adder(.a(a), .b(b), .sum(sum));\nsubtractor_module subtractor(.a(a), .b(b), .diff(diff));\nand_module and_op(.a(a), .b(b), .and_res(and_res));\nor_module or_op(.a(a), .b(b), .or_res(or_res));\n\nalways @(*) begin\n    case(op)\n        2'b00: result = sum;\n        2'b01: result = diff;\n        2'b10: result = and_res;\n        2'b11: result = or_res;\n    endcase\nend\nendmodule\n\nmodule adder_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] sum\n);\nassign sum = a + b;\nendmodule\n\nmodule subtractor_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] diff\n);\nassign diff = a - b;\nendmodule\n\nmodule and_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] and_res\n);\nassign and_res = a & b;\nendmodule\n\nmodule or_module(\n    input [3:0] a,\n    input [3:0] b,\n    output [3:0] or_res\n);\nassign or_res = a | b;\nendmodule","task_id":"stagepipe3_v_19"}
{"Instruction":"Implement a module for a 4-bit arithmetic logic unit (ALU) with basic arithmetic and logical operations.\n\nModule name:  \n    simple_alu               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op_code[1:0]: 2-bit operation code to specify the ALU operation.\n    data_a[3:0]: 4-bit input operand A.\n    data_b[3:0]: 4-bit input operand B.\nOutput ports:\n    result[3:0]: 4-bit output resulting from the specified ALU operation.\n    zero: Output high when result is zero.\n\nImplementation:\nIn the simple_alu module, the basic arithmetic operations (addition, subtraction) and logical operations (AND, OR) are supported. The op_decoder submodule interprets the op_code and triggers the corresponding operation in the arithmetic_logic submodule. The result_manager submodule checks the result from arithmetic_logic and outputs a zero flag if the result is zero.\nGive me the complete code.","Response":"`define ADD 2'b00\n`define SUB 2'b01\n`define AND 2'b10\n`define OR  2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);\nwire [3:0] operation_result;\n\nop_decoder decoder (\n    .op_code(op_code),\n    .data_a(data_a),\n    .data_b(data_b),\n    .result(operation_result)\n);\n\nresult_manager manager (\n    .clk(clk),\n    .rst(rst),\n    .operation_result(operation_result),\n    .final_result(result),\n    .zero_flag(zero)\n);\n\nendmodule\n\nmodule op_decoder(\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output reg [3:0] result\n);\n    always @* begin\n        case(op_code)\n            `ADD: result = data_a + data_b;\n            `SUB: result = data_a - data_b;\n            `AND: result = data_a & data_b;\n            `OR: result = data_a | data_b;\n            default: result = 4'b0000;\n        endcase\n    end\nendmodule\n\nmodule result_manager(\n    input clk,\n    input rst,\n    input [3:0] operation_result,\n    output reg [3:0] final_result,\n    output reg zero_flag\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            final_result <= 0;\n            zero_flag <= 1'b1;\n        end else begin\n            final_result <= operation_result;\n            zero_flag <= (operation_result == 0);\n        end\n    end\nendmodule","task_id":"stagepipe3_v_20"}
{"Instruction":"Implement a module for a basic 4-function arithmetic unit that computes add, subtract, multiply, and divide operations based on opcode input.\n\nModule name:  \n    arithmetic_unit               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    opcode[1:0]: 2-bit input specifying the operation (00-add, 01-subtract, 10-multiply, 11-divide).\n    data_a[7:0]: 8-bit input operand A.\n    data_b[7:0]: 8-bit input operand B.\nOutput ports:\n    result[15:0]: 16-bit output result of the arithmetic operation.\n    valid: Output flag indicating if the result is valid (e.g., not a division by zero).\n\nImplementation:\nIn the arithmetic_unit module, four different arithmetic operation stages (adder, subtractor, multiplier, divider) are instantiated. The operation to be performed is selected based on the opcode input. The adder module performs addition, the subtractor performs subtraction, the multiplier carries out multiplication, and the divider handles division, including setting the valid flag to 0 when division by zero is attempted. The result from the selected operation stage is output through the result port.\nGive me the complete code.","Response":"`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define MUL_OP 2'b10\n`define DIV_OP 2'b11\n\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);\nwire [15:0] add_result;\nwire [15:0] sub_result;\nwire [15:0] mul_result;\nwire [15:0] div_result;\nwire div_valid;\n\nadder add_module (.a(data_a), .b(data_b), .result(add_result));\nsubtractor sub_module (.a(data_a), .b(data_b), .result(sub_result));\nmultiplier mul_module (.a(data_a), .b(data_b), .result(mul_result));\ndivider div_module (.a(data_a), .b(data_b), .result(div_result), .valid(div_valid));\n\nalways @(posedge clk or posedge rst) begin\n    if(rst) begin\n        result <= 0;\n        valid <= 1;\n    end else begin\n        case(opcode)\n            `ADD_OP: result <= add_result;\n            `SUB_OP: result <= sub_result;\n            `MUL_OP: result <= mul_result;\n            `DIV_OP: begin\n                result <= div_result;\n                valid <= div_valid;\n            end\n            default: begin\n                result <= 0;\n                valid <= 1;\n            end\n        endcase\n    end\nend\nendmodule\n\n\/\/ Arithmetic operation submodules\nmodule adder(input [7:0] a, input [7:0] b, output [15:0] result);\nassign result = a + b;\nendmodule\n\nmodule subtractor(input [7:0] a, input [7:0] b, output [15:0] result);\nassign result = a - b;\nendmodule\n\nmodule multiplier(input [7:0] a, input [7:0] b, output [15:0] result);\nassign result = a * b;\nendmodule\n\nmodule divider(input [7:0] a, input [7:0] b, output [15:0] result, output valid);\nassign result = (b != 0) ? (a \/ b) : 0;\nassign valid = (b != 0);\nendmodule","task_id":"stagepipe3_v_21"}
{"Instruction":"Design a 4-bit magnitude comparator that takes two 4-bit binary numbers and outputs whether the first number is greater than, less than, or equal to the second number.\n\nModule name: \n    magnitude_comparator\n\nFunction:\n    This module compares two 4-bit numbers and outputs three signals indicating whether the first number (A) is greater than, less than, or equal to the second number (B).\n\nInput ports:\n    A [3:0]: 4-bit input representing the first number.\n    B [3:0]: 4-bit input representing the second number.\n\nOutput ports:\n    gt: Output signal that is high if A > B.\n    lt: Output signal that is high if A < B.\n    eq: Output signal that is high if A == B.\n\nImplementation:\n    The magnitude_comparator uses submodules to compare each bit of A and B starting from the most significant bit. The comparison logic determines if A is greater than, less than, or equal to B by cascading comparisons from the highest bit to the lowest bit.\n    - If the higher significant bit of A is greater than B, then A is greater regardless of the lower bits.\n    - If the higher significant bit of A is less than B, then A is less regardless of the lower bits.\n    - If bits are equal, the comparison continues to the next lower bit.\n\n    A series of `bit_compare` submodules are instantiated for bit-by-bit comparison, providing intermediate signals for greater than, less than, or equal conditions that are then used to determine the final output.\nGive me the complete code.","Response":"module magnitude_comparator (A, B, gt, lt, eq);\n    input [3:0] A;\n    input [3:0] B;\n    output gt, lt, eq;\n    wire gt0, gt1, gt2, gt3;\n    wire lt0, lt1, lt2, lt3;\n    wire eq0, eq1, eq2, eq3;\n\n    \/\/ Bit-by-bit comparison\n    bit_compare bc0 (A[3], B[3], gt3, lt3, eq3);\n    bit_compare bc1 (A[2], B[2], gt2, lt2, eq2);\n    bit_compare bc2 (A[1], B[1], gt1, lt1, eq1);\n    bit_compare bc3 (A[0], B[0], gt0, lt0, eq0);\n\n    \/\/ Output determination\n    assign gt = gt3 | (eq3 & gt2) | (eq3 & eq2 & gt1) | (eq3 & eq2 & eq1 & gt0);\n    assign lt = lt3 | (eq3 & lt2) | (eq3 & eq2 & lt1) | (eq3 & eq2 & eq1 & lt0);\n    assign eq = eq3 & eq2 & eq1 & eq0;\n\nendmodule\n\nmodule bit_compare(a, b, gt, lt, eq);\n    input a, b;\n    output gt, lt, eq;\n\n    assign gt = a & ~b;\n    assign lt = ~a & b;\n    assign eq = a ~^ b; \/\/ XOR for equality check\nendmodule\n","task_id":"barrel_shifter_v_22"}
{"Instruction":"Design a 4-bit arithmetic logic unit (ALU) that performs bitwise AND, bitwise OR, addition, and subtraction based on a 2-bit operation selector. The ALU takes two 4-bit inputs and outputs the 4-bit result along with a carry or borrow flag.\n\nModule name: \n    simple_alu\n\nFunction:\n    A 4-bit ALU which can perform bitwise AND, bitwise OR, addition, and subtraction. The operation is determined by a 2-bit control signal.\n\nInput ports:\n    a [3:0]: 4-bit input operand A.\n    b [3:0]: 4-bit input operand B.\n    op [1:0]: 2-bit control signal to select the operation:\n              00 - bitwise AND\n              01 - bitwise OR\n              10 - addition\n              11 - subtraction\n\nOutput ports:\n    result [3:0]: 4-bit result of the operation.\n    carry_borrow: Carry out for addition and borrow flag for subtraction.\n\nImplementation:\n    The ALU operations are handled based on the `op` signal:\n    - 00: Performs bitwise AND using a series of AND gates.\n    - 01: Performs bitwise OR using a series of OR gates.\n    - 10: Performs addition using a 4-bit adder that also provides a carry output.\n    - 11: Performs subtraction using a 4-bit subtractor, where the borrow out is considered.\n    Each operation type is implemented in its own submodule: `bitwise_and`, `bitwise_or`, `adder_4bit`, and `subtractor_4bit`.\nGive me the complete code.","Response":"module simple_alu(a, b, op, result, carry_borrow);\n    input [3:0] a, b;\n    input [1:0] op;\n    output [3:0] result;\n    output carry_borrow;\n    wire [3:0] w_and, w_or, w_add, w_sub;\n    wire c_add, b_sub;\n\n    bitwise_and and_unit(a, b, w_and);\n    bitwise_or or_unit(a, b, w_or);\n    adder_4bit add_unit(a, b, w_add, c_add);\n    subtractor_4bit sub_unit(a, b, w_sub, b_sub);\n\n    assign result = (op == 2'b00) ? w_and :\n                    (op == 2'b01) ? w_or :\n                    (op == 2'b10) ? w_add :\n                    w_sub;\n                    \n    assign carry_borrow = (op == 2'b10) ? c_add : b_sub;\n\nendmodule\n\nmodule bitwise_and(input [3:0] a, input [3:0] b, output [3:0] out);\n    assign out = a & b;\nendmodule\n\nmodule bitwise_or(input [3:0] a, input [3:0] b, output [3:0] out);\n    assign out = a | b;\nendmodule\n\nmodule adder_4bit(input [3:0] a, input [3:0] b, output [3:0] sum, output carry);\n    assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_4bit(input [3:0] a, input [3:0] b, output [3:0] diff, output borrow);\n    assign {borrow, diff} = {1'b0, a} - {1'b0, b};\nendmodule\n","task_id":"barrel_shifter_v_23"}
{"Instruction":"Design a Priority Encoder in Verilog, which encodes an 8-bit input into a 3-bit output code corresponding to the highest order '1' found in the input.\n\nModule name: \n    priority_encoder\n\nFunction:\n    An 8-bit Priority Encoder which scans the input from the most significant bit (MSB) to least significant bit (LSB). It outputs a 3-bit binary code representing the position of the highest order bit that is set to '1'. If no bits are set, an additional 'valid' output is set to '0'.\n\nInput ports:\n    in [7:0]: 8-bit input where each bit will be scanned to find the highest order '1'.\n\nOutput ports:\n    code [2:0]: 3-bit output code indicating the position of the first '1' from MSB.\n    valid: Output signal that indicates if the output code is valid (i.e., at least one '1' is present in the input).\n\nImplementation:\n    The priority encoder checks each bit of the input starting from the MSB using a series of conditional checks and logic gates. If a '1' is detected, the corresponding binary code for the position is set at the output. The output 'valid' is set to '1' if any '1' is detected across all bits; otherwise, it remains '0'.\n    The process involves using multiple instances of a `check_bit` submodule, which determines if the current inspected bit is '1' and if it is the highest order '1' found so far based on priority logic.\nGive me the complete code.","Response":"module priority_encoder(in, code, valid);\n    input [7:0] in;\n    output [2:0] code;\n    output valid;\n    wire [7:0] found;\n\n    \/\/ Instance for each bit checking\n    check_bit cb7 (.in(in[7]), .found(found[7]));\n    check_bit cb6 (.in(in[6]), .found(found[6]));\n    check_bit cb5 (.in(in[5]), .found(found[5]));\n    check_bit cb4 (.in(in[4]), .found(found[4]));\n    check_bit cb3 (.in(in[3]), .found(found[3]));\n    check_bit cb2 (.in(in[2]), .found(found[2]));\n    check_bit cb1 (.in(in[1]), .found(found[1]));\n    check_bit cb0 (.in(in[0]), .found(found[0]));\n\n    assign valid = |in;  \/\/ valid is high if any bit in 'in' is high\n    assign code = found[7] ? 3'b111 :\n                  found[6] ? 3'b110 :\n                  found[5] ? 3'b101 :\n                  found[4] ? 3'b100 :\n                  found[3] ? 3'b011 :\n                  found[2] ? 3'b010 :\n                  found[1] ? 3'b001 :\n                  found[0] ? 3'b000 : 3'b000;\n\nendmodule\n\nmodule check_bit(in, found);\n    input in;\n    output found;\n    assign found = in;  \/\/ This module will output '1' if input is '1'\nendmodule\n","task_id":"barrel_shifter_v_24"}
{"Instruction":"Design a digital alarm system using Verilog, which sets off an alarm based on predefined temperature and smoke sensor inputs. This system consists of an 8-bit temperature sensor input and a 1-bit smoke detector signal. An alarm is triggered if the temperature is above a threshold or if smoke is detected.\n\nModule name: \n    alarm_system\n\nFunction:\n    A digital alarm system that monitors signals from an 8-bit temperature sensor and a 1-bit smoke detector. The system triggers a 1-bit alarm output when the temperature exceeds a specified threshold or if smoke is detected.\n\nInput ports:\n    temp_sensor [7:0]: 8-bit input from the temperature sensor.\n    smoke_sensor [0]: 1-bit input indicating smoke detection.\n\nOutput ports:\n    alarm_out [0]: 1-bit output that triggers the alarm.\n\nImplementation:\n    The alarm system evaluates the inputs from the temperature sensor and the smoke detector. If the temperature value exceeds a pre-set threshold, or if the smoke detector signal is high, the alarm is triggered.\n    The system utilizes comparison logic to check if the temperature is above the threshold and a logical OR operation to evaluate the condition of either temperature or smoke triggering the alarm.\n    - The `compare_temp` submodule compares the 8-bit temperature input against a predefined threshold.\n    - The `or_logic` submodule takes the output from `compare_temp` and the smoke detector input to perform an OR operation, determining the final alarm state.\nGive me the complete code.","Response":"module alarm_system (temp_sensor, smoke_sensor, alarm_out);\n    input  [7:0] temp_sensor;\n    input  smoke_sensor;\n    output alarm_out;\n    wire temp_high;\n\n    \/\/ Instance of temperature comparison\n    compare_temp  comp_temp (.temp_in(temp_sensor), .temp_high(temp_high));\n\n    \/\/ Instance of OR logic to determine alarm state\n    or_logic  or_gate (.temp_high(temp_high), .smoke_signal(smoke_sensor), .alarm_out(alarm_out));\nendmodule\n\nmodule compare_temp(temp_in, temp_high);\n    input [7:0] temp_in;\n    output temp_high;\n    \/\/ Temperature threshold for comparison\n    parameter THRESHOLD = 8'h5A; \/\/ example threshold value (90 in decimal)\n    \n    assign temp_high = (temp_in > THRESHOLD) ? 1'b1 : 1'b0;\nendmodule\n\nmodule or_logic(temp_high, smoke_signal, alarm_out);\n    input temp_high, smoke_signal;\n    output alarm_out;\n    \n    assign alarm_out = temp_high | smoke_signal;\nendmodule\n","task_id":"barrel_shifter_v_25"}
{"Instruction":"Implement a module of a carry-lookahead 16-bit adder using the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.","Response":"module add_16bit(A, B, S, C_out);\n    input [16:1] A;       \/\/ 16-bit input A\n    input [16:1] B;       \/\/ 16-bit input B\n    output [16:1] S;      \/\/ 16-bit sum output\n    output C_out;         \/\/ Carry out\n\n    wire c4, c8, c12;\n\n    \/\/ Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        \/\/ 4-bit input A\n    input [4:1] B;        \/\/ 4-bit input B\n    input C_in;           \/\/ Carry in\n    output [4:1] S;       \/\/ 4-bit sum output\n    output C_out;         \/\/ Carry out\n\n    wire p1, p2, p3, p4;  \/\/ Propagate signals\n    wire g1, g2, g3, g4;  \/\/ Generate signals\n    wire c1, c2, c3;      \/\/ Internal carry signals\n\n    \/\/ Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    \/\/ Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              \/\/ Input A\n    input B;              \/\/ Input B\n    input C_in;           \/\/ Carry in\n    output S;             \/\/ Sum output\n    output C_out;         \/\/ Carry out\n\n    assign S = A ^ B ^ C_in; \/\/ Sum calculation\n    assign C_out = (A & B) | ((A ^ B) & C_in); \/\/ Carry out calculation\nendmodule\n","task_id":"sub_16bit_v_26"}
{"Instruction":"Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit carry lookahead adder block you design.\nGive me the complete code.","Response":"module add_16bit(A, B, S, C_out);\n    input [16:1] A;       \/\/ 16-bit input A\n    input [16:1] B;       \/\/ 16-bit input B\n    output [16:1] S;      \/\/ 16-bit sum output\n    output C_out;         \/\/ Carry out\n\n    wire c4, c8, c12;\n\n    \/\/ Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        \/\/ 4-bit input A\n    input [4:1] B;        \/\/ 4-bit input B\n    input C_in;           \/\/ Carry in\n    output [4:1] S;       \/\/ 4-bit sum output\n    output C_out;         \/\/ Carry out\n\n    wire g1, g2, g3, g4;  \/\/ Generate signals\n    wire p1, p2, p3, p4;  \/\/ Propagate signals\n    wire c1, c2, c3;      \/\/ Internal carry signals\n\n    \/\/ Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    \/\/ Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              \/\/ Input A\n    input B;              \/\/ Input B\n    input C_in;           \/\/ Carry in\n    output S;             \/\/ Sum output\n    output C_out;         \/\/ Carry out\n\n    assign S = A ^ B ^ C_in; \/\/ Sum calculation\n    assign C_out = (A & B) | ((A ^ B) & C_in); \/\/ Carry out calculation\nendmodule\n","task_id":"sub_16bit_v_27"}
{"Instruction":"Implement a module for a 16-bit parity generator which computes the even parity for two 8-bit inputs using a two-level hierarchical design.\n\nModule name:\n    parity_16bit               \nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\nOutput ports:\n    P: Single output representing the even parity of the combined 16 bits of X and Y.\n\nImplementation:\nThe top module parity_16bit consists of instances of 8-bit parity generator blocks, followed by a final parity computation of their outputs.\nGive me the complete code.","Response":"module parity_16bit(X, Y, P);\n    input [7:0] X;        \/\/ 8-bit input X\n    input [7:0] Y;        \/\/ 8-bit input Y\n    output P;             \/\/ Output parity\n\n    wire P_X, P_Y;\n\n    \/\/ Instantiate 8-bit parity generators\n    parity_8 gen1(\n        .data(X),\n        .parity(P_X)\n    );\n\n    parity_8 gen2(\n        .data(Y),\n        .parity(P_Y)\n    );\n\n    \/\/ Final parity calculation to combine parities from X and Y\n    assign P = P_X ^ P_Y;\n\nendmodule\n\nmodule parity_8(data, parity);\n    input [7:0] data;     \/\/ 8-bit data input\n    output parity;        \/\/ Output parity\n\n    assign parity = ^data; \/\/ XOR of all bits to calculate even parity\n\nendmodule\n","task_id":"sub_16bit_v_28"}
{"Instruction":"Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.","Response":"module add_16bit(A, B, S, C_out);\n    input [16:1] A;       \/\/ 16-bit input A\n    input [16:1] B;       \/\/ 16-bit input B\n    output [16:1] S;      \/\/ 16-bit sum output\n    output C_out;         \/\/ Carry out\n\n    wire c4, c8, c12;\n\n    \/\/ Instantiate 4-bit adders\n    adder_4 add1(\n        .A(A[4:1]),\n        .B(B[4:1]),\n        .C_in(0),\n        .S(S[4:1]),\n        .C_out(c4)\n    );\n\n    adder_4 add2(\n        .A(A[8:5]),\n        .B(B[8:5]),\n        .C_in(c4),\n        .S(S[8:5]),\n        .C_out(c8)\n    );\n\n    adder_4 add3(\n        .A(A[12:9]),\n        .B(B[12:9]),\n        .C_in(c8),\n        .S(S[12:9]),\n        .C_out(c12)\n    );\n\n    adder_4 add4(\n        .A(A[16:13]),\n        .B(B[16:13]),\n        .C_in(c12),\n        .S(S[16:13]),\n        .C_out(C_out)\n    );\nendmodule\n\nmodule adder_4(A, B, C_in, S, C_out);\n    input [4:1] A;        \/\/ 4-bit input A\n    input [4:1] B;        \/\/ 4-bit input B\n    input C_in;           \/\/ Carry in\n    output [4:1] S;       \/\/ 4-bit sum output\n    output C_out;         \/\/ Carry out\n\n    wire p1, p2, p3, p4;  \/\/ Propagate signals\n    wire g1, g2, g3, g4;  \/\/ Generate signals\n    wire c1, c2, c3;      \/\/ Internal carry signals\n\n    \/\/ Instantiate full adders for each bit\n    full_adder fa1(\n        .A(A[1]),\n        .B(B[1]),\n        .C_in(C_in),\n        .S(S[1]),\n        .C_out(c1)\n    );\n\n    full_adder fa2(\n        .A(A[2]),\n        .B(B[2]),\n        .C_in(c1),\n        .S(S[2]),\n        .C_out(c2)\n    );\n\n    full_adder fa3(\n        .A(A[3]),\n        .B(B[3]),\n        .C_in(c2),\n        .S(S[3]),\n        .C_out(c3)\n    );\n\n    full_adder fa4(\n        .A(A[4]),\n        .B(B[4]),\n        .C_in(c3),\n        .S(S[4]),\n        .C_out(C_out)\n    );\n\n    \/\/ Generate and propagate signals\n    assign p1 = A[1] ^ B[1];\n    assign g1 = A[1] & B[1];\n\n    assign p2 = A[2] ^ B[2];\n    assign g2 = A[2] & B[2];\n\n    assign p3 = A[3] ^ B[3];\n    assign g3 = A[3] & B[3];\n\n    assign p4 = A[4] ^ B[4];\n    assign g4 = A[4] & B[4];\n\nendmodule\n\nmodule full_adder(A, B, C_in, S, C_out);\n    input A;              \/\/ Input A\n    input B;              \/\/ Input B\n    input C_in;           \/\/ Carry in\n    output S;             \/\/ Sum output\n    output C_out;         \/\/ Carry out\n\n    assign S = A ^ B ^ C_in; \/\/ Sum calculation\n    assign C_out = (A & B) | ((A | B) & C_in); \/\/ Carry out calculation\nendmodule\n","task_id":"sub_16bit_v_29"}
{"Instruction":"Implement a module of a parallel adder with 1x4 configuration in combinational logic.\n\nModule name:  \n    parallel_adder1x4               \nInput ports:\n    a0[7:0]: 8-bit input operand A0.\n    a1[7:0]: 8-bit input operand A1.\n    a2[7:0]: 8-bit input operand A2.\n    a3[7:0]: 8-bit input operand A3.\n    b0[7:0]: 8-bit input operand B0.\n    b1[7:0]: 8-bit input operand B1.\n    b2[7:0]: 8-bit input operand B2.\n    b3[7:0]: 8-bit input operand B3.\nOutput ports:\n    sum0[8:0]: 9-bit output representing the sum of A0 and B0.\n    sum1[8:0]: 9-bit output representing the sum of A1 and B1.\n    sum2[8:0]: 9-bit output representing the sum of A2 and B2.\n    sum3[8:0]: 9-bit output representing the sum of A3 and B3.\n\nImplementation:\nIn the parallel_adder1x4 module, four Adder Units (AU) are instantiated. Each AU performs the addition of its corresponding pair of inputs. AU0 (au0) computes the sum of inputs a0 and b0. AU1 (au1) computes the sum of inputs a1 and b1. AU2 (au2) computes the sum of inputs a2 and b2. AU3 (au3) computes the sum of inputs a3 and b3. Each AU outputs a result with a carry bit, which accommodates the possibility of overflow in binary addition. This arrangement ensures independent, simultaneous operations, promoting efficiency in operations such as vector addition.\nGive me the complete code.","Response":"module parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);\n    \/\/ 4 AUs\n    AU au0(.a(a0), .b(b0), .sum(sum0));\n    AU au1(.a(a1), .b(b1), .sum(sum1));\n    AU au2(.a(a2), .b(b2), .sum(sum2));\n    AU au3(.a(a3), .b(b3), .sum(sum3));\nendmodule\n\nmodule AU(\n    input [7:0] a,\n    input [7:0] b,\n    output [8:0] sum\n);\n    assign sum = a + b;\nendmodule","task_id":"systolic1x4_v_30"}
{"Instruction":"Design and implement a Verilog module for a 2x2 multiplier matrix using a row-wise computation method.\n\nModule name:  \n    matrix_multiplier2x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    x0[7:0]: 8-bit input operand X0.\n    x1[7:0]: 8-bit input operand X1.\n    y0[7:0]: 8-bit input operand Y0.\n    y1[7:0]: 8-bit input operand Y1.\nOutput ports:\n    p0[15:0]: 16-bit output representing the product of X0 and Y0.\n    p1[15:0]: 16-bit output representing the product of X1 and Y0.\n    p2[15:0]: 16-bit output representing the product of X0 and Y1.\n    p3[15:0]: 16-bit output representing the product of X1 and Y1.\n\nImplementation:\nIn the matrix_multiplier2x2 module, four multiplier units are instantiated, each performing multiplication of its designated pair of input operands. The first multiplier (mult0) processes x0 and y0 directly to compute p0. The second multiplier (mult1) processes x1 and y0 to compute p1. Similarly, mult2 multiplies x0 and y1 to compute p2, and mult3 multiplies x1 and y1 to compute p3. This arrangement allows for parallel computation of the matrix products, enhancing performance for applications requiring matrix operations.\nGive me the complete code.","Response":"module matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);\n    \/\/ Instantiate multiplier units\n    multiplier mult0(.clk(clk), .rst(rst), .a(x0), .b(y0), .result(p0));\n    multiplier mult1(.clk(clk), .rst(rst), .a(x1), .b(y0), .result(p1));\n    multiplier mult2(.clk(clk), .rst(rst), .a(x0), .b(y1), .result(p2));\n    multiplier mult3(.clk(clk), .rst(rst), .a(x1), .b(y1), .result(p3));\nendmodule\n\nmodule multiplier(\n    input clk,\n    input rst,\n    input [7:0] a,\n    input [7:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result <= 0;\n        end else begin\n            result <= a * b;\n        end\n    end\nendmodule\n","task_id":"systolic1x4_v_31"}
{"Instruction":"Implement a module of a cyclic data rotator with a 4-bit configuration utilizing combinational logic.\n\nModule name:  \n    cyclic_rotator4              \nInput ports:\n    en: Enable signal, active high.\n    rot_dir: Rotation direction, 1 for left, 0 for right.\n    in_data[3:0]: 4-bit input data to rotate.\nOutput ports:\n    out_data[3:0]: 4-bit output data after rotation.\n\nImplementation:\nIn the cyclic_rotator4 module, two submodules are instantiated for each rotation direction: left_rotate and right_rotate. Based on the rot_dir input, the respective rotation submodule is activated to perform a one-bit position shift either to the left or right. The left_rotate submodule performs a cyclic shift to the left (e.g., 1001 becomes 0011), and the right_rotate submodule performs a cyclic shift to the right (e.g., 1001 becomes 1100). Each submodule uses bitwise concatenation and slicing to achieve the rotation. The top module uses a multiplexer controlled by the rot_dir input to select between the outputs of these two submodules, sending the result to the out_data output.\nGive me the complete code.","Response":"module cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);\n\nwire [3:0] left_rotated_data;\nwire [3:0] right_rotated_data;\n\nleft_rotate lr(\n    .data(in_data),\n    .rotated_data(left_rotated_data)\n);\n\nright_rotate rr(\n    .data(in_data),\n    .rotated_data(right_rotated_data)\n);\n\nassign out_data = (en) ? ((rot_dir) ? left_rotated_data : right_rotated_data) : in_data;\n\nendmodule\n\nmodule left_rotate(\n  input [3:0] data,\n  output [3:0] rotated_data\n);\n  assign rotated_data = {data[2:0], data[3]};\nendmodule\n\nmodule right_rotate(\n  input [3:0] data,\n  output [3:0] rotated_data\n);\n  assign rotated_data = {data[0], data[3:1]};\nendmodule\n","task_id":"systolic1x4_v_32"}
{"Instruction":"Implement a module for a dual-mode counter that can operate in both up and down counting modes controlled by an external signal.\n\nModule name:  \n    dual_mode_counter               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    mode: Mode selection signal (0 for up-counting, 1 for down-counting).\n    enable: Counter enable signal.\nOutput ports:\n    count[7:0]: 8-bit output representing the current count value.\n\nImplementation:\nIn the dual_mode_counter module, a Counter submodule is instantiated. The Counter operates differently based on the mode signal. In up-counting mode, the count value increments each clock cycle when enable is high. In down-counting mode, the count decrements each cycle when enable is high. The count value is reset to zero when the reset signal is asserted.\nGive me the complete code.","Response":"module dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);\n  wire [7:0] next_count;\n  Counter counter_inst (\n    .clk(clk),\n    .rst(rst),\n    .mode(mode),\n    .enable(enable),\n    .count(next_count)\n  );\n  assign count = next_count;\nendmodule\n\nmodule Counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output reg [7:0] count\n);\n  always @(posedge clk or posedge rst) begin\n    if (rst) begin\n      count <= 0;\n    end\n    else if (enable) begin\n      if (mode == 0)  \/\/ 0 for up-counting\n        count <= count + 1;\n      else            \/\/ 1 for down-counting\n        count <= count - 1;\n    end\n  end\nendmodule\n","task_id":"systolic1x2_v_33"}
{"Instruction":"Design a Verilog module for a dual-latch system with separate input triggers.\n\nModule name:  \n    dual_latch_system               \nInput ports:\n    clk: Clock signal.\n    reset: Reset signal, active high.\n    d0[7:0]: 8-bit input data for first latch.\n    d1[7:0]: 8-bit input data for second latch.\n    load0: Load signal for first latch, active high.\n    load1: Load signal for second latch, active high.\nOutput ports:\n    q0[7:0]: 8-bit output from the first latch.\n    q1[7:0]: 8-bit output from the second latch.\n\nImplementation:\nIn the dual_latch_system module, two separate latches (latch0 and latch1) are instantiated. Each latch captures the input data when its respective load signal is asserted. The first latch (latch0) captures data from d0 on a positive edge of load0. The second latch (latch1) captures data from d1 on a positive edge of load1. Reset functionality is common for both latches, resetting their outputs to zero when the reset signal is active.\nGive me the complete code.","Response":"module dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);\n    Latch latch0 (\n        .clk(clk),\n        .reset(reset),\n        .d(d0),\n        .load(load0),\n        .q(q0)\n    );\n    Latch latch1 (\n        .clk(clk),\n        .reset(reset),\n        .d(d1),\n        .load(load1),\n        .q(q1)\n    );\nendmodule\n\nmodule Latch (\n    input clk,\n    input reset,\n    input [7:0] d,\n    input load,\n    output reg [7:0] q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            q <= 0;\n        end else if (load) begin\n            q <= d;\n        end\n    end\nendmodule\n","task_id":"systolic1x2_v_34"}
{"Instruction":"Design a Verilog module implementing a dual shift register system with individual load and shift control.\n\nModule name:\ndual_shift_register\n\nInput ports:\nclk: Clock signal.\nrst: Reset signal, active high.\nload0: Load control signal for shift register 0.\nload1: Load control signal for shift register 1.\ndata0[7:0]: 8-bit input data for shift register 0.\ndata1[7:0]: 8-bit input data for shift register 1.\nshift0: Shift control signal for shift register 0.\nshift1: Shift control signal for shift register 1.\n\nOutput ports:\nout0[7:0]: 8-bit output from shift register 0.\nout1[7:0]: 8-bit output from shift register 1.\n\nImplementation:\nThe dual_shift_register module consists of two distinct submodules, each being a shift register. Shift register 0 (sr0) loads data from data0 when load0 is high, otherwise it shifts its contents to the right when shift0 is high. Similarly, shift register 1 (sr1) operates with data1, load1, and shift1 signals.\nGive me the complete code.","Response":"module dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);\n    ShiftRegister sr0 (\n        .clk(clk),\n        .rst(rst),\n        .load(load0),\n        .data(data0),\n        .shift(shift0),\n        .out(out0)\n    );\n    ShiftRegister sr1 (\n        .clk(clk),\n        .rst(rst),\n        .load(load1),\n        .data(data1),\n        .shift(shift1),\n        .out(out1)\n    );\n\nendmodule\n\nmodule ShiftRegister (\n    input clk,\n    input rst,\n    input load,\n    input [7:0] data,\n    input shift,\n    output reg [7:0] out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            out <= 0;\n        else if (load)\n            out <= data;\n        else if (shift)\n            out <= out >> 1; \/\/ shift right operation\n    end\nendmodule","task_id":"systolic1x2_v_35"}
{"Instruction":"Implement a module of a 32-bit adder using submodules with multiple bit-level full adders in combinational logic.\n\nModule name:\n    adder_32bit\n\nInput ports:\n    X [31:0]: First 32-bit input operand (binary number to add).\n    Y [31:0]: Second 32-bit input operand (binary number to add).\nOutput ports:\n    Sum [31:0]: 32-bit output representing the sum of X and Y.\n    Carry_out: 1-bit output indicating the carry out of the addition.\n\nImplementation:\nAddition Logic: The module adds two 32-bit binary numbers X and Y using combinational logic.\nA carry propagation is handled, starting from the least significant bit to the most significant bit.\nCarry Generation: The full adder generates a carry which is passed to the next higher bit.\nModular Design:\nThe main module (adder_32bit) instantiates four 8-bit adder submodules (adder_8bit), each handling 8 bits of the input operands.\nThe outputs (Sum and Carry_out) are calculated through the cascading carries between submodules.\nGive me the complete code.","Response":"module adder_32bit(\n    input [31:0] X,    \/\/ First 32-bit input operand\n    input [31:0] Y,    \/\/ Second 32-bit input operand\n    output [31:0] Sum, \/\/ 32-bit output sum\n    output Carry_out   \/\/ Carry output\n);\n\n    wire [3:0] carry;   \/\/ Internal carry wires between submodules\n\n    \/\/ Instantiate the four 8-bit adders\n    adder_8bit adder0 (\n        .a(X[7:0]),\n        .b(Y[7:0]),\n        .cin(1'b0),\n        .sum(Sum[7:0]),\n        .cout(carry[0])\n    );\n\n    adder_8bit adder1 (\n        .a(X[15:8]),\n        .b(Y[15:8]),\n        .cin(carry[0]),\n        .sum(Sum[15:8]),\n        .cout(carry[1])\n    );\n\n    adder_8bit adder2 (\n        .a(X[23:16]),\n        .b(Y[23:16]),\n        .cin(carry[1]),\n        .sum(Sum[23:16]),\n        .cout(carry[2])\n    );\n\n    adder_8bit adder3 (\n        .a(X[31:24]),\n        .b(Y[31:24]),\n        .cin(carry[2]),\n        .sum(Sum[31:24]),\n        .cout(Carry_out)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a,    \/\/ 8-bit part of the first operand\n    input [7:0] b,    \/\/ 8-bit part of the second operand\n    input cin,        \/\/ Carry input from the previous stage\n    output [7:0] sum, \/\/ Sum output of this stage\n    output cout       \/\/ Carry output of this stage\n);\n\n    \/\/ Logic to perform bit-wise addition\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n","task_id":"comparator_32bit_v_36"}
{"Instruction":"Design a 32-bit adder using Verilog, incorporating a set of 8-bit submodules for the addition process. Each submodule should perform 8-bit addition with carry in and carry out.\n\nModule name:\n    adder_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand for addition.\n    B [31:0]: Second 32-bit input operand for addition.\n    Cin: Carry input for the least significant bit addition.\nOutput ports:\n    Sum [31:0]: 32-bit output sum of A and B.\n    Cout: Carry output from the most significant bit addition.\n\nImplementation:\nAddition Logic: The module adds two 32-bit numbers A and B by using cascaded 8-bit adder submodules that handle carry propagation.\nModular Design: The main module (adder_32bit) instantiates four 8-bit adder submodules (adder_8bit). Carry outputs of each submodule are chained to the carry inputs of the next higher submodule, starting from the least significant to the most significant.\nGive me the complete code.","Response":"module adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);\n\n    wire C1, C2, C3;\n\n    adder_8bit add0 (\n        .a(A[7:0]),\n        .b(B[7:0]),\n        .cin(Cin),\n        .sum(Sum[7:0]),\n        .cout(C1)\n    );\n\n    adder_8bit add1 (\n        .a(A[15:8]),\n        .b(B[15:8]),\n        .cin(C1),\n        .sum(Sum[15:8]),\n        .cout(C2)\n    );\n\n    adder_8bit add2 (\n        .a(A[23:16]),\n        .b(B[23:16]),\n        .cin(C2),\n        .sum(Sum[23:16]),\n        .cout(C3)\n    );\n\n    adder_8bit add3 (\n        .a(A[31:24]),\n        .b(B[31:24]),\n        .cin(C3),\n        .sum(Sum[31:24]),\n        .cout(Cout)\n    );\n\nendmodule\n\nmodule adder_8bit(\n    input [7:0] a,\n    input [7:0] b,\n    input cin,\n    output [7:0] sum,\n    output cout\n);\n\n    assign {cout, sum} = a + b + cin;\n\nendmodule\n","task_id":"comparator_32bit_v_37"}
{"Instruction":"Implement a module of a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, and bitwise AND operation using submodules for each function in combinational logic.\n\nModule name:\n    alu_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand.\n    B [31:0]: Second 32-bit input operand.\n    op [1:0]: Operation selector where 00 = addition, 01 = subtraction, 10 = AND.\n\nOutput ports:\n    result [31:0]: 32-bit output result of the selected operation.\n    carry_out: 1-bit output for carry (relevant in addition and subtraction).\n\nImplementation:\nOperational Logic: The ALU selects between addition, subtraction, and AND operations based on the operation selector 'op'.\nAdder and subtractor modules handle arithmetic operations, generating both result and carry\/borrow outputs.\nAND operation is handled by a separate bitwise AND submodule.\nThe top module (alu_32bit) instantiates these submodules and uses multiplexing logic to choose the correct output based on the operation selected.\nGive me the complete code.","Response":"module alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);\n\n    wire [31:0] sum;\n    wire [31:0] diff;\n    wire [31:0] and_result;\n    wire sum_carry_out;\n    wire diff_borrow_out;\n\n    \/\/ Instantiate the adder module\n    adder_32bit add_inst (\n        .A(A),\n        .B(B),\n        .sum(sum),\n        .carry_out(sum_carry_out)\n    );\n\n    \/\/ Instantiate the subtractor module\n    subtractor_32bit sub_inst (\n        .A(A),\n        .B(B),\n        .diff(diff),\n        .borrow_out(diff_borrow_out)\n    );\n\n    \/\/ Instantiate the AND module\n    and_32bit and_inst (\n        .A(A),\n        .B(B),\n        .and_result(and_result)\n    );\n\n    \/\/ Multiplexer for selecting operation result\n    assign result = (op == 2'b00) ? sum :\n                    (op == 2'b01) ? diff :\n                    (op == 2'b10) ? and_result : 32'bx;\n\n    \/\/ Multiplexer for carry output\n    assign carry_out = (op == 2'b00) ? sum_carry_out :\n                       (op == 2'b01) ? diff_borrow_out : 1'b0;\n\nendmodule\n\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] sum,\n    output carry_out\n);\n    assign {carry_out, sum} = A + B;\nendmodule\n\nmodule subtractor_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] diff,\n    output borrow_out\n);\n    assign {borrow_out, diff} = A - B;\nendmodule\n\nmodule and_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] and_result\n);\n    assign and_result = A & B;\nendmodule\n","task_id":"comparator_32bit_v_38"}
{"Instruction":"A data multiplexer module designed to select and output data based on priority control signals. The module segregates input data streams and channels them through specific paths based on control signals, utilizing submodules for the multiplexing process.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    sel [2:0]: Selection signal determining the active data input path (0 for path1, 1 for path2, and so forth).\n    d0 [7:0]: 8-bit data input from path 0.\n    d1 [7:0]: 8-bit data input from path 1.\n    d2 [7:0]: 8-bit data input from path 2.\n\nOutput ports:\n    data_out [7:0]: 8-bit data output reflecting the selected input data.\n\nImplementation:\n    The data multiplexer utilizes three submodules, each handling one data input path.\n    Based on the selection signal sel:\n    - If sel is 3'b000, data is fetched from the first path (mux_path0).\n    - If sel is 3'b001, data is fetched from the second path (mux_path1).\n    - If sel is 3'b010, data is fetched from the third path (mux_path2).\n    The output data_out is assigned the output from the active submodule based on the selection signal.\nGive me the complete code.","Response":"module data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);\n\n    \/\/ Submodule for data paths\n    wire [7:0] path0_out, path1_out, path2_out;\n\n    mux_path mux0 (\n        .clk(clk),\n        .sel(sel),\n        .data(d0),\n        .path_out(path0_out),\n        .sel_code(3'b000) \/\/ Path 0 selection code\n    );\n\n    mux_path mux1 (\n        .clk(clk),\n        .sel(sel),\n        .data(d1),\n        .path_out(path1_out),\n        .sel_code(3'b001) \/\/ Path 1 selection code\n    );\n\n    mux_path mux2 (\n        .clk(clk),\n        .sel(sel),\n        .data(d2),\n        .path_out(path2_out),\n        .sel_code(3'b010) \/\/ Path 2 selection code\n    );\n\n    \/\/ Output assignment using a multiplexer logic\n    assign data_out = (sel == 3'b000) ? path0_out :\n                      (sel == 3'b001) ? path1_out :\n                      (sel == 3'b010) ? path2_out : 8'd0;\n\nendmodule\n\n\/\/ Submodule for handling each data path\nmodule mux_path (\n    input clk,\n    input [2:0] sel,\n    input [7:0] data,\n    output reg [7:0] path_out,\n    input [2:0] sel_code \/\/ Path selection code\n);\n\n    always @(posedge clk) begin\n        if (sel == sel_code) begin\n            path_out <= data; \/\/ Pass data if selection matches\n        end else begin\n            path_out <= path_out; \/\/ Retain previous value\n        end\n    end\n\nendmodule","task_id":"instr_reg_v_39"}
{"Instruction":"A data multiplexer module designed to route data from multiple inputs to a single output based on a control signal. This module uses submodules for handling data from various sources, aggregating the selected data into a single output channel for downstream processing.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    sel [1:0]: Control signal to select the input source.\n    in0 [7:0]: 8-bit data from input source 0.\n    in1 [7:0]: 8-bit data from input source 1.\n    in2 [7:0]: 8-bit data from input source 2.\n    in3 [7:0]: 8-bit data from input source 3.\n\nOutput ports:\n    out [7:0]: The selected 8-bit data output.\n\nImplementation:\n    The data multiplexer is implemented using four submodules, each responsible for holding data from a distinct source.\n    On the rising edge of the clock (clk), if the sel signal selects an input, the corresponding submodule outputs its stored data to the main output.\n    Each submodule reacts to changes in the input data when the selection signal matches its specific code, otherwise it retains the previous value.\n    The output port out directly reflects the data from the selected submodule.\nGive me the complete code.","Response":"module data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);\n\n    wire [7:0] out0, out1, out2, out3;\n\n    data_holder hold0 (\n        .clk(clk),\n        .data(in0),\n        .out(out0),\n        .sel_code(2'b00),\n        .sel(sel)\n    );\n\n    data_holder hold1 (\n        .clk(clk),\n        .data(in1),\n        .out(out1),\n        .sel_code(2'b01),\n        .sel(sel)\n    );\n\n    data_holder hold2 (\n        .clk(clk),\n        .data(in2),\n        .out(out2),\n        .sel_code(2'b10),\n        .sel(sel)\n    );\n\n    data_holder hold3 (\n        .clk(clk),\n        .data(in3),\n        .out(out3),\n        .sel_code(2'b11),\n        .sel(sel)\n    );\n\n    \/\/ Output assignment based on selection\n    assign out = (sel == 2'b00) ? out0 :\n                 (sel == 2'b01) ? out1 :\n                 (sel == 2'b10) ? out2 :\n                 out3;\n\nendmodule\n\n\/\/ Submodule for holding data\nmodule data_holder (\n    input clk,\n    input [7:0] data,\n    output reg [7:0] out,\n    input [1:0] sel_code,\n    input [1:0] sel\n);\n\n    always @(posedge clk) begin\n        if (sel == sel_code) begin\n            out <= data; \/\/ Load data if selected\n        end else begin\n            out <= out; \/\/ Maintain current data if not selected\n        end\n    end\n\nendmodule","task_id":"instr_reg_v_40"}
{"Instruction":"Design and implement a pulse width modulation (PWM) signal generator in Verilog, which uses adjustable duty cycle and frequency settings. The design consists of a submodule for maintaining the PWM count and another submodule for generating the PWM signal based on the count and settings.\n\nModule Name:\n    pwm_generator\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] duty_cycle: Specifies the duty cycle percentage of the PWM signal.\n    [7:0] freq: Frequency control, setting the PWM signal frequency.\n\nOutput Ports:\n    pwm_out: Pulse width modulated output signal.\n\nInternal Modules:\n    PWM Counter Module (pwm_counter)\n    Functionality: Maintains the PWM cycle count and resets based on the frequency.\n    Input Ports:\n    clk: Clock signal.\n    reset: Signal to reset the counter.\n    [7:0] freq: Frequency setting for PWM cycle.\n    Output Ports:\n    [15:0] count: Current PWM cycle count.\n    \n    PWM Signal Generator Module (pwm_signal)\n    Functionality: Generates the PWM output signal based on the current count and duty cycle settings.\n    Input Ports:\n    clk: Clock signal.\n    [15:0] count: Current count from the pwm_counter.\n    [7:0] duty_cycle: Duty cycle percentage.\n    [7:0] freq: Frequency setting for PWM cycle.\n    Output Ports:\n    pwm_out: PWM output signal.\n\nImplementation:\nPWM Counter Operation: The pwm_counter module increments the count on each rising edge of clk. When the count reaches (freq - 1), it resets to 0.\nPWM Signal Generation: The pwm_signal module produces a high output on pwm_out when the count is less than (freq * duty_cycle \/ 100), otherwise low. The pulse width is adjusted according to duty_cycle.\nGive me the complete code.","Response":"module pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);\n\n    wire [15:0] pwm_count;\n    wire reset;\n\n    \/\/ Instance of PWM counter module\n    pwm_counter pc (\n        .clk(clk),\n        .reset(reset),\n        .freq(freq),\n        .count(pwm_count)\n    );\n\n    \/\/ Instance of PWM signal generator module\n    pwm_signal ps (\n        .clk(clk),\n        .count(pwm_count),\n        .duty_cycle(duty_cycle),\n        .freq(freq),\n        .pwm_out(pwm_out)\n    );\n\n    \/\/ Reset logic\n    assign reset = (freq == 0);\n\nendmodule\n\nmodule pwm_counter(\n    input clk,\n    input reset,\n    input [7:0] freq,\n    output reg [15:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 0;\n        end else begin\n            if (count >= freq - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\nendmodule\n\nmodule pwm_signal(\n    input clk,\n    input [15:0] count,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output reg pwm_out\n);\n\n    always @(posedge clk) begin\n        if (count < (freq * duty_cycle \/ 100)) begin\n            pwm_out <= 1;\n        end else begin\n            pwm_out <= 0;\n        end\n    end\n\nendmodule","task_id":"square_wave_v_41"}
{"Instruction":"Design a pulse width modulation (PWM) controller using Verilog that adjusts the duty cycle of the output PWM signal based on an 8-bit input control value. The system includes submodules for pulse generation and duty cycle control.\n\nModule Name:\n    pwm_controller\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] duty_cycle: Control value defining the duty cycle of the PWM signal.\n\nOutput Ports:\n    pwm_out: PWM output signal.\n\nInternal Modules:\n    Pulse Generator Module (pulse_gen)\n    Functionality: Generates pulses based on the current duty cycle setting.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] duty_cycle: 8-bit value determining pulse width.\n    Output Ports:\n    pwm_out: PWM output signal.\n\n    Duty Cycle Controller Module (duty_ctrl)\n    Functionality: Manages the adjustment of the duty cycle based on input control.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] duty_cycle: 8-bit control input.\n    Output Ports:\n    [7:0] adjusted_duty: Adjusted duty cycle setting.\n\nImplementation:\nPulse Generation: The pulse_gen module outputs high or low signals on pwm_out based on comparison between an internal counter and the adjusted_duty value.\nDuty Cycle Adjustment: The duty_ctrl module produces an adjusted duty cycle which dynamically changes the output pulse width by modifying internal settings according to the input duty_cycle value.\nGive me the complete code.","Response":"module pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);\n\n    wire [7:0] adjusted_duty;\n\n    \/\/ Instance of Duty Cycle Controller\n    duty_cycle_controller duty_ctrl (\n        .clk(clk),\n        .duty_cycle(duty_cycle),\n        .adjusted_duty(adjusted_duty)\n    );\n\n    \/\/ Instance of Pulse Generator\n    pulse_generator pulse_gen (\n        .clk(clk),\n        .adjusted_duty(adjusted_duty),\n        .pwm_out(pwm_out)\n    );\n\nendmodule\n\nmodule duty_cycle_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output reg [7:0] adjusted_duty\n);\n\n    always @(posedge clk) begin\n        adjusted_duty <= duty_cycle; \/\/ Placeholder for more complex logic if needed\n    end\n\nendmodule\n\nmodule pulse_generator(\n    input clk,\n    input [7:0] adjusted_duty,\n    output reg pwm_out\n);\n    reg [7:0] counter = 0;\n\n    always @(posedge clk) begin\n        if (counter < adjusted_duty)\n            pwm_out <= 1;\n        else\n            pwm_out <= 0;\n\n        counter <= (counter == 255) ? 0 : counter + 1;\n    end\n\nendmodule\n","task_id":"square_wave_v_42"}
{"Instruction":"Design and implement a 32-bit comparator module in Verilog which uses hierarchical structure with 8-bit comparator submodules.\n\nModule name:  \n    comparator_32bit               \nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\nOutput ports:\n    equal: Output signal that is high when A equals B.\n\nImplementation:\nThe comparator_32bit module should utilize four instances of an 8-bit comparator submodule. Each submodule compares corresponding sections of the inputs and the results are combined to produce the final output.\nGive me the complete code.","Response":"module comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);\n\n    wire [3:0] equal_parts;\n\n    compare8 comp8_inst1 (\n        .a(a[31:24]),\n        .b(b[31:24]),\n        .equal(equal_parts[3])\n    );\n\n    compare8 comp8_inst2 (\n        .a(a[23:16]),\n        .b(b[23:16]),\n        .equal(equal_parts[2])\n    );\n\n    compare8 comp8_inst3 (\n        .a(a[15:8]),\n        .b(b[15:8]),\n        .equal(equal_parts[1])\n    );\n\n    compare8 comp8_inst4 (\n        .a(a[7:0]),\n        .b(b[7:0]),\n        .equal(equal_parts[0])\n    );\n\n    assign equal = &(equal_parts);\n\nendmodule\n\nmodule compare8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire equal\n);\n\n    assign equal = (a == b);\n\nendmodule\n","task_id":"adder_16bit_v_43"}
{"Instruction":"Design a 32-bit binary multiplier using combinational logic that multiplies two 16-bit binary numbers.\n\nModule name:  \n    multiplier_32bit               \nInput ports:\n    x[15:0]: 16-bit input operand X.\n    y[15:0]: 16-bit input operand Y.\nOutput ports:\n    prod[31:0]: 32-bit output representing the product of X and Y.\n\nImplementation:\nIn the multiplier_32bit module, you will need to design a smaller bit-width multiplier (8-bit multiplier), which will be instantiated multiple times.\nGive me the complete code.","Response":"module multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);\n\n    wire [15:0] p1, p2, p3, p4;\n    wire [23:0] temp1, temp2, temp3, temp4;\n\n    mult8 mult8_inst1 (\n        .a(x[7:0]),\n        .b(y[7:0]),\n        .p(p1)\n    );\n\n    mult8 mult8_inst2 (\n        .a(x[7:0]),\n        .b(y[15:8]),\n        .p(p2)\n    );\n\n    mult8 mult8_inst3 (\n        .a(x[15:8]),\n        .b(y[7:0]),\n        .p(p3)\n    );\n\n    mult8 mult8_inst4 (\n        .a(x[15:8]),\n        .b(y[15:8]),\n        .p(p4)\n    );\n\n    assign temp1 = {8'b0, p1};\n    assign temp2 = {p2, 8'b0};\n    assign temp3 = {p3, 8'b0};\n    assign temp4 = {p4, 16'b0};\n\n    assign prod = temp1 + temp2 + temp3 + temp4;\n\nendmodule\n\nmodule mult8 (\n    input wire [7:0] a,\n    input wire [7:0] b,\n    output wire [15:0] p\n);\n\n    wire [15:0] partial [7:0];\n\n    genvar i;\n    generate\n        for (i = 0; i < 8; i = i + 1) begin : bit_multiply\n            assign partial[i] = (b[i] ? (a << i) : 16'b0);\n        end\n    endgenerate\n\n    assign p = partial[0] + partial[1] + partial[2] + partial[3] + partial[4] + partial[5] + partial[6] + partial[7];\n\nendmodule\n","task_id":"adder_16bit_v_44"}
{"Instruction":"Design a Verilog top-level module named `bitwise_reverse8` that includes a module `bit_reverse` to reverse the order of bits in an 8-bit input. The top module should instantiate two separate `bit_reverse` modules. The first module reverses the input data `din`, and the second module reverses the output of the first module, effectively returning the original order but through two stages of processing.\n\nModule name:\n    bitwise_reverse8\n\nInput ports:\n    din [7:0]: 8-bit data input whose bits are to be reversed.\n\nOutput ports:\n    dout [7:0]: 8-bit output data, which is the twice reversed input data (original order restored).\n\nImplementation:\nThe top module, `bitwise_reverse8`, instantiates two `bit_reverse` modules. The first module reverses the bits of the input `din`, and the second module reverses the bits of the output from the first module. This design demonstrates bit manipulation and module instantiation for creating a data flow through multiple processing stages.\nGive me the complete code.","Response":"module bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);\n    wire [7:0] temp;\n\n    \/\/ Instantiating the first bit reversing module\n    bit_reverse br1 (\n        .data_in(din),\n        .data_out(temp)\n    );\n\n    \/\/ Instantiating the second bit reversing module\n    bit_reverse br2 (\n        .data_in(temp),\n        .data_out(dout)\n    );\nendmodule\n\nmodule bit_reverse (\n    input [7:0] data_in,\n    output reg [7:0] data_out\n);\n    always @(*) begin\n        data_out[0] = data_in[7];\n        data_out[1] = data_in[6];\n        data_out[2] = data_in[5];\n        data_out[3] = data_in[4];\n        data_out[4] = data_in[3];\n        data_out[5] = data_in[2];\n        data_out[6] = data_in[1];\n        data_out[7] = data_in[0];\n    end\nendmodule\n","task_id":"shift8_v_45"}
{"Instruction":"Design a Verilog module named `adder_selector` that performs an 8-bit addition of two input numbers (a, b). The module should also have a submodule that decides if the result should be output directly or zeroed based on a control signal (ctrl). If ctrl is high, output the result of the addition; if ctrl is low, output zero.\n\nModule name:\n    adder_selector\n\nInput ports:\n    a [7:0]: 8-bit input representing the first number.\n    b [7:0]: 8-bit input representing the second number.\n    ctrl: Control signal that determines the output behavior.\n\nOutput ports:\n    sum [7:0]: The 8-bit output which is either the sum of a and b or zero based on the ctrl signal.\n\nImplementation:\nThe top_module `adder_selector` contains an instance of an 8-bit adder `my_adder8` and uses a conditional statement in always block to decide the output based on ctrl signal. It sets the output `sum` to either the result of the addition or zero.\nGive me the complete code.","Response":"module adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);\n    wire [7:0] adder_out;\n\n    \/\/ Instantiating the 8-bit adder\n    my_adder8 adder (.a(a), .b(b), .sum(adder_out));\n\n    \/\/ Conditional output logic based on ctrl signal\n    always @(*) begin\n        if (ctrl)\n            sum = adder_out;\n        else\n            sum = 8'b0;\n    end\nendmodule\n\nmodule my_adder8 (\n    input [7:0] a,\n    input [7:0] b,\n    output [7:0] sum\n);\n    assign sum = a + b; \/\/ Simple addition\nendmodule\n","task_id":"shift8_v_46"}
{"Instruction":"Implement a modular pulse width modulator (PWM) that generates three different duty cycles from a base clock of 100MHz. The three output signals should have duty cycles of 25%, 50%, and 75%.\n\nModule name:\n    pwm_gen\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    PWM_25: Output PWM signal with a duty cycle of 25%.\n    PWM_50: Output PWM signal with a duty cycle of 50%.\n    PWM_75: Output PWM signal with a duty cycle of 75%.\n\nImplementation:\nThe module uses three submodules to generate the required PWM signals:\npwm_25 generates the PWM signal with a 25% duty cycle by comparing a running counter to a fixed threshold.\npwm_50 generates the PWM signal with a 50% duty cycle by comparing a running counter to a fixed threshold.\npwm_75 generates the PWM signal with a 75% duty cycle by comparing a running counter to a fixed threshold.\nEach submodule increments its counter on every positive edge of CLK_in or resets it when RST is active. If RST is asserted, the PWM outputs are set to 0. Otherwise, the counters are compared to their respective thresholds to set the PWM outputs.\nGive me the complete code.","Response":"module pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    \/\/ Submodule instances\n    wire pwm_25_out;\n    wire pwm_50_out;\n    wire pwm_75_out;\n\n    pwm_25 pwm_module_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_50 pwm_module_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_75 pwm_module_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    \/\/ Assign outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n\/\/ Submodule for 25% duty cycle PWM generation\nmodule pwm_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt < 25)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n\n            cnt <= (cnt == 99) ? 0 : cnt + 1;\n        end\n    end\nendmodule\n\n\/\/ Submodule for 50% duty cycle PWM generation\nmodule pwm_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt < 50)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n\n            cnt <= (cnt == 99) ? 0 : cnt + 1;\n        end\n    end\nendmodule\n\n\/\/ Submodule for 75% duty cycle PWM generation\nmodule pwm_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 0;\n            cnt <= 0;\n        end else begin\n            if (cnt < 75)\n                PWM_out <= 1;\n            else\n                PWM_out <= 0;\n\n            cnt <= (cnt == 99) ? 0 : cnt + 1;\n        end\n    end\nendmodule\n","task_id":"freq_div_v_47"}
{"Instruction":"Implement a modular pulse width modulator (PWM) that generates three distinct PWM signals based on a fixed 100MHz input clock. The module should produce PWM signals with 25%, 50%, and 75% duty cycles.\n\nModule name:\n    pwm_generator\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    PWM_25: PWM output with a 25% duty cycle.\n    PWM_50: PWM output with a 50% duty cycle.\n    PWM_75: PWM output with a 75% duty cycle.\n\nImplementation:\nThe module uses three submodules to generate the required PWM signals:\npwm_25 generates the PWM signal with a 25% duty cycle.\npwm_50 generates the PWM signal with a 50% duty cycle.\npwm_75 generates the PWM signal with a 75% duty cycle.\nEach submodule counts clock cycles to determine the duration of the high and low states of the output, resetting the count either when it reaches the full cycle count or when RST is active. If RST is asserted, all PWM outputs are reset to 0.\nGive me the complete code.","Response":"module pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);\n\n    \/\/ Submodule instances\n    wire pwm_25_out;\n    wire pwm_50_out;\n    wire pwm_75_out;\n\n    pwm_25 pwm_duty_25 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_25_out)\n    );\n\n    pwm_50 pwm_duty_50 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_50_out)\n    );\n\n    pwm_75 pwm_duty_75 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .PWM_out(pwm_75_out)\n    );\n\n    \/\/ Assign outputs\n    assign PWM_25 = pwm_25_out;\n    assign PWM_50 = pwm_50_out;\n    assign PWM_75 = pwm_75_out;\n\nendmodule\n\n\/\/ Submodule for 25% duty cycle PWM generation\nmodule pwm_25 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 1'b0;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            PWM_out <= (cnt < 25) ? 1'b1 : 1'b0;\n            if (cnt >= 99) cnt <= 0;\n        end\n    end\nendmodule\n\n\/\/ Submodule for 50% duty cycle PWM generation\nmodule pwm_50 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 1'b0;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            PWM_out <= (cnt < 50) ? 1'b1 : 1'b0;\n            if (cnt >= 99) cnt <= 0;\n        end\n    end\nendmodule\n\n\/\/ Submodule for 75% duty cycle PWM generation\nmodule pwm_75 (\n    input CLK_in,\n    input RST,\n    output reg PWM_out\n);\n    reg [6:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            PWM_out <= 1'b0;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n            PWM_out <= (cnt < 75) ? 1'b1 : 1'b0;\n            if (cnt >= 99) cnt <= 0;\n        end\n    end\nendmodule\n","task_id":"freq_div_v_48"}
{"Instruction":"A pulse width modulator (PWM) that controls the output pulse width based on an adjustable duty cycle. The module generates PWM signals with a duty cycle value provided as a parameter.\n\nModule name:\n    pwm_controller\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the PWM generator.\n\nOutput ports:\n    pwm_out: PWM output signal.\n\nImplementation:\n\nThe module generates a PWM signal with a duty cycle defined by the parameter DUTY_CYCLE, which defaults to 50%.\nIt consists of two submodules: `counter` which is a simple up-counter, and `comparator` that compares the counter value to the duty cycle threshold. \nThe `counter` counts up to a MAX_COUNT value and resets, providing a basis for PWM period.\nThe `comparator` outputs a high signal when the counter value is less than the duty cycle threshold, thus controlling the duty cycle of the PWM.\nThe active low reset signal rst_n initializes the counter.\nGive me the complete code.","Response":"module pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);\n    \/\/ Parameters for PWM configuration\n    parameter DUTY_CYCLE = 50; \/\/ 50% duty cycle\n    parameter MAX_COUNT = 100; \/\/ Full cycle count\n\n    wire [6:0] count_value; \/\/ assuming 7-bit for 100 max count\n    wire pwm_signal;\n\n    \/\/ Instantiate the counter module\n    counter #(.MAX_COUNT(MAX_COUNT)) u_counter (\n        .clk(clk),\n        .rst_n(rst_n),\n        .count(count_value)\n    );\n\n    \/\/ Instantiate the comparator module\n    comparator #(.DUTY_CYCLE(DUTY_CYCLE), .MAX_COUNT(MAX_COUNT)) u_comparator (\n        .count(count_value),\n        .pwm(pwm_signal)\n    );\n\n    \/\/ Assign the comparator output to the PWM output\n    assign pwm_out = pwm_signal;\n\nendmodule\n\nmodule counter(\n    input clk,\n    input rst_n,\n    output reg [6:0] count\n);\n    parameter MAX_COUNT = 100;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            count <= 0;\n        end else begin\n            if (count >= MAX_COUNT - 1) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\nendmodule\n\nmodule comparator(\n    input [6:0] count,\n    output reg pwm\n);\n    parameter DUTY_CYCLE = 50;\n    parameter MAX_COUNT = 100;\n\n    always @(*) begin\n        if (count < (MAX_COUNT * DUTY_CYCLE \/ 100)) begin\n            pwm = 1'b1;\n        end else begin\n            pwm = 1'b0;\n        end\n    end\nendmodule\n","task_id":"freq_divbyodd_v_49"}
{"Instruction":"Design a modular multiplier for a 32-bit processor using Verilog. The input operands a and b are both 32-bit, and the operation to be executed is defined by the signal multc, which selects between signed and unsigned multiplication. The 64-bit output y outputs the result of the operation, with the msb and lsb outputs indicating the most and least significant bits of the result respectively. The zero output indicates if the result is zero.\n\nThe operations and their corresponding opcodes are:\n- MULT (signed multiplication): 1'b0\n- MULTU (unsigned multiplication): 1'b1\n\nModule name:\nmultiplier\n\nInput ports:\na: a 32-bit input operand\nb: a 32-bit input operand\nmultc: a 1-bit control signal for selecting the operation type\n\nOutput ports:\ny: a 64-bit output representing the result of the multiplication\nmsb: a 32-bit output representing the most significant bits of the result\nlsb: a 32-bit output representing the least significant bits of the result\nzero: a 1-bit output indicating whether the result is zero\n\nImplementation:\nThe module incorporates submodules for both signed and unsigned multiplication, selecting the result based on the multc control signal.\nGive me the complete code.","Response":"`timescale 1ns \/ 1ps\n\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);\n\nwire [63:0] mult_signed_result, mult_unsigned_result;\n\n\/\/ Instantiate multiplication operations\nsigned_mult mult_signed(.a(a), .b(b), .result(mult_signed_result));\nunsigned_mult mult_unsigned(.a(a), .b(b), .result(mult_unsigned_result));\n\n\/\/ Result selection based on multc\nassign y = (multc == 1'b0) ? mult_signed_result : mult_unsigned_result;\nassign msb = y[63:32];\nassign lsb = y[31:0];\nassign zero = (y == 64'b0);\n\nendmodule\n\n\/\/ Submodules definition\nmodule signed_mult(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = $signed(a) * $signed(b);\nendmodule\n\nmodule unsigned_mult(\n    input [31:0] a,\n    input [31:0] b,\n    output [63:0] result\n);\n    assign result = a * b;\nendmodule\n","task_id":"alu_v_50"}
{"Instruction":"Design a modular Verilog system for a 4-bit binary up-counter with asynchronous reset and enable control. The system increments the count on each rising edge of the clock if the enable signal is high. When the asynchronous reset is activated (active high), the counter resets to zero. The final count should be displayed continuously on the output port with an overflow flag indicating when the counter wraps around from the maximum count back to zero.\n\nModule name:\n    binary_up_counter\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Asynchronous reset signal (active high).\n    en: Enable signal to control the counting.\nOutput ports:\n    count_out[3:0]: 4-bit output displaying the current count.\n    overflow: Output signal that indicates an overflow condition (set high on wrap-around).\n\nImplementation:\nThe design consists of the following submodules:\n1. Count Control Module: Manages the count increment and initializes count on reset.\n2. Overflow Detection Module: Detects and outputs an overflow condition when the counter wraps around.\nGive me the complete code.","Response":"`timescale 1ns\/1ps\n\nmodule binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);\n\n    wire [3:0] count;\n    wire wrap_around;\n\n    \/\/ Instantiate the count control module\n    count_control u_count_control (\n        .clk(clk),\n        .rst(rst),\n        .en(en),\n        .count(count),\n        .wrap_around(wrap_around)\n    );\n\n    \/\/ Instantiate the overflow detection module\n    overflow_detection u_overflow_detection (\n        .wrap_around(wrap_around),\n        .overflow(overflow)\n    );\n\n    assign count_out = count;\n\nendmodule\n\nmodule count_control (\n    input               clk,\n    input               rst,\n    input               en,\n    output reg [3:0]   count,\n    output              wrap_around\n);\n\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            count <= 0;\n        end\n        else if (en) begin\n            if (count == 4'b1111) begin\n                count <= 0;\n            end else begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    assign wrap_around = (count == 4'b1111) && en;\n\nendmodule\n\nmodule overflow_detection (\n    input               wrap_around,\n    output reg          overflow\n);\n\n    always @(posedge wrap_around) begin\n        overflow <= 1'b1;\n    end\n\n    always @(negedge wrap_around) begin\n        overflow <= 1'b0;\n    end\n\nendmodule\n","task_id":"accu_v_51"}
{"Instruction":"Implement a simple arithmetic logic unit (ALU) that performs four functions: addition, subtraction, bitwise AND, and bitwise OR operations based on a 2-bit control input.\n\nModule name:\n    simple_alu\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op_code[1:0]: Control signal to choose the operation (00 for addition, 01 for subtraction, 10 for AND, 11 for OR).\n    operand_a[31:0]: 32-bit input operand A.\n    operand_b[31:0]: 32-bit input operand B.\nOutput ports:\n    result[31:0]: 32-bit result of the operation.\n\nImplementation:\nIn the simple_alu module, four operations are instantiated: add, subtract, bitwise_and, and bitwise_or. The add module performs addition of operand_a and operand_b. The subtract module performs subtraction of operand_b from operand_a. The bitwise_and module performs a bitwise AND operation between operand_a and operand_b. The bitwise_or module performs a bitwise OR operation between operand_a and operand_b. The selected result from these operations is output based on the op_code input.\nGive me the complete code.","Response":"`define ADD_OP 2'b00\n`define SUB_OP 2'b01\n`define AND_OP 2'b10\n`define OR_OP 2'b11\n\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);\n\n\/\/ Operation results\nwire [31:0] res_add, res_sub, res_and, res_or;\n\n\/\/ Instantiate operation modules\nadd_operation add(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_add)\n);\n\nsubtract_operation subtract(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_sub)\n);\n\nand_operation bitwise_and(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_and)\n);\n\nor_operation bitwise_or(\n    .a(operand_a),\n    .b(operand_b),\n    .result(res_or)\n);\n\nalways @(posedge clk) begin\n    if (rst) begin\n        result <= 0;\n    end else begin\n        case (op_code)\n            `ADD_OP: result <= res_add;\n            `SUB_OP: result <= res_sub;\n            `AND_OP: result <= res_and;\n            `OR_OP: result <= res_or;\n            default: result <= 0;\n        endcase\n    end\nend\n\nendmodule\n\n\/\/ Addition module\nmodule add_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a + b;\nendmodule\n\n\/\/ Subtraction module\nmodule subtract_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a - b;\nendmodule\n\n\/\/ AND operation module\nmodule and_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a & b;\nendmodule\n\n\/\/ OR operation module\nmodule or_operation(\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);\nassign result = a | b;\nendmodule","task_id":"stagepipe5_v_52"}
{"Instruction":"Implement a module of a 16-bit comparator using combinational logic that outputs equality, greater than, and less than signals.\n\nModule name:\n    comparator_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\nOutput ports:\n    eq: Output signal that is high if A equals B.\n    gt: Output signal that is high if A is greater than B.\n    lt: Output signal that is high if A is less than B.\n\nImplementation:\nThe comparator_16bit is built using multiple 4-bit comparator slices. Each 4-bit comparator slice outputs local equality, greater than, and less than signals. These outputs are then combined in a hierarchical manner to deduce the overall relationship between the 16-bit inputs A and B.\nGive me the complete code.","Response":"`timescale 1ns \/ 1ns\n\nmodule comparator_16bit(a, b, eq, gt, lt);\ninput [15:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_local, gt_local, lt_local;\n\ncomparator_4bit_slice comp_slice1(\n.a(a[3:0]),\n.b(b[3:0]),\n.eq(eq_local[0]),\n.gt(gt_local[0]),\n.lt(lt_local[0]));\n\ncomparator_4bit_slice comp_slice2(\n.a(a[7:4]),\n.b(b[7:4]),\n.eq(eq_local[1]),\n.gt(gt_local[1]),\n.lt(lt_local[1]));\n\ncomparator_4bit_slice comp_slice3(\n.a(a[11:8]),\n.b(b[11:8]),\n.eq(eq_local[2]),\n.gt(gt_local[2]),\n.lt(lt_local[2]));\n\ncomparator_4bit_slice comp_slice4(\n.a(a[15:12]),\n.b(b[15:12]),\n.eq(eq_local[3]),\n.gt(gt_local[3]),\n.lt(lt_local[3]));\n\nassign eq = &eq_local;\nassign gt = |(gt_local & ~(|lt_local));\nassign lt = |(lt_local & ~(|gt_local));\nendmodule\n\nmodule comparator_4bit_slice(a, b, eq, gt, lt);\ninput [3:0] a, b;\noutput eq, gt, lt;\n\nwire [3:0] eq_bit, gt_bit, lt_bit;\n\ngenvar i;\ngenerate\n    for (i = 0; i < 4; i = i + 1) begin : comp_bits\n        assign eq_bit[i] = (a[i] == b[i]);\n        assign gt_bit[i] = (a[i] & ~b[i]);\n        assign lt_bit[i] = (~a[i] & b[i]);\n    end\nendgenerate\n\nassign eq = &eq_bit;\nassign gt = |(gt_bit & ~(|lt_bit));\nassign lt = |(lt_bit & ~(|gt_bit));\nendmodule\n","task_id":"adder_16bit_csa_v_53"}
{"Instruction":"Implement a module of a 32-bit binary subtractor that employs a series of 8-bit subtractor blocks to perform the operation, and handles borrow-in and borrow-out.\n\nModule name:  \n    subtractor_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\n    Bin: Borrow-in input.\nOutput ports:\n    D[32:1]: 32-bit output representing the difference of A minus B.\n    Bout: Borrow-out output.\n\nImplementation:\nThe top module subtractor_32bit consists of several instances of the 8-bit subtractor block you design.\nGive me the complete code.","Response":"module subtractor_32bit(A, B, Bin, D, Bout);\n    input [32:1] A;\n    input [32:1] B;\n    input Bin;\n    output [32:1] D;\n    output Bout;\n\n    wire [3:0] b;\n\n    subtractor_8 SUB1(\n        .A(A[8:1]),\n        .B(B[8:1]),\n        .Bin(Bin),\n        .D(D[8:1]),\n        .Bout(b[0])\n    );\n\n    subtractor_8 SUB2(\n        .A(A[16:9]),\n        .B(B[16:9]),\n        .Bin(b[0]),\n        .D(D[16:9]),\n        .Bout(b[1])\n    );\n\n    subtractor_8 SUB3(\n        .A(A[24:17]),\n        .B(B[24:17]),\n        .Bin(b[1]),\n        .D(D[24:17]),\n        .Bout(b[2])\n    );\n\n    subtractor_8 SUB4(\n        .A(A[32:25]),\n        .B(B[32:25]),\n        .Bin(b[2]),\n        .D(D[32:25]),\n        .Bout(b[3])\n    );\n\n    assign Bout = b[3];\nendmodule\n\nmodule subtractor_8(A, B, Bin, D, Bout);\n    input [8:1] A;\n    input [8:1] B;\n    input Bin;\n    output [8:1] D;\n    output Bout;\n\n    wire [7:0] borrow;\n\n    full_subtractor FS1(.a(A[1]), .b(B[1]), .bin(Bin), .d(D[1]), .bout(borrow[0]));\n    full_subtractor FS2(.a(A[2]), .b(B[2]), .bin(borrow[0]), .d(D[2]), .bout(borrow[1]));\n    full_subtractor FS3(.a(A[3]), .b(B[3]), .bin(borrow[1]), .d(D[3]), .bout(borrow[2]));\n    full_subtractor FS4(.a(A[4]), .b(B[4]), .bin(borrow[2]), .d(D[4]), .bout(borrow[3]));\n    full_subtractor FS5(.a(A[5]), .b(B[5]), .bin(borrow[3]), .d(D[5]), .bout(borrow[4]));\n    full_subtractor FS6(.a(A[6]), .b(B[6]), .bin(borrow[4]), .d(D[6]), .bout(borrow[5]));\n    full_subtractor FS7(.a(A[7]), .b(B[7]), .bin(borrow[5]), .d(D[7]), .bout(borrow[6]));\n    full_subtractor FS8(.a(A[8]), .b(B[8]), .bin(borrow[6]), .d(D[8]), .bout(Bout));\nendmodule\n\nmodule full_subtractor(a, b, bin, d, bout);\n    input a, b, bin;\n    output d, bout;\n\n    assign d = a ^ b ^ bin;\n    assign bout = (~a & b) | (bin & (~a ^ b));\nendmodule\n","task_id":"adder_32bit_v_54"}
{"Instruction":"Design a binary counter module that increments the count by one on every rising edge of the clock, using three T flip-flops configured to toggle their state. The counter should reset to zero when the reset input is high.\n\nModule name:\n    binary_counter\n\nInput ports:\n    clk: Clock signal for synchronization.\n    reset: Reset signal to reset the counter to zero.\n\nOutput ports:\n    count: 3-bit output reflecting the current count value.\n\nImplementation:\nThe binary counter consists of three instances of the provided T flip-flop module (my_tff). Each flip-flop's output represents a bit of the binary count. The first T flip-flop toggles on every clock cycle. Each subsequent T flip-flop toggles when all lower-order bits are high. A synchronous reset is applied to each flip-flop.\nGive me the complete code.","Response":"module binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);\n    wire t0, t1, t2; \/\/ Intermediate toggle signals\n\n    \/\/ Instantiate three T flip-flops\n    my_tff u0 (.clk(clk), .toggle(1'b1), .reset(reset), .q(count[0]));   \/\/ Least Significant Bit\n    my_tff u1 (.clk(clk), .toggle(count[0]), .reset(reset), .q(count[1]));\n    my_tff u2 (.clk(clk), .toggle(count[0] & count[1]), .reset(reset), .q(count[2]));  \/\/ Most Significant Bit\n\nendmodule\n\nmodule my_tff (\n    input clk,\n    input toggle,\n    input reset,\n    output reg q\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            q <= 0;\n        else if (toggle)\n            q <= ~q;\n    end\nendmodule\n","task_id":"shift_reg_v_55"}
{"Instruction":"Implement a modular 4-bit binary up counter with synchronous reset functionality.\n\nModule name:\n    binary_up_counter\n\nInput ports:\n    clk: Clock signal that drives the counting.\n    reset: Synchronous reset signal to set the counter to zero.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current count value.\n\nInternal logic:\nCount Initialization: A submodule initializes the counter to zero when the reset signal is asserted.\nCount Increment: Another submodule handles the increment operation of the counter, increasing the count by one on each rising edge of the clock signal, unless the reset is asserted.\n\nModularity: The design consists of separate submodules for initialization and counting, promoting better organization and code reusability.\nReset Behavior: When reset is high, the counter is set to zero (out = 4'b0000).\nGive me the complete code.","Response":"module binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);\n\n    wire [3:0] current_state;\n\n    \/\/ Submodule for count initialization\n    count_init init (\n        .reset(reset),\n        .current_state(current_state)\n    );\n\n    \/\/ Submodule for count increment\n    count_increment increment (\n        .clk(clk),\n        .reset(reset),\n        .current_state_in(current_state),\n        .current_state_out(out)\n    );\n\nendmodule\n\n\/\/ Submodule for count initialization\nmodule count_init (\n    input wire reset,\n    output reg [3:0] current_state\n);\n\n    always @ (posedge reset) begin\n        current_state <= 4'b0000;\n    end\n\nendmodule\n\n\/\/ Submodule for count increment\nmodule count_increment (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] current_state_in,\n    output reg [3:0] current_state_out\n);\n\n    always @ (posedge clk) begin\n        if (reset)\n            current_state_out <= 4'b0000;\n        else\n            current_state_out <= current_state_in + 1'b1;\n    end\n\nendmodule\n","task_id":"ring_counter_v_56"}
