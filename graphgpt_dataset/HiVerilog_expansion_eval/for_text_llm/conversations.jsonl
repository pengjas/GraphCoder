{"task_id": "pe_v_0", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'mode', 'type': 'input port'}, {'id': 3, 'content': 'op1', 'type': 'input port'}, {'id': 4, 'content': 'op2', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'u_adder', 'type': 'submodule'}, {'id': 7, 'content': 'u_subtractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 3, 4, 3, 2, 6, 7], [6, 6, 7, 7, 5, 5, 5]]\n, Implement a modular 32-bit Adder-Subtractor using Verilog. In the top module named `as_module`, instantiate submodules for addition and subtraction. The `as_module` orchestrates these submodules to perform either addition or subtraction based on a mode input.\n\nModule name:\n    as_module\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, high to reset, low otherwise.\n    mode: Operation mode, 0 for addition and 1 for subtraction.\n    op1: 32-bit input operand 1.\n    op2: 32-bit input operand 2.\n\nOutput ports:\n    result: 32-bit output, result of addition or subtraction.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule takes two 32-bit inputs (op1 and op2) and produces a 32-bit result of their addition.\nSubtractor Submodule:\nThis submodule subtracts the second 32-bit input (op2) from the first (op1) and outputs the 32-bit result.\nThe main as_module module uses the mode input to select and output the result from either the Adder or Subtractor submodule based on the operation mode.\nGive me the complete code.\nmodule as_module(\n    input clk,\n    input rst,\n    input mode,\n    input [31:0] op1,\n    input [31:0] op2,\n    output [31:0] result\n);"}
{"task_id": "pe_v_1", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'x', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'input port'}, {'id': 4, 'content': 'z', 'type': 'input port'}, {'id': 5, 'content': 'quotient', 'type': 'output port'}, {'id': 6, 'content': 'difference', 'type': 'output port'}, {'id': 7, 'content': 'u_divider', 'type': 'submodule'}, {'id': 8, 'content': 'u_subtractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 4, 7, 7, 8], [7, 7, 8, 8, 5, 6]]\n, Implement a modular 32-bit Integer Divider and Subtractor system using Verilog. The main module, named `ds`, should include submodules for division and subtraction. It connects these to perform the operations, handling 32-bit integers.\n\nModule name:\n    ds\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    rst: Reset signal, high to reset, low otherwise.\n    x: 32-bit dividend input.\n    y: 32-bit divisor input.\n    z: 32-bit subtrahend input.\n\nOutput ports:\n    quotient: 32-bit output for the division result.\n    difference: 32-bit output for the subtraction result.\n\nImplementation:\nThe module includes:\nDivider Submodule:\nThis submodule takes two 32-bit inputs (x and y) and calculates the division, providing a 32-bit quotient.\nSubtractor Submodule:\nThis submodule takes the division result and a 32-bit input z, computing the subtraction (quotient - z) and outputting a 32-bit difference.\nThe main `ds` module integrates these submodules, outputting the results for quotient and difference.\nGive me the complete code.\nmodule ds(\n    input clk,\n    input rst,\n    input [31:0] x,\n    input [31:0] y,\n    input [31:0] z,\n    output [31:0] quotient,\n    output [31:0] difference\n);"}
{"task_id": "pe_v_2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'a', 'type': 'input port'}, {'id': 2, 'content': 'b', 'type': 'input port'}, {'id': 3, 'content': 'op_sel', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'u_and', 'type': 'submodule'}, {'id': 8, 'content': 'u_or', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 1, 2, 1, 2, 1, 2, 7, 6, 8, 5], [5, 5, 6, 6, 7, 7, 8, 8, 4, 4, 4, 4]]\n, Design a modular Arithmetic Logic Unit (ALU) for 32-bit integers. The top module, alu_module, should integrate submodules for addition, subtraction, bitwise AND, and bitwise OR operations. The alu_module connects these submodules to perform the specified operation based on an operation selector input.\n\nModule name:\n    alu_module\n\nInput ports:\n    clk: Clock signal for synchronous operations.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n    op_sel: 2-bit operation selector (00 for ADD, 01 for SUB, 10 for AND, 11 for OR).\n\nOutput ports:\n    result: 32-bit output representing the ALU operation result.\n\nImplementation:\nThe module includes:\nAdder Submodule:\n    This submodule takes two 32-bit inputs and provides a 32-bit output of their sum.\nSubtractor Submodule:\n    This submodule takes two 32-bit inputs and provides a 32-bit output of their difference.\nAND Submodule:\n    This submodule performs a bitwise AND operation on two 32-bit inputs to produce a 32-bit output.\nOR Submodule:\n    This submodule performs a bitwise OR operation on two 32-bit inputs to produce a 32-bit output.\nThe main alu_module uses the operation selector to choose which submodule's output to route to the main output result.\nGive me the complete code.\nmodule alu_module(\n    input clk,\n    input [31:0] a,\n    input [31:0] b,\n    input [1:0] op_sel,\n    output reg [31:0] result\n);"}
{"task_id": "pe_v_3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'op_sel', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_bitwise_and', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 2, 3, 1, 6, 5], [5, 5, 6, 6, 4, 4, 4]]\n, Implement a modular Arithmetic Logic Unit (ALU) for 32-bit integers, performing addition and bitwise AND operations. The top module, alu, connects the submodules for addition and bitwise AND operation. Each submodule handles one operation and outputs the result to the alu module, which then selects the output based on an operation select signal.\n\nModule name:\n    alu\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    op_sel: Operation select signal. 0 for addition, 1 for bitwise AND.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    result: 32-bit output representing the result of the selected operation.\n\nImplementation:\nAdder Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 32-bit result of their addition.\nAND Submodule:\nThis submodule performs a bitwise AND operation on two 32-bit inputs (a and b) and outputs the result.\nThe main alu module connects these submodules and selects the appropriate operation result based on the op_sel signal, driving the output result accordingly.\nGive me the complete code.\nmodule alu(\n    input clk,\n    input op_sel,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] result\n);"}
{"task_id": "pe_v_4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'mode', 'type': 'input port'}, {'id': 3, 'content': 'a', 'type': 'input port'}, {'id': 4, 'content': 'b', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'u_adder', 'type': 'submodule'}, {'id': 7, 'content': 'u_subtractor', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 4, 3, 4, 2, 6, 7], [6, 6, 7, 7, 5, 5, 5]]\n, Implement a modular Dual-mode Arithmetic Unit for 16-bit integers. In the dual_mode_arithmetic module, there are submodules for addition and subtraction. The dual_mode_arithmetic module selects either addition or subtraction based on the mode input.\n\nModule name:\n    dual_mode_arithmetic\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    mode: Mode selection signal. Defined as 0 for addition and 1 for subtraction.\n    a: 16-bit input operand A.\n    b: 16-bit input operand B.\n\nOutput ports:\n    result: 16-bit output representing the arithmetic result.\n\nImplementation:\nThe module includes:\nAdder Submodule:\nThis submodule takes two 16-bit inputs (a and b) and produces a 16-bit result of their addition.\nSubtractor Submodule:\nThis submodule subtracts the input B from input A and outputs a 16-bit result.\nThe main dual_mode_arithmetic module uses a multiplexer controlled by the mode input to select between the outputs of the adder and subtractor submodules and drives the output result accordingly.\nGive me the complete code.\nmodule dual_mode_arithmetic(\n    input clk,\n    input rst,\n    input mode,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);"}
{"task_id": "adder_8bit_v_5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'product', 'type': 'output port'}, {'id': 3, 'content': 'GPP0', 'type': 'submodule'}, {'id': 4, 'content': 'GPP1', 'type': 'submodule'}, {'id': 5, 'content': 'GPP2', 'type': 'submodule'}, {'id': 6, 'content': 'GPP3', 'type': 'submodule'}, {'id': 7, 'content': 'A4BS0', 'type': 'submodule'}, {'id': 8, 'content': 'A4BS1', 'type': 'submodule'}, {'id': 9, 'content': 'A4BS2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 4, 3, 7, 5, 8, 6, 9], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 2]]\n, Implement a module of a 4-bit multiplier using a series of full adders in sequential logic.\n\nModule name:  \n    multiplier_4bit               \nInput ports:\n    a[3:0]: 4-bit input operand A.\n    b[3:0]: 4-bit input operand B.\nOutput ports:\n    product[7:0]: 8-bit output representing the product of A and B.\n\nImplementation:\nThe module utilizes a series of full adders and shift registers to perform the multiplication operation.\nGive me the complete code.\nmodule multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);"}
{"task_id": "adder_8bit_v_6", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'bin', 'type': 'input port'}, {'id': 3, 'content': 'diff', 'type': 'output port'}, {'id': 4, 'content': 'bout', 'type': 'output port'}, {'id': 5, 'content': 'FS0', 'type': 'submodule'}, {'id': 6, 'content': 'FS1', 'type': 'submodule'}, {'id': 7, 'content': 'FS2', 'type': 'submodule'}, {'id': 8, 'content': 'FS3', 'type': 'submodule'}, {'id': 9, 'content': 'FS4', 'type': 'submodule'}, {'id': 10, 'content': 'FS5', 'type': 'submodule'}, {'id': 11, 'content': 'FS6', 'type': 'submodule'}, {'id': 12, 'content': 'FS7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 0, 10, 1, 0, 11, 1, 8, 10, 12, 9, 5, 7, 6, 11, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A and B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);"}
{"task_id": "adder_8bit_v_7", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'bin', 'type': 'input port'}, {'id': 3, 'content': 'diff', 'type': 'output port'}, {'id': 4, 'content': 'bout', 'type': 'output port'}, {'id': 5, 'content': 'S0', 'type': 'submodule'}, {'id': 6, 'content': 'S1', 'type': 'submodule'}, {'id': 7, 'content': 'S2', 'type': 'submodule'}, {'id': 8, 'content': 'S3', 'type': 'submodule'}, {'id': 9, 'content': 'S4', 'type': 'submodule'}, {'id': 10, 'content': 'S5', 'type': 'submodule'}, {'id': 11, 'content': 'S6', 'type': 'submodule'}, {'id': 12, 'content': 'S7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 0, 10, 1, 0, 11, 1, 6, 11, 7, 8, 5, 9, 10, 12, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit subtractor using a series of 1-bit subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A and B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (1-bit subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] a, b, \n    input bin, \n    output [7:0] diff, \n    output bout);"}
{"task_id": "adder_8bit_v_8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'bin', 'type': 'input port'}, {'id': 3, 'content': 'diff', 'type': 'output port'}, {'id': 4, 'content': 'bout', 'type': 'output port'}, {'id': 5, 'content': 'FS0', 'type': 'submodule'}, {'id': 6, 'content': 'FS1', 'type': 'submodule'}, {'id': 7, 'content': 'FS2', 'type': 'submodule'}, {'id': 8, 'content': 'FS3', 'type': 'submodule'}, {'id': 9, 'content': 'FS4', 'type': 'submodule'}, {'id': 10, 'content': 'FS5', 'type': 'submodule'}, {'id': 11, 'content': 'FS6', 'type': 'submodule'}, {'id': 12, 'content': 'FS7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 1, 0, 6, 1, 0, 7, 1, 0, 8, 1, 0, 9, 1, 0, 10, 1, 0, 11, 1, 5, 7, 9, 12, 10, 11, 8, 6, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit subtractor using multiple bit-level subtractors in combinational logic.\n\nModule name:  \n    subtractor_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    bin: Borrow-in input.\nOutput ports:\n    diff[7:0]: 8-bit output representing the difference of A from B.\n    bout: Borrow-out output.\n\nImplementation:\nThe module utilizes a series of bit-level subtractors (full subtractors) to perform the subtraction operation.\nGive me the complete code.\nmodule subtractor_8bit(\n    input [7:0] a, b,\n    input bin,\n    output [7:0] diff,\n    output bout);"}
{"task_id": "adder_8bit_v_9", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'product', 'type': 'output port'}, {'id': 3, 'content': 'SAA0', 'type': 'submodule'}, {'id': 4, 'content': 'SAA1', 'type': 'submodule'}, {'id': 5, 'content': 'SAA2', 'type': 'submodule'}, {'id': 6, 'content': 'SAA3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 4, 5, 3, 6], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Implement a module for a 4-bit multiplier using shift and add method in combinational logic.\n\nModule name:  \n    multiplier_4bit               \nInput ports:\n    a[3:0]: 4-bit input multiplicand.\n    b[3:0]: 4-bit input multiplier.\nOutput ports:\n    product[7:0]: 8-bit output representing the product of A and B.\n\nImplementation:\nThe module uses a series of bit-shifts and add operations controlled by the bits of the multiplier.\nGive me the complete code.\nmodule multiplier_4bit(\n    input [3:0] a, b,\n    output [7:0] product);"}
{"task_id": "up_down_counter_v_10", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'control_signal', 'type': 'input port'}, {'id': 2, 'content': 'count', 'type': 'output port'}, {'id': 3, 'content': 'u_toggle_logic', 'type': 'submodule'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 3, 5, 1, 4, 0, 5], [3, 4, 4, 5, 5, 5, 2]]\n, Design a 32-bit binary ripple counter that operates on an active-high signal and provides a toggle output every clock cycle. The counter should increase when the signal is high and reset when low.\n\nModule name: binary_ripple_counter\n\nFunction:\nA 32-bit binary ripple counter that toggles its count based on an external control signal. The counter increases with each clock pulse if the control signal is high; it resets to zero when the signal is low.\n\nInput ports:\n- clk: Clock signal (1-bit), used to synchronize the counting process.\n- control_signal: External control signal (1-bit), determines if the counter should count or reset.\n\nOutput ports:\n- count [31:0]: 32-bit output representing the current counter value.\n\nImplementation:\nThe module consists of three submodules: toggle_logic, counter_logic, and counter_register.\n- The toggle_logic module determines whether to toggle the count based on the control signal.\n- The counter_logic module calculates the next count value based on the current count and toggle conditions.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the control_signal condition.\nGive me the complete code.\nmodule binary_ripple_counter (\n    input wire clk,\n    input wire control_signal,\n    output wire [31:0] count\n);"}
{"task_id": "up_down_counter_v_11", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'op_code', 'type': 'input port'}, {'id': 1, 'content': 'a', 'type': 'input port'}, {'id': 2, 'content': 'b', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'u_and_logic', 'type': 'submodule'}, {'id': 8, 'content': 'u_or_logic', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 1, 2, 1, 2, 1, 2, 7, 5, 0, 8, 6, 7, 5, 0, 8, 6], [5, 5, 6, 6, 7, 7, 8, 8, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]]\n, Design a 32-bit arithmetic logic unit (ALU) that can perform addition, subtraction, bitwise AND, OR operations based on a 2-bit control signal. The ALU should be implemented modularly with separate logic for each operation.\n\nModule name:\n    modular_alu\n\nFunction:\nA 32-bit ALU capable of performing selected arithmetic and logical operations determined by a control signal.\n\nInput ports:\n    - op_code: Control signal (2-bit), selects the operation to perform.\n    - a [31:0]: First operand (32-bit).\n    - b [31:0]: Second operand (32-bit).\n\nOutput ports:\n    - result [31:0]: 32-bit output, result of the ALU operation.\n    - zero: Output signal (1-bit), indicates if the result is zero.\n\nImplementation:\nThe module consists of four submodules: adder, subtractor, and_logic, or_logic.\n- The adder module performs addition of a and b.\n- The subtractor module performs subtraction of a from b.\n- The and_logic module performs bitwise AND operation on a and b.\n- The or_logic module performs bitwise OR operation on a and b.\nThe result output shows the outcome based on the operation selected by op_code, which can control adding, subtracting, bitwise AND or OR operations. The zero output indicates whether the result is zero.\nGive me the complete code.\nmodule modular_alu (\n    input wire [1:0] op_code,\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire [31:0] result,\n    output wire zero\n);"}
{"task_id": "up_down_counter_v_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'op_code', 'type': 'input port'}, {'id': 1, 'content': 'operand_a', 'type': 'input port'}, {'id': 2, 'content': 'operand_b', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'u_and_bit', 'type': 'submodule'}, {'id': 8, 'content': 'u_or_bit', 'type': 'submodule'}, {'id': 9, 'content': 'u_xor_bit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 2, 1, 2, 1, 2, 1, 2, 1, 5, 7, 9, 6, 8, 5, 7, 9, 6, 8], [5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4]]\n, Design a 32-bit arithmetic logic unit (ALU) in Verilog that performs addition, subtraction, bitwise AND, OR, and XOR operations based on a 3-bit control input, structured with a top module and several submodules for handling specific operations.\n\nModule name:\n    multi_function_alu\n\nFunction:\nA 32-bit ALU that performs multiple arithmetic and logical operations determined by a control signal, with modular implementation.\n\nInput ports:\n    - op_code: Operation code (3-bit), selects the operation to perform (000 for ADD, 001 for SUB, 010 for AND, 011 for OR, 100 for XOR).\n    - operand_a [31:0]: First operand (32-bit).\n    - operand_b [31:0]: Second operand (32-bit).\n\nOutput ports:\n    - result [31:0]: 32-bit output of the selected operation.\n    - zero: Output signal (1-bit), high if the result is zero.\n\nImplementation:\nThe module consists of five submodules: adder, subtractor, and_bit, or_bit, and xor_bit.\n- The adder module calculates the sum of operand_a and operand_b.\n- The subtractor module calculates the difference between operand_a and operand_b.\n- The and_bit module performs bitwise AND on operand_a and operand_b.\n- The or_bit module performs bitwise OR on operand_a and operand_b.\n- The xor_bit module performs bitwise XOR on operand_a and operand_b.\nThe result is selected based on the op_code, and the zero flag is set if the result is zero.\nGive me the complete code.\nmodule multi_function_alu (\n    input wire [2:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result,\n    output wire zero\n);"}
{"task_id": "up_down_counter_v_13", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'op_code', 'type': 'input port'}, {'id': 2, 'content': 'operand_a', 'type': 'input port'}, {'id': 3, 'content': 'operand_b', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'u_adder', 'type': 'submodule'}, {'id': 6, 'content': 'u_subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'u_bitwise_operator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 3, 2, 3, 2, 1, 6, 7, 5, 1], [5, 5, 6, 6, 7, 7, 7, 4, 4, 4, 4]]\n, Design a Verilog module for a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, bitwise AND, OR operations based on a control signal. Implement this using modular design with specific submodules handling different arithmetic and logical functions.\n\nModule name:\n    configurable_alu\n\nFunction:\nA 32-bit ALU that can perform addition, subtraction, bitwise AND, and OR operations, controlled by a 2-bit signal.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the operations.\n    - op_code: Operation code (2-bit), determines the operation to perform:\n        - 00: Addition\n        - 01: Subtraction\n        - 10: Bitwise AND\n        - 11: Bitwise OR\n    - operand_a [31:0]: First 32-bit operand.\n    - operand_b [31:0]: Second 32-bit operand.\n\nOutput ports:\n    - result [31:0]: 32-bit output representing the result of the ALU operation.\n\nImplementation:\nThe module includes three submodules: adder, subtractor, and bitwise_operator.\n- The adder module performs the addition of two 32-bit numbers.\n- The subtractor module performs the subtraction between two 32-bit numbers.\n- The bitwise_operator module handles both the AND and OR operations based on an internal control signal derived from op_code.\nThe result output depends on op_code and reflects the outcome of the operation performed by the relevant submodule.\nGive me the complete code.\nmodule configurable_alu (\n    input wire clk,\n    input wire [1:0] op_code,\n    input wire [31:0] operand_a,\n    input wire [31:0] operand_b,\n    output wire [31:0] result\n);"}
{"task_id": "sub_8bit_v_14", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'GP0', 'type': 'submodule'}, {'id': 4, 'content': 'GP1', 'type': 'submodule'}, {'id': 5, 'content': 'GP2', 'type': 'submodule'}, {'id': 6, 'content': 'GP3', 'type': 'submodule'}, {'id': 7, 'content': 'GP4', 'type': 'submodule'}, {'id': 8, 'content': 'GP5', 'type': 'submodule'}, {'id': 9, 'content': 'GP6', 'type': 'submodule'}, {'id': 10, 'content': 'GP7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 4, 7, 9, 8, 5, 3, 6, 10], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_8bit combines the products from multiple instances of the gen_product module, which calculates partial products. Each gen_product module handles the multiplication operation for one bit of Y with all bits of X and accumulates the results using shift and add methodology.\nGive me the complete code.\nmodule mult_8bit(X, Y, P);"}
{"task_id": "sub_8bit_v_15", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'AS0', 'type': 'submodule'}, {'id': 4, 'content': 'AS1', 'type': 'submodule'}, {'id': 5, 'content': 'AS2', 'type': 'submodule'}, {'id': 6, 'content': 'AS3', 'type': 'submodule'}, {'id': 7, 'content': 'AS4', 'type': 'submodule'}, {'id': 8, 'content': 'AS5', 'type': 'submodule'}, {'id': 9, 'content': 'AS6', 'type': 'submodule'}, {'id': 10, 'content': 'AS7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 3, 0, 1, 4, 0, 1, 5, 0, 1, 6, 0, 7, 1, 0, 8, 1, 0, 1, 9, 0, 10], [3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 2]]\n, Implement a module of an 8-bit multiplier that uses modular design principles.\n\nModule name:\n    mult_8bit\n\nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\n\nOutput ports:\n    P[15:0]: 16-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_8bit uses a series of add_shift modules to perform the multiplication operation through repeated additions based on the shifting method. Each add_shift module is responsible for conditionally adding the multiplicand X shifted left by a specific number of positions to an accumulator based on a corresponding bit in the multiplier Y.\n\nGive me the complete code.\nGive me the complete code.\nmodule mult_8bit(X, Y, P);"}
{"task_id": "sub_8bit_v_16", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'add1', 'type': 'submodule'}, {'id': 4, 'content': 'add2', 'type': 'submodule'}, {'id': 5, 'content': 'add3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 3, 1, 0, 1, 4, 0, 5], [3, 3, 4, 4, 4, 5, 5, 5, 2]]\n, Implement a module of a 4-bit multiplier using a series of adders and shift operations.\n\nModule name:\n    mul_4bit\n\nInput ports:\n    X[3:0]: 4-bit input operand X.\n    Y[3:0]: 4-bit input operand Y.\n\nOutput ports:\n    P[7:0]: 8-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mul_4bit performs multiplication by using bitwise AND operations and shifts to construct partial products, which are then added using an adder_8bit module. The adder_8bit module is composed of full_adder modules to handle the addition of each bit.\nGive me the complete code.\nmodule mul_4bit(X, Y, P);"}
{"task_id": "sub_8bit_v_17", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'adder_0', 'type': 'submodule'}, {'id': 4, 'content': 'adder_1', 'type': 'submodule'}, {'id': 5, 'content': 'adder_2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 3, 1, 0, 4, 1, 0, 5], [3, 3, 4, 4, 4, 5, 5, 5, 2]]\n, Implement a module of a 4-bit multiplier using a combination of adders and shift registers.\n\nModule name:\n    mult_4bit\n\nInput ports:\n    X[3:0]: 4-bit input multiplicand X.\n    Y[3:0]: 4-bit input multiplier Y.\n\nOutput ports:\n    P[7:0]: 8-bit output representing the product of X and Y.\n\nImplementation:\nThe top module mult_4bit utilizes a series of shift and add operations implemented through adder_4bit modules. Each adder_4bit module handles the addition based on the shifted value of X and the bit value of Y.\nGive me the complete code.\nmodule mult_4bit(X, Y, P);"}
{"task_id": "stagepipe3_v_18", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'op_code', 'type': 'input port'}, {'id': 2, 'content': 'operand_a', 'type': 'input port'}, {'id': 3, 'content': 'operand_b', 'type': 'input port'}, {'id': 4, 'content': 'result', 'type': 'output port'}, {'id': 5, 'content': 'adder', 'type': 'submodule'}, {'id': 6, 'content': 'subtractor', 'type': 'submodule'}, {'id': 7, 'content': 'and_logical', 'type': 'submodule'}, {'id': 8, 'content': 'or_logical', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 2, 3, 2, 3, 2, 3, 2, 5, 8, 6, 7], [5, 5, 6, 6, 7, 7, 8, 8, 4, 4, 4, 4]]\n, Design and implement a Verilog module for a simple 4-bit arithmetic logic unit (ALU) with basic operations including addition, subtraction, AND, OR operations.\n\nModule name:  \n    simple_alu4bit               \nInput ports:\n    clk: Clock signal.\n    op_code[1:0]: 2-bit operation selector.\n    operand_a[3:0]: 4-bit input operand A.\n    operand_b[3:0]: 4-bit input operand B.\nOutput ports:\n    result[3:0]: 4-bit output result of the ALU operation.\n\nImplementation:\nThe simple_alu4bit module consists of four primary operational stages: adder, subtractor, and_logical, or_logical. Each stage is implemented as a separate submodule that performs the specific arithmetic or logical operation based on the op_code input. The adder stage computes the sum of operand_a and operand_b. The subtractor stage computes the difference between operand_a and operand_b. The and_logical stage performs a bitwise AND operation, and the or_logical stage performs a bitwise OR operation. The result from the appropriate submodule is selected based on the op_code and output through the result port.\nGive me the complete code.\nmodule simple_alu4bit(\n    input clk,\n    input [1:0] op_code,\n    input [3:0] operand_a,\n    input [3:0] operand_b,\n    output reg [3:0] result\n);"}
{"task_id": "stagepipe3_v_19", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'op', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'adder', 'type': 'submodule'}, {'id': 5, 'content': 'subtractor', 'type': 'submodule'}, {'id': 6, 'content': 'and_op', 'type': 'submodule'}, {'id': 7, 'content': 'or_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 5, 4, 7, 6], [4, 4, 5, 5, 6, 6, 7, 7, 3, 3, 3, 3]]\n, Implement a module for a simple 4-bit arithmetic logic unit (ALU) that performs addition, subtraction, bitwise AND, and bitwise OR based on a 2-bit operation selector.\n\nModule name:  \n    simple_alu               \nInput ports:\n    a[3:0]: 4-bit input operand.\n    b[3:0]: 4-bit input operand.\n    op[1:0]: 2-bit operation selector where 00 is ADD, 01 is SUBTRACT, 10 is AND, and 11 is OR.\nOutput ports:\n    result[3:0]: 4-bit output result of the ALU operation.\n\nImplementation:\nThe simple_alu module instantiates four submodules: adder, subtractor, and_module, and or_module. Each submodule performs a specific operation based on the operation selector 'op'. The adder module calculates the sum of a and b. The subtractor module calculates the difference between a and b. The and_module performs a bitwise AND operation, and the or_module performs a bitwise OR operation. The output of each submodule is connected to a multiplexer, which selects the final result based on 'op'.\nGive me the complete code.\nmodule simple_alu(\n    input [3:0] a,\n    input [3:0] b,\n    input [1:0] op,\n    output reg [3:0] result\n);"}
{"task_id": "stagepipe3_v_20", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'zero', 'type': 'output port'}, {'id': 7, 'content': 'decoder', 'type': 'submodule'}, {'id': 8, 'content': 'manager', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 4, 2, 7, 0, 1, 8, 8], [7, 7, 7, 8, 8, 8, 5, 6]]\n, Implement a module for a 4-bit arithmetic logic unit (ALU) with basic arithmetic and logical operations.\n\nModule name:  \n    simple_alu               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op_code[1:0]: 2-bit operation code to specify the ALU operation.\n    data_a[3:0]: 4-bit input operand A.\n    data_b[3:0]: 4-bit input operand B.\nOutput ports:\n    result[3:0]: 4-bit output resulting from the specified ALU operation.\n    zero: Output high when result is zero.\n\nImplementation:\nIn the simple_alu module, the basic arithmetic operations (addition, subtraction) and logical operations (AND, OR) are supported. The op_decoder submodule interprets the op_code and triggers the corresponding operation in the arithmetic_logic submodule. The result_manager submodule checks the result from arithmetic_logic and outputs a zero flag if the result is zero.\nGive me the complete code.\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [3:0] data_a,\n    input [3:0] data_b,\n    output [3:0] result,\n    output zero\n);"}
{"task_id": "stagepipe3_v_21", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'opcode', 'type': 'input port'}, {'id': 3, 'content': 'data_a', 'type': 'input port'}, {'id': 4, 'content': 'data_b', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'valid', 'type': 'output port'}, {'id': 7, 'content': 'add_module', 'type': 'submodule'}, {'id': 8, 'content': 'sub_module', 'type': 'submodule'}, {'id': 9, 'content': 'mul_module', 'type': 'submodule'}, {'id': 10, 'content': 'div_module', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[3, 4, 3, 4, 3, 4, 3, 4, 10, 8, 7, 9, 10], [7, 7, 8, 8, 9, 9, 10, 10, 5, 5, 5, 5, 6]]\n, Implement a module for a basic 4-function arithmetic unit that computes add, subtract, multiply, and divide operations based on opcode input.\n\nModule name:  \n    arithmetic_unit               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    opcode[1:0]: 2-bit input specifying the operation (00-add, 01-subtract, 10-multiply, 11-divide).\n    data_a[7:0]: 8-bit input operand A.\n    data_b[7:0]: 8-bit input operand B.\nOutput ports:\n    result[15:0]: 16-bit output result of the arithmetic operation.\n    valid: Output flag indicating if the result is valid (e.g., not a division by zero).\n\nImplementation:\nIn the arithmetic_unit module, four different arithmetic operation stages (adder, subtractor, multiplier, divider) are instantiated. The operation to be performed is selected based on the opcode input. The adder module performs addition, the subtractor performs subtraction, the multiplier carries out multiplication, and the divider handles division, including setting the valid flag to 0 when division by zero is attempted. The result from the selected operation stage is output through the result port.\nGive me the complete code.\nmodule arithmetic_unit(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [7:0] data_a,\n    input [7:0] data_b,\n    output reg [15:0] result,\n    output reg valid\n);"}
{"task_id": "barrel_shifter_v_22", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'gt', 'type': 'output port'}, {'id': 3, 'content': 'lt', 'type': 'output port'}, {'id': 4, 'content': 'eq', 'type': 'output port'}, {'id': 5, 'content': 'bc0', 'type': 'submodule'}, {'id': 6, 'content': 'bc1', 'type': 'submodule'}, {'id': 7, 'content': 'bc2', 'type': 'submodule'}, {'id': 8, 'content': 'bc3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 8, 5, 6, 7, 8, 5, 6, 8, 5, 7], [5, 5, 6, 6, 7, 7, 8, 8, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]]\n, Design a 4-bit magnitude comparator that takes two 4-bit binary numbers and outputs whether the first number is greater than, less than, or equal to the second number.\n\nModule name: \n    magnitude_comparator\n\nFunction:\n    This module compares two 4-bit numbers and outputs three signals indicating whether the first number (A) is greater than, less than, or equal to the second number (B).\n\nInput ports:\n    A [3:0]: 4-bit input representing the first number.\n    B [3:0]: 4-bit input representing the second number.\n\nOutput ports:\n    gt: Output signal that is high if A > B.\n    lt: Output signal that is high if A < B.\n    eq: Output signal that is high if A == B.\n\nImplementation:\n    The magnitude_comparator uses submodules to compare each bit of A and B starting from the most significant bit. The comparison logic determines if A is greater than, less than, or equal to B by cascading comparisons from the highest bit to the lowest bit.\n    - If the higher significant bit of A is greater than B, then A is greater regardless of the lower bits.\n    - If the higher significant bit of A is less than B, then A is less regardless of the lower bits.\n    - If bits are equal, the comparison continues to the next lower bit.\n\n    A series of `bit_compare` submodules are instantiated for bit-by-bit comparison, providing intermediate signals for greater than, less than, or equal conditions that are then used to determine the final output.\nGive me the complete code.\nmodule magnitude_comparator (A, B, gt, lt, eq);"}
{"task_id": "barrel_shifter_v_23", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'op', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'carry_borrow', 'type': 'output port'}, {'id': 5, 'content': 'and_unit', 'type': 'submodule'}, {'id': 6, 'content': 'or_unit', 'type': 'submodule'}, {'id': 7, 'content': 'add_unit', 'type': 'submodule'}, {'id': 8, 'content': 'sub_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 2, 8, 5, 7, 6, 7, 2, 8], [5, 5, 6, 6, 7, 7, 8, 8, 3, 3, 3, 3, 3, 4, 4, 4]]\n, Design a 4-bit arithmetic logic unit (ALU) that performs bitwise AND, bitwise OR, addition, and subtraction based on a 2-bit operation selector. The ALU takes two 4-bit inputs and outputs the 4-bit result along with a carry or borrow flag.\n\nModule name: \n    simple_alu\n\nFunction:\n    A 4-bit ALU which can perform bitwise AND, bitwise OR, addition, and subtraction. The operation is determined by a 2-bit control signal.\n\nInput ports:\n    a [3:0]: 4-bit input operand A.\n    b [3:0]: 4-bit input operand B.\n    op [1:0]: 2-bit control signal to select the operation:\n              00 - bitwise AND\n              01 - bitwise OR\n              10 - addition\n              11 - subtraction\n\nOutput ports:\n    result [3:0]: 4-bit result of the operation.\n    carry_borrow: Carry out for addition and borrow flag for subtraction.\n\nImplementation:\n    The ALU operations are handled based on the `op` signal:\n    - 00: Performs bitwise AND using a series of AND gates.\n    - 01: Performs bitwise OR using a series of OR gates.\n    - 10: Performs addition using a 4-bit adder that also provides a carry output.\n    - 11: Performs subtraction using a 4-bit subtractor, where the borrow out is considered.\n    Each operation type is implemented in its own submodule: `bitwise_and`, `bitwise_or`, `adder_4bit`, and `subtractor_4bit`.\nGive me the complete code.\nmodule simple_alu(a, b, op, result, carry_borrow);"}
{"task_id": "barrel_shifter_v_24", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'code', 'type': 'output port'}, {'id': 2, 'content': 'valid', 'type': 'output port'}, {'id': 3, 'content': 'cb7', 'type': 'submodule'}, {'id': 4, 'content': 'cb6', 'type': 'submodule'}, {'id': 5, 'content': 'cb5', 'type': 'submodule'}, {'id': 6, 'content': 'cb4', 'type': 'submodule'}, {'id': 7, 'content': 'cb3', 'type': 'submodule'}, {'id': 8, 'content': 'cb2', 'type': 'submodule'}, {'id': 9, 'content': 'cb1', 'type': 'submodule'}, {'id': 10, 'content': 'cb0', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 0, 0, 0, 0, 0, 0, 0, 10, 9, 7, 6, 3, 8, 4, 5, 0], [3, 4, 5, 6, 7, 8, 9, 10, 1, 1, 1, 1, 1, 1, 1, 1, 2]]\n, Design a Priority Encoder in Verilog, which encodes an 8-bit input into a 3-bit output code corresponding to the highest order '1' found in the input.\n\nModule name: \n    priority_encoder\n\nFunction:\n    An 8-bit Priority Encoder which scans the input from the most significant bit (MSB) to least significant bit (LSB). It outputs a 3-bit binary code representing the position of the highest order bit that is set to '1'. If no bits are set, an additional 'valid' output is set to '0'.\n\nInput ports:\n    in [7:0]: 8-bit input where each bit will be scanned to find the highest order '1'.\n\nOutput ports:\n    code [2:0]: 3-bit output code indicating the position of the first '1' from MSB.\n    valid: Output signal that indicates if the output code is valid (i.e., at least one '1' is present in the input).\n\nImplementation:\n    The priority encoder checks each bit of the input starting from the MSB using a series of conditional checks and logic gates. If a '1' is detected, the corresponding binary code for the position is set at the output. The output 'valid' is set to '1' if any '1' is detected across all bits; otherwise, it remains '0'.\n    The process involves using multiple instances of a `check_bit` submodule, which determines if the current inspected bit is '1' and if it is the highest order '1' found so far based on priority logic.\nGive me the complete code.\nmodule priority_encoder(in, code, valid);"}
{"task_id": "barrel_shifter_v_25", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'temp_sensor', 'type': 'input port'}, {'id': 1, 'content': 'smoke_sensor', 'type': 'input port'}, {'id': 2, 'content': 'alarm_out', 'type': 'output port'}, {'id': 3, 'content': 'comp_temp', 'type': 'submodule'}, {'id': 4, 'content': 'or_gate', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 4], [3, 4, 4, 2]]\n, Design a digital alarm system using Verilog, which sets off an alarm based on predefined temperature and smoke sensor inputs. This system consists of an 8-bit temperature sensor input and a 1-bit smoke detector signal. An alarm is triggered if the temperature is above a threshold or if smoke is detected.\n\nModule name: \n    alarm_system\n\nFunction:\n    A digital alarm system that monitors signals from an 8-bit temperature sensor and a 1-bit smoke detector. The system triggers a 1-bit alarm output when the temperature exceeds a specified threshold or if smoke is detected.\n\nInput ports:\n    temp_sensor [7:0]: 8-bit input from the temperature sensor.\n    smoke_sensor [0]: 1-bit input indicating smoke detection.\n\nOutput ports:\n    alarm_out [0]: 1-bit output that triggers the alarm.\n\nImplementation:\n    The alarm system evaluates the inputs from the temperature sensor and the smoke detector. If the temperature value exceeds a pre-set threshold, or if the smoke detector signal is high, the alarm is triggered.\n    The system utilizes comparison logic to check if the temperature is above the threshold and a logical OR operation to evaluate the condition of either temperature or smoke triggering the alarm.\n    - The `compare_temp` submodule compares the 8-bit temperature input against a predefined threshold.\n    - The `or_logic` submodule takes the output from `compare_temp` and the smoke detector input to perform an OR operation, determining the final alarm state.\nGive me the complete code.\nmodule alarm_system (temp_sensor, smoke_sensor, alarm_out);"}
{"task_id": "sub_16bit_v_26", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C_out', 'type': 'output port'}, {'id': 4, 'content': 'add1', 'type': 'submodule'}, {'id': 5, 'content': 'add2', 'type': 'submodule'}, {'id': 6, 'content': 'add3', 'type': 'submodule'}, {'id': 7, 'content': 'add4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 1, 0, 1, 5, 0, 6, 1, 0, 7, 4, 6, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder using the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}
{"task_id": "sub_16bit_v_27", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C_out', 'type': 'output port'}, {'id': 4, 'content': 'add1', 'type': 'submodule'}, {'id': 5, 'content': 'add2', 'type': 'submodule'}, {'id': 6, 'content': 'add3', 'type': 'submodule'}, {'id': 7, 'content': 'add4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 5, 1, 0, 6, 1, 0, 5, 7, 6, 4, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit carry lookahead adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}
{"task_id": "sub_16bit_v_28", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'P', 'type': 'output port'}, {'id': 3, 'content': 'gen1', 'type': 'submodule'}, {'id': 4, 'content': 'gen2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 3], [3, 4, 2, 2]]\n, Implement a module for a 16-bit parity generator which computes the even parity for two 8-bit inputs using a two-level hierarchical design.\n\nModule name:\n    parity_16bit               \nInput ports:\n    X[7:0]: 8-bit input operand X.\n    Y[7:0]: 8-bit input operand Y.\nOutput ports:\n    P: Single output representing the even parity of the combined 16 bits of X and Y.\n\nImplementation:\nThe top module parity_16bit consists of instances of 8-bit parity generator blocks, followed by a final parity computation of their outputs.\nGive me the complete code.\nmodule parity_16bit(X, Y, P);"}
{"task_id": "sub_16bit_v_29", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C_out', 'type': 'output port'}, {'id': 4, 'content': 'add1', 'type': 'submodule'}, {'id': 5, 'content': 'add2', 'type': 'submodule'}, {'id': 6, 'content': 'add3', 'type': 'submodule'}, {'id': 7, 'content': 'add4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 5, 0, 1, 6, 0, 6, 4, 7, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a carry-lookahead 16-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:\n    add_16bit\nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    S[16:1]: 16-bit output representing the sum of A and B.\n    C_out: Carry-out output.\n\nImplementation:\nThe top module add_16bit consists of several instances of the 4-bit full adder block you design.\nGive me the complete code.\nmodule add_16bit(A, B, S, C_out);"}
{"task_id": "systolic1x4_v_30", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a0', 'type': 'input port'}, {'id': 1, 'content': 'a1', 'type': 'input port'}, {'id': 2, 'content': 'a2', 'type': 'input port'}, {'id': 3, 'content': 'a3', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'b1', 'type': 'input port'}, {'id': 6, 'content': 'b2', 'type': 'input port'}, {'id': 7, 'content': 'b3', 'type': 'input port'}, {'id': 8, 'content': 'sum0', 'type': 'output port'}, {'id': 9, 'content': 'sum1', 'type': 'output port'}, {'id': 10, 'content': 'sum2', 'type': 'output port'}, {'id': 11, 'content': 'sum3', 'type': 'output port'}, {'id': 12, 'content': 'au0', 'type': 'submodule'}, {'id': 13, 'content': 'au1', 'type': 'submodule'}, {'id': 14, 'content': 'au2', 'type': 'submodule'}, {'id': 15, 'content': 'au3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 4, 5, 1, 6, 2, 3, 7, 12, 13, 14, 15], [12, 12, 13, 13, 14, 14, 15, 15, 8, 9, 10, 11]]\n, Implement a module of a parallel adder with 1x4 configuration in combinational logic.\n\nModule name:  \n    parallel_adder1x4               \nInput ports:\n    a0[7:0]: 8-bit input operand A0.\n    a1[7:0]: 8-bit input operand A1.\n    a2[7:0]: 8-bit input operand A2.\n    a3[7:0]: 8-bit input operand A3.\n    b0[7:0]: 8-bit input operand B0.\n    b1[7:0]: 8-bit input operand B1.\n    b2[7:0]: 8-bit input operand B2.\n    b3[7:0]: 8-bit input operand B3.\nOutput ports:\n    sum0[8:0]: 9-bit output representing the sum of A0 and B0.\n    sum1[8:0]: 9-bit output representing the sum of A1 and B1.\n    sum2[8:0]: 9-bit output representing the sum of A2 and B2.\n    sum3[8:0]: 9-bit output representing the sum of A3 and B3.\n\nImplementation:\nIn the parallel_adder1x4 module, four Adder Units (AU) are instantiated. Each AU performs the addition of its corresponding pair of inputs. AU0 (au0) computes the sum of inputs a0 and b0. AU1 (au1) computes the sum of inputs a1 and b1. AU2 (au2) computes the sum of inputs a2 and b2. AU3 (au3) computes the sum of inputs a3 and b3. Each AU outputs a result with a carry bit, which accommodates the possibility of overflow in binary addition. This arrangement ensures independent, simultaneous operations, promoting efficiency in operations such as vector addition.\nGive me the complete code.\nmodule parallel_adder1x4(\n    input [7:0] a0,\n    input [7:0] a1,\n    input [7:0] a2,\n    input [7:0] a3,\n    input [7:0] b0,\n    input [7:0] b1,\n    input [7:0] b2,\n    input [7:0] b3,\n    output [8:0] sum0,\n    output [8:0] sum1,\n    output [8:0] sum2,\n    output [8:0] sum3\n);"}
{"task_id": "systolic1x4_v_31", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'x0', 'type': 'input port'}, {'id': 3, 'content': 'x1', 'type': 'input port'}, {'id': 4, 'content': 'y0', 'type': 'input port'}, {'id': 5, 'content': 'y1', 'type': 'input port'}, {'id': 6, 'content': 'p0', 'type': 'output port'}, {'id': 7, 'content': 'p1', 'type': 'output port'}, {'id': 8, 'content': 'p2', 'type': 'output port'}, {'id': 9, 'content': 'p3', 'type': 'output port'}, {'id': 10, 'content': 'mult0', 'type': 'submodule'}, {'id': 11, 'content': 'mult1', 'type': 'submodule'}, {'id': 12, 'content': 'mult2', 'type': 'submodule'}, {'id': 13, 'content': 'mult3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 2, 4, 3, 0, 1, 5, 0, 1, 2, 3, 5, 0, 1, 10, 11, 12, 13], [10, 10, 10, 10, 11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 6, 7, 8, 9]]\n, Design and implement a Verilog module for a 2x2 multiplier matrix using a row-wise computation method.\n\nModule name:  \n    matrix_multiplier2x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    x0[7:0]: 8-bit input operand X0.\n    x1[7:0]: 8-bit input operand X1.\n    y0[7:0]: 8-bit input operand Y0.\n    y1[7:0]: 8-bit input operand Y1.\nOutput ports:\n    p0[15:0]: 16-bit output representing the product of X0 and Y0.\n    p1[15:0]: 16-bit output representing the product of X1 and Y0.\n    p2[15:0]: 16-bit output representing the product of X0 and Y1.\n    p3[15:0]: 16-bit output representing the product of X1 and Y1.\n\nImplementation:\nIn the matrix_multiplier2x2 module, four multiplier units are instantiated, each performing multiplication of its designated pair of input operands. The first multiplier (mult0) processes x0 and y0 directly to compute p0. The second multiplier (mult1) processes x1 and y0 to compute p1. Similarly, mult2 multiplies x0 and y1 to compute p2, and mult3 multiplies x1 and y1 to compute p3. This arrangement allows for parallel computation of the matrix products, enhancing performance for applications requiring matrix operations.\nGive me the complete code.\nmodule matrix_multiplier2x2(\n    input clk,\n    input rst,\n    input [7:0] x0,\n    input [7:0] x1,\n    input [7:0] y0,\n    input [7:0] y1,\n    output [15:0] p0,\n    output [15:0] p1,\n    output [15:0] p2,\n    output [15:0] p3\n);"}
{"task_id": "systolic1x4_v_32", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'en', 'type': 'input port'}, {'id': 1, 'content': 'rot_dir', 'type': 'input port'}, {'id': 2, 'content': 'in_data', 'type': 'input port'}, {'id': 3, 'content': 'out_data', 'type': 'output port'}, {'id': 4, 'content': 'lr', 'type': 'submodule'}, {'id': 5, 'content': 'rr', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 2, 1, 0, 2, 5, 4], [4, 5, 3, 3, 3, 3, 3]]\n, Implement a module of a cyclic data rotator with a 4-bit configuration utilizing combinational logic.\n\nModule name:  \n    cyclic_rotator4              \nInput ports:\n    en: Enable signal, active high.\n    rot_dir: Rotation direction, 1 for left, 0 for right.\n    in_data[3:0]: 4-bit input data to rotate.\nOutput ports:\n    out_data[3:0]: 4-bit output data after rotation.\n\nImplementation:\nIn the cyclic_rotator4 module, two submodules are instantiated for each rotation direction: left_rotate and right_rotate. Based on the rot_dir input, the respective rotation submodule is activated to perform a one-bit position shift either to the left or right. The left_rotate submodule performs a cyclic shift to the left (e.g., 1001 becomes 0011), and the right_rotate submodule performs a cyclic shift to the right (e.g., 1001 becomes 1100). Each submodule uses bitwise concatenation and slicing to achieve the rotation. The top module uses a multiplexer controlled by the rot_dir input to select between the outputs of these two submodules, sending the result to the out_data output.\nGive me the complete code.\nmodule cyclic_rotator4(\n  input en,\n  input rot_dir,\n  input [3:0] in_data,\n  output [3:0] out_data\n);"}
{"task_id": "systolic1x2_v_33", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'mode', 'type': 'input port'}, {'id': 3, 'content': 'enable', 'type': 'input port'}, {'id': 4, 'content': 'count', 'type': 'output port'}, {'id': 5, 'content': 'counter_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 0, 1, 5], [5, 5, 5, 5, 4]]\n, Implement a module for a dual-mode counter that can operate in both up and down counting modes controlled by an external signal.\n\nModule name:  \n    dual_mode_counter               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    mode: Mode selection signal (0 for up-counting, 1 for down-counting).\n    enable: Counter enable signal.\nOutput ports:\n    count[7:0]: 8-bit output representing the current count value.\n\nImplementation:\nIn the dual_mode_counter module, a Counter submodule is instantiated. The Counter operates differently based on the mode signal. In up-counting mode, the count value increments each clock cycle when enable is high. In down-counting mode, the count decrements each cycle when enable is high. The count value is reset to zero when the reset signal is asserted.\nGive me the complete code.\nmodule dual_mode_counter (\n  input clk,\n  input rst,\n  input mode,\n  input enable,\n  output [7:0] count\n);"}
{"task_id": "systolic1x2_v_34", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'd0', 'type': 'input port'}, {'id': 3, 'content': 'd1', 'type': 'input port'}, {'id': 4, 'content': 'load0', 'type': 'input port'}, {'id': 5, 'content': 'load1', 'type': 'input port'}, {'id': 6, 'content': 'q0', 'type': 'output port'}, {'id': 7, 'content': 'q1', 'type': 'output port'}, {'id': 8, 'content': 'latch0', 'type': 'submodule'}, {'id': 9, 'content': 'latch1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 4, 0, 1, 5, 3, 0, 1, 8, 9], [8, 8, 8, 8, 9, 9, 9, 9, 6, 7]]\n, Design a Verilog module for a dual-latch system with separate input triggers.\n\nModule name:  \n    dual_latch_system               \nInput ports:\n    clk: Clock signal.\n    reset: Reset signal, active high.\n    d0[7:0]: 8-bit input data for first latch.\n    d1[7:0]: 8-bit input data for second latch.\n    load0: Load signal for first latch, active high.\n    load1: Load signal for second latch, active high.\nOutput ports:\n    q0[7:0]: 8-bit output from the first latch.\n    q1[7:0]: 8-bit output from the second latch.\n\nImplementation:\nIn the dual_latch_system module, two separate latches (latch0 and latch1) are instantiated. Each latch captures the input data when its respective load signal is asserted. The first latch (latch0) captures data from d0 on a positive edge of load0. The second latch (latch1) captures data from d1 on a positive edge of load1. Reset functionality is common for both latches, resetting their outputs to zero when the reset signal is active.\nGive me the complete code.\nmodule dual_latch_system (\n    input clk,\n    input reset,\n    input [7:0] d0,\n    input [7:0] d1,\n    input load0,\n    input load1,\n    output [7:0] q0,\n    output [7:0] q1\n);"}
{"task_id": "systolic1x2_v_35", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'load0', 'type': 'input port'}, {'id': 3, 'content': 'load1', 'type': 'input port'}, {'id': 4, 'content': 'data0', 'type': 'input port'}, {'id': 5, 'content': 'data1', 'type': 'input port'}, {'id': 6, 'content': 'shift0', 'type': 'input port'}, {'id': 7, 'content': 'shift1', 'type': 'input port'}, {'id': 8, 'content': 'out0', 'type': 'output port'}, {'id': 9, 'content': 'out1', 'type': 'output port'}, {'id': 10, 'content': 'sr0', 'type': 'submodule'}, {'id': 11, 'content': 'sr1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 4, 7, 0, 1, 3, 5, 10, 11], [10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 8, 9]]\n, Design a Verilog module implementing a dual shift register system with individual load and shift control.\n\nModule name:\ndual_shift_register\n\nInput ports:\nclk: Clock signal.\nrst: Reset signal, active high.\nload0: Load control signal for shift register 0.\nload1: Load control signal for shift register 1.\ndata0[7:0]: 8-bit input data for shift register 0.\ndata1[7:0]: 8-bit input data for shift register 1.\nshift0: Shift control signal for shift register 0.\nshift1: Shift control signal for shift register 1.\n\nOutput ports:\nout0[7:0]: 8-bit output from shift register 0.\nout1[7:0]: 8-bit output from shift register 1.\n\nImplementation:\nThe dual_shift_register module consists of two distinct submodules, each being a shift register. Shift register 0 (sr0) loads data from data0 when load0 is high, otherwise it shifts its contents to the right when shift0 is high. Similarly, shift register 1 (sr1) operates with data1, load1, and shift1 signals.\nGive me the complete code.\nmodule dual_shift_register(\n    input clk,\n    input rst,\n    input load0,\n    input load1,\n    input [7:0] data0,\n    input [7:0] data1,\n    input shift0,\n    input shift1,\n    output [7:0] out0,\n    output [7:0] out1\n);"}
{"task_id": "comparator_32bit_v_36", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'X', 'type': 'input port'}, {'id': 1, 'content': 'Y', 'type': 'input port'}, {'id': 2, 'content': 'Sum', 'type': 'output port'}, {'id': 3, 'content': 'Carry_out', 'type': 'output port'}, {'id': 4, 'content': 'adder0', 'type': 'submodule'}, {'id': 5, 'content': 'adder1', 'type': 'submodule'}, {'id': 6, 'content': 'adder2', 'type': 'submodule'}, {'id': 7, 'content': 'adder3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 1, 0, 5, 1, 0, 6, 1, 0, 5, 4, 6, 7, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a 32-bit adder using submodules with multiple bit-level full adders in combinational logic.\n\nModule name:\n    adder_32bit\n\nInput ports:\n    X [31:0]: First 32-bit input operand (binary number to add).\n    Y [31:0]: Second 32-bit input operand (binary number to add).\nOutput ports:\n    Sum [31:0]: 32-bit output representing the sum of X and Y.\n    Carry_out: 1-bit output indicating the carry out of the addition.\n\nImplementation:\nAddition Logic: The module adds two 32-bit binary numbers X and Y using combinational logic.\nA carry propagation is handled, starting from the least significant bit to the most significant bit.\nCarry Generation: The full adder generates a carry which is passed to the next higher bit.\nModular Design:\nThe main module (adder_32bit) instantiates four 8-bit adder submodules (adder_8bit), each handling 8 bits of the input operands.\nThe outputs (Sum and Carry_out) are calculated through the cascading carries between submodules.\nGive me the complete code.\nmodule adder_32bit(\n    input [31:0] X,    // First 32-bit input operand\n    input [31:0] Y,    // Second 32-bit input operand\n    output [31:0] Sum, // 32-bit output sum\n    output Carry_out   // Carry output\n);"}
{"task_id": "comparator_32bit_v_37", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'Sum', 'type': 'output port'}, {'id': 4, 'content': 'Cout', 'type': 'output port'}, {'id': 5, 'content': 'add0', 'type': 'submodule'}, {'id': 6, 'content': 'add1', 'type': 'submodule'}, {'id': 7, 'content': 'add2', 'type': 'submodule'}, {'id': 8, 'content': 'add3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 1, 6, 0, 1, 7, 0, 5, 8, 7, 6, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Design a 32-bit adder using Verilog, incorporating a set of 8-bit submodules for the addition process. Each submodule should perform 8-bit addition with carry in and carry out.\n\nModule name:\n    adder_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand for addition.\n    B [31:0]: Second 32-bit input operand for addition.\n    Cin: Carry input for the least significant bit addition.\nOutput ports:\n    Sum [31:0]: 32-bit output sum of A and B.\n    Cout: Carry output from the most significant bit addition.\n\nImplementation:\nAddition Logic: The module adds two 32-bit numbers A and B by using cascaded 8-bit adder submodules that handle carry propagation.\nModular Design: The main module (adder_32bit) instantiates four 8-bit adder submodules (adder_8bit). Carry outputs of each submodule are chained to the carry inputs of the next higher submodule, starting from the least significant to the most significant.\nGive me the complete code.\nmodule adder_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input Cin,\n    output [31:0] Sum,\n    output Cout\n);"}
{"task_id": "comparator_32bit_v_38", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'op', 'type': 'input port'}, {'id': 3, 'content': 'result', 'type': 'output port'}, {'id': 4, 'content': 'carry_out', 'type': 'output port'}, {'id': 5, 'content': 'add_inst', 'type': 'submodule'}, {'id': 6, 'content': 'sub_inst', 'type': 'submodule'}, {'id': 7, 'content': 'and_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 7, 5, 2, 6, 5, 2, 6], [5, 5, 6, 6, 7, 7, 3, 3, 3, 3, 4, 4, 4]]\n, Implement a module of a 32-bit arithmetic logic unit (ALU) that performs addition, subtraction, and bitwise AND operation using submodules for each function in combinational logic.\n\nModule name:\n    alu_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand.\n    B [31:0]: Second 32-bit input operand.\n    op [1:0]: Operation selector where 00 = addition, 01 = subtraction, 10 = AND.\n\nOutput ports:\n    result [31:0]: 32-bit output result of the selected operation.\n    carry_out: 1-bit output for carry (relevant in addition and subtraction).\n\nImplementation:\nOperational Logic: The ALU selects between addition, subtraction, and AND operations based on the operation selector 'op'.\nAdder and subtractor modules handle arithmetic operations, generating both result and carry/borrow outputs.\nAND operation is handled by a separate bitwise AND submodule.\nThe top module (alu_32bit) instantiates these submodules and uses multiplexing logic to choose the correct output based on the operation selected.\nGive me the complete code.\nmodule alu_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    input [1:0] op,\n    output [31:0] result,\n    output carry_out\n);"}
{"task_id": "instr_reg_v_39", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'sel', 'type': 'input port'}, {'id': 2, 'content': 'd0', 'type': 'input port'}, {'id': 3, 'content': 'd1', 'type': 'input port'}, {'id': 4, 'content': 'd2', 'type': 'input port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'mux0', 'type': 'submodule'}, {'id': 7, 'content': 'mux1', 'type': 'submodule'}, {'id': 8, 'content': 'mux2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 3, 1, 0, 1, 0, 4, 7, 6, 1, 8], [6, 6, 6, 7, 7, 7, 8, 8, 8, 5, 5, 5, 5]]\n, A data multiplexer module designed to select and output data based on priority control signals. The module segregates input data streams and channels them through specific paths based on control signals, utilizing submodules for the multiplexing process.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    sel [2:0]: Selection signal determining the active data input path (0 for path1, 1 for path2, and so forth).\n    d0 [7:0]: 8-bit data input from path 0.\n    d1 [7:0]: 8-bit data input from path 1.\n    d2 [7:0]: 8-bit data input from path 2.\n\nOutput ports:\n    data_out [7:0]: 8-bit data output reflecting the selected input data.\n\nImplementation:\n    The data multiplexer utilizes three submodules, each handling one data input path.\n    Based on the selection signal sel:\n    - If sel is 3'b000, data is fetched from the first path (mux_path0).\n    - If sel is 3'b001, data is fetched from the second path (mux_path1).\n    - If sel is 3'b010, data is fetched from the third path (mux_path2).\n    The output data_out is assigned the output from the active submodule based on the selection signal.\nGive me the complete code.\nmodule data_mux (\n    input clk,\n    input [2:0] sel,\n    input [7:0] d0,\n    input [7:0] d1,\n    input [7:0] d2,\n    output [7:0] data_out\n);"}
{"task_id": "instr_reg_v_40", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'sel', 'type': 'input port'}, {'id': 2, 'content': 'in0', 'type': 'input port'}, {'id': 3, 'content': 'in1', 'type': 'input port'}, {'id': 4, 'content': 'in2', 'type': 'input port'}, {'id': 5, 'content': 'in3', 'type': 'input port'}, {'id': 6, 'content': 'out', 'type': 'output port'}, {'id': 7, 'content': 'hold0', 'type': 'submodule'}, {'id': 8, 'content': 'hold1', 'type': 'submodule'}, {'id': 9, 'content': 'hold2', 'type': 'submodule'}, {'id': 10, 'content': 'hold3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 1, 3, 4, 1, 0, 1, 0, 5, 10, 1, 8, 9, 7], [7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 6, 6, 6, 6, 6]]\n, A data multiplexer module designed to route data from multiple inputs to a single output based on a control signal. This module uses submodules for handling data from various sources, aggregating the selected data into a single output channel for downstream processing.\n\nModule name:\n    data_mux\n\nInput ports:\n    clk: Clock signal for synchronization.\n    sel [1:0]: Control signal to select the input source.\n    in0 [7:0]: 8-bit data from input source 0.\n    in1 [7:0]: 8-bit data from input source 1.\n    in2 [7:0]: 8-bit data from input source 2.\n    in3 [7:0]: 8-bit data from input source 3.\n\nOutput ports:\n    out [7:0]: The selected 8-bit data output.\n\nImplementation:\n    The data multiplexer is implemented using four submodules, each responsible for holding data from a distinct source.\n    On the rising edge of the clock (clk), if the sel signal selects an input, the corresponding submodule outputs its stored data to the main output.\n    Each submodule reacts to changes in the input data when the selection signal matches its specific code, otherwise it retains the previous value.\n    The output port out directly reflects the data from the selected submodule.\nGive me the complete code.\nmodule data_mux (\n    input clk,\n    input [1:0] sel,\n    input [7:0] in0,\n    input [7:0] in1,\n    input [7:0] in2,\n    input [7:0] in3,\n    output [7:0] out\n);"}
{"task_id": "square_wave_v_41", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'duty_cycle', 'type': 'input port'}, {'id': 2, 'content': 'freq', 'type': 'input port'}, {'id': 3, 'content': 'pwm_out', 'type': 'output port'}, {'id': 4, 'content': 'pc', 'type': 'submodule'}, {'id': 5, 'content': 'ps', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 2, 0, 4, 1, 5], [4, 4, 5, 5, 5, 5, 3]]\n, Design and implement a pulse width modulation (PWM) signal generator in Verilog, which uses adjustable duty cycle and frequency settings. The design consists of a submodule for maintaining the PWM count and another submodule for generating the PWM signal based on the count and settings.\n\nModule Name:\n    pwm_generator\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] duty_cycle: Specifies the duty cycle percentage of the PWM signal.\n    [7:0] freq: Frequency control, setting the PWM signal frequency.\n\nOutput Ports:\n    pwm_out: Pulse width modulated output signal.\n\nInternal Modules:\n    PWM Counter Module (pwm_counter)\n    Functionality: Maintains the PWM cycle count and resets based on the frequency.\n    Input Ports:\n    clk: Clock signal.\n    reset: Signal to reset the counter.\n    [7:0] freq: Frequency setting for PWM cycle.\n    Output Ports:\n    [15:0] count: Current PWM cycle count.\n    \n    PWM Signal Generator Module (pwm_signal)\n    Functionality: Generates the PWM output signal based on the current count and duty cycle settings.\n    Input Ports:\n    clk: Clock signal.\n    [15:0] count: Current count from the pwm_counter.\n    [7:0] duty_cycle: Duty cycle percentage.\n    [7:0] freq: Frequency setting for PWM cycle.\n    Output Ports:\n    pwm_out: PWM output signal.\n\nImplementation:\nPWM Counter Operation: The pwm_counter module increments the count on each rising edge of clk. When the count reaches (freq - 1), it resets to 0.\nPWM Signal Generation: The pwm_signal module produces a high output on pwm_out when the count is less than (freq * duty_cycle / 100), otherwise low. The pulse width is adjusted according to duty_cycle.\nGive me the complete code.\nmodule pwm_generator(\n    input clk,\n    input [7:0] duty_cycle,\n    input [7:0] freq,\n    output pwm_out\n);"}
{"task_id": "square_wave_v_42", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'duty_cycle', 'type': 'input port'}, {'id': 2, 'content': 'pwm_out', 'type': 'output port'}, {'id': 3, 'content': 'duty_ctrl', 'type': 'submodule'}, {'id': 4, 'content': 'pulse_gen', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 4], [3, 3, 4, 4, 2]]\n, Design a pulse width modulation (PWM) controller using Verilog that adjusts the duty cycle of the output PWM signal based on an 8-bit input control value. The system includes submodules for pulse generation and duty cycle control.\n\nModule Name:\n    pwm_controller\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] duty_cycle: Control value defining the duty cycle of the PWM signal.\n\nOutput Ports:\n    pwm_out: PWM output signal.\n\nInternal Modules:\n    Pulse Generator Module (pulse_gen)\n    Functionality: Generates pulses based on the current duty cycle setting.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] duty_cycle: 8-bit value determining pulse width.\n    Output Ports:\n    pwm_out: PWM output signal.\n\n    Duty Cycle Controller Module (duty_ctrl)\n    Functionality: Manages the adjustment of the duty cycle based on input control.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] duty_cycle: 8-bit control input.\n    Output Ports:\n    [7:0] adjusted_duty: Adjusted duty cycle setting.\n\nImplementation:\nPulse Generation: The pulse_gen module outputs high or low signals on pwm_out based on comparison between an internal counter and the adjusted_duty value.\nDuty Cycle Adjustment: The duty_ctrl module produces an adjusted duty cycle which dynamically changes the output pulse width by modifying internal settings according to the input duty_cycle value.\nGive me the complete code.\nmodule pwm_controller(\n    input clk,\n    input [7:0] duty_cycle,\n    output pwm_out\n);"}
{"task_id": "adder_16bit_v_43", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'equal', 'type': 'output port'}, {'id': 3, 'content': 'comp8_inst1', 'type': 'submodule'}, {'id': 4, 'content': 'comp8_inst2', 'type': 'submodule'}, {'id': 5, 'content': 'comp8_inst3', 'type': 'submodule'}, {'id': 6, 'content': 'comp8_inst4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 5, 4, 6, 3], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Design and implement a 32-bit comparator module in Verilog which uses hierarchical structure with 8-bit comparator submodules.\n\nModule name:  \n    comparator_32bit               \nInput ports:\n    a[31:0]: 32-bit input operand A.\n    b[31:0]: 32-bit input operand B.\nOutput ports:\n    equal: Output signal that is high when A equals B.\n\nImplementation:\nThe comparator_32bit module should utilize four instances of an 8-bit comparator submodule. Each submodule compares corresponding sections of the inputs and the results are combined to produce the final output.\nGive me the complete code.\nmodule comparator_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    output wire equal\n);"}
{"task_id": "adder_16bit_v_44", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'x', 'type': 'input port'}, {'id': 1, 'content': 'y', 'type': 'input port'}, {'id': 2, 'content': 'prod', 'type': 'output port'}, {'id': 3, 'content': 'mult8_inst1', 'type': 'submodule'}, {'id': 4, 'content': 'mult8_inst2', 'type': 'submodule'}, {'id': 5, 'content': 'mult8_inst3', 'type': 'submodule'}, {'id': 6, 'content': 'mult8_inst4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 6, 3, 4, 5], [3, 3, 4, 4, 5, 5, 6, 6, 2, 2, 2, 2]]\n, Design a 32-bit binary multiplier using combinational logic that multiplies two 16-bit binary numbers.\n\nModule name:  \n    multiplier_32bit               \nInput ports:\n    x[15:0]: 16-bit input operand X.\n    y[15:0]: 16-bit input operand Y.\nOutput ports:\n    prod[31:0]: 32-bit output representing the product of X and Y.\n\nImplementation:\nIn the multiplier_32bit module, you will need to design a smaller bit-width multiplier (8-bit multiplier), which will be instantiated multiple times.\nGive me the complete code.\nmodule multiplier_32bit (\n    input wire [15:0] x,\n    input wire [15:0] y,\n    output wire [31:0] prod\n);"}
{"task_id": "shift8_v_45", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'din', 'type': 'input port'}, {'id': 1, 'content': 'dout', 'type': 'output port'}, {'id': 2, 'content': 'br1', 'type': 'submodule'}, {'id': 3, 'content': 'br2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 3], [2, 3, 1]]\n, Design a Verilog top-level module named `bitwise_reverse8` that includes a module `bit_reverse` to reverse the order of bits in an 8-bit input. The top module should instantiate two separate `bit_reverse` modules. The first module reverses the input data `din`, and the second module reverses the output of the first module, effectively returning the original order but through two stages of processing.\n\nModule name:\n    bitwise_reverse8\n\nInput ports:\n    din [7:0]: 8-bit data input whose bits are to be reversed.\n\nOutput ports:\n    dout [7:0]: 8-bit output data, which is the twice reversed input data (original order restored).\n\nImplementation:\nThe top module, `bitwise_reverse8`, instantiates two `bit_reverse` modules. The first module reverses the bits of the input `din`, and the second module reverses the bits of the output from the first module. This design demonstrates bit manipulation and module instantiation for creating a data flow through multiple processing stages.\nGive me the complete code.\nmodule bitwise_reverse8 (\n    input [7:0] din,\n    output [7:0] dout\n);"}
{"task_id": "shift8_v_46", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'ctrl', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'adder', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4], [4, 4, 3]]\n, Design a Verilog module named `adder_selector` that performs an 8-bit addition of two input numbers (a, b). The module should also have a submodule that decides if the result should be output directly or zeroed based on a control signal (ctrl). If ctrl is high, output the result of the addition; if ctrl is low, output zero.\n\nModule name:\n    adder_selector\n\nInput ports:\n    a [7:0]: 8-bit input representing the first number.\n    b [7:0]: 8-bit input representing the second number.\n    ctrl: Control signal that determines the output behavior.\n\nOutput ports:\n    sum [7:0]: The 8-bit output which is either the sum of a and b or zero based on the ctrl signal.\n\nImplementation:\nThe top_module `adder_selector` contains an instance of an 8-bit adder `my_adder8` and uses a conditional statement in always block to decide the output based on ctrl signal. It sets the output `sum` to either the result of the addition or zero.\nGive me the complete code.\nmodule adder_selector (\n    input [7:0] a,\n    input [7:0] b,\n    input ctrl,\n    output reg [7:0] sum\n);"}
{"task_id": "freq_div_v_47", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'PWM_25', 'type': 'output port'}, {'id': 3, 'content': 'PWM_50', 'type': 'output port'}, {'id': 4, 'content': 'PWM_75', 'type': 'output port'}, {'id': 5, 'content': 'pwm_module_25', 'type': 'submodule'}, {'id': 6, 'content': 'pwm_module_50', 'type': 'submodule'}, {'id': 7, 'content': 'pwm_module_75', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular pulse width modulator (PWM) that generates three different duty cycles from a base clock of 100MHz. The three output signals should have duty cycles of 25%, 50%, and 75%.\n\nModule name:\n    pwm_gen\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    PWM_25: Output PWM signal with a duty cycle of 25%.\n    PWM_50: Output PWM signal with a duty cycle of 50%.\n    PWM_75: Output PWM signal with a duty cycle of 75%.\n\nImplementation:\nThe module uses three submodules to generate the required PWM signals:\npwm_25 generates the PWM signal with a 25% duty cycle by comparing a running counter to a fixed threshold.\npwm_50 generates the PWM signal with a 50% duty cycle by comparing a running counter to a fixed threshold.\npwm_75 generates the PWM signal with a 75% duty cycle by comparing a running counter to a fixed threshold.\nEach submodule increments its counter on every positive edge of CLK_in or resets it when RST is active. If RST is asserted, the PWM outputs are set to 0. Otherwise, the counters are compared to their respective thresholds to set the PWM outputs.\nGive me the complete code.\nmodule pwm_gen (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);"}
{"task_id": "freq_div_v_48", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'PWM_25', 'type': 'output port'}, {'id': 3, 'content': 'PWM_50', 'type': 'output port'}, {'id': 4, 'content': 'PWM_75', 'type': 'output port'}, {'id': 5, 'content': 'pwm_duty_25', 'type': 'submodule'}, {'id': 6, 'content': 'pwm_duty_50', 'type': 'submodule'}, {'id': 7, 'content': 'pwm_duty_75', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 1, 0, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular pulse width modulator (PWM) that generates three distinct PWM signals based on a fixed 100MHz input clock. The module should produce PWM signals with 25%, 50%, and 75% duty cycles.\n\nModule name:\n    pwm_generator\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    PWM_25: PWM output with a 25% duty cycle.\n    PWM_50: PWM output with a 50% duty cycle.\n    PWM_75: PWM output with a 75% duty cycle.\n\nImplementation:\nThe module uses three submodules to generate the required PWM signals:\npwm_25 generates the PWM signal with a 25% duty cycle.\npwm_50 generates the PWM signal with a 50% duty cycle.\npwm_75 generates the PWM signal with a 75% duty cycle.\nEach submodule counts clock cycles to determine the duration of the high and low states of the output, resetting the count either when it reaches the full cycle count or when RST is active. If RST is asserted, all PWM outputs are reset to 0.\nGive me the complete code.\nmodule pwm_generator (\n    input CLK_in,\n    input RST,\n    output PWM_25,\n    output PWM_50,\n    output PWM_75\n);"}
{"task_id": "freq_divbyodd_v_49", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'pwm_out', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_comparator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 4], [3, 3, 4, 2]]\n, A pulse width modulator (PWM) that controls the output pulse width based on an adjustable duty cycle. The module generates PWM signals with a duty cycle value provided as a parameter.\n\nModule name:\n    pwm_controller\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the PWM generator.\n\nOutput ports:\n    pwm_out: PWM output signal.\n\nImplementation:\n\nThe module generates a PWM signal with a duty cycle defined by the parameter DUTY_CYCLE, which defaults to 50%.\nIt consists of two submodules: `counter` which is a simple up-counter, and `comparator` that compares the counter value to the duty cycle threshold. \nThe `counter` counts up to a MAX_COUNT value and resets, providing a basis for PWM period.\nThe `comparator` outputs a high signal when the counter value is less than the duty cycle threshold, thus controlling the duty cycle of the PWM.\nThe active low reset signal rst_n initializes the counter.\nGive me the complete code.\nmodule pwm_controller(\n    input clk,\n    input rst_n,\n    output pwm_out\n);"}
{"task_id": "alu_v_50", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'multc', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'msb', 'type': 'output port'}, {'id': 5, 'content': 'lsb', 'type': 'output port'}, {'id': 6, 'content': 'zero', 'type': 'output port'}, {'id': 7, 'content': 'mult_signed', 'type': 'submodule'}, {'id': 8, 'content': 'mult_unsigned', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 2, 7, 8, 2, 7, 8, 2, 7, 8, 2, 7, 8], [7, 7, 8, 8, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6]]\n, Design a modular multiplier for a 32-bit processor using Verilog. The input operands a and b are both 32-bit, and the operation to be executed is defined by the signal multc, which selects between signed and unsigned multiplication. The 64-bit output y outputs the result of the operation, with the msb and lsb outputs indicating the most and least significant bits of the result respectively. The zero output indicates if the result is zero.\n\nThe operations and their corresponding opcodes are:\n- MULT (signed multiplication): 1'b0\n- MULTU (unsigned multiplication): 1'b1\n\nModule name:\nmultiplier\n\nInput ports:\na: a 32-bit input operand\nb: a 32-bit input operand\nmultc: a 1-bit control signal for selecting the operation type\n\nOutput ports:\ny: a 64-bit output representing the result of the multiplication\nmsb: a 32-bit output representing the most significant bits of the result\nlsb: a 32-bit output representing the least significant bits of the result\nzero: a 1-bit output indicating whether the result is zero\n\nImplementation:\nThe module incorporates submodules for both signed and unsigned multiplication, selecting the result based on the multc control signal.\nGive me the complete code.\nmodule multiplier(\n    input [31:0] a,\n    input [31:0] b,\n    input multc,\n    output [63:0] y,\n    output [31:0] msb,\n    output [31:0] lsb,\n    output zero\n);"}
{"task_id": "accu_v_51", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'en', 'type': 'input port'}, {'id': 3, 'content': 'count_out', 'type': 'output port'}, {'id': 4, 'content': 'overflow', 'type': 'output port'}, {'id': 5, 'content': 'u_count_control', 'type': 'submodule'}, {'id': 6, 'content': 'u_overflow_detection', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 5, 6], [5, 5, 5, 6, 3, 4]]\n, Design a modular Verilog system for a 4-bit binary up-counter with asynchronous reset and enable control. The system increments the count on each rising edge of the clock if the enable signal is high. When the asynchronous reset is activated (active high), the counter resets to zero. The final count should be displayed continuously on the output port with an overflow flag indicating when the counter wraps around from the maximum count back to zero.\n\nModule name:\n    binary_up_counter\nInput ports:\n    clk: Clock input for synchronization.\n    rst: Asynchronous reset signal (active high).\n    en: Enable signal to control the counting.\nOutput ports:\n    count_out[3:0]: 4-bit output displaying the current count.\n    overflow: Output signal that indicates an overflow condition (set high on wrap-around).\n\nImplementation:\nThe design consists of the following submodules:\n1. Count Control Module: Manages the count increment and initializes count on reset.\n2. Overflow Detection Module: Detects and outputs an overflow condition when the counter wraps around.\nGive me the complete code.\nmodule binary_up_counter (\n    input               clk,\n    input               rst,\n    input               en,\n\n    output      [3:0]   count_out,\n    output              overflow\n);"}
{"task_id": "stagepipe5_v_52", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'op_code', 'type': 'input port'}, {'id': 3, 'content': 'operand_a', 'type': 'input port'}, {'id': 4, 'content': 'operand_b', 'type': 'input port'}, {'id': 5, 'content': 'result', 'type': 'output port'}, {'id': 6, 'content': 'add', 'type': 'submodule'}, {'id': 7, 'content': 'subtract', 'type': 'submodule'}, {'id': 8, 'content': 'bitwise_and', 'type': 'submodule'}, {'id': 9, 'content': 'bitwise_or', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 3, 4, 3, 4, 3, 4, 3, 7, 9, 6, 8], [6, 6, 7, 7, 8, 8, 9, 9, 5, 5, 5, 5]]\n, Implement a simple arithmetic logic unit (ALU) that performs four functions: addition, subtraction, bitwise AND, and bitwise OR operations based on a 2-bit control input.\n\nModule name:\n    simple_alu\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    op_code[1:0]: Control signal to choose the operation (00 for addition, 01 for subtraction, 10 for AND, 11 for OR).\n    operand_a[31:0]: 32-bit input operand A.\n    operand_b[31:0]: 32-bit input operand B.\nOutput ports:\n    result[31:0]: 32-bit result of the operation.\n\nImplementation:\nIn the simple_alu module, four operations are instantiated: add, subtract, bitwise_and, and bitwise_or. The add module performs addition of operand_a and operand_b. The subtract module performs subtraction of operand_b from operand_a. The bitwise_and module performs a bitwise AND operation between operand_a and operand_b. The bitwise_or module performs a bitwise OR operation between operand_a and operand_b. The selected result from these operations is output based on the op_code input.\nGive me the complete code.\nmodule simple_alu(\n    input clk,\n    input rst,\n    input [1:0] op_code,\n    input [31:0] operand_a,\n    input [31:0] operand_b,\n    output reg [31:0] result\n);"}
{"task_id": "adder_16bit_csa_v_53", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'eq', 'type': 'output port'}, {'id': 3, 'content': 'gt', 'type': 'output port'}, {'id': 4, 'content': 'lt', 'type': 'output port'}, {'id': 5, 'content': 'comp_slice1', 'type': 'submodule'}, {'id': 6, 'content': 'comp_slice2', 'type': 'submodule'}, {'id': 7, 'content': 'comp_slice3', 'type': 'submodule'}, {'id': 8, 'content': 'comp_slice4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 7, 8, 6, 5, 7, 8, 6, 5, 7, 8, 6, 5], [5, 5, 6, 6, 7, 7, 8, 8, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4]]\n, Implement a module of a 16-bit comparator using combinational logic that outputs equality, greater than, and less than signals.\n\nModule name:\n    comparator_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\nOutput ports:\n    eq: Output signal that is high if A equals B.\n    gt: Output signal that is high if A is greater than B.\n    lt: Output signal that is high if A is less than B.\n\nImplementation:\nThe comparator_16bit is built using multiple 4-bit comparator slices. Each 4-bit comparator slice outputs local equality, greater than, and less than signals. These outputs are then combined in a hierarchical manner to deduce the overall relationship between the 16-bit inputs A and B.\nGive me the complete code.\nmodule comparator_16bit(a, b, eq, gt, lt);"}
{"task_id": "adder_32bit_v_54", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Bin', 'type': 'input port'}, {'id': 3, 'content': 'D', 'type': 'output port'}, {'id': 4, 'content': 'Bout', 'type': 'output port'}, {'id': 5, 'content': 'SUB1', 'type': 'submodule'}, {'id': 6, 'content': 'SUB2', 'type': 'submodule'}, {'id': 7, 'content': 'SUB3', 'type': 'submodule'}, {'id': 8, 'content': 'SUB4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 1, 5, 0, 1, 6, 0, 7, 1, 0, 7, 6, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 32-bit binary subtractor that employs a series of 8-bit subtractor blocks to perform the operation, and handles borrow-in and borrow-out.\n\nModule name:  \n    subtractor_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\n    Bin: Borrow-in input.\nOutput ports:\n    D[32:1]: 32-bit output representing the difference of A minus B.\n    Bout: Borrow-out output.\n\nImplementation:\nThe top module subtractor_32bit consists of several instances of the 8-bit subtractor block you design.\nGive me the complete code.\nmodule subtractor_32bit(A, B, Bin, D, Bout);"}
{"task_id": "shift_reg_v_55", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'count', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 4, 0, 3, 1, 4, 3, 5], [3, 3, 4, 4, 4, 5, 5, 5, 5, 2, 2, 2]]\n, Design a binary counter module that increments the count by one on every rising edge of the clock, using three T flip-flops configured to toggle their state. The counter should reset to zero when the reset input is high.\n\nModule name:\n    binary_counter\n\nInput ports:\n    clk: Clock signal for synchronization.\n    reset: Reset signal to reset the counter to zero.\n\nOutput ports:\n    count: 3-bit output reflecting the current count value.\n\nImplementation:\nThe binary counter consists of three instances of the provided T flip-flop module (my_tff). Each flip-flop's output represents a bit of the binary count. The first T flip-flop toggles on every clock cycle. Each subsequent T flip-flop toggles when all lower-order bits are high. A synchronous reset is applied to each flip-flop.\nGive me the complete code.\nmodule binary_counter (\n    input clk,\n    input reset,\n    output [2:0] count\n);"}
{"task_id": "ring_counter_v_56", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'increment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 3, 1, 4], [3, 4, 4, 4, 2]]\n, Implement a modular 4-bit binary up counter with synchronous reset functionality.\n\nModule name:\n    binary_up_counter\n\nInput ports:\n    clk: Clock signal that drives the counting.\n    reset: Synchronous reset signal to set the counter to zero.\n\nOutput ports:\n    out [3:0]: 4-bit output representing the current count value.\n\nInternal logic:\nCount Initialization: A submodule initializes the counter to zero when the reset signal is asserted.\nCount Increment: Another submodule handles the increment operation of the counter, increasing the count by one on each rising edge of the clock signal, unless the reset is asserted.\n\nModularity: The design consists of separate submodules for initialization and counting, promoting better organization and code reusability.\nReset Behavior: When reset is high, the counter is set to zero (out = 4'b0000).\nGive me the complete code.\nmodule binary_up_counter (\n    input wire clk,\n    input wire reset,\n    output wire [3:0] out\n);"}
{"task_id": "up_down_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'up_down', 'type': 'input port'}, {'id': 3, 'content': 'count', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_counter_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 2, 0, 5, 1, 0, 4, 5], [4, 4, 4, 4, 5, 5, 5, 3]]\n, Module name:\n    up_down_counter\n\nFunction:\nA 16-bit counter that can increment or decrement based on control signals, implemented in a modular fashion.\n\nInput ports:\n    - clk: Clock signal (1-bit), used to synchronize the counting process.\n    - reset: Reset signal (1-bit), used to reset the counter to zero.\n    - up_down: Control signal (1-bit), determines the counting direction.\n    If up_down = 1, the counter increments; if up_down = 0, it decrements.\n\nOutput ports:\n    - count [15:0]: 16-bit output representing the current counter value.\n\nImplementation:\nThe module consists of two submodules: counter_logic and counter_register.\n- The counter_logic module calculates the next count value based on the current count and control signals.\n- The counter_register module updates the current count value on the rising edge of the clock signal or resets it based on the reset condition.\nThe count output reflects the current value of the counter, which can range from 0 to 65535.\n\nGive me the complete code.\nmodule up_down_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [15:0] count\n);"}
{"task_id": "ring_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'reset', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'init', 'type': 'submodule'}, {'id': 4, 'content': 'transition', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular version of an 8-bit ring counter for cyclic state sequences.\n\nModule name:\n    ring_counter\n\nInput ports:\n    clk: Clock signal that drives the state transitions of the ring counter.\n    reset: Reset signal to initialize the counter to its starting state.\nOutput ports:\n    out [7:0]: 8-bit output representing the current state of the ring counter. Only one bit is set high at any time, and the set bit cycles through the 8-bit output.\n\nInternal logic:\nState Initialization: A submodule initializes the counter to its starting state when the reset signal is high, typically with the least significant bit (LSB) of out set to 1 (i.e., out = 8'b0000_0001).\nState Transition: Another submodule handles the cyclic behavior of the ring counter, where the 1 shifts to the next bit in the sequence on each rising edge of the clock signal. After reaching the most significant bit (MSB), it wraps around to the LSB.\nModularity: The design consists of separate submodules for initialization and state transition, promoting better organization and reusability of the code.\nReset Behavior: When reset is high, the ring counter is reset to its initial state (out = 8'b0000_0001).\n\nGive me the complete code.\nmodule ring_counter (\n    input wire clk,\n    input wire reset,\n    output wire [7:0] out\n);"}
{"task_id": "counter_12", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'rst_n', 'type': 'input port'}, {'id': 1, 'content': 'clk', 'type': 'input port'}, {'id': 2, 'content': 'valid_count', 'type': 'input port'}, {'id': 3, 'content': 'out', 'type': 'output port'}, {'id': 4, 'content': 'u_counter_logic', 'type': 'submodule'}, {'id': 5, 'content': 'u_output_register', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 2, 1, 0, 4, 2, 5], [4, 4, 4, 5, 5, 5, 5, 3]]\n, Implement a module of a counter design that counts from 4'b0000 to 4'd11, with the counting controlled by an input signal valid_count. The counter should pause when valid_count is 0. It should increment on each clock cycle when valid_count is active and reset to 0 when the reset signal (rst_n) is active.\n\nModule Name:\n    counter_12\n\nInput Ports:\n    rst_n: Reset signal (active low)\n    clk: Clock signal\n    valid_count: Signal to enable counting\n\nOutput Ports:\n    out: 4-bit output representing the current count value\n\nImplementation:\nThe main module (counter_12) integrates two submodules: counter_logic and output_register.\ncounter_logic:\nIf the reset signal is active (!rst_n), the counter resets to 0 (4'b0000).\nWhen valid_count is 1, the counter increments. If the count value equals 4'd11, it wraps around and resets to 0.\noutput_register:\nIf the reset signal is active, the output is set to 0.\nWhen valid_count is active, it updates the output with the current count value from counter_logic. If valid_count is 0, it retains the current output.\n\nGive me the complete code.\nmodule\nmodule counter_12 (\n    input rst_n,\n    input clk,\n    input valid_count,\n    output [3:0] out\n);"}
{"task_id": "JC_counter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'Q', 'type': 'output port'}, {'id': 3, 'content': 'reg_inst', 'type': 'submodule'}, {'id': 4, 'content': 'logic_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Implement a modular 64-bit Johnson counter (torsional ring counter) with the following specifications:\n\nModule name:\n    JC_counter\n\nInput ports:\n    - clk: Clock signal used for synchronous operation.\n    - rst_n: Active-low reset signal to initialize the counter.\n\nOutput port:\n    - Q: 64-bit register representing the current count value.\n\nImplementation:\nThe design should consist of submodules for better organization and separation of functionality.\nJC_counter: The main module that integrates the submodules.\nJC_register: A submodule responsible for storing the current state of the counter. It should reset to zero when the reset signal (rst_n) is low.\nJC_logic: A submodule that calculates the next state of the counter based on the current state. It should update the output Q based on the least significant bit (LSB) of the current state.\n\nGive me the complete code.\nmodule for the Johnson Counter\nmodule JC_counter(\n    input                clk,\n    input                rst_n,\n    output [63:0]       Q\n);"}
{"task_id": "freq_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'CLK_in', 'type': 'input port'}, {'id': 1, 'content': 'RST', 'type': 'input port'}, {'id': 2, 'content': 'CLK_50', 'type': 'output port'}, {'id': 3, 'content': 'CLK_10', 'type': 'output port'}, {'id': 4, 'content': 'CLK_1', 'type': 'output port'}, {'id': 5, 'content': 'clk_div_50', 'type': 'submodule'}, {'id': 6, 'content': 'clk_div_10', 'type': 'submodule'}, {'id': 7, 'content': 'clk_div_1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 5, 6, 7], [5, 5, 6, 6, 7, 7, 2, 3, 4]]\n, Implement a modular frequency divider that takes an input clock frequency of 100MHz and generates three output clock frequencies: 50MHz, 10MHz, and 1MHz.\n\nModule name:\n    freq_div\n\nInput ports:\n    CLK_in: Input clock signal\n    RST: Reset signal\n\nOutput ports:\n    CLK_50: Output clock signal with a frequency of CLK_in divided by 2.\n    CLK_10: Output clock signal with a frequency of CLK_in divided by 10.\n    CLK_1: Output clock signal with a frequency of CLK_in divided by 100.\n\nImplementation:\nThe module uses three submodules to generate the required clock frequencies:\nclk_div_2 generates the 50MHz clock by toggling the output on every positive edge of CLK_in.\nclk_div_10 generates the 10MHz clock by counting to 4 and toggling the output.\nclk_div_100 generates the 1MHz clock by counting to 49 and toggling the output.\nOn every positive edge of CLK_in or when RST is active, if RST is asserted, all output clocks are reset to 0. Otherwise, the counters increment accordingly to generate the desired frequencies.\n\nGive me the complete code.\nmodule freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_50,\n    output CLK_10,\n    output CLK_1\n);"}
{"task_id": "freq_divbyfrac", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_average', 'type': 'submodule'}, {'id': 5, 'content': 'u_clk_adjustment', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 1, 0, 3, 1, 5, 4], [3, 3, 4, 4, 4, 5, 5, 5, 2, 2]]\n, Create a modular frequency divider that divides the input clock frequency by fractional values. This module generates a clock signal with a fractional frequency division (3.5x) using a double-edge clocking technique to achieve half-integer division while adjusting for duty cycle imbalance.\n\nModule name:\n    freq_divbyfrac\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Fractionally divided clock output.\n    \nImplementation:\nThe module performs fractional frequency division by counting clock cycles and generating two intermediate clock signals: one with 4 source clock cycles and another with 3 source clock cycles, based on the division factor defined by the MUL2_DIV_CLK parameter (set to 7 for 3.5x division).\nThe counter submodule (counter) keeps track of clock cycles and resets after reaching the specified limit.\nThe average clock generator submodule (clk_average) generates an averaged clock signal based on the counter value, producing high signals at defined intervals for the first and second cycles.\nThe clock adjustment submodule (clk_adjustment) creates phase-shifted versions of the divided clock on the negative edge of the input clock.\nFinally, the two intermediate clock signals are logically OR-ed to produce the final fractional clock output (clk_div), ensuring a uniform period.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Average Generator Submodule: Responsible for generating the averaged clock signal.\nClock Adjustment Submodule: Responsible for generating the adjusted clock signal.\n\nGive me the complete code.\nmodule freq_divbyfrac(\n    input               clk,\n    input               rst_n,\n    output              clk_div\n);"}
{"task_id": "freq_divbyodd", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_pos_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_neg_counter', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 4, 3], [3, 3, 4, 4, 2, 2]]\n, A frequency divider that divides the input clock frequency by odd numbers. The module generates a divided clock output by an odd divisor value provided as a parameter.\n\nModule name:\n    freq_divbyodd\n\nInput ports:\n    clk: Input clock signal.\n    rst_n: Active low reset signal that initializes the divider.\n\nOutput ports:\n    clk_div: Divided clock output.\n\nImplementation:\n\nThe module divides the input clock frequency by an odd number defined by the parameter NUM_DIV, which defaults to 5. \nIt consists of two submodules: `pos_edge_counter` and `neg_edge_counter`, which count the rising and falling edges of the clock, respectively. \nEach counter counts up to NUM_DIV - 1. \nThe `pos_edge_counter` generates a clock output for the positive edge, while the `neg_edge_counter` generates a clock output for the negative edge. \nThe final divided clock output, clk_div, is derived by logically OR-ing clk_div1 and clk_div2 to account for both clock edges. \nThe active low reset signal rst_n initializes the counters and the clock divider outputs.\n\nGive me the complete code.\nmodule freq_divbyodd(\n    input clk,\n    input rst_n,\n    output clk_div\n);"}
{"task_id": "freq_divbyeven", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'clk_div', 'type': 'output port'}, {'id': 3, 'content': 'u_counter', 'type': 'submodule'}, {'id': 4, 'content': 'u_clk_divider', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 3, 4], [3, 3, 4, 4, 4, 2]]\n, Create a modular frequency divider that divides the input clock frequency by even numbers. This module generates a divided clock signal by toggling its output every specified number of input clock cycles.\n\nModule name:\n    freq_divbyeven\n\nInput ports:\n    clk: Input clock signal that will be divided.\n    rst_n: Active-low reset signal to initialize the module.\n\nOutput ports:\n    clk_div: Divided clock output signal.\n\nImplementation:\nThe frequency divider consists of two submodules: a counter and a clock divider. The NUM_DIV parameter specifies the division factor, which must be an even number.\nThe counter submodule counts the number of clock cycles. When the reset signal (rst_n) is low, the counter initializes to zero.\nThe counter increments until it reaches half of NUM_DIV - 1.\nWhen the counter reaches this limit, it resets to zero.\nThe clock divider submodule toggles the clk_div output signal whenever the counter resets, effectively dividing the frequency of the input clock by the even number specified by NUM_DIV.\nCounter:\nThe counter is a 4-bit register that tracks the number of clock cycles.\nSubmodules:\nCounter Submodule: Responsible for counting clock cycles.\nClock Divider Submodule: Responsible for toggling the divided clock output.\n\nGive me the complete code.\nmodule freq_divbyeven(\n    input clk,\n    input rst_n,\n    output clk_div\n);"}
{"task_id": "alu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'aluc', 'type': 'input port'}, {'id': 3, 'content': 'r', 'type': 'output port'}, {'id': 4, 'content': 'zero', 'type': 'output port'}, {'id': 5, 'content': 'carry', 'type': 'output port'}, {'id': 6, 'content': 'negative', 'type': 'output port'}, {'id': 7, 'content': 'overflow', 'type': 'output port'}, {'id': 8, 'content': 'flag', 'type': 'output port'}, {'id': 9, 'content': 'add', 'type': 'submodule'}, {'id': 10, 'content': 'addu', 'type': 'submodule'}, {'id': 11, 'content': 'sub', 'type': 'submodule'}, {'id': 12, 'content': 'and1', 'type': 'submodule'}, {'id': 13, 'content': 'or1', 'type': 'submodule'}, {'id': 14, 'content': 'xor1', 'type': 'submodule'}, {'id': 15, 'content': 'nor1', 'type': 'submodule'}, {'id': 16, 'content': 'slt_inst', 'type': 'submodule'}, {'id': 17, 'content': 'sltu_inst', 'type': 'submodule'}, {'id': 18, 'content': 'sll', 'type': 'submodule'}, {'id': 19, 'content': 'srl', 'type': 'submodule'}, {'id': 20, 'content': 'sra', 'type': 'submodule'}, {'id': 21, 'content': 'lui_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 14, 21, 18, 17, 11, 13, 20, 19, 10, 9, 12, 16, 15, 9, 10, 0, 1, 2], [9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 14, 14, 15, 15, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 8, 8, 8]]\n, Implement a modular ALU for a 32-bit MIPS-ISA CPU. The inputs are the two operands a and b, and the control signal aluc selects the operation to be performed. The output r gives the result, while zero indicates if the result is zero, carry indicates if a carry occurred, negative indicates if the result is negative, overflow indicates if overflow occurred, and flag is a general flag set based on specific operations (SLT and SLTU).\n\nThe supported operations and corresponding opcodes are as follows:\n\n    ADD: 6'b100000\n    ADDU: 6'b100001\n    SUB: 6'b100010\n    SUBU: 6'b100011\n    AND: 6'b100100\n    OR: 6'b100101\n    XOR: 6'b100110\n    NOR: 6'b100111\n    SLT: 6'b101010\n    SLTU: 6'b101011\n    SLL: 6'b000000\n    SRL: 6'b000010\n    SRA: 6'b000011\n    SLLV: 6'b000100\n    SRLV: 6'b000110\n    SRAV: 6'b000111\n    LUI: 6'b001111\n\nModule name:\n    alu\nInput ports:\n    a: a 32-bit input operand\n    b: a 32-bit input operand\n    aluc: a 6-bit control signal for selecting the operation to be performed\nOutput ports:\n    r: a 32-bit output representing the result of the operation\n    zero: a 1-bit output indicating whether the result is zero\n    carry: a 1-bit output indicating whether a carry occurred during the operation\n    negative: a 1-bit output indicating whether the result is negative\n    overflow: a 1-bit output indicating whether an overflow occurred during the operation\n    flag: a 1-bit output representing a general flag, which is set based on specific operations (SLT and SLTU)\n    \nImplementation:\nThe module is structured into submodules for different operations, such as addition, subtraction, and logical operations. Each operation is encapsulated within its module, allowing for better organization and reusability. The result is selected based on the aluc control signal using a case statement. Flags are computed similarly to the previous implementation, ensuring functionality remains consistent.\n\nProvide the complete Verilog code for this modular ALU implementation.\nmodule alu(\n    input [31:0] a,\n    input [31:0] b,\n    input [5:0] aluc,\n    output [31:0] r,\n    output zero,\n    output carry,\n    output negative,\n    output overflow,\n    output flag\n);"}
{"task_id": "pe", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a', 'type': 'input port'}, {'id': 3, 'content': 'b', 'type': 'input port'}, {'id': 4, 'content': 'c', 'type': 'output port'}, {'id': 5, 'content': 'u_multiplier', 'type': 'submodule'}, {'id': 6, 'content': 'u_accumulator', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 3, 5, 0, 1, 6], [5, 5, 6, 6, 6, 4]]\n, Implement a modular Multiplying Accumulator for 32-bit integers. In the pe module, there are submodules for multiplication and accumulation. The pe module connects these submodules to perform the operations.\n\nModule name:\n    pe\n\nInput ports:\n    clk: Clock signal used for synchronous operations.\n    rst: Reset signal. Defined as 1 for reset and 0 for reset signal inactive.\n    a: 32-bit input operand A.\n    b: 32-bit input operand B.\n\nOutput ports:\n    c: 32-bit output representing the accumulated result.\n\nImplementation:\nThe module includes:\nMultiplier Submodule:\nThis submodule takes two 32-bit inputs (a and b) and produces a 64-bit result of their multiplication.\nAccumulator Submodule:\nThis submodule accumulates the lower 32 bits of the multiplication result into a register, current_value. It resets the value to 0 when rst is high and adds the new multiplication result during each clock cycle when rst is low.\nThe main pe module connects these submodules and drives the output c with the accumulated result.\n\nGive me the complete code.\nmodule pe(\n    input clk,\n    input rst,\n    input [31:0] a,\n    input [31:0] b,\n    output [31:0] c\n);"}
{"task_id": "instr_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'fetch', 'type': 'input port'}, {'id': 3, 'content': 'data', 'type': 'input port'}, {'id': 4, 'content': 'ins', 'type': 'output port'}, {'id': 5, 'content': 'ad1', 'type': 'output port'}, {'id': 6, 'content': 'ad2', 'type': 'output port'}, {'id': 7, 'content': 'ins1', 'type': 'submodule'}, {'id': 8, 'content': 'ins2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 3, 2, 1, 0, 3, 2, 1, 7, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 4, 5, 6]]\n, An instruction register module designed to hold and process CPU instructions in a modular way. It captures incoming instructions from various sources and separates them into distinct fields for further processing using submodules.\n\nModule name:\n    instr_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    rst: Active low reset signal to initialize the register.\n    fetch [1:0]: Control signal indicating the source of the instruction (1 for register, 2 for RAM/ROM).\n    data [7:0]: 8-bit data input representing the instruction to be fetched.\n\nOutput ports:\n    ins [2:0]: High 3 bits of the instruction, indicating the opcode or operation.\n    ad1 [4:0]: Low 5 bits of the instruction, representing the register address.\n    ad2 [7:0]: The full 8-bit data from the second source.\n\nImplementation:\n    The instruction register is implemented using two submodules, each responsible for storing instructions from different sources.\n    On the rising edge of the clock (clk), if the reset (rst) signal is low, both instruction outputs are initialized to zero.\n    Based on the fetch signal:\n    If fetch is 2'b01, the instruction is fetched from the data input into the first submodule (ins_p1).\n    If fetch is 2'b10, the instruction is fetched from the data input into the second submodule (ins_p2).\n    If neither condition is met, the previous values in both submodules are retained.\n    The outputs ins, ad1, and ad2 are derived from the stored instructions in the respective submodules.\n\nGive me the complete code.\nmodule instr_reg (\n    input clk,\n    input rst,\n    input [1:0] fetch,\n    input [7:0] data,\n    output [2:0] ins,\n    output [4:0] ad1,\n    output [7:0] ad2\n);"}
{"task_id": "square_wave", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'freq', 'type': 'input port'}, {'id': 2, 'content': 'wave_out', 'type': 'output port'}, {'id': 3, 'content': 'cnt', 'type': 'submodule'}, {'id': 4, 'content': 'wg', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 0, 1, 4], [3, 3, 4, 4, 4, 2]]\n, The module is a modular square wave generator designed to produce square wave signals with variable frequency. It consists of submodules for counting clock cycles and generating the square wave output.\n\nModule Name:\n    square_wave\n\nInput Ports:\n    clk: Clock signal that drives the module.\n    [7:0] freq: Frequency control, specifying how often the square wave toggles.\n\nOutput Ports:\n    wave_out: Square wave output signal.\n\nInternal Modules:\n    Counter Module (counter)\n    Functionality: Counts clock cycles and resets based on the frequency value.\n    Input Ports:\n    clk: Clock signal.\n    enable: Control signal to enable counting.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    [7:0] count: Current count value.\n    Wave Generator Module (wave_generator)\n    Functionality: Generates the square wave by toggling the output signal.\n    Input Ports:\n    clk: Clock signal.\n    [7:0] count: Current count value from the counter.\n    [7:0] freq: Frequency value for toggling.\n    Output Ports:\n    wave_out: Square wave output signal.\n\nImplementation:\nCounter Operation: The counter module increments on each rising edge of clk. When the count reaches (freq - 1), it resets to 0. The count is enabled based on the frequency value.\nSquare Wave Generation: The wave_generator module toggles the wave_out signal at the rate determined by freq. The output frequency is inversely proportional to the input frequency value.\n    \nGive me the complete code.\nmodule square_wave(\n    input clk,\n    input [7:0] freq,\n    output wave_out\n);"}
{"task_id": "signal_generator", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'wave', 'type': 'output port'}, {'id': 3, 'content': 'state_inst', 'type': 'submodule'}, {'id': 4, 'content': 'wave_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 0, 1, 0, 1, 3, 4], [3, 3, 3, 4, 4, 4, 2]]\n, Implement a Triangle Wave signal generator module that generates a waveform by incrementing and decrementing a 5-bit signal named wave. The waveform cycles between 0 and 31, which is incremented or decremented by 1.\n\nModule name:\n    signal_generator\n\nInput ports:\n    clk: Clock signal used for synchronous operation.\n    rst_n: Active-low reset signal. Defined as 0 for reset and 1 for reset signal inactive.\n\nOutput ports:\n    wave: 5-bit output waveform signal representing the generated waveform.\n    \nImplementation:\nThe module is divided into two submodules: a state control module and a waveform generation module.\n\nState Control Module:\nThis module manages the state transitions used to control the waveform generation.\nIt contains a 2-bit register state that determines whether the waveform is in the incrementing or decrementing phase.\nOn reset (~rst_n), the state is set to 00.\nWaveform Generation Module:\nThis module generates the waveform by maintaining a 5-bit register wave.\nThe waveform is incremented when the state is 00 and decremented when the state is 01.\nIt resets the wave to 0 on reset.\nThe waveform generation continues to cycle between 0 and 31 based on the state transitions, controlled by the clk signal.\n\nGive me the complete code.\nmodule signal_generator (\n    input clk,\n    input rst_n,\n    output [4:0] wave\n);"}
{"task_id": "shift8", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'sel', 'type': 'input port'}, {'id': 3, 'content': 'q', 'type': 'output port'}, {'id': 4, 'content': 'u0', 'type': 'submodule'}, {'id': 5, 'content': 'u1', 'type': 'submodule'}, {'id': 6, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 4, 0, 0, 5, 4, 6, 5, 1], [4, 4, 5, 5, 6, 6, 3, 3, 3, 3]]\n, A top-level module designed to instantiate three 8-bit D flip-flops (my_dff8) and connect them to create an 8-bit wide shift register of length 3. Additionally, implement a 4-to-1 multiplexer that selects the output based on a 2-bit select signal (sel), which determines the delay of the input signal (d) through the shift register.\n\nModule name:\n    shift8\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d [7:0]: 8-bit data input to be shifted through the register.\n    sel [1:0]: Control signal that selects which output to present (0-3 cycles of delay).\n\nOutput ports:\n    q [7:0]: The output data after the selected number of clock cycles.\n\nImplementation:\nThe top_module consists of three instances of my_dff8, each representing a D flip-flop. The output of each flip-flop is connected to the next one, creating a chain that allows the input data to be shifted through the register.\nThe output q is determined by the sel input, which selects the output of the appropriate flip-flop or the original input d based on the number of cycles to delay\n\nGive me the complete code.\nmodule shift8 (\n    input clk,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] q\n);"}
{"task_id": "shift_reg", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'd', 'type': 'input port'}, {'id': 2, 'content': 'q', 'type': 'output port'}, {'id': 3, 'content': 'u0', 'type': 'submodule'}, {'id': 4, 'content': 'u1', 'type': 'submodule'}, {'id': 5, 'content': 'u2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 3, 0, 4, 5], [3, 3, 4, 4, 5, 5, 2]]\n, You are to design a shift register module that utilizes three instances of a D flip-flop. The shift register should shift the input data through each flip-flop on the rising edge of the clock.\n\nModule name:\n    shift_reg\n\nInput ports:\n    clk: Clock signal for synchronization.\n    d: Data input to be shifted through the register.\n\nOutput ports:\n    q: The output from the last flip-flop in the chain.\n\nImplementation:\nThe shift register consists of three instances of the provided D flip-flop module (my_dff).\nEach flip-flop's output is connected to the next flip-flop's data input, creating a chain effect.\nThe clock signal is connected to all instances to ensure synchronized operation.\n\nGive me the complete code.\nmodule shift_reg (\n    input clk,\n    input d,\n    output q\n);"}
{"task_id": "barrel_shifter", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'in', 'type': 'input port'}, {'id': 1, 'content': 'ctrl', 'type': 'input port'}, {'id': 2, 'content': 'out', 'type': 'output port'}, {'id': 3, 'content': 'ins_17', 'type': 'submodule'}, {'id': 4, 'content': 'ins_16', 'type': 'submodule'}, {'id': 5, 'content': 'ins_15', 'type': 'submodule'}, {'id': 6, 'content': 'ins_14', 'type': 'submodule'}, {'id': 7, 'content': 'ins_13', 'type': 'submodule'}, {'id': 8, 'content': 'ins_12', 'type': 'submodule'}, {'id': 9, 'content': 'ins_11', 'type': 'submodule'}, {'id': 10, 'content': 'ins_10', 'type': 'submodule'}, {'id': 11, 'content': 'ins_27', 'type': 'submodule'}, {'id': 12, 'content': 'ins_26', 'type': 'submodule'}, {'id': 13, 'content': 'ins_25', 'type': 'submodule'}, {'id': 14, 'content': 'ins_24', 'type': 'submodule'}, {'id': 15, 'content': 'ins_23', 'type': 'submodule'}, {'id': 16, 'content': 'ins_22', 'type': 'submodule'}, {'id': 17, 'content': 'ins_21', 'type': 'submodule'}, {'id': 18, 'content': 'ins_20', 'type': 'submodule'}, {'id': 19, 'content': 'ins_07', 'type': 'submodule'}, {'id': 20, 'content': 'ins_06', 'type': 'submodule'}, {'id': 21, 'content': 'ins_05', 'type': 'submodule'}, {'id': 22, 'content': 'ins_04', 'type': 'submodule'}, {'id': 23, 'content': 'ins_03', 'type': 'submodule'}, {'id': 24, 'content': 'ins_02', 'type': 'submodule'}, {'id': 25, 'content': 'ins_01', 'type': 'submodule'}, {'id': 26, 'content': 'ins_00', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 3, 1, 4, 1, 5, 3, 1, 4, 6, 1, 5, 7, 1, 8, 6, 1, 7, 9, 1, 10, 8, 1, 11, 1, 12, 11, 1, 12, 13, 1, 14, 13, 1, 15, 14, 1, 15, 16, 1, 17, 16, 1, 18, 17, 1, 22, 23, 19, 25, 24, 26, 20, 21], [3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 17, 18, 18, 18, 19, 19, 20, 20, 20, 21, 21, 21, 22, 22, 22, 23, 23, 23, 24, 24, 24, 25, 25, 25, 26, 26, 26, 2, 2, 2, 2, 2, 2, 2, 2]]\n, Module name: \n    barrel_shifter\n\nFunction:\n    A barrel shifter for rotating bits efficiently. This 8-bit barrel shifter takes an 8-bit input and shifts or rotates the bits based on a 3-bit control signal.\n\nInput ports:\n    in [7:0]: 8-bit input to be shifted.\n    ctrl [2:0]: 3-bit control signal that determines how many positions to shift. The control signal specifies the amount of shift, where each bit indicates a shift by 1, 2, or 4 positions.\n\nOutput ports:\n    out [7:0]: 8-bit shifted output.\n\nImplementation:\n    The barrel shifter shifts the input `in` based on the value of the `ctrl` signal. The shifting happens in stages, where each stage shifts by 4, 2, or 1 position, as controlled by `ctrl[2]`, `ctrl[1]`, and `ctrl[0]`, respectively.\n    The shifts are achieved using a series of 2-to-1 multiplexers (`mux2X1`) that select between the shifted input and the original input. Each stage of multiplexers performs the shift, and the result is passed to the next stage for further shifting if required.\n    - When `ctrl[2]` is high, the input is shifted by 4 positions.\n    - When `ctrl[1]` is high, the intermediate result is shifted by 2 positions.\n    - When `ctrl[0]` is high, the intermediate result is shifted by 1 position.\n    \n    The `mux2X1` submodule is used to select between two input values based on the `sel` signal, determining which bit is used in the shifted output at each stage.\n\nGive me the complete code.\nmodule barrel_shifter (in, ctrl, out);"}
{"task_id": "systolic1x2", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'b0', 'type': 'input port'}, {'id': 5, 'content': 'c0', 'type': 'output port'}, {'id': 6, 'content': 'c1', 'type': 'output port'}, {'id': 7, 'content': 'pe0', 'type': 'submodule'}, {'id': 8, 'content': 'pe1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 4, 1, 4, 0, 3, 1, 7, 8], [7, 7, 7, 7, 8, 8, 8, 8, 5, 6]]\n, Implement a module of a systolic array with 1x2 configuration in sequential logic.\n\nModule name:  \n    systolic1x2               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n\nImplementation:\nIn the systolic1x2 module, two Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The second PE (pe1) takes input a1 and a delayed version of b0, named b1, which is updated with the value of b0 every clock cycle unless reset is active. This systolic passing of data (b0 to b1) among the PEs is crucial for pipelining in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x2 (\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1\n);"}
{"task_id": "stagepipe5", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'res_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'decode', 'type': 'submodule'}, {'id': 7, 'content': 'execute', 'type': 'submodule'}, {'id': 8, 'content': 'memory', 'type': 'submodule'}, {'id': 9, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 5, 0, 0, 6, 3, 0, 7, 0, 8, 9], [5, 5, 5, 6, 6, 7, 7, 7, 8, 8, 9, 9, 4]]\n, Implement a pipeline processor with 5 stages: Fetch, Decode, Execute, Memory, and Writeback.\n\nModule name:\n    stagepipe5\nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[31:0][0:31]: 32-element instruction memory with 32-bit instructions.\n    reg_file[31:0][0:31]: 32-element register file with 32-bit registers.\nOutput ports:\n    res_reg_file[31:0][0:31]: 32-element result register file with 32-bit registers.\n\nImplementation:\nIn the stagepipe5 module, five pipeline stages are instantiated: fetch_stage, decode_stage, execute_stage, memory_stage, and writeback_stage. The fetch_stage module fetches the next instruction from the instruction memory based on the program counter (pc). The decode_stage module decodes the instruction to identify the source registers (rs1, rs2), destination register (rd), and the operation (op). The execute_stage module performs the operation (addition or subtraction) on the values read from the register file and produces the result. The memory_stage module passes the ALU result to the next stage. Finally, the writeback_stage module writes the result back to the register file. The pc is updated in the fetch_stage to fetch the next instruction in the following cycle. The pipeline ensures continuous instruction processing by passing intermediate data between stages through pipeline registers.\n\nGive me the complete code.\nmodule stagepipe5(\n  input clk,\n  input rst,\n  input [31:0] instr_mem [0:31],\n  input [31:0] reg_file [0:31],\n  output [31:0] res_reg_file [0:31]\n);"}
{"task_id": "systolic1x4", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'a0', 'type': 'input port'}, {'id': 3, 'content': 'a1', 'type': 'input port'}, {'id': 4, 'content': 'a2', 'type': 'input port'}, {'id': 5, 'content': 'a3', 'type': 'input port'}, {'id': 6, 'content': 'b0', 'type': 'input port'}, {'id': 7, 'content': 'c0', 'type': 'output port'}, {'id': 8, 'content': 'c1', 'type': 'output port'}, {'id': 9, 'content': 'c2', 'type': 'output port'}, {'id': 10, 'content': 'c3', 'type': 'output port'}, {'id': 11, 'content': 'pe0', 'type': 'submodule'}, {'id': 12, 'content': 'pe1', 'type': 'submodule'}, {'id': 13, 'content': 'pe2', 'type': 'submodule'}, {'id': 14, 'content': 'pe3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 0, 6, 1, 6, 0, 3, 1, 4, 6, 0, 1, 6, 0, 1, 5, 11, 12, 13, 14], [11, 11, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 7, 8, 9, 10]]\n, Implement a module of a systolic array with 1x4 configuration in sequential logic.\n\nModule name:  \n    systolic1x4               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    a0[15:0]: 16-bit input operand A0.\n    a1[15:0]: 16-bit input operand A1.\n    a2[15:0]: 16-bit input operand A2.\n    a3[15:0]: 16-bit input operand A3.\n    b0[15:0]: 16-bit input operand B0.\nOutput ports:\n    c0[31:0]: 32-bit output representing the accumulated product of A0 and B0.\n    c1[31:0]: 32-bit output representing the accumulated product of A1 and the forwarded value of B0 (now B1).\n    c2[31:0]: 32-bit output representing the accumulated product of A2 and the forwarded value of B1 (now B2).\n    c3[31:0]: 32-bit output representing the accumulated product of A3 and the forwarded value of B2 (now B3).\n\nImplementation:\nIn the systolic1x4 module, four Processing Elements (PEs) are instantiated. Each PE performs multiplication and accumulation of its inputs. The first PE (pe0) takes inputs a0 and b0 directly. The subsequent PEs take input a1, a2, and a3 respectively, each receiving a progressively delayed version of b0. Specifically, PE1 (pe1) receives b1 which is a delayed version of b0, PE2 (pe2) receives b2 which is a delayed version of b1, and PE3 (pe3) receives b3 which is a delayed version of b2. These delays are managed through registers that update with the value of the previous register each clock cycle, unless reset is active. This systolic passing of data among the PEs facilitates pipelining, crucial for maintaining throughput in larger systolic array configurations.\n\nGive me the complete code.\nmodule systolic1x4(\n  input clk,\n  input rst,\n  input [15:0] a0,\n  input [15:0] a1,\n  input [15:0] a2,\n  input [15:0] a3,\n  input [15:0] b0,\n  output [31:0] c0,\n  output [31:0] c1,\n  output [31:0] c2,\n  output [31:0] c3 \n);"}
{"task_id": "stagepipe3", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'instr_mem', 'type': 'input port'}, {'id': 3, 'content': 'reg_file', 'type': 'input port'}, {'id': 4, 'content': 'out_reg_file', 'type': 'output port'}, {'id': 5, 'content': 'fetch', 'type': 'submodule'}, {'id': 6, 'content': 'execute', 'type': 'submodule'}, {'id': 7, 'content': 'writeback', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 2, 1, 0, 5, 3, 0, 6, 7], [5, 5, 5, 6, 6, 6, 7, 7, 4]]\n, Implement a module of a 3-stage pipeline processor.\n\nModule name:  \n    stagepipe3               \nInput ports:\n    clk: Clock signal.\n    rst: Reset signal, active high.\n    instr_mem[0:31]: 32x32-bit memory array representing the instruction memory.\n    reg_file[0:31]: 32x32-bit array representing the register file.\nOutput ports:\n    out_reg_file[31:0]: 32-bit output representing the updated value in the register file.\n\nImplementation:\nIn the stagepipe3 module, three stages of a pipeline (fetch, execute, writeback) are instantiated and connected sequentially. The fetch_stage module is responsible for fetching instructions from instruction memory using a program counter (pc). It outputs the fetched instruction to the execute_stage. The execute_stage module decodes the fetched instruction and performs the necessary arithmetic operations on operands fetched from the register file. Depending on the instruction type, it performs either addition or subtraction. The result of this computation is then passed to the writeback_stage, which writes the computed value back into a specific register in the register file, completing the cycle\u3002\n\nGive me the complete code.\nmodule stagepipe3(\n    input clk,\n    input rst,\n    input [31:0] instr_mem [0:31],\n    input [31:0] reg_file [0:31],\n    output [31:0] out_reg_file  \n);"}
{"task_id": "accu", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'data_in', 'type': 'input port'}, {'id': 3, 'content': 'valid_in', 'type': 'input port'}, {'id': 4, 'content': 'valid_out', 'type': 'output port'}, {'id': 5, 'content': 'data_out', 'type': 'output port'}, {'id': 6, 'content': 'u_counter', 'type': 'submodule'}, {'id': 7, 'content': 'u_data_accumulator', 'type': 'submodule'}, {'id': 8, 'content': 'u_valid_output', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 3, 6, 0, 1, 3, 2, 6, 0, 1, 3, 6, 8, 7], [6, 6, 6, 6, 7, 7, 7, 7, 7, 8, 8, 8, 8, 4, 5]]\n, Implement a modular design for a serial input data accumulator. The system should receive 8-bit data inputs and accumulate the values. The valid_in signal will indicate when new data is ready for accumulation. After receiving four valid input data, the module should output the accumulated result and set valid_out to 1 for one cycle.\n\nModule name:\n    accu\nInput ports:\n    clk: Clock input for synchronization.\n    rst_n: Active-low reset signal.\n    data_in[7:0]: 8-bit input data for addition.\n    valid_in: Input signal indicating readiness for new data.\nOutput ports:\n    valid_out: Output signal indicating when four input data accumulations have been reached.\n    data_out[9:0]: 10-bit output data representing the accumulated sum.\n\nImplementation:\nThe design consists of the following submodules:\nCounter Module: Counts the number of valid input data received. It resets after counting four inputs.\nData Accumulator Module: Accumulates the four received data_in values and maintains the accumulated result.\nValid Output Module: Generates the valid_out signal, which is set to 1 when four inputs have been accumulated.\n\nGive me the complete code.\nmodule accu (\n    input               clk,\n    input               rst_n,\n    input       [7:0]   data_in,\n    input               valid_in,\n\n    output              valid_out,\n    output      [9:0]   data_out\n);"}
{"task_id": "radix2_div", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst', 'type': 'input port'}, {'id': 2, 'content': 'dividend', 'type': 'input port'}, {'id': 3, 'content': 'divisor', 'type': 'input port'}, {'id': 4, 'content': 'sign', 'type': 'input port'}, {'id': 5, 'content': 'opn_valid', 'type': 'input port'}, {'id': 6, 'content': 'res_ready', 'type': 'input port'}, {'id': 7, 'content': 'res_valid', 'type': 'output port'}, {'id': 8, 'content': 'result', 'type': 'output port'}, {'id': 9, 'content': 'abs_dividend', 'type': 'submodule'}, {'id': 10, 'content': 'neg_divisor_mod', 'type': 'submodule'}, {'id': 11, 'content': 'ctrl', 'type': 'submodule'}, {'id': 12, 'content': 'res_mgmt', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[4, 2, 4, 3, 5, 1, 9, 0, 10, 11, 0, 1, 6, 12, 11], [9, 9, 10, 10, 11, 11, 11, 11, 11, 12, 12, 12, 12, 7, 8]]\n, Implement a modular radix-2 divider for 8-bit signed or unsigned integers. The module accepts a dividend and a divisor as inputs and produces a 16-bit result containing both the quotient and the remainder. The design supports both signed and unsigned division operations.\n\nModule Name:\nradix2_div\n\nInput Ports:\n\nclk: Clock signal used for synchronous operation.\nrst: The reset signal to initialize or reset the module.\nsign: 1-bit indicating if the operation is signed (1) or unsigned (0).\ndividend: 8-bit input signal representing the dividend for division.\ndivisor: 8-bit input signal representing the divisor for division.\nopn_valid: 1-bit indicating that a valid operation request is present.\nOutput Ports:\n\nres_valid: 1-bit output signal indicating the result is valid and ready.\nresult: 16-bit output containing the remainder in the upper 8 bits and the quotient in the lower 8 bits.\n\nImplementation:\n\nModule Structure:\nThe design is composed of several submodules to enhance modularity and maintainability.\nEach submodule handles specific tasks: calculating absolute values, negating the divisor, controlling the division process, and managing result validity.\n\nAbsolute Value Calculation:\nThe abs_value module computes the absolute value of the dividend based on the sign input.\n\nNegative Divisor Calculation:\nThe neg_value module computes the negated absolute value of the divisor based on the sign input.\n\nDivision Control Logic:\nThe divider_control module manages the division process, incrementing a counter, updating a shift register, and determining when the division is complete.\n\nResult Management:\nThe result_management module handles the validity of the output result based on the state of the counter and reset signal.\n\nGive me the complete code.\nmodule radix2_div(\n    input wire clk,\n    input wire rst,\n    input wire [7:0] dividend,    \n    input wire [7:0] divisor,    \n    input wire sign,       \n    input wire opn_valid,   \n    output reg res_valid,   \n    input wire res_ready,   \n    output wire [15:0] result\n);"}
{"task_id": "div_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'prep', 'type': 'submodule'}, {'id': 5, 'content': 'div_op', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 5, 5], [4, 4, 5, 2, 3]]\n, Implement a 32-bit divider module where the dividend is 32 bits and the divisor is 16 bits using a modular design approach. The module should be composed of submodules to enhance clarity and maintainability. The first submodule will prepare the dividend and divisor by adjusting their bit widths. The second submodule will perform the division operation by shifting the dividend and comparing it with the divisor to compute the quotient and remainder.\n\nModule name:\n    div_32bit\n\nInput ports:\n    A: 32-bit dividend.\n    B: 16-bit divisor.\n\nOutput ports:\n    result: 32-bit quotient.\n    odd: 32-bit remainder.\n\nImplementation:\nThe top module (div_32bit) instantiates two submodules: prep_dividend and div_operation. The prep_dividend module prepares the inputs, while the div_operation module handles the division algorithm. The output signals are assigned from the results of the division operation.\n\nGive me the complete code.\nmodule div_32bit(\n    input wire [31:0] A,   // 32-bit dividend\n    input wire [15:0] B,   // 16-bit divisor\n    output wire [31:0] result, // 32-bit quotient\n    output wire [31:0] odd      // 32-bit remainder\n);"}
{"task_id": "div_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'result', 'type': 'output port'}, {'id': 3, 'content': 'odd', 'type': 'output port'}, {'id': 4, 'content': 'ctrl', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a modular 16-bit divider module, where the dividend is 16 bits and the divisor is 8 bits in combinational logic. The module should consist of submodules, enhancing organization and reusability. The main module should handle input and output ports, while a separate control unit submodule performs the division operation.\n\nModule name:\n    div_16bit\n\nInput ports:\n    A: 16-bit dividend.\n    B: 8-bit divisor.\n    \nOutput ports:\n    result: 16-bit quotient.\n    odd: 16-bit remainder.\n\nImplementation:\nThe top module connects the input and output ports and instantiates a control unit. The control unit handles the division logic, initializing temporary variables, performing the division algorithm, and updating the quotient and remainder. The division process involves shifting the dividend, comparing it with the divisor, and constructing the final results.\n\nGive me the complete code.\nmodule div_16bit (\n    input wire [15:0] A,       // 16-bit dividend\n    input wire [7:0] B,       // 8-bit divisor\n    output wire [15:0] result, // 16-bit quotient\n    output wire [15:0] odd     // 16-bit remainder\n);"}
{"task_id": "sub_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'adder_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 4], [4, 4, 2, 3]]\n, Implement a module of an 8-bit subtractor that uses modular design principles.\n\nModule name:\n    sub_8bit\n\nInput ports:\n    A[7:0]: 8-bit input operand A.\n    B[7:0]: 8-bit input operand B.\n\nOutput ports:\n    D[7:0]: 8-bit output representing the difference of A and B.\n    B_out: Borrow output indicating if a borrow was generated during the subtraction.\n\nImplementation:\nThe top module sub_8bit generates the 2's complement of B and utilizes an adder_8bit module to perform the subtraction operation. The adder_8bit module consists of multiple instances of the full_adder module to handle the addition of each bit.\n\nGive me the complete code.\nmodule sub_8bit(A, B, D, B_out);"}
{"task_id": "sub_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'Diff', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'S1', 'type': 'submodule'}, {'id': 5, 'content': 'S2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 5, 2, 2, 3]]\n, Implement a module of a 32-bit subtractor that uses a modular architecture.\n\nModule name:\n    sub_32bit\n\nInput ports:\n    A[31:0]: 32-bit input operand A.\n    B[31:0]: 32-bit input operand B.\n\nOutput ports:\n    Diff[31:0]: 32-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_32bit consists of two instances of a 16-bit subtractor block you design.\n\nPlease provide the complete code.\nmodule sub_32bit(A, B, Diff, B_out);"}
{"task_id": "sub_64bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub0', 'type': 'submodule'}, {'id': 5, 'content': 'sub1', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 0, 4, 5, 4, 5], [4, 4, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a 64-bit subtractor that utilizes a hierarchical architecture consisting of submodules for modular design.\n\nModule name:  \n    sub_64bit               \nInput ports:\n    A[63:0]: 64-bit input operand A.\n    B[63:0]: 64-bit input operand B.\nOutput ports:\n    D[63:0]: 64-bit output representing the difference A - B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_64bit consists of two instances of the 32-bit subtractor module, which in turn consists of two instances of the 16-bit subtractor module, and each 16-bit subtractor contains two 8-bit subtractor modules.\n\nGive me the complete code.\nmodule sub_64bit(A, B, D, B_out);"}
{"task_id": "sub_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'D', 'type': 'output port'}, {'id': 3, 'content': 'B_out', 'type': 'output port'}, {'id': 4, 'content': 'sub1', 'type': 'submodule'}, {'id': 5, 'content': 'sub2', 'type': 'submodule'}, {'id': 6, 'content': 'sub3', 'type': 'submodule'}, {'id': 7, 'content': 'sub4', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 1, 4, 0, 1, 0, 5, 1, 0, 6, 6, 7, 4, 5, 7], [4, 4, 5, 5, 5, 6, 6, 6, 7, 7, 7, 2, 2, 2, 2, 3]]\n, Implement a module of a borrow-lookahead 16-bit subtractor that uses the Borrow-Lookahead Subtractor (BLS) architecture.\n\nModule name:\n    sub_16bit               \nInput ports:\n    A[16:1]: 16-bit input operand A.\n    B[16:1]: 16-bit input operand B.\nOutput ports:\n    D[16:1]: 16-bit output representing the difference of A and B.\n    B_out: Borrow-out output.\n\nImplementation:\nThe top module sub_16bit consists of several instances of the 4-bit full subtractor block you design.\n\nGive me the complete code.\nmodule sub_16bit(A, B, D, B_out);"}
{"task_id": "comparator_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'A_greater', 'type': 'output port'}, {'id': 3, 'content': 'A_equal', 'type': 'output port'}, {'id': 4, 'content': 'A_less', 'type': 'output port'}, {'id': 5, 'content': 'sub_inst', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 5, 1, 0, 5], [5, 5, 2, 3, 3, 4]]\n, Implement a module of a 32-bit comparator using submodules with multiple bit-level comparators in combinational logic.\n\nModule name:\n    comparator_32bit\n\nInput ports:\n    A [31:0]: First 32-bit input operand (binary number to compare).\n    B [31:0]: Second 32-bit input operand (binary number to compare).\nOutput ports:\n    A_greater: 1-bit output indicating if A is greater than B.\n    A_equal: 1-bit output indicating if A is equal to B.\n    A_less: 1-bit output indicating if A is less than B.\n\nImplementation:\nComparison Logic: The module compares the two 32-bit binary numbers A and B using combinational logic.\nA subtraction operation is performed: A - B. The result of this subtraction helps determine whether A is greater than, equal to, or less than B.\nCarry Generation: If a borrow occurs during the subtraction, A is less than B (A_less).\nIf no borrow occurs and the result of subtraction is non-zero, A is greater than B (A_greater).\nIf A and B are equal, the result of subtraction is zero (A_equal).\nModular Design:\nThe main module (comparator_32bit) instantiates a submodule (subtractor_32bit) that performs the actual subtraction.\nThe outputs (A_greater, A_equal, A_less) are mutually exclusive, ensuring only one of the three outputs is high (1) at any given time.\n\nGive me the complete code.\nmodule comparator_32bit(\n    input [31:0] A,   // First 32-bit input operand\n    input [31:0] B,   // Second 32-bit input operand\n    output A_greater, \n    output A_equal,   \n    output A_less     \n);"}
{"task_id": "adder_32bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'A', 'type': 'input port'}, {'id': 1, 'content': 'B', 'type': 'input port'}, {'id': 2, 'content': 'S', 'type': 'output port'}, {'id': 3, 'content': 'C32', 'type': 'output port'}, {'id': 4, 'content': 'CLA1', 'type': 'submodule'}, {'id': 5, 'content': 'CLA2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[1, 0, 4, 0, 1, 5, 4, 5, 4], [4, 4, 5, 5, 5, 2, 2, 3, 3]]\n, Implement a module of a carry-lookahead 32-bit adder that uses the Carry-Lookahead Adder (CLA) architecture.\n\nModule name:  \n    adder_32bit               \nInput ports:\n    A[32:1]: 32-bit input operand A.\n    B[32:1]: 32-bit input operand B.\nOutput ports:\n    S[32:1]: 32-bit output representing the sum of A and B.\n    C32: Carry-out output.\n\nImplementation:\nThe top module adder_32bit consists of several instances of the 16 bit CLA block you design.\n\nGive me the complete code.\nmodule adder_32bit(A,B,S,C32);"}
{"task_id": "adder_16bit_csa", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'rca1', 'type': 'submodule'}, {'id': 6, 'content': 'csa_slice1', 'type': 'submodule'}, {'id': 7, 'content': 'csa_slice2', 'type': 'submodule'}, {'id': 8, 'content': 'csa_slice3', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 0, 1, 5, 6, 0, 1, 7, 0, 1, 6, 7, 5, 8, 8], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 3, 3, 3, 3, 4]]\n, Implement a module of a 16-bit carry select adder in combinational logic.\n\nModule name:\n    carry_select_adder_16bit\nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[15:0]: 16-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe carry_select_adder_16bit is built using a 4-bit ripple carry adder and several 4-bit carry select adder slices. The initial 4-bit section uses a ripple carry adder. Subsequent sections use carry select adder slices, which compute sums and carry-out bits based on the previous carry. Each 4-bit carry select adder slice includes two ripple carry adders and a multiplexer to select the appropriate sum and carry based on the carry-in.\n\nGive me the complete code.\nmodule adder_16bit_csa(a, b, cin, sum, cout);"}
{"task_id": "adder_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'Cin', 'type': 'input port'}, {'id': 3, 'content': 'y', 'type': 'output port'}, {'id': 4, 'content': 'Co', 'type': 'output port'}, {'id': 5, 'content': 'add8_inst1', 'type': 'submodule'}, {'id': 6, 'content': 'add8_inst2', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 6, 2, 1, 0, 6, 5, 5], [5, 5, 5, 6, 6, 6, 3, 3, 4]]\n, Implement a module of a 16-bit full adder in combinational logic.\n\nModule name:  \n    adder_16bit               \nInput ports:\n    a[15:0]: 16-bit input operand A.\n    b[15:0]: 16-bit input operand B.\n    Cin: Carry-in input.\nOutput ports:\n    y[15:0]: 16-bit output representing the sum of A and B.\n    Co: Carry-out output.\n\nImplementation:\nIn the adder_16bit module, you need to design a small bit-width adder(8-bit adder), which will be instantiated multiple times.\n\nGive me the complete code.\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] y,\n    output wire Co\n);"}
{"task_id": "adder_8bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'a', 'type': 'input port'}, {'id': 1, 'content': 'b', 'type': 'input port'}, {'id': 2, 'content': 'cin', 'type': 'input port'}, {'id': 3, 'content': 'sum', 'type': 'output port'}, {'id': 4, 'content': 'cout', 'type': 'output port'}, {'id': 5, 'content': 'FA0', 'type': 'submodule'}, {'id': 6, 'content': 'FA1', 'type': 'submodule'}, {'id': 7, 'content': 'FA2', 'type': 'submodule'}, {'id': 8, 'content': 'FA3', 'type': 'submodule'}, {'id': 9, 'content': 'FA4', 'type': 'submodule'}, {'id': 10, 'content': 'FA5', 'type': 'submodule'}, {'id': 11, 'content': 'FA6', 'type': 'submodule'}, {'id': 12, 'content': 'FA7', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[2, 1, 0, 0, 5, 1, 0, 1, 6, 0, 1, 7, 8, 0, 1, 0, 1, 9, 10, 0, 1, 0, 11, 1, 5, 6, 8, 11, 9, 10, 12, 7, 12], [5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 3, 3, 3, 3, 3, 3, 3, 3, 4]]\n, Implement a module of an 8-bit adder with multiple bit-level adders in combinational logic. \n\nModule name:  \n    adder_8bit               \nInput ports:\n    a[7:0]: 8-bit input operand A.\n    b[7:0]: 8-bit input operand B.\n    cin: Carry-in input.\nOutput ports:\n    sum[7:0]: 8-bit output representing the sum of A and B.\n    cout: Carry-out output.\n\nImplementation:\nThe module utilizes a series of bit-level adders (full adders) to perform the addition operation.\n\nGive me the complete code.\nmodule adder_8bit(\n    input [7:0] a, b, \n    input cin, \n    output [7:0] sum, \n    output cout);"}
{"task_id": "multi_16bit", "Instruction": "Please act as a professional Verilog designer. Given a submodules interconnection graph: \nnodes: [{'id': 0, 'content': 'clk', 'type': 'input port'}, {'id': 1, 'content': 'rst_n', 'type': 'input port'}, {'id': 2, 'content': 'start', 'type': 'input port'}, {'id': 3, 'content': 'ain', 'type': 'input port'}, {'id': 4, 'content': 'bin', 'type': 'input port'}, {'id': 5, 'content': 'yout', 'type': 'output port'}, {'id': 6, 'content': 'done', 'type': 'output port'}, {'id': 7, 'content': 'ctrl', 'type': 'submodule'}, {'id': 8, 'content': 'reg_unit', 'type': 'submodule'}, {'id': 9, 'content': 'mul_unit', 'type': 'submodule'}], \nedge_attrs: [], \nconnectivity: [[0, 1, 2, 7, 3, 2, 0, 4, 1, 7, 2, 0, 1, 8, 9, 8, 7], [7, 7, 7, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 5, 5, 6]]\n, Implement a module of an unsigned 16-bit multiplier using submodules. The multiplier should utilize shift-and-accumulate operations to generate the product output (yout). The module must include control signals such as clock (clk), reset (rst_n), and start (start), along with a completion flag (done) indicating the completion of the multiplication operation.\n\nModule name:\n    multi_16bit\n\nInput ports:\n    clk: Chip clock signal.\n    rst_n: Active-low reset signal. Defined as 0 for chip reset and 1 for reset signal inactive.\n    start: Chip enable signal to initiate the multiplication operation.\n    ain: Input signal representing the multiplicand (a) with a data width of 16 bits.\n    bin: Input signal representing the multiplier (b) with a data width of 16 bits.\n\nOutput ports:\n    yout: Product output signal with a data width of 32 bits.\n    done: Chip output flag signal. Defined as 1 indicates the completion of the multiplication operation.\n\nImplementation:\nControl Unit: This submodule manages the shift count register and the completion flag. It updates the shift count on each positive clock edge or reset signal, handling the start and reset conditions accordingly.\nRegister Unit: This submodule stores the multiplicand and multiplier. It initializes these registers on reset and loads them with input values when the multiplication operation starts.\nMultiplier Unit: This submodule implements the shift-and-accumulate logic. On each clock cycle, it checks the appropriate bit of the multiplicand and updates the product register by accumulating the shifted multiplier.\nOutput Assignment: The final product output (yout) is assigned from the product register, and the done flag indicates the multiplication completion status.\n\nGive me the complete code.\nmodule multi_16bit (\n    input clk,          // Chip clock signal.\n    input rst_n,        // Active-low reset signal.\n    input start,        // Chip enable signal.\n    input [15:0] ain,   // Input a (multiplicand) with a data width of 16 bits.\n    input [15:0] bin,   // Input b (multiplier) with a data width of 16 bits.\n    output [31:0] yout, // Product output with a data width of 32 bits.\n    output done         // Chip output flag signal.\n);"}
