{"task_id": 21, "response": "module ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);\n\n    // Submodule for configuration register\n    wire [31:0] config_reg_output;\n    reg [31:0] config_reg_internal;\n\n    configuration_store config_store (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load(load),\n        .config_data(config_data),\n        .config_out(config_reg_output)\n    );\n\n    always @ (posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            config_reg_internal <= 32'b0;\n        end else if (load) begin\n            config_reg_internal <= config_data;\n        end\n    end\n\n    assign current_config = config_reg_internal;\n\nendmodule\n\n// Submodule for configuration register\nmodule configuration_store (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output reg [31:0] config_out\n);\n\n    always @ (posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            config_out <= 32'b0;\n        end else if (load) begin\n            config_out <= config_data;\n        end\n    end\n\nendmodule"}
{"task_id": 21, "response": "module ctrl_unit_config_reg (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output [31:0] current_config\n);\n\n    // Submodule for configuration register\n    wire [31:0] config_reg_output;\n    configuration_register config_store (\n        .clk(clk),\n        .rst_n(rst_n),\n        .load(load),\n        .config_data(config_data),\n        .config_out(config_reg_output)\n    );\n\n    // Output assignment\n    assign current_config = config_reg_output;\n\nendmodule\n\n// Submodule for configuration register\nmodule configuration_register (\n    input clk,\n    input rst_n,\n    input load,\n    input [31:0] config_data,\n    output reg [31:0] config_out\n);\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            config_out <= 32'b0; // Reset to default value\n        end else if (load) begin\n            config_out <= config_data;\n        end\n    end\n\nendmodule"}
{"task_id": 22, "response": "module subtractor_32bit_css(A, B, Diff);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n\n    wire [7:0] c1, c2, c3, c4;\n    wire [7:0] s1, s2, s3, s4;\n\n    cs_subtractor sub1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(1'b0),\n        .S(s1),\n        .Cout(c1)\n    );\n\n    cs_subtractor sub2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .S(s2),\n        .Cout(c2)\n    );\n\n    cs_subtractor sub3 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .S(s3),\n        .Cout(c3)\n    );\n\n    cs_subtractor sub4 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .S(s4),\n        .Cout(Diff[31:24])\n    );\n\n    assign Diff[23:0] = s4;\n\nendmodule\n\nmodule cs_subtractor(A, B, Cin, S, Cout);\n    input [7:0] A, B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    assign {Cout, S} = A - B - Cin;\nendmodule"}
{"task_id": 0, "response": "module multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_15_out;\n    wire clk_3_out;\n\n    clk_div_4 div_15 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    clk_div_20 div_3 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 1) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] count;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            count <= 0;\n        end else if (count == 9) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 14, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the BCD increment logic\n    bcd_increment u_bcd_increment (\n        .current_count(count),\n        .next_count(next_count),\n        .enable(enable)\n    );\n\n    // Instantiate the BCD register\n    bcd_register u_bcd_register (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule bcd_increment (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            if (current_count < 9) begin\n                next_count = current_count + 1;\n            end else begin\n                next_count = 0;\n            end\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule bcd_register (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else if (enable) begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 22, "response": "module subtractor_32bit_css(A, B, Diff);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] Diff;\n\n    wire [7:0] c1, c2, c3, c4;\n    wire [7:0] s1, s2, s3, s4;\n\n    cs_subtractor sub1 (\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Cin(1'b0),\n        .S(s1),\n        .Cout(c1)\n    );\n\n    cs_subtractor sub2 (\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Cin(c1),\n        .S(s2),\n        .Cout(c2)\n    );\n\n    cs_subtractor sub3 (\n        .A(A[23:16]),\n        .B(B[23:16]),\n        .Cin(c2),\n        .S(s3),\n        .Cout(c3)\n    );\n\n    cs_subtractor sub4 (\n        .A(A[31:24]),\n        .B(B[31:24]),\n        .Cin(c3),\n        .S(s4),\n        .Cout(Diff[31:24])\n    );\n\n    assign Diff[23:0] = s1 + s2 + s3 + s4;\n\nendmodule\n\nmodule cs_subtractor(A, B, Cin, S, Cout);\n    input [7:0] A;\n    input [7:0] B;\n    input Cin;\n    output [7:0] S;\n    output Cout;\n\n    wire [8:0] diff;\n    wire carry;\n\n    assign diff = A + B + ~Cin;\n    assign {Cout, S} = diff[8:1];\nendmodule"}
{"task_id": 14, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the BCD increment logic\n    bcd_increment u_bcd_increment (\n        .current_count(count),\n        .next_count(next_count),\n        .enable(enable)\n    );\n\n    // Instantiate the BCD register\n    bcd_register u_bcd_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule bcd_increment (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            if (current_count < 9) begin\n                next_count = current_count + 1;\n            end else begin\n                next_count = 0;\n            end\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule bcd_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 0, "response": "module multi_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire clk_15_out;\n    wire clk_3_out;\n\n    clk_div_4 div_15 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_15_out)\n    );\n\n    clk_div_20 div_3 (\n        .CLK_in(CLK_in),\n        .RST(RST),\n        .CLK_out(clk_3_out)\n    );\n\n    assign CLK_15 = clk_15_out;\n    assign CLK_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_4 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [1:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 1) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_20 (\n    input CLK_in,\n    input RST,\n    output reg CLK_out\n);\n    reg [3:0] cnt;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 9) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": 23, "response": "module sub_32bit_cascaded(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [6:0] borrow;\n\n    borrow_save_subt bss1(A[31:28], B[31:28], D[31:28], borrow[0]);\n    borrow_save_subt bss2(A[27:24], B[27:24], D[27:24], borrow[1]);\n    borrow_save_subt bss3(A[23:20], B[23:20], D[23:20], borrow[2]);\n    borrow_save_subt bss4(A[19:16], B[19:16], D[19:16], borrow[3]);\n    borrow_save_subt bss5(A[15:12], B[15:12], D[15:12], borrow[4]);\n    borrow_save_subt bss6(A[11:8], B[11:8], D[11:8], borrow[5]);\n    borrow_save_subt bss7(A[7:4], B[7:4], D[7:4], borrow[6]);\n    borrow_save_subt bss8(A[3:0], B[3:0], D[3:0], borrow[7]);\n\n    assign B_out = borrow[7];\nendmodule\n\nmodule borrow_save_subt(A, B, D, B_in);\n    input [3:0] A;\n    input [3:0] B;\n    input B_in;\n    output [3:0] D;\n    output B_out;\n\n    wire [3:0] temp;\n    wire [2:0] borrow;\n\n    assign temp = A - B - B_in;\n    assign D = temp;\n    assign B_out = (A[3] & ~B[3]) | (B[3] & B_in);\nendmodule"}
{"task_id": 1, "response": "module binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);\n\n    wire equal_out, greater_out;\n\n    equal_comparator_16bit equality(\n        .A(X),\n        .B(Y),\n        .equal(equal_out)\n    );\n\n    magnitude_comparator_16bit magnitude(\n        .A(X),\n        .B(Y),\n        .greater(greater_out)\n    );\n\n    assign X_greater = greater_out;\n    assign X_equal = equal_out;\n    assign X_less = ~(equal_out | greater_out);\n\nendmodule\n\nmodule equal_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output equal\n);\n    assign equal = (A == B);\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output greater\n);\n    assign greater = (A > B);\nendmodule"}
{"task_id": 1, "response": "module binary_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output X_greater,\n    output X_equal,\n    output X_less\n);\n\n    wire equal_out, greater_out;\n\n    equal_comparator_16bit equality (\n        .A(X),\n        .B(Y),\n        .equal(equal_out)\n    );\n\n    magnitude_comparator_16bit magnitude (\n        .A(X),\n        .B(Y),\n        .greater(greater_out)\n    );\n\n    assign X_greater = greater_out;\n    assign X_equal = equal_out;\n    assign X_less = ~(equal_out | greater_out);\n\nendmodule\n\nmodule equal_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output equal\n);\n    assign equal = (A == B);\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output greater\n);\n    assign greater = (A > B);\nendmodule"}
{"task_id": 7, "response": "`timescale 1ns/1ps\n\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);\n\n    reg [15:0] data_a, data_b;\n    reg [31:0] sum, product;\n    reg op_valid;\n\n    // Instantiate the adder and multiplier modules\n    adder u_adder (\n        .a(data_a),\n        .b(data_b),\n        .sum(sum),\n        .cout(op_valid)\n    );\n\n    multiplier u_multiplier (\n        .a(data_a),\n        .b(data_b),\n        .product(product)\n    );\n\n    // Control logic to select operation\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_a <= 16'b0;\n            data_b <= 16'b0;\n            result_out <= 32'b0;\n            result_valid <= 1'b0;\n            op_valid <= 1'b0;\n        end else begin\n            if (op_valid) begin\n                if (control == 1'b0) begin\n                    result_out <= sum;\n                    result_valid <= 1'b1;\n                end else begin\n                    result_out <= product;\n                    result_valid <= 1'b1;\n                end\n            end else begin\n                result_valid <= 1'b0;\n            end\n        end\n    end\n\n    // Pipeline the inputs\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_a <= 16'b0;\n            data_b <= 16'b0;\n        end else begin\n            if (result_valid) begin\n                data_a <= data_in;\n                data_b <= data_in;\n            end\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] sum,\n    output cout\n);\n\n    assign sum = a + b;\n    assign cout = 1'b0;\n\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n\n    assign product = a * b;\n\nendmodule"}
{"task_id": 23, "response": "module sub_32bit_cascaded(A, B, D, B_out);\n    input [31:0] A;\n    input [31:0] B;\n    output [31:0] D;\n    output B_out;\n\n    wire [6:0] borrow;\n\n    borrow_save_subt bss1(A[31:28], B[31:28], B_out, borrow[0]);\n    borrow_save_subt bss2(A[27:24], B[27:24], borrow[0], borrow[1]);\n    borrow_save_subt bss3(A[23:20], B[23:20], borrow[1], borrow[2]);\n    borrow_save_subt bss4(A[19:16], B[19:16], borrow[2], borrow[3]);\n    borrow_save_subt bss5(A[15:12], B[15:12], borrow[3], borrow[4]);\n    borrow_save_subt bss6(A[11:8], B[11:8], borrow[4], borrow[5]);\n    borrow_save_subt bss7(A[7:4], B[7:4], borrow[5], borrow[6]);\n    borrow_save_subt bss8(A[3:0], B[3:0], borrow[6], B_out);\n\nendmodule\n\nmodule borrow_save_subt(A, B, B_in, B_out, D);\n    input [3:0] A, B;\n    input B_in;\n    output B_out;\n    output [3:0] D;\n\n    assign D = A - B - B_in;\n    assign B_out = (A[3] & ~B[3]) | (B[3] & B_in);\nendmodule"}
{"task_id": 15, "response": "module stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);\nwire [31:0] fetch_out;\nwire [31:0] decode_out;\nwire [31:0] execute_out;\nwire [31:0] memory_access_out;\nwire [31:0] writeback_out;\n\nfetch_stage fetch(.clk(clk), .rst(rst), .data_mem(data_mem), .ctrl_unit(ctrl_unit), .data_out(fetch_out));\ndecode_stage decode(.clk(clk), .rst(rst), .data_in(fetch_out), .decode_out(decode_out));\nexecute_stage execute(.clk(clk), .rst(rst), .data_in(decode_out), .execute_out(execute_out));\nmemory_access_stage memory_access(.clk(clk), .rst(rst), .data_in(execute_out), .memory_access_out(memory_access_out));\nwriteback_stage writeback(.clk(clk), .rst(rst), .data_in(memory_access_out), .result_reg(result_reg));\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] data_mem[0:31],\n    input [7:0] ctrl_unit[0:7],\n    output reg [31:0] data_out\n);\n    reg [4:0] index;\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            index <= 0;\n            data_out <= 0;\n        end else begin\n            if (index < 32) begin\n                data_out <= data_mem[ctrl_unit[index]];\n                index <= index + 1;\n            end\n        end\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] decode_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            decode_out <= 0;\n        end else begin\n            decode_out <= data_in;\n        end\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] execute_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            execute_out <= 0;\n        end else begin\n            execute_out <= data_in;\n        end\n    end\nendmodule\n\nmodule memory_access_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] memory_access_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            memory_access_out <= 0;\n        end else begin\n            memory_access_out <= data_in;\n        end\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] result_reg\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst) begin\n            result_reg <= 0;\n        end else begin\n            result_reg <= data_in;\n        end\n    end\nendmodule"}
{"task_id": 24, "response": "module hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);\n    wire clk_60_out;\n    wire clk_3_out;\n\n    clk_div_by_2 div_60 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_60_out)\n    );\n\n    clk_div_by_40 div_3 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_3_out)\n    );\n\n    assign clk_60 = clk_60_out;\n    assign clk_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_by_2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\nmodule clk_div_by_40 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] count;\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n            count <= 0;\n        end else if (count == 19) begin\n            clk_out <= ~clk_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 2, "response": "module magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    wire [3:0] comp0, comp1, comp2, comp3;\n\n    bitwise_comparator_4bit comp0_instance (.X(X[3:0]), .Y(Y[3:0]), .X_greater_Y(comp0[0]), .X_equal_Y(comp0[1]), .X_less_Y(comp0[2]));\n    bitwise_comparator_4bit comp1_instance (.X(X[7:4]), .Y(Y[7:4]), .X_greater_Y(comp1[0]), .X_equal_Y(comp1[1]), .X_less_Y(comp1[2]));\n    bitwise_comparator_4bit comp2_instance (.X(X[11:8]), .Y(Y[11:8]), .X_greater_Y(comp2[0]), .X_equal_Y(comp2[1]), .X_less_Y(comp2[2]));\n    bitwise_comparator_4bit comp3_instance (.X(X[15:12]), .Y(Y[15:12]), .X_greater_Y(comp3[0]), .X_equal_Y(comp3[1]), .X_less_Y(comp3[2]));\n\n    always @(*) begin\n        X_greater_Y = comp0[2] | (comp0[1] & comp1[2]) | (comp0[0] & comp1[1] & comp2[2]) | (comp0[0] & comp1[0] & comp2[1] & comp3[2]);\n        X_equal_Y = (comp0[1] & comp1[1] & comp2[1] & comp3[1]) | (comp0[0] & comp1[0] & comp2[0] & comp3[0]);\n        X_less_Y = comp0[2] | (comp0[1] & comp1[2]) | (comp0[0] & comp1[1] & comp2[2]) | (comp0[0] & comp1[0] & comp2[1] & comp3[2]);\n    end\nendmodule\n\nmodule bitwise_comparator_4bit(\n    input [3:0] X,\n    input [3:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    always @(*) begin\n        X_greater_Y = (X > Y);\n        X_equal_Y = (X == Y);\n        X_less_Y = (X < Y);\n    end\nendmodule"}
{"task_id": 7, "response": "`timescale 1ns/1ps\n\nmodule arithmetic_pipeline (\n    input               clk,\n    input               rst_n,\n    input       [15:0]  data_in,\n    input               control,\n    \n    output reg          result_valid,\n    output reg  [31:0]  result_out\n);\n\n    reg [15:0] data_a;\n    reg [15:0] data_b;\n    reg [31:0] result;\n    reg op_valid;\n\n    wire [31:0] op_type;\n    wire [31:0] op_result;\n\n    assign op_type = control ? 2'b01 : 2'b10;\n\n    // Instantiate the adder and multiplier modules\n    adder u_adder (\n        .a(data_a),\n        .b(data_b),\n        .sum(result)\n    );\n\n    multiplier u_multiplier (\n        .a(data_a),\n        .b(data_b),\n        .product(result)\n    );\n\n    // Control logic to determine operation and output result\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            data_a <= 16'd0;\n            data_b <= 16'd0;\n            result_valid <= 1'b0;\n            op_valid <= 1'b0;\n        end else begin\n            if (op_valid) begin\n                data_a <= data_in;\n                data_b <= data_in;\n                op_valid <= 1'b0;\n            end else begin\n                op_valid <= 1'b1;\n            end\n        end\n    end\n\n    // Output logic\n    always @(posedge clk) begin\n        if (op_valid) begin\n            result_out <= result;\n            result_valid <= 1'b1;\n        end else begin\n            result_valid <= 1'b0;\n        end\n    end\n\nendmodule\n\nmodule adder (\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule multiplier (\n    input [15:0] a,\n    input [15:0] b,\n    output [31:0] product\n);\n    assign product = $signed(a) * $signed(b);\nendmodule"}
{"task_id": 24, "response": "module hierarchical_freq_div (\n    input clk_in,\n    input rst,\n    output clk_60,\n    output clk_3\n);\n\n    wire clk_60_out;\n    wire clk_3_out;\n\n    clk_div_by_2 div_60 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_60_out)\n    );\n\n    clk_div_by_40 div_3 (\n        .clk_in(clk_in),\n        .rst(rst),\n        .clk_out(clk_3_out)\n    );\n\n    assign clk_60 = clk_60_out;\n    assign clk_3 = clk_3_out;\n\nendmodule\n\nmodule clk_div_by_2 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n        end else begin\n            clk_out <= ~clk_out;\n        end\n    end\nendmodule\n\nmodule clk_div_by_40 (\n    input clk_in,\n    input rst,\n    output reg clk_out\n);\n    reg [5:0] count;\n\n    always @(posedge clk_in or posedge rst) begin\n        if (rst) begin\n            clk_out <= 0;\n            count <= 0;\n        end else if (count == 19) begin\n            clk_out <= ~clk_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule"}
{"task_id": 15, "response": "module stagepipe5(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output [31:0] result_reg  \n);\nwire [31:0] fetch_out;\nwire [31:0] decode_out;\nwire [31:0] execute_out;\nwire [31:0] memory_access_out;\nwire [31:0] writeback_out;\n\nfetch_stage fetch(\n    .clk(clk),\n    .rst(rst),\n    .data_mem(data_mem),\n    .ctrl_unit(ctrl_unit),\n    .data_out(fetch_out)\n);\n\ndecode_stage decode(\n    .clk(clk),\n    .rst(rst),\n    .data_in(fetch_out),\n    .data_out(decode_out)\n);\n\nexecute_stage execute(\n    .clk(clk),\n    .rst(rst),\n    .data_in(decode_out),\n    .data_out(execute_out)\n);\n\nmemory_access_stage memory_access(\n    .clk(clk),\n    .rst(rst),\n    .data_in(execute_out),\n    .data_out(memory_access_out)\n);\n\nwriteback_stage writeback(\n    .clk(clk),\n    .rst(rst),\n    .data_in(memory_access_out),\n    .data_out(writeback_out)\n);\n\nassign result_reg = writeback_out;\n\nendmodule\n\nmodule fetch_stage(\n    input clk,\n    input rst,\n    input [31:0] data_mem [0:31],\n    input [7:0] ctrl_unit [0:7],\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_mem[ctrl_unit[0]];\n    end\nendmodule\n\nmodule decode_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule execute_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule memory_access_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule\n\nmodule writeback_stage(\n    input clk,\n    input rst,\n    input [31:0] data_in,\n    output reg [31:0] data_out\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 0;\n        else\n            data_out <= data_in;\n    end\nendmodule"}
{"task_id": 8, "response": "module power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);\n\n    wire is_power_two;\n\n    // Instantiate the power of two checker submodule\n    is_power_two_16bit power_two_checker (\n        .input_number(A),\n        .is_power_two(is_power_two)\n    );\n\n    // Determine if A is a power of two and less than B\n    assign A_is_power_two_less_B = is_power_two && (A < B);\n\nendmodule\n\nmodule is_power_two_16bit(\n    input [15:0] input_number,\n    output is_power_two\n);\n\n    // Check if only one bit is set to 1\n    assign is_power_two = (input_number & (input_number - 16'b1)) == 16'b0;\n\nendmodule"}
{"task_id": 2, "response": "module magnitude_comparator_16bit(\n    input [15:0] X,\n    input [15:0] Y,\n    output reg X_greater_Y,\n    output reg X_equal_Y,\n    output reg X_less_Y\n);\n    wire [3:0] X_greater_Y_4bit, X_equal_Y_4bit, X_less_Y_4bit;\n\n    bitwise_comparator_4bit comp0(.X(X[3:0]), .Y(Y[3:0]), .X_greater_Y(X_greater_Y_4bit[0]), .X_equal_Y(X_equal_Y_4bit[0]), .X_less_Y(X_less_Y_4bit[0]));\n    bitwise_comparator_4bit comp1(.X(X[7:4]), .Y(Y[7:4]), .X_greater_Y(X_greater_Y_4bit[1]), .X_equal_Y(X_equal_Y_4bit[1]), .X_less_Y(X_less_Y_4bit[1]));\n    bitwise_comparator_4bit comp2(.X(X[11:8]), .Y(Y[11:8]), .X_greater_Y(X_greater_Y_4bit[2]), .X_equal_Y(X_equal_Y_4bit[2]), .X_less_Y(X_less_Y_4bit[2]));\n    bitwise_comparator_4bit comp3(.X(X[15:12]), .Y(Y[15:12]), .X_greater_Y(X_greater_Y_4bit[3]), .X_equal_Y(X_equal_Y_4bit[3]), .X_less_Y(X_less_Y_4bit[3]));\n\n    always @(*) begin\n        X_greater_Y = &X_greater_Y_4bit;\n        X_equal_Y = &X_equal_Y_4bit;\n        X_less_Y = &X_less_Y_4bit;\n    end\nendmodule\n\nmodule bitwise_comparator_4bit(\n    input [3:0] X,\n    input [3:0] Y,\n    output X_greater_Y,\n    output X_equal_Y,\n    output X_less_Y\n);\n    assign X_greater_Y = (X > Y);\n    assign X_equal_Y = (X == Y);\n    assign X_less_Y = (X < Y);\nendmodule"}
{"task_id": 8, "response": "module power_two_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_is_power_two_less_B\n);\n\n    wire is_power_two;\n\n    is_power_two_16bit power_two_checker (\n        .input(A),\n        .is_power_two(is_power_two)\n    );\n\n    assign A_is_power_two_less_B = is_power_two && (A < B);\n\nendmodule\n\nmodule is_power_two_16bit(\n    input [15:0] input,\n    output is_power_two\n);\n\n    reg is_power_two;\n\n    always @(*) begin\n        is_power_two = (input & (input - 16'b1)) == 16'b0;\n    end\n\nendmodule"}
{"task_id": 16, "response": "module multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);\n    wire [15:0] partial_product0, partial_product1, partial_product2, partial_product3;\n    \n    // Instantiate four 4-bit multipliers for each chunk\n    multiplier_4bit mul0(.A(A[3:0]), .B(B[3:0]), .Product(partial_product0));\n    multiplier_4bit mul1(.A(A[7:4]), .B(B[7:4]), .Product(partial_product1));\n    multiplier_4bit mul2(.A(A[11:8]), .B(B[11:8]), .Product(partial_product2));\n    multiplier_4bit mul3(.A(A[15:12]), .B(B[15:12]), .Product(partial_product3));\n    \n    // Calculate the final product\n    assign Product = partial_product0 << 0 | partial_product1 << 4 | partial_product2 << 8 | partial_product3 << 12;\nendmodule\n\nmodule multiplier_4bit(\n    input [3:0] A,   \n    input [3:0] B,   \n    output [7:0] Product\n);\n    // Simple multiplication logic for 4-bit numbers\n    assign Product = A * B;\nendmodule"}
{"task_id": 25, "response": "module carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);\n    wire [15:0] lower_sum, upper_sum0, upper_sum1;\n    wire lower_carry, upper_carry0, upper_carry1;\n\n    // Instantiate lower 16-bit adder\n    adder_16bit lower_adder (\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .Cin(Cin),\n        .sum(lower_sum),\n        .Cout(lower_carry)\n    );\n\n    // Instantiate upper 16-bit adder for first 16-bit block\n    adder_16bit upper_adder0 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(lower_carry),\n        .sum(upper_sum0),\n        .Cout(upper_carry0)\n    );\n\n    // Instantiate upper 16-bit adder for second 16-bit block\n    adder_16bit upper_adder1 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(lower_carry),\n        .sum(upper_sum1),\n        .Cout(upper_carry1)\n    );\n\n    assign sum = {upper_sum1, upper_sum0} | {upper_carry1, upper_carry0, lower_carry} << 16;\n    assign Cout = upper_carry1 | upper_carry0;\n\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    wire Cout_temp;\n    assign {Cout_temp, sum} = a + b + Cin;\n    assign Cout = Cout_temp;\nendmodule"}
{"task_id": 16, "response": "module multiplier_16bit(\n    input [15:0] A,   \n    input [15:0] B,   \n    output [31:0] Product\n);\n    wire [15:0] partial_product0, partial_product1, partial_product2, partial_product3;\n\n    // Instantiate four 4-bit multipliers for each chunk of A and B\n    multiplier_4bit mul0(.A(A[3:0]), .B(B[3:0]), .Product(partial_product0));\n    multiplier_4bit mul1(.A(A[7:4]), .B(B[7:4]), .Product(partial_product1));\n    multiplier_4bit mul2(.A(A[11:8]), .B(B[11:8]), .Product(partial_product2));\n    multiplier_4bit mul3(.A(A[15:12]), .B(B[15:12]), .Product(partial_product3));\n\n    // Calculate the final product\n    assign Product = partial_product0 << 0 | partial_product1 << 4 | partial_product2 << 8 | partial_product3 << 12;\n\nendmodule\n\nmodule multiplier_4bit(\n    input [3:0] A,   \n    input [3:0] B,   \n    output [7:0] Product\n);\n    // Simple multiplication logic\n    assign Product = A * B;\nendmodule"}
{"task_id": 3, "response": "module sub_16bit(A, B, Result, Overflow);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Result;\n    output Overflow;\n\n    wire [7:0] lower_result;\n    wire [7:0] higher_result;\n    wire lower_overflow;\n    wire higher_overflow;\n\n    sub_8bit lower_sub(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Result(lower_result),\n        .Overflow(lower_overflow)\n    );\n\n    sub_8bit higher_sub(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Result(higher_result),\n        .Overflow(higher_overflow)\n    );\n\n    assign Result = {higher_result, lower_result};\n    assign Overflow = (lower_overflow ^ higher_overflow);\n\nendmodule\n\nmodule sub_8bit(A, B, Result, Overflow);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Result;\n    output Overflow;\n\n    wire [7:0] difference;\n    wire borrow_out;\n\n    adder_8bit adder(\n        .A(A),\n        .B(~B),\n        .Sum(difference),\n        .Carry(borrow_out)\n    );\n\n    assign Result = difference;\n    assign Overflow = borrow_out;\n\nendmodule\n\nmodule adder_8bit(A, B, Sum, Carry);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Sum;\n    output Carry;\n\n    wire [7:0] carry;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(0), .Sum(Sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(Sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(Sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(Sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(Sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(Sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(Sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(Sum[7]), .Cout(Carry));\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": 25, "response": "module carry_select_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] sum,\n    output wire Cout\n);\n    wire [15:0] lower_sum, upper_sum0, upper_sum1;\n    wire lower_cout, upper_cout0, upper_cout1;\n\n    adder_16bit lower_adder (\n        .a(a[15:0]),\n        .b(b[15:0]),\n        .Cin(Cin),\n        .sum(lower_sum),\n        .Cout(lower_cout)\n    );\n\n    adder_16bit upper_adder0 (\n        .a(a[31:16]),\n        .b(b[31:16]),\n        .Cin(lower_cout),\n        .sum(upper_sum0),\n        .Cout(upper_cout0)\n    );\n\n    adder_16bit upper_adder1 (\n        .a(a[31:31]),\n        .b(b[31:31]),\n        .Cin(upper_cout0),\n        .sum(upper_sum1),\n        .Cout(upper_cout1)\n    );\n\n    assign sum = {upper_sum1, upper_sum0} | {upper_sum1, upper_sum0} << 16;\n    assign Cout = upper_cout1 | upper_cout1 << 16;\nendmodule\n\nmodule adder_16bit (\n    input wire [15:0] a,\n    input wire [15:0] b,\n    input wire Cin,\n    output wire [15:0] sum,\n    output wire Cout\n);\n    wire [15:0] carry;\n    full_adder FA0 (.a(a[0]), .b(b[0]), .Cin(Cin), .sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1 (.a(a[1]), .b(b[1]), .Cin(carry[0]), .sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2 (.a(a[2]), .b(b[2]), .Cin(carry[1]), .sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3 (.a(a[3]), .b(b[3]), .Cin(carry[2]), .sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4 (.a(a[4]), .b(b[4]), .Cin(carry[3]), .sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5 (.a(a[5]), .b(b[5]), .Cin(carry[4]), .sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6 (.a(a[6]), .b(b[6]), .Cin(carry[5]), .sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7 (.a(a[7]), .b(b[7]), .Cin(carry[6]), .sum(sum[7]), .Cout(carry[7]));\n    full_adder FA8 (.a(a[8]), .b(b[8]), .Cin(carry[7]), .sum(sum[8]), .Cout(carry[8]));\n    full_adder FA9 (.a(a[9]), .b(b[9]), .Cin(carry[8]), .sum(sum[9]), .Cout(carry[9]));\n    full_adder FA10 (.a(a[10]), .b(b[10]), .Cin(carry[9]), .sum(sum[10]), .Cout(carry[10]));\n    full_adder FA11 (.a(a[11]), .b(b[11]), .Cin(carry[10]), .sum(sum[11]),"}
{"task_id": 9, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n.a(a[7:0]),\n.b(b[7:0]),\n.cin(cin),\n.sum(sum[7:0]),\n.cout(carry[0])\n);\n\ncarry_lookahead_adder_8bit cla2(\n.a(a[15:8]),\n.b(b[15:8]),\n.cin(carry[0]),\n.sum(sum[15:8]),\n.cout(carry[1])\n);\n\ncarry_lookahead_8bit cla3(\n.a(a[23:16]),\n.b(b[23:16]),\n.cin(carry[1]),\n.sum(sum[23:16]),\n.cout(carry[2])\n);\n\ncarry_lookahead_8bit cla4(\n.a(a[31:24]),\n.b(b[31:24]),\n.cin(carry[2]),\n.sum(sum[31:24]),\n.cout(cout)\n);\nendmodule\n\nmodule carry_lookahead_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [8:0] c;\n\nadd_8bit add1(\n.a(a),\n.b(b),\n.cin(cin),\n.sum(sum),\n.cout(c[0])\n);\n\nadd_8bit add2(\n.a(a),\n.b(b),\n.cin(c[0]),\n.sum(sum),\n.cout(c[1])\n);\n\nadd_8bit add3(\n.a(a),\n.b(b),\n.cin(c[1]),\n.sum(sum),\n.cout(c[2])\n);\n\nadd_8bit add4(\n.a(a),\n.b(b),\n.cin(c[2]),\n.sum(sum),\n.cout(c[3])\n);\n\nadd_8bit add5(\n.a(a),\n.b(b),\n.cin(c[3]),\n.sum(sum),\n.cout(c[4])\n);\n\nadd_8bit add6(\n.a(a),\n.b(b),\n.cin(c[4]),\n.sum(sum),\n.cout(c[5])\n);\n\nadd_8bit add7(\n.a(a),\n.b(b),\n.cin(c[5]),\n.sum(sum),\n.cout(c[6])\n);\n\nadd_8bit add8(\n.a(a),\n.b(b),\n.cin(c[6]),\n.sum(sum),\n.cout(cout)\n);\nendmodule\n\nmodule add_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [8:0] c;\n\nadd_4bit add1(\n.a(a[3:0]),\n.b(b[3:0]),\n.cin(cin),\n.sum(sum[3:0]),\n.cout(c[0])\n);\n\nadd_4bit add2(\n.a(a[7:4]),\n.b(b[7:4]),\n.cin(c[0]),\n.sum(sum[7:4]),\n.cout(c[1])\n);\n\nadd_4bit add3(\n.a(a[7:4]),\n.b(b[7:4]),\n.cin(c[1]),\n.sum(sum[7:4]),\n.cout(c[2])\n);\n\nadd_4bit add4(\n.a(a[7:4]),\n.b(b[7:4]),"}
{"task_id": 17, "response": "module complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);\n\n    wire clk_25;\n    wire clk_5;\n    wire clk_1;\n    wire clk_200;\n\n    clk_div_8 div_25MHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_25)\n    );\n\n    clk_div_40 div_5MHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_5)\n    );\n\n    clk_div_200 div_1MHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_1)\n    );\n\n    clk_div_1000 div_200kHz (\n        .CLK_200MHz(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_200)\n    );\n\n    assign CLK_25MHz = clk_25;\n    assign CLK_5MHz = clk_5;\n    assign CLK_1MHz = clk_1;\n    assign CLK_200kHz = clk_200;\n\nendmodule\n\nmodule clk_div_8 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [2:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            count <= 0;\n        end else if (count == 3) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_40 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [5:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            count <= 0;\n        end else if (count == 19) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_200 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [7:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            count <= 0;\n        end else if (count == 99) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_10000 (\n    input CLK_200MHz,\n    input reset,\n    output reg CLK_out\n);\n    reg [9:0] count;\n\n    always @(posedge CLK_200MHz or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 1'b0;\n            count <= 0;\n        end else if (count == 499) begin\n            CLK_out <= ~CLK_out;\n            count <= 0;\n        end else begin\n            count <= count +"}
{"task_id": 3, "response": "module sub_16bit(A, B, Result, Overflow);\n    input [15:0] A;\n    input [15:0] B;\n    output [15:0] Result;\n    output Overflow;\n\n    wire [7:0] lower_result;\n    wire [7:0] higher_result;\n    wire lower_overflow;\n    wire higher_overflow;\n\n    sub_8bit lower_sub(\n        .A(A[7:0]),\n        .B(B[7:0]),\n        .Result(lower_result),\n        .Overflow(lower_overflow)\n    );\n\n    sub_8bit higher_sub(\n        .A(A[15:8]),\n        .B(B[15:8]),\n        .Result(higher_result),\n        .Overflow(higher_overflow)\n    );\n\n    assign Result = {higher_result, lower_result};\n    assign Overflow = (lower_overflow ^ higher_overflow);\n\nendmodule\n\nmodule sub_8bit(A, B, Result, Overflow);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Result;\n    output Overflow;\n\n    wire [7:0] borrow;\n\n    adder_8bit adder(\n        .A(A),\n        .B(~B),\n        .Result(Result),\n        .Borrow(borrow)\n    );\n\n    assign Overflow = borrow;\n\nendmodule\n\nmodule adder_8bit(A, B, Result, Borrow);\n    input [7:0] A;\n    input [7:0] B;\n    output [7:0] Result;\n    output Borrow;\n\n    wire [7:0] sum;\n    wire [7:0] carry;\n\n    full_adder FA0(.A(A[0]), .B(B[0]), .Cin(0), .Sum(sum[0]), .Cout(carry[0]));\n    full_adder FA1(.A(A[1]), .B(B[1]), .Cin(carry[0]), .Sum(sum[1]), .Cout(carry[1]));\n    full_adder FA2(.A(A[2]), .B(B[2]), .Cin(carry[1]), .Sum(sum[2]), .Cout(carry[2]));\n    full_adder FA3(.A(A[3]), .B(B[3]), .Cin(carry[2]), .Sum(sum[3]), .Cout(carry[3]));\n    full_adder FA4(.A(A[4]), .B(B[4]), .Cin(carry[3]), .Sum(sum[4]), .Cout(carry[4]));\n    full_adder FA5(.A(A[5]), .B(B[5]), .Cin(carry[4]), .Sum(sum[5]), .Cout(carry[5]));\n    full_adder FA6(.A(A[6]), .B(B[6]), .Cin(carry[5]), .Sum(sum[6]), .Cout(carry[6]));\n    full_adder FA7(.A(A[7]), .B(B[7]), .Cin(carry[6]), .Sum(sum[7]), .Cout(Borrow));\n\n    assign Result = sum;\n\nendmodule\n\nmodule full_adder(A, B, Cin, Sum, Cout);\n    input A;\n    input B;\n    input Cin;\n    output Sum;\n    output Cout;\n\n    assign Sum = A ^ B ^ Cin;\n    assign Cout = (A & B) | (Cin & (A ^ B));\n\nendmodule"}
{"task_id": 26, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);\n\nwire [15:0] add_result, sub_result;\n\nadd_stage ADD (\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .result(add_result)\n);\n\nsub_stage SUB (\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .result(sub_result)\n);\n\nmult_stage MULT (\n    .clk(clk),\n    .rst(rst),\n    .a(add_result),\n    .b(sub_result),\n    .result(result)\n);\n\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule sub_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a - b;\n    end\nendmodule\n\nmodule mult_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a * b;\n    end\nendmodule"}
{"task_id": 4, "response": "module mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the next count logic\n    next_count_logic u_next_count_logic (\n        .current_count(count),\n        .enable(enable),\n        .next_count(next_count)\n    );\n\n    // Instantiate the count register\n    count_register u_count_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule next_count_logic (\n    input wire [3:0] current_count,\n    input wire enable,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (enable) begin\n            next_count = (current_count == 4'h9) ? 4'h0 : current_count + 1;\n        end else begin\n            next_count = current_count;\n        end\n    end\n\nendmodule\n\nmodule count_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 4'h0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 9, "response": "`timescale 1ns / 1ns\n\nmodule carry_lookahead_adder_32bit(a, b, cin, sum, cout);\ninput [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [3:0] carry;\n\ncarry_lookahead_adder_8bit cla1(\n.a(a[7:0]),\n.b(b[7:0]),\n.cin(cin),\n.sum(sum[7:0]),\n.cout(carry[0])\n);\n\ncarry_lookahead_adder_8bit cla2(\n.a(a[15:8]),\n.b(b[15:8]),\n.cin(carry[0]),\n.sum(sum[15:8]),\n.cout(carry[1])\n);\n\ncarry_lookahead_adder_8bit cla3(\n.a(a[23:16]),\n.b(b[23:16]),\n.cin(carry[1]),\n.sum(sum[23:16]),\n.cout(carry[2])\n);\n\ncarry_lookahead_adder_8bit cla4(\n.a(a[31:24]),\n.b(b[31:24]),\n.cin(carry[2]),\n.sum(sum[31:24]),\n.cout(cout)\n);\nendmodule\n\nmodule carry_lookahead_adder_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [8:0] c;\n\nadd_8bit adder1(\n.a(a),\n.b(b),\n.cin(cin),\n.sum(sum),\n.cout(c[0])\n);\n\nadd_8bit adder2(\n.a(a),\n.b(b),\n.cin(c[0]),\n.sum(sum),\n.cout(c[1])\n);\n\nadd_8bit adder3(\n.a(a),\n.b(b),\n.cin(c[1]),\n.sum(sum),\n.cout(c[2])\n);\n\nadd_8bit adder4(\n.a(a),\n.b(b),\n.cin(c[2]),\n.sum(sum),\n.cout(c[3])\n);\n\nadd_8bit adder5(\n.a(a),\n.b(b),\n.cin(c[3]),\n.sum(sum),\n.cout(c[4])\n);\n\nadd_8bit adder6(\n.a(a),\n.b(b),\n.cin(c[4]),\n.sum(sum),\n.cout(c[5])\n);\n\nadd_8bit adder7(\n.a(a),\n.b(b),\n.cin(c[5]),\n.sum(sum),\n.cout(c[6])\n);\n\nadd_8bit adder8(\n.a(a),\n.b(b),\n.cin(c[6]),\n.sum(sum),\n.cout(cout)\n);\nendmodule\n\nmodule add_8bit(a, b, cin, sum, cout);\ninput [7:0] a, b;\ninput cin;\noutput [7:0] sum;\noutput cout;\n\nwire [8:0] c;\n\nadd_8bit_2 adder1(\n.a(a),\n.b(b),\n.cin(cin),\n.sum(sum),\n.cout(c[0])\n);\n\nadd_8bit_2 adder2(\n.a(a),\n.b(b),\n.cin(c[0]),\n.sum(sum),\n.cout(c[1])\n);\n\nadd_8bit_2 adder3(\n.a(a),\n.b(b),\n.cin(c[1]),\n.sum(sum),\n.cout(c[2])\n);\n\nadd_8bit_2 adder4(\n.a(a),\n.b(b),\n.cin(c[2]),\n.sum(sum),"}
{"task_id": 26, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] op1,\n    input [15:0] op2,\n    output [31:0] result\n);\n\nwire [15:0] add_result, sub_result;\n\nadd_stage ADD (\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .result(add_result)\n);\n\nsub_stage SUB (\n    .clk(clk),\n    .rst(rst),\n    .a(op1),\n    .b(op2),\n    .result(sub_result)\n);\n\nmult_stage MULT (\n    .clk(clk),\n    .rst(rst),\n    .a(add_result),\n    .b(sub_result),\n    .result(result)\n);\n\nendmodule\n\nmodule add_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a + b;\n    end\nendmodule\n\nmodule sub_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a - b;\n    end\nendmodule\n\nmodule mult_stage(\n    input clk,\n    input rst,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [31:0] result\n);\n    always @(posedge clk or posedge rst) begin\n        if (rst)\n            result <= 0;\n        else\n            result <= a * b;\n    end\nendmodule"}
{"task_id": 4, "response": "module mod10_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    output wire [3:0] count\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the next count logic\n    next_count_logic u_next_count_logic (\n        .current_count(count),\n        .enable(enable),\n        .next_count(next_count)\n    );\n\n    // Instantiate the count register\n    count_register u_count_register (\n        .clk(clk),\n        .reset(reset),\n        .next_count(next_count),\n        .current_count(count)\n    );\n\nendmodule\n\nmodule next_count_logic (\n    input wire [3:0] current_count,\n    input wire enable,\n    output wire [3:0] next_count\n);\n\n    assign next_count = (current_count == 9 && enable) ? 0 : current_count + 1;\n\nendmodule\n\nmodule count_register (\n    input wire clk,\n    input wire reset,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 0;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 17, "response": "`timescale 1ns / 1ps\n\nmodule complex_freq_div (\n    input CLK_200MHz,\n    input reset,\n    output CLK_25MHz,\n    output CLK_5MHz,\n    output CLK_1MHz,\n    output CLK_200kHz\n);\n\n    wire clk_25;\n    wire clk_5;\n    wire clk_1;\n    wire clk_200;\n\n    clk_div_8 div_25MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_25)\n    );\n\n    clk_div_40 div_5MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_5)\n    );\n\n    clk_div_200 div_1MHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_1)\n    );\n\n    clk_div_1000 div_200kHz (\n        .CLK_in(CLK_200MHz),\n        .reset(reset),\n        .CLK_out(clk_200)\n    );\n\n    assign CLK_25MHz = clk_25;\n    assign CLK_5MHz = clk_5;\n    assign CLK_1MHz = clk_1;\n    assign CLK_200kHz = clk_200;\n\nendmodule\n\nmodule clk_div_8 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [2:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 3) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_40 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [5:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 19) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_200 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [7:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 99) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule\n\nmodule clk_div_1000 (\n    input CLK_in,\n    input reset,\n    output reg CLK_out\n);\n    reg [9:0] cnt;\n\n    always @(posedge CLK_in or posedge reset) begin\n        if (reset) begin\n            CLK_out <= 0;\n            cnt <= 0;\n        end else if (cnt == 499) begin\n            CLK_out <= ~CLK_out;\n            cnt <= 0;\n        end else begin\n            cnt <= cnt + 1;\n        end\n    end\nendmodule"}
{"task_id": 5, "response": "module barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);\n    wire [31:0] left_shift, right_shift;\n    \n    // Generate left circular shift output\n    assign left_shift = (data_in << shift_amt) | (data_in >> (32 - shift_amt));\n    \n    // Generate right circular shift output\n    assign right_shift = (data_in >> shift_amt) | (data_in << (32 - shift_amt));\n    \n    // Mux the outputs based on shift direction\n    assign data_out = shift_dir ? right_shift : left_shift;\n\nendmodule"}
{"task_id": 10, "response": "module combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\nwire [15:0] addition_result;\nwire [15:0] subtraction_result;\nwire [15:0] xor_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(addition_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(subtraction_result)\n);\n\nxor_module u_xor (\n    .a(a),\n    .b(b),\n    .result(xor_result)\n);\n\nalways @(posedge clk) begin\n    case(sel)\n        2'b00: result <= addition_result;\n        2'b01: result <= subtraction_result;\n        2'b10: result <= xor_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a ^ b;\nendmodule"}
{"task_id": 5, "response": "module barrel_shifter_32 (\n    input [31:0] data_in,\n    input [4:0] shift_amt,\n    input shift_dir,\n    output [31:0] data_out\n);\n    wire [31:0] left_shift, right_shift;\n    \n    // Generate left shift\n    assign left_shift = data_in << shift_amt;\n    \n    // Generate right shift\n    assign right_shift = data_in >> shift_amt;\n    \n    // Mux to select left or right shift\n    assign data_out = shift_dir ? right_shift : left_shift;\n\nendmodule"}
{"task_id": 27, "response": "module adder_64bit(A, B, Cin, Sum, Cout);\n    input [63:0] A, B;\n    input Cin;\n    output [63:0] Sum;\n    output Cout;\n\n    wire [7:0] carry;\n\n    adder_8bit adder0(.a(A[7:0]), .b(B[7:0]), .cin(Cin), .sum(Sum[7:0]), .cout(carry[0]));\n    adder_8bit adder1(.a(A[15:8]), .b(B[15:8]), .cin(carry[0]), .sum(Sum[15:8]), .cout(carry[1]));\n    adder_8bit adder2(.a(A[23:16]), .b(B[23:16]), .cin(carry[1]), .sum(Sum[23:16]), .cout(carry[2]));\n    adder_8bit adder3(.a(A[31:24]), .b(B[31:24]), .cin(carry[2]), .sum(Sum[31:24]), .cout(carry[3]));\n    adder_8bit adder4(.a(A[39:32]), .b(B[39:32]), .cin(carry[3]), .sum(Sum[39:32]), .cout(carry[4]));\n    adder_8bit adder5(.a(A[47:40]), .b(B[47:40]), .cin(carry[4]), .sum(Sum[47:40]), .cout(carry[5]));\n    adder_8bit adder6(.a(A[55:48]), .b(B[55:48]), .cin(carry[5]), .sum(Sum[55:48]), .cout(carry[6]));\n    adder_8bit adder7(.a(A[63:56]), .b(B[63:56]), .cin(carry[6]), .sum(Sum[63:56]), .cout(carry[7]));\n\n    assign Cout = carry[7];\nendmodule\n\nmodule adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a, b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [7:0] g, p;\n    assign g = a & b;\n    assign p = a ^ b;\n\n    assign sum = p ^ (p + g);\n    assign cout = (a & b) | (p & cin);\nendmodule"}
{"task_id": 18, "response": "module signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    wire sign_A = A[15];\n    wire sign_B = B[15];\n\n    // Comparison of signs\n    assign A_greater = (sign_A & ~sign_B);\n    assign A_equal = (sign_A == sign_B) & (A_greater == 0);\n    assign A_less = ~(sign_A | sign_B);\n\n    // Instantiate the 15-bit unsigned magnitude comparator\n    unsigned_magnitude_comparator_15bit mag_comp (\n        .A(A[14:0]),\n        .B(B[14:0]),\n        .A_greater(mag_comp_out_greater),\n        .A_equal(mag_comp_out_equal),\n        .A_less(mag_comp_out_less)\n    );\n\n    // Connect the magnitude comparator outputs\n    assign mag_comp_out_greater = (sign_A == 0) & mag_comp_out_greater;\n    assign mag_comp_out_equal = (sign_A == sign_B) & mag_comp_out_equal;\n    assign mag_comp_out_less = (sign_A == 1) & mag_comp_out_less;\n\nendmodule\n\nmodule unsigned_magnitude_comparator_15bit(\n    input [14:0] A,   \n    input [14:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    // Comparison logic\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\n\nendmodule"}
{"task_id": 10, "response": "module combined_alu(\n    input clk,\n    input [1:0] sel,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\nwire [15:0] addition_result;\nwire [15:0] subtraction_result;\nwire [15:0] xor_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .sum(addition_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .difference(subtraction_result)\n);\n\nxor_module u_xor (\n    .a(a),\n    .b(b),\n    .xor_result(xor_result)\n);\n\nalways @(posedge clk) begin\n    case(sel)\n        2'b00: result <= addition_result;\n        2'b01: result <= subtraction_result;\n        2'b10: result <= xor_result;\n        default: result <= 16'b0;\n    endcase\nend\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] sum\n);\n    assign sum = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] difference\n);\n    assign difference = a - b;\nendmodule\n\nmodule xor_module(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] xor_result\n);\n    assign xor_result = a ^ b;\nendmodule"}
{"task_id": 6, "response": "module memory_shifter(data, shift_control, out);\n\ninput [15:0] data;\ninput [3:0] shift_control;\noutput reg [15:0] out;\n\nwire [15:0] shifted_left, shifted_right, rotated_right;\n\nshift_left shift_left_module(\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .shifted_data(shifted_left)\n);\n\nshift_right shift_right_module(\n    .data(data),\n    .shift_amount(shift_control[1:0]),\n    .shifted_data(shifted_right)\n);\n\nrotate_right rotate_right_module(\n    .data(data),\n    .shift_amount(shift_control[3:2]),\n    .rotated_data(rotated_right)\n);\n\nassign out = (shift_control[3:2] == 2'b00) ? data : (shift_control[3:2] == 2'b01) ? shifted_left : (shift_control[3:2] == 2'b10) ? shifted_right : rotated_right;\n\nendmodule\n\nmodule shift_left(data, shift_amount, shifted_data);\ninput [15:0] data;\ninput [1:0] shift_amount;\noutput [15:0] shifted_data;\n\nassign shifted_data = data << shift_amount;\n\nendmodule\n\nmodule shift_right(data, shift_amount, shifted_data);\ninput [15:0] data;\ninput [1:0] shift_amount;\noutput [15:0] shifted_data;\n\nassign shifted_data = data >> shift_amount;\n\nendmodule\n\nmodule rotate_right(data, shift_amount, rotated_data);\ninput [15:0] data;\ninput [1:0] shift_amount;\noutput [15:0] rotated_data;\n\nassign rotated_data = {data[shift_amount-1:0], data[15:shift_amount]};\n\nendmodule\n\nmodule output_selector(data, out);\ninput [15:0] data;\noutput [15:0] out;\n\nassign out = data;\n\nendmodule"}
{"task_id": 27, "response": "module adder_64bit(A, B, Cin, Sum, Cout);\n    input [63:0] A, B;\n    input Cin;\n    output [63:0] Sum;\n    output Cout;\n\n    wire [7:0] carry;\n\n    adder_8bit adder0(.a(A[7:0]), .b(B[7:0]), .cin(Cin), .sum(Sum[7:0]), .cout(carry[0]));\n    adder_8bit adder1(.a(A[15:8]), .b(B[15:8]), .cin(carry[0]), .sum(Sum[15:8]), .cout(carry[1]));\n    adder_8bit adder2(.a(A[23:16]), .b(B[23:16]), .cin(carry[1]), .sum(Sum[23:16]), .cout(carry[2]));\n    adder_8bit adder3(.a(A[31:24]), .b(B[31:24]), .cin(carry[2]), .sum(Sum[31:24]), .cout(carry[3]));\n    adder_8bit adder4(.a(A[39:32]), .b(B[39:32]), .cin(carry[3]), .sum(Sum[39:32]), .cout(carry[4]));\n    adder_8bit adder5(.a(A[47:40]), .b(B[47:40]), .cin(carry[4]), .sum(Sum[47:40]), .cout(carry[5]));\n    adder_8bit adder6(.a(A[55:48]), .b(B[55:48]), .cin(carry[5]), .sum(Sum[55:48]), .cout(carry[6]));\n    adder_8bit adder7(.a(A[63:56]), .b(B[63:56]), .cin(carry[6]), .sum(Sum[63:56]), .cout(Cout));\nendmodule\n\nmodule adder_8bit(a, b, cin, sum, cout);\n    input [7:0] a, b;\n    input cin;\n    output [7:0] sum;\n    output cout;\n\n    wire [7:0] g, p;\n\n    assign g = a & b;\n    assign p = a ^ b;\n\n    assign sum = p ^ (p + cin);\n    assign cout = (a & b) | (p & cin);\nendmodule"}
{"task_id": 18, "response": "module signed_magnitude_comparator_16bit(\n    input [15:0] A,   \n    input [15:0] B,  \n    output reg A_greater, \n    output reg A_equal,   \n    output reg A_less     \n);\n\n    wire [14:0] mag_A;\n    wire [14:0] mag_B;\n    wire sign_A;\n    wire sign_B;\n\n    // Extracting the sign and magnitude\n    assign sign_A = A[15];\n    assign mag_A = A[14:0];\n    assign sign_B = B[15];\n    assign mag_B = B[14:0];\n\n    // Instantiating the magnitude comparator\n    unsigned_magnitude_comparator_15bit mag_comp (\n        .A(mag_A),\n        .B(mag_B),\n        .A_greater(A_greater),\n        .A_equal(A_equal),\n        .A_less(A_less)\n    );\n\n    // Comparison of signs\n    always @(*) begin\n        if (sign_A != sign_B) begin\n            A_greater = sign_A;\n            A_equal = 0;\n            A_less = ~sign_A;\n        end\n        else begin\n            A_greater = 0;\n            A_equal = A_equal | (~sign_A & A_greater); // A_greater is 0 if A_equal is 1\n            A_less = 0;\n        end\n    end\n\nendmodule\n\nmodule unsigned_magnitude_comparator_15bit(\n    input [14:0] A,\n    input [14:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A == B) begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end else begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end\n    end\n\nendmodule"}
{"task_id": 11, "response": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n\n    // Submodules for decoding instruction fields\n    wire [31:0] func_imm;\n    wire [4:0] reg_rd, reg_rs1, reg_rs2;\n    wire [6:0] func_code;\n\n    opcode_decoder opcode_decoder (\n        .instr(instr),\n        .opcode(opcode)\n    );\n\n    func_code_decoder func_code_decoder (\n        .instr(instr),\n        .func3(func3),\n        .func7(func7)\n    );\n\n    register_file registers (\n        .instr(instr),\n        .rd(reg_rd),\n        .rs1(reg_rs1),\n        .rs2(reg_rs2)\n    );\n\n    func_immediate func_immediate (\n        .instr(instr),\n        .imm(func_imm)\n    );\n\n    assign rd = reg_rd;\n    assign rs1 = reg_rs1;\n    assign rs2 = reg_rs2;\n    assign imm = func_imm;\n\nendmodule\n\nmodule opcode_decoder (\n    input [31:0] instr,\n    output [6:0] opcode\n);\n    assign opcode = instr[6:0];\nendmodule\n\nmodule func_code_decoder (\n    input [31:0] instr,\n    output [2:0] func3,\n    output [6:0] func7\n);\n    assign func3 = instr[14:12];\n    assign func7 = instr[31:25];\nendmodule\n\nmodule register_file (\n    input [31:0] instr,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\nendmodule\n\nmodule func_immediate (\n    input [31:0] instr,\n    output [31:0] imm\n);\n    assign imm = instr[31:20];\nendmodule"}
{"task_id": 6, "response": "module memory_shifter(data, shift_control, out);\n\ninput [15:0] data;\ninput [3:0] shift_control;\noutput reg [15:0] out;\n\nwire [15:0] shift_left_out, shift_right_out, rotate_right_out;\n\nshift_left shift_left_module (.data(data), .count(shift_control[1:0]), .out(shift_left_out));\nshift_right shift_right_module (.data(data), .count(shift_control[1:0]), .out(shift_right_out));\nrotate_right rotate_right_module (.data(data), .count(shift_control[3:2]), .out(rotate_right_out));\n\nassign out = (shift_control[3:2] == 2'b00) ? data : (shift_control[3:2] == 2'b01) ? shift_left_out : (shift_control[3:2] == 2'b10) ? shift_right_out : rotate_right_out;\n\nendmodule\n\nmodule shift_left(data, count, out);\ninput [15:0] data;\ninput [1:0] count;\noutput [15:0] out;\n\nassign out = (count == 2'b00) ? data : (count == 2'b01) ? data << 1 : (count == 2'b10) ? data << 2 : data << 3;\n\nendmodule\n\nmodule shift_right(data, count, out);\ninput [15:0] data;\ninput [1:0] count;\noutput [15:0] out;\n\nassign out = (count == 2'b00) ? data : (count == 2'b01) ? data >> 1 : (count == 2'b10) ? data >> 2 : data >> 3;\n\nendmodule\n\nmodule rotate_right(data, count, out);\ninput [15:0] data;\ninput [1:0] count;\noutput [15:0] out;\n\nassign out = (count == 2'b00) ? data : (count == 2'b01) ? {data[0], data[15:1]} : (count == 2'b10) ? {data[2:0], data[15:3]} : {data[3:0], data[15:4]};\n\nendmodule\n\nmodule output_selector(data, out);\ninput [15:0] data;\noutput [15:0] out;\n\nassign out = data;\n\nendmodule"}
{"task_id": 28, "response": "module alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result;\n\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\nand u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\nor u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Selective output based on op_code\nassign result = (op_code == 2'b00) ? add_result :\n                (op_code == 2'b01) ? sub_result :\n                (op_code == 2'b10) ? and_result :\n                                      or_result;\n\nendmodule\n\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\nmodule and(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\nmodule or(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 11, "response": "module instr_decoder (\n    input [31:0] instr,\n    output [6:0] opcode,\n    output [4:0] rs1,\n    output [4:0] rs2,\n    output [4:0] rd,\n    output [2:0] func3,\n    output [6:0] func7,\n    output [31:0] imm\n);\n\n    // Submodules for decoding instruction fields\n    func_decoder func_decoder (\n        .instr(instr),\n        .func3(func3),\n        .func7(func7)\n    );\n\n    register_decoder registers (\n        .instr(instr),\n        .rd(rd),\n        .rs1(rs1),\n        .rs2(rs2)\n    );\n\n    immediate_decoder immediates (\n        .instr(instr),\n        .imm(imm)\n    );\n\n    // Extract opcode from the input instruction\n    assign opcode = instr[6:0];\n\nendmodule\n\nmodule func_decoder (\n    input [31:0] instr,\n    output [2:0] func3,\n    output [6:0] func7\n);\n    assign func3 = instr[14:12];\n    assign func7 = instr[31:25];\nendmodule\n\nmodule register_decoder (\n    input [31:0] instr,\n    output [4:0] rd,\n    output [4:0] rs1,\n    output [4:0] rs2\n);\n    assign rd = instr[11:7];\n    assign rs1 = instr[19:15];\n    assign rs2 = instr[24:20];\nendmodule\n\nmodule immediate_decoder (\n    input [31:0] instr,\n    output [31:0] imm\n);\n    assign imm = {instr[31:20], instr[19:12]};\nendmodule"}
{"task_id": 19, "response": "module bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);\n\n    wire [11:0] next_value;\n\n    // Instantiate the control unit\n    control_unit u_control_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .next_value(next_value)\n    );\n\n    // Instantiate the increment/decrement logic\n    increment_decrement_logic u_increment_decrement_logic (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .current_value(value),\n        .next_value(next_value)\n    );\n\n    // Instantiate the register unit\n    register_unit u_register_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_value(next_value),\n        .current_value(value)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (next_value == 12'b1111_1111_1111) ? 12'b0 : next_value + 1; // Increment\n            end else begin\n                next_value <= (next_value == 12'b0) ? 12'b1111_1111_1111 : next_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule increment_decrement_logic (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    input wire [11:0] current_value,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (current_value == 12'b1111_1111_1111) ? 12'b0 : current_value + 1; // Increment\n            end else begin\n                next_value <= (current_value == 12'b0) ? 12'b1111_1111_1111 : current_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [11:0] next_value,\n    output reg [11:0] current_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            current_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            current_value <= next_value;\n        end\n    end\n\nendmodule"}
{"task_id": 28, "response": "module alu(\n    input [1:0] op_code,\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n\nwire [15:0] add_result, sub_result, and_result, or_result;\n\n// Instantiating the adder module\nadder u_adder (\n    .a(a),\n    .b(b),\n    .result(add_result)\n);\n\n// Instantiating the subtractor module\nsubtractor u_subtractor (\n    .a(a),\n    .b(b),\n    .result(sub_result)\n);\n\n// Instantiating the AND module\nand_gate u_and (\n    .a(a),\n    .b(b),\n    .result(and_result)\n);\n\n// Instantiating the OR module\nor_gate u_or (\n    .a(a),\n    .b(b),\n    .result(or_result)\n);\n\n// Selective output based on op_code\nassign result = (op_code == 2'b00) ? add_result :\n                (op_code == 2'b01) ? sub_result :\n                (op_code == 2'b10) ? and_result :\n                or_result;\n\nendmodule\n\n// Submodule for addition\nmodule adder(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a + b;\nendmodule\n\n// Submodule for subtraction\nmodule subtractor(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a - b;\nendmodule\n\n// Submodule for bitwise AND\nmodule and_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a & b;\nendmodule\n\n// Submodule for bitwise OR\nmodule or_gate(\n    input [15:0] a,\n    input [15:0] b,\n    output [15:0] result\n);\n    assign result = a | b;\nendmodule"}
{"task_id": 12, "response": "module dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the shift logic\n    shift_logic u_shift_logic (\n        .current_count(count_out),\n        .shift_dir(shift_dir),\n        .next_count(next_count)\n    );\n\n    // Instantiate the register to hold the count\n    shift_register u_shift_register (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(data_in),\n        .next_count(next_count),\n        .current_count(count_out)\n    );\n\nendmodule\n\nmodule shift_logic (\n    input wire [3:0] current_count,\n    input wire shift_dir,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (shift_dir) begin\n            next_count = {current_count[0], current_count[3:1]}; // Shift right\n        end else begin\n            next_count = {current_count[2:0], current_count[3]}; // Shift left\n        end\n    end\n\nendmodule\n\nmodule shift_register (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    input wire [3:0] next_count,\n    output reg [3:0] current_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            current_count <= 4'b0000;\n        end else if (load) begin\n            current_count <= data_in;\n        end else begin\n            current_count <= next_count;\n        end\n    end\n\nendmodule"}
{"task_id": 19, "response": "module bidirectional_circular_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output wire [11:0] value\n);\n\n    wire [11:0] next_value;\n\n    // Instantiate the control unit\n    control_unit u_control_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .direction(direction),\n        .next_value(next_value)\n    );\n\n    // Instantiate the increment/decrement logic\n    increment_decrement_logic u_increment_decrement_logic (\n        .current_value(value),\n        .next_value(next_value),\n        .direction(direction)\n    );\n\n    // Instantiate the register unit\n    register_unit u_register_unit (\n        .clk(clk),\n        .reset(reset),\n        .enable(enable),\n        .next_value(next_value),\n        .current_value(value)\n    );\n\nendmodule\n\nmodule control_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire direction,\n    output reg [11:0] next_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            next_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            if (direction) begin\n                next_value <= (next_value == 12'b1111_1111_1111) ? 12'b0 : next_value + 1; // Increment\n            end else begin\n                next_value <= (next_value == 12'b0) ? 12'b1111_1111_1111 : next_value - 1; // Decrement\n            end\n        end\n    end\n\nendmodule\n\nmodule increment_decrement_logic (\n    input wire [11:0] current_value,\n    input wire [11:0] next_value,\n    input wire direction,\n    output reg [11:0] next_value\n);\n\n    always @(*) begin\n        if (direction) begin\n            next_value = (current_value == 12'b1111_1111_1111) ? 12'b0 : current_value + 1; // Increment\n        end else begin\n            next_value = (current_value == 12'b0) ? 12'b1111_1111_1111 : current_value - 1; // Decrement\n        end\n    end\n\nendmodule\n\nmodule register_unit (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire [11:0] next_value,\n    output reg [11:0] current_value\n);\n\n    always @ (posedge clk or posedge reset) begin\n        if (reset) begin\n            current_value <= 12'b0; // Reset to initial value\n        end else if (enable) begin\n            current_value <= next_value; // Update on enable\n        end\n    end\n\nendmodule"}
{"task_id": 12, "response": "module dynamic_shift_counter (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire shift_dir,\n    input wire [3:0] data_in,\n    output wire [3:0] count_out\n);\n\n    wire [3:0] next_count;\n\n    // Instantiate the shift logic\n    shift_logic u_shift_logic (\n        .current_count(count_out),\n        .shift_dir(shift_dir),\n        .next_count(next_count)\n    );\n\n    // Instantiate the shift register\n    shift_register u_shift_register (\n        .clk(clk),\n        .reset(reset),\n        .load(load),\n        .data_in(data_in),\n        .current_count(count_out),\n        .next_count(next_count)\n    );\n\nendmodule\n\nmodule shift_logic (\n    input wire [3:0] current_count,\n    input wire shift_dir,\n    output reg [3:0] next_count\n);\n\n    always @(*) begin\n        if (shift_dir) begin\n            next_count = {current_count[2:0], current_count[3]};\n        end else begin\n            next_count = {current_count[0], current_count[3:1]};\n        end\n    end\n\nendmodule\n\nmodule shift_register (\n    input wire clk,\n    input wire reset,\n    input wire load,\n    input wire [3:0] data_in,\n    input wire [3:0] current_count,\n    output reg [3:0] next_count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            next_count <= 4'b0000;\n        end else if (load) begin\n            next_count <= data_in;\n        end else begin\n            next_count <= current_count;\n        end\n    end\n\nendmodule"}
{"task_id": 13, "response": "module bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n    wire count_direction;\n\n    // Submodule for controlling count direction\n    direction_control direction_control (\n        .up_down(up_down),\n        .count_direction(count_direction)\n    );\n\n    // Submodule for counting\n    counter_module count_module (\n        .clk(clk),\n        .reset(reset),\n        .count_direction(count_direction),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\n// Submodule for controlling count direction\nmodule direction_control (\n    input wire up_down,\n    output wire count_direction\n);\n\n    assign count_direction = up_down;\n\nendmodule\n\n// Submodule for counting\nmodule counter_module (\n    input wire clk,\n    input wire reset,\n    input wire count_direction,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            count <= 4'b0000;\n        end else if (count_direction) begin\n            count <= count + 1;\n        end else begin\n            count <= count - 1;\n        end\n    end\n\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns / 1ps\n\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [15:0] add_out, sub_out, and_out, or_out, xor_out, slt_out, not_out;\nwire add_carry, sub_borrow;\n\nadd_sub add_mod(.a(a), .b(b), .op(4'b0000), .result(add_out), .carry(add_carry));\nadd_sub sub_mod(.a(a), .b(b), .op(4'b0001), .result(sub_out), .carry(sub_borrow));\nbitwise and_mod(.a(a), .b(b), .op(4'b0010), .result(and_out));\nbitwise or_mod(.a(a), .b(b), .op(4'b0011), .result(or_out));\nbitwise xor_mod(.a(a), .b(b), .op(4'b0100), .result(xor_out));\nbitwise slt_mod(.a(a), .b(b), .op(4'b0101), .result(slt_out));\nbitwise not_mod(.a(a), .op(4'b0110), .result(not_out));\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_out;\n        4'b0001: result = sub_out;\n        4'b0010: result = and_out;\n        4'b0011: result = or_out;\n        4'b0100: result = xor_out;\n        4'b0101: result = slt_out;\n        4'b0110: result = not_out;\n        default: result = 16'bx;\n    endcase\nend\n\nassign zero = (result == 16'b0);\nassign carry = (op_code == 4'b0000) ? add_carry : sub_borrow;\nassign negative = result[15];\n\nendmodule\n\nmodule add_sub(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output [15:0] result,\n    output carry\n);\n    reg [15:0] temp_result;\n    reg temp_carry;\n\n    always @(*) begin\n        case(op)\n            4'b0000: {temp_carry, temp_result} = a + b;\n            4'b0001: {temp_carry, temp_result} = a - b;\n            default: {temp_carry, temp_result} = 16'bx;\n        endcase\n    end\n\n    assign result = temp_result;\n    assign carry = temp_carry;\nendmodule\n\nmodule bitwise(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op,\n    output [15:0] result\n);\n    reg [15:0] temp_result;\n\n    always @(*) begin\n        case(op)\n            4'b0010: temp_result = a & b;\n            4'b0011: temp_result = a | b;\n            4'b0100: temp_result = a ^ b;\n            4'b0101: temp_result = (a < b) ? 1 : 0;\n            4'b0110: temp_result = ~a;\n            default: temp_result = 16'bx;\n        endcase\n    end\n\n    assign result = temp_result;\nendmodule"}
{"task_id": 20, "response": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);\n\n    wire [6:0] op_type_out;\n    wire [4:0] dest_reg_out;\n    wire [31:0] immediate_out;\n\n    // Instantiate the operation decoder\n    decode_op op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .op_type(op_type_out)\n    );\n\n    // Instantiate the destination register decoder\n    decode_dest dest_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .dest_reg(dest_reg_out)\n    );\n\n    // Instantiate the immediate value decoder\n    decode_imm imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .immediate(immediate_out)\n    );\n\n    assign op_type = op_type_out;\n    assign dest_reg = dest_reg_out;\n    assign immediate = immediate_out;\n\nendmodule\n\n// Submodule for decoding the operation type\nmodule decode_op (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] op_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            op_type <= 0;\n        end else begin\n            op_type <= instruction[6:0];\n        end\n    end\nendmodule\n\n// Submodule for decoding the destination register\nmodule decode_dest (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [4:0] dest_reg\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            dest_reg <= 0;\n        end else begin\n            dest_reg <= instruction[11:7];\n        end\n    end\nendmodule\n\n// Submodule for decoding the immediate value\nmodule decode_imm (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] immediate\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            immediate <= 0;\n        end else begin\n            immediate <= instruction[31:20];\n        end\n    end\nendmodule"}
{"task_id": 13, "response": "module bidirectional_counter (\n    input wire clk,\n    input wire reset,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    wire [3:0] current_count;\n    wire direction;\n\n    // Submodule for controlling count direction\n    direction_control direction_control (\n        .up_down(up_down),\n        .direction(direction)\n    );\n\n    // Submodule for counting\n    counter_module count_module (\n        .clk(clk),\n        .reset(reset),\n        .direction(direction),\n        .count(current_count)\n    );\n\n    assign count = current_count;\n\nendmodule\n\n// Submodule for controlling count direction\nmodule direction_control (\n    input wire up_down,\n    output wire direction\n);\n\n    assign direction = up_down;\n\nendmodule\n\n// Submodule for counting\nmodule counter_module (\n    input wire clk,\n    input wire reset,\n    input wire direction,\n    output reg [3:0] count\n);\n\n    always @(posedge clk or posedge reset) begin\n        if (reset)\n            count <= 4'b0000;\n        else if (direction)\n            count <= count + 1;\n        else\n            count <= count - 1;\n    end\n\nendmodule"}
{"task_id": 29, "response": "`timescale 1ns / 1ps\n\nmodule compact_alu(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] op_code,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n\nwire [15:0] add_out, sub_out, and_out, or_out, xor_out, slt_out, not_out;\nwire add_carry, sub_borrow;\n\nadder_16 add_mod(.a(a), .b(b), .sum(add_out), .carry(add_carry));\nsubtractor_16 sub_mod(.a(a), .b(b), .diff(sub_out), .borrow(sub_borrow));\nand_16 and_mod(.a(a), .b(b), .out(and_out));\nor_16 or_mod(.a(a), .b(b), .out(or_out));\nxor_16 xor_mod(.a(a), .b(b), .out(xor_out));\nslt_16 slt_mod(.a(a), .b(b), .out(slt_out));\nnot_16 not_mod(.a(a), .out(not_out));\n\nalways @(*) begin\n    case(op_code)\n        4'b0000: result = add_out;\n        4'b0001: result = sub_out;\n        4'b0010: result = and_out;\n        4'b0011: result = or_out;\n        4'b0100: result = xor_out;\n        4'b0101: result = slt_out;\n        4'b0110: result = not_out;\n        default: result = 16'bx;\n    endcase\nend\n\nassign zero = (result == 16'b0);\nassign carry = (op_code == 4'b0000) ? add_carry : sub_borrow;\nassign negative = result[15];\n\nendmodule\n\nmodule adder_16(input [15:0] a, input [15:0] b, output [15:0] sum, output carry);\n    assign {carry, sum} = a + b;\nendmodule\n\nmodule subtractor_16(input [15:0] a, input [15:0] b, output [15:0] diff, output borrow);\n    assign {borrow, diff} = a - b;\nendmodule\n\nmodule and_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a & b;\nendmodule\n\nmodule or_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a | b;\nendmodule\n\nmodule xor_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = a ^ b;\nendmodule\n\nmodule slt_16(input [15:0] a, input [15:0] b, output [15:0] out);\n    assign out = (a < b) ? 16'b1 : 16'b0;\nendmodule\n\nmodule not_16(input [15:0] a, output [15:0] out);\n    assign out = ~a;\nendmodule"}
{"task_id": 20, "response": "module instruction_decoder (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output [6:0] op_type,\n    output [4:0] dest_reg,\n    output [31:0] immediate\n);\n\n    wire [6:0] op_type_out;\n    wire [4:0] dest_reg_out;\n    wire [31:0] immediate_out;\n\n    // Instantiating the operation decoder\n    decode_op op_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .op_type(op_type_out)\n    );\n\n    // Instantiating the destination register decoder\n    decode_dest dest_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .dest_reg(dest_reg_out)\n    );\n\n    // Instantiating the immediate value decoder\n    decode_imm imm_decoder (\n        .clk(clk),\n        .rst(rst),\n        .instruction(instruction),\n        .immediate(immediate_out)\n    );\n\n    assign op_type = op_type_out;\n    assign dest_reg = dest_reg_out;\n    assign immediate = immediate_out;\n\nendmodule\n\nmodule decode_op (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [6:0] op_type\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            op_type <= 0;\n        end else begin\n            op_type <= instruction[6:0]; // Extract the operation type\n        end\n    end\nendmodule\n\nmodule decode_dest (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [4:0] dest_reg\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            dest_reg <= 0;\n        end else begin\n            dest_reg <= instruction[11:7]; // Extract the destination register\n        end\n    end\nendmodule\n\nmodule decode_imm (\n    input clk,\n    input rst,\n    input [31:0] instruction,\n    output reg [31:0] immediate\n);\n    always @(posedge clk or negedge rst) begin\n        if (!rst) begin\n            immediate <= 0;\n        end else begin\n            immediate <= instruction[31:20]; // Extract the immediate value\n        end\n    end\nendmodule"}
