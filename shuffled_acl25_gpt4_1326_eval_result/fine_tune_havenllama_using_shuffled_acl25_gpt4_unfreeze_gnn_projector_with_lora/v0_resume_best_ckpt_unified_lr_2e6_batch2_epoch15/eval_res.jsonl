{"task_id": 21, "response": "module ripple_carry_adder_8bit(A, B, Cin, S, Cout); \ninput [7:0] A, B; \ninput Cin; \noutput [7:0] S; \noutput Cout; \nwire [1:0] C1, C2; \nwire [1:0] S1, S2; \nwire [1:0] C3, C4; \nwire [1:0] S3, S4; \nwire [1:0] C5, C6; \nwire [1:0] S5, S6; \nwire [1:0] C7, C8; \nwire [1:0] S7, S8; \nwire [1:0] C9, C10; \nwire [1:0] S9, S10; \nwire [1:0] C11, C12; \nwire [1:0] S11, S12; \nwire [1:0] C13, C14; \nwire [1:0] S13, S14; \nwire [1:0] C15, C16; \nwire [1:0] S15, S16; \nwire [1:0] C17, C18; \nwire [1:0] S17, S18; \nwire [1:0] C19, C20; \nwire [1:0] S19, S20; \nwire [1:0] C21, C22; \nwire [1:0] S21, S22; \nwire [1:0] C23, C24; \nwire [1:0] S23, S24; \nwire [1:0] C25, C26; \nwire [1:0] S25, S26; \nwire [1:0] C27, C28; \nwire [1:0] S27, S28; \nwire [1:0] C29, C30; \nwire [1:0] S29, S30; \nwire [1:0] C31, C32; \nwire [1:0] S31, S32; \nwire [1:0] C33, C34; \nwire [1:0] S33, S34; \nwire [1:0] C35, C36; \nwire [1:0] S35, S36; \nwire [1:0] C37, C38; \nwire [1:0] S37, S38; \nwire [1:0] C39, C40; \nwire [1:0] S39, S40; \nwire [1:0] C41, C42; \nwire [1:0] S41, S42; \nwire [1:0] C43, C44; \nwire [1:0] S43, S44; \nwire [1:0] C45, C46; \nwire [1:0] S45, S46; \nwire [1:0] C47, C48; \nwire [1:0] S47, S48; \nwire [1:0] C49, C50; \nwire [1:0] S49, S50; \nwire [1:0] C51, C52; \nwire [1:0] S51, S52; \nwire [1:0] C53, C54; \nwire [1:0] S53, S54; \nwire [1:0] C55, C56; \nwire [1:0] S55, S56; \nwire [1:0] C57, C58; \nwire [1:0] S57, S58; \nwire [1:0] C59, C60; \nwire [1:0] S59, S60; \nwire [1:0] C61, C62; \nwire [1:0]"}
{"task_id": 21, "response": "input [7:0] A, B;\ninput Cin;\noutput [7:0] S;\noutput Cout;\n\nwire [1:0] C1, C2;\n\nassign C1 = Cin;\nassign C2 = C1;\n\nassign S[0] = A[0] ^ B[0] ^ C1;\nassign Cout = (A[0] & B[0]) | (A[0] & C1) | (B[0] & C1);\n\nassign S[1] = A[1] ^ B[1] ^ C2;\nassign Cout = (A[1] & B[1]) | (A[1] & C2) | (B[1] & C2);\n\nassign S[2] = A[2] ^ B[2] ^ C2;\nassign Cout = (A[2] & B[2]) | (A[2] & C2) | (B[2] & C2);\n\nassign S[3] = A[3] ^ B[3] ^ C2;\nassign Cout = (A[3] & B[3]) | (A[3] & C2) | (B[3] & C2);\n\nassign S[4] = A[4] ^ B[4] ^ C2;\nassign Cout = (A[4] & B[4]) | (A[4] & C2) | (B[4] & C2);\n\nassign S[5] = A[5] ^ B[5] ^ C2;\nassign Cout = (A[5] & B[5]) | (A[5] & C2) | (B[5] & C2);\n\nassign S[6] = A[6] ^ B[6] ^ C2;\nassign Cout = (A[6] & B[6]) | (A[6] & C2) | (B[6] & C2);\n\nassign S[7] = A[7] ^ B[7] ^ C2;\nassign Cout = (A[7] & B[7]) | (A[7] & C2) | (B[7] & C2);\n\nendmodule"}
{"task_id": 7, "response": "always @(*) begin\n        case (op)\n            4'b0000: result = a + b;\n            4'b0001: result = a - b;\n            4'b0010: result = a & b;\n            4'b0011: result = a | b;\n            4'b0100: result = a ^ b;\n            4'b0101: result = {a[14:0], 1'b0};\n            4'b0110: result = {1'b0, a[15:1]};\n            4'b0111: result = ~a;\n            default: result = 16'h0000;\n        endcase\n        zero = (result == 16'h0000);\n    end\nendmodule"}
{"task_id": 22, "response": "wire [7:0] binary_count;\n\n    // Binary counter\n    submodule (binary_counter) (\n        .clk(clk),\n        .reset(reset),\n        .binary_count(binary_count)\n    );\n\n    // Binary to Gray converter\n    submodule (binary_to_gray_converter) (\n        .binary_count(binary_count),\n        .gray_count(gray_count)\n    );\n\nendmodule\n\nmodule binary_counter (\n    input wire clk,\n    input wire reset,\n    output reg [7:0] binary_count\n);\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            binary_count <= 8'b00000000;\n        end else begin\n            binary_count <= binary_count + 1;\n        end\n    end\nendmodule\n\nmodule binary_to_gray_converter (\n    input wire [7:0] binary_count,\n    output wire [7:0] gray_count\n);\n    assign gray_count = binary_count ^ (binary_count >> 1);\nendmodule"}
{"task_id": 7, "response": "always @(*) begin\n    case(op)\n        4'b0000: result = a + b;\n        4'b0001: result = a - b;\n        4'b0010: result = a & b;\n        4'b0011: result = a | b;\n        4'b0100: result = a ^ b;\n        4'b0101: result = a << 1;\n        4'b0110: result = a >> 1;\n        4'b0111: result = ~a;\n        default: result = 16'h0000;\n    endcase\n    zero = (result == 16'h0000);\nend\nendmodule"}
{"task_id": 22, "response": "wire [7:0] binary_count;\n\n    // binary_counter\n    submodule (binary_to_gray_converter) (\n        input wire [7:0] binary_count,\n        output wire [7:0] gray_count\n    );\n        assign gray_count = binary_count ^ (binary_count >> 1);\n    endsubmodule\n\n    // binary_to_gray_converter\n    submodule (binary_counter) (\n        input wire clk,\n        input wire reset,\n        output reg [7:0] binary_count\n    );\n        always @(posedge clk or posedge reset) begin\n            if (reset) begin\n                binary_count <= 8'h00;\n            end else begin\n                binary_count <= binary_count + 1;\n            end\n        end\n    endsubmodule\n\nendmodule"}
{"task_id": 23, "response": "input [15:0] data_in; \ninput [3:0] shift_ctrl; \noutput [15:0] data_out; \nreg [15:0] data_out; \nalways @(data_in or shift_ctrl) begin \n    if (shift_ctrl[3]) \n        data_out = data_in >> shift_ctrl[2:0]; \n    else \n        data_out = data_in << shift_ctrl[2:0]; \nend \nendmodule"}
{"task_id": 0, "response": "module magnitude_comparator_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\nwire [7:0] A_greater_8, A_equal_8, A_less_8;\n\nassign {A_greater_8, A_equal_8, A_less_8} = A > B ? {1'b1, 1'b0, 1'b0} : (A == B ? {1'b0, 1'b1, 1'b0} : {1'b0, 1'b0, 1'b1});\n\nalways @(*) begin\n    if (A_greater_8) begin\n        A_greater = 1'b1;\n        A_equal = 1'b0;\n        A_less = 1'b0;\n    end else if (A_equal_8) begin\n        A_greater = 1'b0;\n        A_equal = 1'b1;\n        A_less = 1'b0;\n    end else begin\n        A_greater = 1'b0;\n        A_equal = 1'b0;\n        A_less = 1'b1;\n    end\nend\n\nendmodule\n\nmodule magnitude_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\nwire [7:0] A_higher, B_higher, A_lower, B_lower;\n\nassign {A_higher, A_lower} = A > B ? {A[15:8], A[7:0]} : {B[15:8], B[7:0]};\nassign {B_higher, B_lower} = A > B ? {B[15:8], B[7:0]} : {A[15:8], A[7:0]};\n\nmagnitude_comparator_8bit higher_cmp(.A(A_higher), .B(B_higher), .A_greater(A_greater), .A_equal(A_equal), .A_less(A_less));\nmagnitude_comparator_8bit lower_cmp(.A(A_lower), .B(B_lower), .A_greater(A_greater), .A_equal(A_equal), .A_less(A_less));\n\nendmodule"}
{"task_id": 14, "response": "module alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);\n    wire [15:0] add_module_result;\n    wire [15:0] sub_module_result;\n    wire [15:0] and_module_result;\n    wire [15:0] or_module_result;\n    wire [15:0] xor_module_result;\n    wire [15:0] not_module_result;\n\n    // ADD\n    always @(*) begin\n        add_module_result = input1 + input2;\n    end\n\n    // SUBTRACT\n    always @(*) begin\n        sub_module_result = input1 - input2;\n    end\n\n    // AND\n    always @(*) begin\n        and_module_result = input1 & input2;\n    end\n\n    // OR\n    always @(*) begin\n        or_module_result = input1 | input2;\n    end\n\n    // XOR\n    always @(*) begin\n        xor_module_result = input1 ^ input2;\n    end\n\n    // NOT\n    always @(*) begin\n        not_module_result = ~(input1 | input2);\n    end\n\n    // SELECT\n    always @(*) begin\n        case (op_code)\n            4'b0000: result = add_module_result;\n            4'b0001: result = sub_module_result;\n            4'b0010: result = and_module_result;\n            4'b0011: result = or_module_result;\n            4'b0100: result = xor_module_result;\n            4'b0101: result = not_module_result;\n            default: result = 16'b0;\n        endcase\n    end\nendmodule"}
{"task_id": 0, "response": "module magnitude_comparator_8bit(\n    input [7:0] A,\n    input [7:0] B,\n    output reg A_greater,\n    output reg A_equal,\n    output reg A_less\n);\n\n    always @(*) begin\n        if (A > B) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (A < B) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end\nendmodule\n\nalways @(*) begin\n    if (A[15:8] == B[15:8]) begin\n        if (magnitude_comparator_8bit_higher(A[7:0], B[7:0])) begin\n            A_greater = 1;\n            A_equal = 0;\n            A_less = 0;\n        end else if (magnitude_comparator_8bit_higher(B[7:0], A[7:0])) begin\n            A_greater = 0;\n            A_equal = 0;\n            A_less = 1;\n        end else begin\n            A_greater = 0;\n            A_equal = 1;\n            A_less = 0;\n        end\n    end else if (A[15:8] > B[15:8]) begin\n        A_greater = 1;\n        A_equal = 0;\n        A_less = 0;\n    end else begin\n        A_greater = 0;\n        A_equal = 0;\n        A_less = 1;\n    end\nend\n\nfunction magnitude_comparator_8bit_higher;\n    input [7:0] A;\n    input [7:0] B;\n    begin\n        if (A > B) begin\n            magnitude_comparator_8bit_higher = 1;\n        end else begin\n            magnitude_comparator_8bit_higher = 0;\n        end\n    end\nendfunction\n\nendmodule"}
{"task_id": 23, "response": "input [15:0] data_in; \ninput [3:0] shift_ctrl; \noutput [15:0] data_out; \n\nreg [15:0] data_out; \n\nalways @(data_in or shift_ctrl) begin \n    case (shift_ctrl[3]) \n        1'b0: \n            case (shift_ctrl[2:0]) \n                3'b000: \n                    data_out = data_in; \n                3'b001: \n                    data_out = {data_in[14:0], 1'b0}; \n                3'b010: \n                    data_out = {data_in[13:0], 2'b00}; \n                3'b011: \n                    data_out = {data_in[12:0], 3'b000}; \n                3'b100: \n                    data_out = {data_in[11:0], 4'b0000}; \n                3'b101: \n                    data_out = {data_in[10:0], 5'b00000}; \n                3'b110: \n                    data_out = {data_in[9:0], 6'b000000}; \n                3'b111: \n                    data_out = {data_in[8:0], 7'b0000000}; \n                default: \n                    data_out = data_in; \n            endcase \n        1'b1: \n            case (shift_ctrl[2:0]) \n                3'b000: \n                    data_out = data_in; \n                3'b001: \n                    data_out = {1'b0, data_in[15:1]}; \n                3'b010: \n                    data_out = {2'b00, data_in[15:2]}; \n                3'b011: \n                    data_out = {3'b000, data_in[15:3]}; \n                3'b100: \n                    data_out = {4'b0000, data_in[15:4]}; \n                3'b101: \n                    data_out = {5'b00000, data_in[15:5]}; \n                3'b110: \n                    data_out = {6'b000000, data_in[15:6]}; \n                3'b111: \n                    data_out = {7'b0000000, data_in[15:7]}; \n                default: \n                    data_out = data_in; \n            endcase \n        default: \n            data_out = data_in; \n    endcase \nend \nendmodule"}
{"task_id": 14, "response": "module alu_16bit(\n    input [15:0] input1,\n    input [15:0] input2,\n    input [3:0] op_code,\n    output reg [15:0] result\n);\n    wire [15:0] add_module_result;\n    wire [15:0] sub_module_result;\n    wire [15:0] and_module_result;\n    wire [15:0] or_module_result;\n    wire [15:0] xor_module_result;\n    wire [15:0] not_module_result;\n\n    // ADD module\n    always @(*) begin\n        add_module_result = input1 + input2;\n    end\n\n    // SUBTRACT module\n    always @(*) begin\n        sub_module_result = input1 - input2;\n    end\n\n    // AND module\n    always @(*) begin\n        and_module_result = input1 & input2;\n    end\n\n    // OR module\n    always @(*) begin\n        or_module_result = input1 | input2;\n    end\n\n    // XOR module\n    always @(*) begin\n        xor_module_result = input1 ^ input2;\n    end\n\n    // NOT module\n    always @(*) begin\n        not_module_result = ~input1;\n    end\n\n    // MAIN ALU module\n    always @(*) begin\n        case (op_code)\n            4'b0000: result = add_module_result;\n            4'b0001: result = sub_module_result;\n            4'b0010: result = and_module_result;\n            4'b0011: result = or_module_result;\n            4'b0100: result = xor_module_result;\n            4'b0101: result = not_module_result;\n            default: result = 16'h0000;\n        endcase\n    end\nendmodule"}
{"task_id": 8, "response": "parameter integer MATRIX_WIDTH = 4;\n    parameter integer PE_WIDTH = 8;\n    parameter integer PE_DEPTH = 2;\n    localparam integer PE_WIDTH_LOG2 = PE_WIDTH >> 1;\n    localparam integer PE_DEPTH_LOG2 = PE_DEPTH >> 1;\n\n    reg [PE_WIDTH_LOG2:0] pe00_a [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe01_a [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe10_a [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe11_a [PE_DEPTH_LOG2:0];\n\n    reg [PE_WIDTH_LOG2:0] pe00_b [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe01_b [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe10_b [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe11_b [PE_DEPTH_LOG2:0];\n\n    integer i;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            for (i = 0; i < PE_WIDTH_LOG2; i = i + 1) begin\n                pe00_a[i] <= 0;\n                pe01_a[i] <= 0;\n                pe10_a[i] <= 0;\n                pe11_a[i] <= 0;\n                pe00_b[i] <= 0;\n                pe01_b[i] <= 0;\n                pe10_b[i] <= 0;\n                pe11_b[i] <= 0;\n            end\n        end else begin\n            for (i = 0; i < PE_WIDTH_LOG2; i = i + 1) begin\n                pe00_a[i] <= a00[i];\n                pe01_a[i] <= a01[i];\n                pe10_a[i] <= a10[i];\n                pe11_a[i] <= a11[i];\n                pe00_b[i] <= b00[i];\n                pe01_b[i] <= b01[i];\n                pe10_b[i] <= b10[i];\n                pe11_b[i] <= b11[i];\n            end\n        end\n    end\n\n    reg [PE_WIDTH_LOG2:0] pe00_c [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe01_c [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe10_c [PE_DEPTH_LOG2:0];\n    reg [PE_WIDTH_LOG2:0] pe11_c [PE_DEPTH_LOG2:0];\n\n    always @(posedge clk) begin\n        pe00_c[0] <= pe00_a[0] + pe00_b[0];\n        for (i = 1; i < PE_WIDTH_LOG2; i = i + 1) begin\n            pe00_c[i] <= pe00_a[i] + pe00_b[i];\n        end\n        pe01_c[0] <= pe01_a[0] + pe01_b[0];\n        for (i = 1; i < PE_WIDTH_LOG2; i = i + 1) begin\n            pe01_c[i] <= pe01_a[i] + pe01_b[i];\n        end\n        pe10_c[0] <= pe10_a[0] + pe10_b[0];\n        for (i = 1; i < PE_WIDTH_LOG2"}
{"task_id": 8, "response": "parameter integer ID = 0;\n\n    reg [15:0] c00, c01, c10, c11;\n    wire [7:0] a00_r, a01_r, a10_r, a11_r, b00_r, b01_r, b10_r, b11_r;\n\n    always @(posedge clk) begin\n        if (rst) begin\n            c00 = 16'b0;\n            c01 = 16'b0;\n            c10 = 16'b0;\n            c11 = 16'b0;\n        end\n        else begin\n            a00_r = a00;\n            a01_r = a01;\n            a10_r = a10;\n            a11_r = a11;\n            b00_r = b00;\n            b01_r = b01;\n            b10_r = b10;\n            b11_r = b11;\n            c00 = a00_r * b00_r;\n            c01 = a01_r * b01_r;\n            c10 = a10_r * b10_r;\n            c11 = a11_r * b11_r;\n        end\n    end\n\nendmodule"}
{"task_id": 15, "response": "wire [3:0] A_greater_4bit, A_equal_4bit, A_less_4bit;\n\n    comparator_4bit comp0(\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .A_greater(A_greater_4bit[0]),\n        .A_equal(A_equal_4bit[0]),\n        .A_less(A_less_4bit[0])\n    );\n\n    comparator_4bit comp1(\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .A_greater(A_greater_4bit[1]),\n        .A_equal(A_equal_4bit[1]),\n        .A_less(A_less_4bit[1])\n    );\n\n    comparator_4bit comp2(\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .A_greater(A_greater_4bit[2]),\n        .A_equal(A_equal_4bit[2]),\n        .A_less(A_less_4bit[2])\n    );\n\n    comparator_4bit comp3(\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .A_greater(A_greater_4bit[3]),\n        .A_equal(A_equal_4bit[3]),\n        .A_less(A_less_4bit[3])\n    );\n\n    assign A_greater = |A_greater_4bit;\n    assign A_equal = &A_greater_4bit & &A_equal_4bit;\n    assign A_less = &A_greater_4bit & &A_less_4bit;\n\nendmodule\n\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\n\nendmodule"}
{"task_id": 1, "response": "wire [15:0] rca_sum0, rca_sum1, rca_carry0, rca_carry1;\n    wire [3:0] mux_carry0, mux_carry1;\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .sum(rca_sum1),\n        .carry(rca_carry1)\n    );\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder2 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder3 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .sum(rca_sum1),\n        .carry(rca_carry1)\n    );\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder4 (\n        .a(rca_sum0),\n        .b(rca_sum1),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder5 (\n        .a(rca_carry0),\n        .b(rca_carry1),\n        .sum(rca_sum1),\n        .carry(rca_carry1)\n    );\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder6 (\n        .a(rca_sum0),\n        .b(rca_sum1),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder7 (\n        .a(rca_carry0),\n        .b(rca_carry1),\n        .sum(rca_sum1),\n        .carry(rca_carry1)\n    );\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder8 (\n        .a(rca_sum0),\n        .b(rca_sum1),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder9 (\n        .a(rca_carry0),\n        .b(rca_carry1),\n        .sum(rca_sum1),\n        .carry(rca_carry1)\n    );\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder10 (\n        .a(rca_sum0),\n        .b(rca_sum1),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder11 (\n        .a(rca_carry0),\n        .b(rca_carry1),\n        .sum(rca_sum1),\n        .carry(rca_carry1)\n    );\n\n    // 4-bit ripple carry adders\n    adder_4bit_rca adder12 (\n        .a(rca_sum0),\n        .b(rca_sum1),\n        .sum(rca_sum0),\n        .carry(rca_carry0)\n    );\n    adder_4bit_rca adder13 (\n        .a(rca_carry0),\n        .b("}
{"task_id": 9, "response": "module bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);\n\n    reg [3:0] count_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            count_reg <= 4'b0000;\n        end else if (enable) begin\n            if (up_down) begin\n                if (count_reg == 4'b1000) begin\n                    count_reg <= 4'b0000;\n                end else begin\n                    count_reg <= count_reg + 1;\n                end\n            end else begin\n                if (count_reg == 4'b0000) begin\n                    count_reg <= 4'b1000;\n                end else begin\n                    count_reg <= count_reg - 1;\n                end\n            end\n        end\n    end\n\n    assign count = count_reg;\nendmodule\n\nmodule bcd_correction (\n    input wire [3:0] count,\n    output wire [3:0] corrected_count\n); ASSISTANT: module bcd_correction (\n    input wire [3:0] count,\n    output wire [3:0] corrected_count\n);\n\n    assign corrected_count = (count > 4'b0100) ? count - 4'b0010 :\n                             (count < 4'b1000) ? count + 4'b0010 :\n                             count;\nendmodule"}
{"task_id": 24, "response": "module alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] and_result;\n    wire [15:0] or_result;\n    wire [15:0] xor_result;\n    wire [15:0] beq_result;\n    wire [15:0] blt_result;\n\n    wire add_carry;\n    wire sub_carry;\n    wire and_carry;\n    wire or_carry;\n    wire xor_carry;\n    wire beq_carry;\n    wire blt_carry;\n\n    wire add_zero;\n    wire sub_zero;\n    wire and_zero;\n    wire or_zero;\n    wire xor_zero;\n    wire beq_zero;\n    wire blt_zero;\n\n    wire add_negative;\n    wire sub_negative;\n    wire and_negative;\n    wire or_negative;\n    wire xor_negative;\n    wire beq_negative;\n    wire blt_negative;\n\n    wire [15:0] add_module_result;\n    wire [15:0] sub_module_result;\n    wire [15:0] and_module_result;\n    wire [15:0] or_module_result;\n    wire [15:0] xor_module_result;\n    wire [15:0] beq_module_result;\n    wire [15:0] blt_module_result;\n\n    wire [15:0] add_module_carry;\n    wire [15:0] sub_module_carry;\n    wire [15:0] and_module_carry;\n    wire [15:0] or_module_carry;\n    wire [15:0] xor_module_carry;\n    wire [15:0] beq_module_carry;\n    wire [15:0] blt_module_carry;\n\n    wire [15:0] add_module_zero;\n    wire [15:0] sub_module_zero;\n    wire [15:0] and_module_zero;\n    wire [15:0] or_module_zero;\n    wire [15:0] xor_module_zero;\n    wire [15:0] beq_module_zero;\n    wire [15:0] blt_module_zero;\n\n    wire [15:0] add_module_negative;\n    wire [15:0] sub_module_negative;\n    wire [15:0] and_module_negative;\n    wire [15:0] or_module_negative;\n    wire [15:0] xor_module_negative;\n    wire [15:0] beq_module_negative;\n    wire [15:0] blt_module_negative;\n\n    assign add_result = a + b;\n    assign sub_result = a - b;\n    assign and_result = a & b;\n    assign or_result = a | b;\n    assign xor_result = a ^ b;\n    assign beq_result = (a == b) ? 16'h0000 : 16'hffff;\n    assign blt_result = (a < b) ? 16'h0000 : 16'hffff;\n\n    assign add_carry = (a[15] == b[15]) ? 1'b0 : a[15];\n    assign sub_carry = (a[15] == b[15]) ? 1'b0 : a[15];\n    assign and_carry = a[15] & b[15];\n    assign or_carry = a[15] | b[15];\n    assign xor_carry = a[15] ^ b[15];\n    assign beq_carry = ("}
{"task_id": 15, "response": "wire [3:0] A_greater_comp, A_equal_comp, A_less_comp;\n\n    comparator_4bit comp0 (\n        .A(A[15:12]),\n        .B(B[15:12]),\n        .A_greater(A_greater_comp[0]),\n        .A_equal(A_equal_comp[0]),\n        .A_less(A_less_comp[0])\n    );\n\n    comparator_4bit comp1 (\n        .A(A[11:8]),\n        .B(B[11:8]),\n        .A_greater(A_greater_comp[1]),\n        .A_equal(A_equal_comp[1]),\n        .A_less(A_less_comp[1])\n    );\n\n    comparator_4bit comp2 (\n        .A(A[7:4]),\n        .B(B[7:4]),\n        .A_greater(A_greater_comp[2]),\n        .A_equal(A_equal_comp[2]),\n        .A_less(A_less_comp[2])\n    );\n\n    comparator_4bit comp3 (\n        .A(A[3:0]),\n        .B(B[3:0]),\n        .A_greater(A_greater_comp[3]),\n        .A_equal(A_equal_comp[3]),\n        .A_less(A_less_comp[3])\n    );\n\n    assign A_greater = A_greater_comp[3] | A_greater_comp[2] | A_greater_comp[1] | A_greater_comp[0];\n    assign A_equal = A_equal_comp[3] & A_equal_comp[2] & A_equal_comp[1] & A_equal_comp[0];\n    assign A_less = A_less_comp[3] & A_less_comp[2] & A_less_comp[1] & A_less_comp[0];\n\nendmodule\n\nmodule comparator_4bit(\n    input [3:0] A,\n    input [3:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n); ASSISTANT:\n\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\n\nendmodule"}
{"task_id": 1, "response": "wire [3:0] carry;\n    wire [3:0] rca_sum;\n    wire [15:0] rca_carry;\n    wire [15:0] mux_sum;\n    wire [15:0] mux_carry;\n\n    // 4-bit ripple carry adder\n    ripple_carry adder0 (\n        .a(a[3:0]),\n        .b(b[3:0]),\n        .sum(rca_sum[0]),\n        .carry(carry[0])\n    );\n    ripple_carry adder1 (\n        .a(a[7:4]),\n        .b(b[7:4]),\n        .sum(rca_sum[1]),\n        .carry(carry[1])\n    );\n    ripple_carry adder2 (\n        .a(a[11:8]),\n        .b(b[11:8]),\n        .sum(rca_sum[2]),\n        .carry(carry[2])\n    );\n    ripple_carry adder3 (\n        .a(a[15:12]),\n        .b(b[15:12]),\n        .sum(rca_sum[3]),\n        .carry(carry[3])\n    );\n\n    // 4-bit ripple carry adder carry-out\n    assign rca_carry = {carry[3], carry[2], carry[1], carry[0]};\n\n    // 4-bit ripple carry adder sum\n    assign rca_sum = {rca_sum[3], rca_sum[2], rca_sum[1], rca_sum[0]};\n\n    // 4-bit ripple carry adder multiplexer\n    assign mux_sum = {rca_sum[3], rca_sum[2], rca_sum[1], rca_sum[0]};\n    assign mux_carry = {rca_carry[3], rca_carry[2], rca_carry[1], rca_carry[0]};\n\n    // 16-bit carry-select adder\n    assign sum = {mux_sum[15], mux_sum[14], mux_sum[13], mux_sum[12], mux_sum[11], mux_sum[10], mux_sum[9], mux_sum[8], mux_sum[7], mux_sum[6], mux_sum[5], mux_sum[4], mux_sum[3], mux_sum[2], mux_sum[1], mux_sum[0]};\n\nendmodule"}
{"task_id": 9, "response": "submodule correction_unit (\n    input wire [3:0] count,\n    output wire [3:0] count_corrected\n);\n    always @(count)\n    begin\n        case (count)\n            4'b1000: count_corrected = 4'b0111;\n            4'b1001: count_corrected = 4'b0110;\n            4'b1010: count_corrected = 4'b0101;\n            4'b1011: count_corrected = 4'b0100;\n            4'b1100: count_corrected = 4'b0011;\n            4'b1101: count_corrected = 4'b0010;\n            4'b1110: count_corrected = 4'b0001;\n            4'b1111: count_corrected = 4'b0000;\n            default: count_corrected = count;\n        endcase\n    end\nendmodule\n\nmodule correction_unit (\n    input wire [3:0] count,\n    output wire [3:0] count_corrected\n);\n    always @(*)\n    begin\n        case (count)\n            4'b1000: count_corrected = 4'b0111;\n            4'b1001: count_corrected = 4'b0110;\n            4'b1010: count_corrected = 4'b0101;\n            4'b1011: count_corrected = 4'b0100;\n            4'b1100: count_corrected = 4'b0011;\n            4'b1101: count_corrected = 4'b0010;\n            4'b1110: count_corrected = 4'b0001;\n            4'b1111: count_corrected = 4'b0000;\n            default: count_corrected = count;\n        endcase\n    end\nendmodule\n\nmodule bcd_counter (\n    input wire clk,\n    input wire reset,\n    input wire enable,\n    input wire up_down,\n    output wire [3:0] count\n);\n    reg [3:0] count_reg;\n\n    always @(posedge clk)\n    begin\n        if (reset)\n            count_reg <= 4'b0000;\n        else if (enable)\n            if (up_down)\n                if (count_reg == 4'b1000)\n                    count_reg <= 4'b0000;\n                else\n                    count_reg <= count_reg + 1;\n            else\n                if (count_reg == 4'b0000)\n                    count_reg <= 4'b1000;\n                else\n                    count_reg <= count_reg - 1;\n    end\n\n    correction_unit correction_unit_inst (\n        .count(count_reg),\n        .count_corrected(count)\n    );\nendmodule"}
{"task_id": 24, "response": "module alu_16bit(\n    input [15:0] a,\n    input [15:0] b,\n    input [3:0] opcode,\n    output reg [15:0] result,\n    output zero,\n    output carry,\n    output negative\n);\n    wire [15:0] add_result;\n    wire [15:0] sub_result;\n    wire [15:0] and_result;\n    wire [15:0] or_result;\n    wire [15:0] xor_result;\n    wire [15:0] beq_result;\n    wire [15:0] blt_result;\n\n    wire [15:0] add_carry;\n    wire [15:0] sub_carry;\n    wire [15:0] and_carry;\n    wire [15:0] or_carry;\n    wire [15:0] xor_carry;\n    wire [15:0] beq_carry;\n    wire [15:0] blt_carry;\n\n    wire [15:0] add_zero;\n    wire [15:0] sub_zero;\n    wire [15:0] and_zero;\n    wire [15:0] or_zero;\n    wire [15:0] xor_zero;\n    wire [15:0] beq_zero;\n    wire [15:0] blt_zero;\n\n    wire [15:0] add_negative;\n    wire [15:0] sub_negative;\n    wire [15:0] and_negative;\n    wire [15:0] or_negative;\n    wire [15:0] xor_negative;\n    wire [15:0] beq_negative;\n    wire [15:0] blt_negative;\n\n    wire [15:0] add_sub_result;\n    wire [15:0] and_or_result;\n    wire [15:0] xor_result_final;\n    wire [15:0] beq_blt_result;\n\n    wire [15:0] add_sub_carry;\n    wire [15:0] and_or_carry;\n    wire [15:0] xor_carry_final;\n    wire [15:0] beq_blt_carry;\n\n    wire [15:0] add_sub_zero;\n    wire [15:0] and_or_zero;\n    wire [15:0] xor_zero_final;\n    wire [15:0] beq_blt_zero;\n\n    wire [15:0] add_sub_negative;\n    wire [15:0] and_or_negative;\n    wire [15:0] xor_negative_final;\n    wire [15:0] beq_blt_negative;\n\n    wire [15:0] add_sub_result_final;\n    wire [15:0] and_or_result_final;\n    wire [15:0] xor_result_final_final;\n    wire [15:0] beq_blt_result_final;\n\n    wire [15:0] add_sub_carry_final;\n    wire [15:0] and_or_carry_final;\n    wire [15:0] xor_carry_final_final;\n    wire [15:0] beq_blt_carry_final;\n\n    wire [15:0] add_sub_zero_final;\n    wire [15:0] and_or_zero_final;\n    wire [15:0] xor_zero_final_final;\n    wire [15:0] beq_blt_zero_final;\n\n    wire [15:0] add_sub_negative_final;\n    wire [15:0] and_or_negative_final;\n    wire [15:0] xor_negative_final_final;\n    wire [15:0] beq_blt_negative_final;\n\n    wire [15:0] add_sub_result_final"}
{"task_id": 2, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_60,\n    output CLK_30,\n    output CLK_15,\n    output CLK_3\n);\n\n    wire [3:0] counter;\n\n    // div_by_2\n    reg [3:0] div_by_2_counter;\n    assign CLK_60 = CLK_in & ~div_by_2_counter[3];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            div_by_2_counter <= 4'b0;\n        end else begin\n            div_by_2_counter <= div_by_2_counter + 1;\n        end\n    end\n\n    // div_by_4\n    reg [3:0] div_by_4_counter;\n    assign CLK_30 = CLK_in & ~div_by_4_counter[3];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            div_by_4_counter <= 4'b0;\n        end else if (div_by_2_counter == 4'b10) begin\n            div_by_4_counter <= div_by_4_counter + 1;\n        end\n    end\n\n    // div_by_8\n    reg [3:0] div_by_8_counter;\n    assign CLK_15 = CLK_in & ~div_by_8_counter[3];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            div_by_8_counter <= 4'b0;\n        end else if (div_by_4_counter == 4'b10) begin\n            div_by_8_counter <= div_by_8_counter + 1;\n        end\n    end\n\n    // div_by_40\n    reg [3:0] div_by_40_counter;\n    assign CLK_3 = CLK_in & ~div_by_40_counter[3];\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            div_by_40_counter <= 4'b0;\n        end else if (div_by_8_counter == 4'b19) begin\n            div_by_40_counter <= div_by_40_counter + 1;\n        end\n    end\n\nendmodule"}
{"task_id": 16, "response": "input [31:0] a, b;\ninput cin;\noutput [31:0] sum;\noutput cout;\n\nwire [7:0] a0, a1, a2, a3;\nwire [7:0] b0, b1, b2, b3;\nwire [7:0] c0, c1, c2, c3;\nwire [7:0] s0, s1, s2, s3;\nwire [7:0] c4, c5, c6, c7;\nwire [7:0] s4, s5, s6, s7;\nwire [7:0] c8, c9, c10, c11;\nwire [7:0] s8, s9, s10, s11;\nwire [7:0] c12, c13, c14, c15;\nwire [7:0] s12, s13, s14, s15;\nwire [7:0] c16, c17, c18, c19;\nwire [7:0] s16, s17, s18, s19;\nwire [7:0] c20, c21, c22, c23;\nwire [7:0] s20, s21, s22, s23;\nwire [7:0] c24, c25, c26, c27;\nwire [7:0] s24, s25, s26, s27;\nwire [7:0] c28, c29, c30, c31;\nwire [7:0] s28, s29, s30, s31;\n\nassign a0 = a[0];\nassign a1 = a[1];\nassign a2 = a[2];\nassign a3 = a[3];\nassign b0 = b[0];\nassign b1 = b[1];\nassign b2 = b[2];\nassign b3 = b[3];\nassign c0 = cin;\nassign c1 = a0 & b0;\nassign c2 = a1 & b1;\nassign c3 = a2 & b2;\nassign c4 = a3 & b3;\nassign c5 = a0 | b0;\nassign c6 = a1 | b1;\nassign c7 = a2 | b2;\nassign c8 = a3 | b3;\nassign c9 = c1 | c2;\nassign c10 = c3 | c4;\nassign c11 = c5 | c6;\nassign c12 = c7 | c8;\nassign c13 = c9 | c10;\nassign c14 = c11 | c12;\nassign c15 = c13 | c14;\nassign c16 = c5 & c6;\nassign c17 = c7 & c8;\nassign c18 = c9 & c10;\nassign c19 = c11 & c12;\nassign c20 = c13 & c14;\nassign c21 = c15 & c16;\nassign c22 = c17 & c18;\nassign c23 = c19 & c20;\nassign c24 = c15 & c16;\nassign c25 = c17 & c18;\nassign c26 = c19 & c20;\nassign c27 = c21 & c22;\nassign c28 = c23 & c24;\nassign c29 = c25 & c26;\nassign c30 = c27 & c28;\nassign c31 = c29 & c30;\nassign s0 = a0 ^ b0;\nassign s1 = a1 ^ b1;\nassign s2 = a2 ^ b2;\nassign s3 = a3 ^ b3;\nassign s4 = c1 ^ c2;\nassign s5 = c3 ^ c4;\nassign s6 = c5 ^ c6;\nassign s7 = c7 ^ c8;\nassign s8 = c9 ^ c10;\nassign s9 = c11 ^ c12;\nassign s10 = c13 ^ c14;\nassign s11"}
{"task_id": 25, "response": "module pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);\n\nreg [15:0] stage1_out;\nreg [15:0] stage2_out;\nreg [15:0] stage3_out;\nreg [15:0] stage4_out;\nreg [15:0] stage5_out;\n\n// Fetch stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage1_out <= 16'b0;\n    end else begin\n        stage1_out <= {opcode, inputA, inputB};\n    end\nend\n\n// Decode stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage2_out <= 16'b0;\n    end else begin\n        case (opcode)\n            2'b00: stage2_out <= stage1_out[15:0] + stage1_out[15:0];\n            2'b01: stage2_out <= stage1_out[15:0] - stage1_out[15:0];\n            2'b10: stage2_out <= stage1_out[15:0] & stage1_out[15:0];\n            2'b11: stage2_out <= stage1_out[15:0] | stage1_out[15:0];\n            default: stage2_out <= 16'b0;\n        endcase\n    end\nend\n\n// Execute stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage3_out <= 16'b0;\n    end else begin\n        stage3_out <= stage2_out;\n    end\nend\n\n// Memory stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage4_out <= 16'b0;\n    end else begin\n        stage4_out <= stage3_out;\n    end\nend\n\n// Writeback stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage5_out <= 16'b0;\n    end else begin\n        stage5_out <= stage4_out;\n    end\nend\n\n// Output stage\nassign outputResult = stage5_out;\n\nendmodule"}
{"task_id": 10, "response": "wire [7:0] a0, a1, a2, a3, a4, a5, a6, a7;\n    wire [7:0] b0, b1, b2, b3, b4, b5, b6, b7;\n    wire [7:0] g0, g1, g2, g3, g4, g5, g6, g7;\n    wire [7:0] p0, p1, p2, p3, p4, p5, p6, p7;\n    wire [7:0] c0, c1, c2, c3, c4, c5, c6, c7;\n    wire [7:0] c8;\n\n    assign a0 = a[0 +: 8];\n    assign a1 = a[8 +: 8];\n    assign a2 = a[16 +: 8];\n    assign a3 = a[24 +: 8];\n    assign a4 = a[32 +: 8];\n    assign a5 = a7;\n    assign a6 = a6;\n    assign a7 = a[31];\n\n    assign b0 = b[0 +: 8];\n    assign b1 = b[8 +: 8];\n    assign b2 = b[16 +: 8];\n    assign b3 = b[24 +: 8];\n    assign b4 = b[32 +: 8];\n    assign b5 = b7;\n    assign b6 = b6;\n    assign b7 = b[31];\n\n    assign g0 = a0 & b0;\n    assign g1 = a1 & b1;\n    assign g2 = a2 & b2;\n    assign g3 = a3 & b3;\n    assign g4 = a4 & b4;\n    assign g5 = a5 & b5;\n    assign g6 = a6 & b6;\n    assign g7 = a7 & b7;\n\n    assign p0 = a0 ^ b0;\n    assign p1 = a1 ^ b1;\n    assign p2 = a2 ^ b2;\n    assign p3 = a3 ^ b3;\n    assign p4 = a4 ^ b4;\n    assign p5 = a5 ^ b5;\n    assign p6 = a6 ^ b6;\n    assign p7 = a7 ^ b7;\n\n    assign c0 = g0 | (p0 & cin);\n    assign c1 = g1 | (p1 & c0);\n    assign c2 = g2 | (p2 & c1);\n    assign c3 = g3 | (p3 & c2);\n    assign c4 = g4 | (p4 & c3);\n    assign c5 = g5 | (p5 & c4);\n    assign c6 = g6 | (p6 & c5);\n    assign c7 = g7 | (p7 & c6);\n\n    assign c8 = c7;\n\n    assign sum = {c8, c7, c6, c5, c4, c3, c2, c1, c0, a7, a6, a5, a4, a3, a2, a1, a0};\n    assign cout = c8;\n\nendmodule"}
{"task_id": 16, "response": "input [31:0] a, b; \ninput cin; \noutput [31:0] sum; \noutput cout; \nwire [7:0] ca, cb, co; \nwire [31:0] sa, sb; \n\ncarry_lookahead_adder_8bit c1 (sa[7:0], sb[7:0], ca, co); \ncarry_lookahead_adder_8bit c2 (sa[15:8], sb[15:8], ca, co); \ncarry_lookahead_adder_8bit c3 (sa[23:16], sb[23:16], ca, co); \ncarry_lookahead_adder_8bit c4 (sa[31:24], sb[31:24], ca, cout); \n\nassign sum = sa; \nassign ca = co; \n\nendmodule"}
{"task_id": 2, "response": "`\n\n    reg [0:3] counter_60;\n    reg [0:3] counter_30;\n    reg [0:3] counter_15;\n    reg [0:3] counter_3;\n\n    reg [0:3] div_by_2;\n    reg [0:3] div_by_4;\n    reg [0:3] div_by_8;\n    reg [0:3] div_by_40;\n\n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter_60 <= 0;\n            counter_30 <= 0;\n            counter_15 <= 0;\n            counter_3 <= 0;\n            div_by_2 <= 0;\n            div_by_4 <= 0;\n            div_by_8 <= 0;\n            div_by_40 <= 0;\n        end else begin\n            counter_60 <= counter_60 + 1;\n            counter_30 <= counter_30 + 1;\n            counter_15 <= counter_15 + 1;\n            counter_3 <= counter_3 + 1;\n            div_by_2 <= div_by_2 + 1;\n            div_by_4 <= div_by_4 + 1;\n            div_by_8 <= div_by_8 + 1;\n            div_by_40 <= div_by_40 + 1;\n        end\n    end\n\n    assign CLK_60 = CLK_in & (counter_60 == 1);\n    assign CLK_30 = CLK_in & (counter_30 == 1);\n    assign CLK_15 = CLK_in & (counter_15 == 1);\n    assign CLK_3 = CLK_in & (counter_3 == 1);\n\nendmodule\n\nmodule div_by_2 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [0:3] counter;\n\n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign CLK_out = CLK_in & (counter == 1);\n\nendmodule\n\nmodule div_by_4 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [0:3] counter;\n\n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign CLK_out = CLK_in & (counter == 1);\n\nendmodule\n\nmodule div_by_8 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [0:3] counter;\n\n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign CLK_out = CLK_in & (counter == 1);\n\nendmodule\n\nmodule div_by_40 (\n    input CLK_in,\n    input RST,\n    output CLK_out\n);\n\n    reg [0:3] counter;\n\n    always @(posedge CLK_in) begin\n        if (RST) begin\n            counter <= 0;\n        end else begin\n            counter <= counter + 1;\n        end\n    end\n\n    assign CLK_out = CLK_in & (counter == 1);\n\nendmodule\n`"}
{"task_id": 25, "response": "module pipelineALU5(\n    input clk,\n    input rst,\n    input [1:0] opcode,\n    input [15:0] inputA,\n    input [15:0] inputB,\n    output [15:0] outputResult\n);\n\nreg [15:0] stage1_output;\nreg [15:0] stage2_output;\nreg [15:0] stage3_output;\nreg [15:0] stage4_output;\nreg [15:0] stage5_output;\n\n// Fetch Stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage1_output <= 16'h0000;\n    end else begin\n        case (opcode)\n            2'b00: stage1_output <= inputA;\n            2'b01: stage1_output <= inputA - inputB;\n            2'b10: stage1_output <= inputA & inputB;\n            2'b11: stage1_output <= inputA | inputB;\n            default: stage1_output <= 16'h0000;\n        endcase\n    end\nend\n\n// Decode Stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage2_output <= 16'h0000;\n    end else begin\n        stage2_output <= stage1_output;\n    end\nend\n\n// Execute Stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage3_output <= 16'h0000;\n    end else begin\n        case (opcode)\n            2'b00: stage3_output <= stage1_output + stage2_output;\n            2'b01: stage3_output <= stage1_output - stage2_output;\n            2'b10: stage3_output <= stage1_output & stage2_output;\n            2'b11: stage3_output <= stage1_output | stage2_output;\n            default: stage3_output <= 16'h0000;\n        endcase\n    end\nend\n\n// Memory Stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage4_output <= 16'h0000;\n    end else begin\n        stage4_output <= stage3_output;\n    end\nend\n\n// Writeback Stage\nalways @(posedge clk) begin\n    if (rst) begin\n        stage5_output <= 16'h0000;\n    end else begin\n        stage5_output <= stage4_output;\n    end\nend\n\n// Output Stage\nassign outputResult = stage5_output;\n\nendmodule"}
{"task_id": 17, "response": "wire wave1_out_internal, wave2_out_internal;\n\n    // Instantiate the basic wave generator\n    basic_wave_gen wave1_gen(\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave1_out_internal)\n    );\n\n    // Instantiate the phase controller\n    phase_ctrl phase_ctrl_inst(\n        .clk(clk),\n        .reset(reset),\n        .phase_shift(phase_shift),\n        .wave_in(wave2_out_internal),\n        .wave_out(wave2_out)\n    );\n\n    // Instantiate the second basic wave generator\n    basic_wave_gen wave2_gen(\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave2_out_internal)\n    );\n\nendmodule\n\nmodule basic_wave_gen(\n    input clk,\n    input reset,\n    output wave_out\n);\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            wave_out_reg <= 1'b0;\n        end else begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n\n    assign wave_out = wave_out_reg;\nendmodule\n\nmodule phase_ctrl(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    input wave_in,\n    output wave_out\n);\n    reg [3:0] phase_shift_reg;\n    reg wave_out_reg;\n\n    always @(posedge clk) begin\n        if (reset) begin\n            phase_shift_reg <= 4'b0;\n            wave_out_reg <= 1'b0;\n        end else begin\n            if (phase_shift_reg == phase_shift) begin\n                wave_out_reg <= wave_in;\n            end else begin\n                phase_shift_reg <= phase_shift_reg + 1'b1;\n            end\n        end\n    end\n\n    assign wave_out = wave_out_reg;\nendmodule"}
{"task_id": 3, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);\n\nreg [0:3] count_33;\nreg [0:4] count_20;\nreg [0:4] count_5;\nreg [0:4] count_2;\n\nreg CLK_33_reg;\nreg CLK_20_reg;\nreg CLK_5_reg;\nreg CLK_2_reg;\n\nalways @(posedge CLK_in) begin\n    if (RST) begin\n        count_33 <= 0;\n        count_20 <= 0;\n        count_5 <= 0;\n        count_2 <= 0;\n        CLK_33_reg <= 0;\n        CLK_20_reg <= 0;\n        CLK_5_reg <= 0;\n        CLK_2_reg <= 0;\n    end else begin\n        if (count_33 == 9) begin\n            count_33 <= 0;\n            CLK_33_reg <= ~CLK_33_reg;\n        end else begin\n            count_33 <= count_33 + 1;\n        end\n        if (count_20 == 19) begin\n            count_20 <= 0;\n            CLK_20_reg <= ~CLK_20_reg;\n        end else begin\n            count_20 <= count_20 + 1;\n        end\n        if (count_5 == 9) begin\n            count_5 <= 0;\n            CLK_5_reg <= ~CLK_5_reg;\n        end else begin\n            count_5 <= count_5 + 1;\n        end\n        if (count_2 == 9) begin\n            count_2 <= 0;\n            CLK_2_reg <= ~CLK_2_reg;\n        end else begin\n            count_2 <= count_2 + 1;\n        end\n    end\nend\n\nassign CLK_33 = CLK_33_reg;\nassign CLK_20 = CLK_20_reg;\nassign CLK_5 = CLK_5_reg;\nassign CLK_2 = CLK_2_reg;\n\nendmodule"}
{"task_id": 26, "response": "wire [31:0] A_extended, B_extended;\nwire [31:0] A_greater_B, A_equal_B, A_less_B;\n\nextend_sign_16bit extend_sign_16bit_inst1(\n    .A(A),\n    .B(B),\n    .A_extended(A_extended),\n    .B_extended(B_extended)\n);\n\ncomparator_32bit comparator_32bit_inst1(\n    .A_extended(A_extended),\n    .B_extended(B_extended),\n    .A_greater_B(A_greater_B),\n    .A_equal_B(A_equal_B),\n    .A_less_B(A_less_B)\n);\n\nassign A_greater = A_greater_B[31];\nassign A_equal = A_equal_B[31];\nassign A_less = A_less_B[31];\n\nendmodule\n\nmodule extend_sign_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output [31:0] A_extended,\n    output [31:0] B_extended\n); ASSISTANT:\nassign A_extended = { {16{A[15]}}, A };\nassign B_extended = { {16{B[15]}}, B };\n\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A_extended,\n    input [31:0] B_extended,\n    output [31:0] A_greater_B,\n    output [31:0] A_equal_B,\n    output [31:0] A_less_B\n); ASSISTANT:\nassign A_greater_B = A_extended > B_extended;\nassign A_equal_B = A_extended == B_extended;\nassign A_less_B = A_extended < B_extended;\n\nendmodule"}
{"task_id": 17, "response": "wire wave1_out_internal;\n    wire wave2_out_internal;\n\n    // Instantiate the submodules\n    basic_wave_gen wave1_gen(\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave1_out_internal)\n    );\n\n    basic_wave_gen wave2_gen(\n        .clk(clk),\n        .reset(reset),\n        .wave_out(wave2_out_internal)\n    );\n\n    phase_ctrl phase_ctrl_inst(\n        .clk(clk),\n        .reset(reset),\n        .phase_shift(phase_shift),\n        .wave_in(wave2_out_internal),\n        .wave_out(wave2_out)\n    );\n\nendmodule\n\nmodule basic_wave_gen(\n    input clk,\n    input reset,\n    output wave_out\n);\n    reg wave_out_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            wave_out_reg <= 1'b0;\n        end else begin\n            wave_out_reg <= ~wave_out_reg;\n        end\n    end\n\n    assign wave_out = wave_out_reg;\nendmodule\n\nmodule phase_ctrl(\n    input clk,\n    input reset,\n    input [3:0] phase_shift,\n    input wave_in,\n    output wave_out\n);\n    reg [3:0] phase_shift_reg;\n    reg wave_out_reg;\n\n    always @(posedge clk or posedge reset) begin\n        if (reset) begin\n            phase_shift_reg <= 4'b0;\n            wave_out_reg <= 1'b0;\n        end else begin\n            phase_shift_reg <= phase_shift_reg + 1'b1;\n            if (phase_shift_reg == phase_shift) begin\n                wave_out_reg <= wave_in;\n                phase_shift_reg <= 4'b0;\n            end\n        end\n    end\n\n    assign wave_out = wave_out_reg;\nendmodule"}
{"task_id": 18, "response": "always @(*) begin\n        case (op_code)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\n\nendmodule"}
{"task_id": 10, "response": "wire [7:0] a0, a1, a2, a3, a4, a5, a6, a7;\n    wire [7:0] b0, b1, b2, b3, b4, b5, b6, b7;\n    wire [7:0] c0, c1, c2, c3, c4, c5, c6, c7;\n    wire [7:0] s0, s1, s2, s3, s4, s5, s6, s7;\n    wire [7:0] c00, c01, c02, c03, c04, c05, c06, c07;\n    wire [7:0] c10, c11, c12, c13, c14, c15, c16, c17;\n    wire [7:0] c20, c21, c22, c23, c24, c25, c26, c27;\n    wire [7:0] c30, c31, c32, c33, c34, c35, c36, c37;\n    wire [7:0] c40, c41, c42, c43, c44, c45, c46, c47;\n    wire [7:0] c50, c51, c52, c53, c54, c55, c56, c57;\n    wire [7:0] c60, c61, c62, c63, c64, c65, c66, c67;\n    wire [7:0] c70, c71, c72, c73, c74, c75, c76, c77;\n\n    assign a0 = a[7:0];\n    assign a1 = a[15:8];\n    assign a2 = a[23:16];\n    assign a3 = a[31:24];\n    assign a4 = 8'b0;\n    assign a5 = 8'b0;\n    assign a6 = 8'b0;\n    assign a7 = 8'b0;\n\n    assign b0 = b[7:0];\n    assign b1 = b[15:8];\n    assign b2 = b[23:16];\n    assign b3 = b[31:24];\n    assign b4 = 8'b0;\n    assign b5 = 8'b0;\n    assign b6 = 8'b0;\n    assign b7 = 8'b0;\n\n    assign c0 = cin;\n    assign c1 = 1'b0;\n    assign c2 = 1'b0;\n    assign c3 = 1'b0;\n    assign c4 = 1'b0;\n    assign c5 = 1'b0;\n    assign c6 = 1'b0;\n    assign c7 = 1'b0;\n\n    assign s0 = a0 + b0 + c0;\n    assign s1 = a1 + b1 + c1;\n    assign s2 = a2 + b2 + c2;\n    assign s3 = a3 + b3 + c3;\n    assign s4 = a4 + b4 + c4;\n    assign s5 = a5 + b5 + c5;\n    assign s6 = a6 + b6 + c6;\n    assign s7 = a7 + b7 + c7;\n\n    assign c00 = s0[7];\n    assign c01 = s1[7];\n    assign c02 = s2[7];\n    assign c03 = s3[7];\n    assign c04 = s4[7];\n    assign c05 = s5[7];\n    assign c06 = s6[7];\n    assign c07 = s7[7];\n\n    assign c10 = s0[6];\n    assign c11 = s1[6];\n    assign c12 = s2[6];\n    assign c13 = s3[6];\n    assign c14 = s4[6"}
{"task_id": 18, "response": "always @(*) begin\n        case (op_code)\n            2'b00: result = a + b;\n            2'b01: result = a - b;\n            2'b10: result = a & b;\n            2'b11: result = a | b;\n        endcase\n    end\n\nendmodule"}
{"task_id": 26, "response": "module extend_sign_16bit(\n    input [15:0] A,\n    output [31:0] A_extended\n); ASSISTANT:\nmodule comparator_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n); ASSISTANT:\nmodule extend_sign_16bit(\n    input [15:0] A,\n    output [31:0] A_extended\n);\n    assign A_extended = {1'b0, A};\nendmodule\n\nmodule comparator_32bit(\n    input [31:0] A,\n    input [31:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n    assign A_greater = (A > B);\n    assign A_equal = (A == B);\n    assign A_less = (A < B);\nendmodule\n\nmodule signed_comparator_16bit(\n    input [15:0] A,\n    input [15:0] B,\n    output A_greater,\n    output A_equal,\n    output A_less\n);\n    wire [31:0] A_extended;\n    wire [31:0] B_extended;\n\n    extend_sign_16bit extend_A(A, A_extended);\n    extend_sign_16bit extend_B(B, B_extended);\n    comparator_32bit compare_inst(A_extended, B_extended, A_greater, A_equal, A_less);\nendmodule"}
{"task_id": 3, "response": "module complex_freq_div (\n    input CLK_in,\n    input RST,\n    output CLK_33,\n    output CLK_20,\n    output CLK_5,\n    output CLK_2\n);\n\n    reg [0:3] counter;\n    reg [0:3] div_3;\n    reg [0:3] div_5;\n    reg [0:3] div_20;\n    reg [0:3] div_50;\n\n    always @(posedge CLK_in or posedge RST) begin\n        if (RST) begin\n            counter <= 0;\n            div_3 <= 0;\n            div_5 <= 0;\n            div_20 <= 0;\n            div_50 <= 0;\n        end else begin\n            if (counter == 9) begin\n                counter <= 0;\n                if (div_3 == 9) begin\n                    div_3 <= 0;\n                end else begin\n                    div_3 <= div_3 + 1;\n                end\n                if (div_5 == 9) begin\n                    div_5 <= 0;\n                end else begin\n                    div_5 <= div_5 + 1;\n                end\n                if (div_20 == 9) begin\n                    div_20 <= 0;\n                end else begin\n                    div_20 <= div_20 + 1;\n                end\n                if (div_50 == 9) begin\n                    div_50 <= 0;\n                end else begin\n                    div_50 <= div_50 + 1;\n                end\n            end else begin\n                counter <= counter + 1;\n            end\n        end\n    end\n\n    assign CLK_33 = (div_3 == 0) ? 0 : CLK_in / 3;\n    assign CLK_20 = (div_5 == 0) ? 0 : CLK_in / 5;\n    assign CLK_5 = (div_20 == 0) ? 0 : CLK_in / 20;\n    assign CLK_2 = (div_50 == 0) ? 0 : CLK_in / 50;\n\nendmodule"}
{"task_id": 4, "response": "endmodule"}
{"task_id": 4, "response": "endmodule"}
{"task_id": 11, "response": "module hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);\n\n    wire [15:0] c_l, c_h;\n    wire [15:0] p_l, p_h;\n\n    // 16-bit carry look-ahead adder\n    assign {c_h, p_h} = a[31:16] + b[31:16] + Cin;\n    assign {c_l, p_l} = a[15:0] + b[15:0] + c_h[15];\n\n    // 8-bit ripple carry adder\n    assign {Co, y[31:16]} = p_h[15] ? {c_l[14], p_l[14:0]} : {c_l[15], p_l[15:1]};\n    assign {Co, y[15:8]} = p_h[7] ? {c_l[6], p_l[6:0]} : {c_l[7], p_l[7:1]};\n    assign {Co, y[7:0]} = p_h[1] ? {c_l[0], p_l[0]} : {c_l[1], p_l[1:1]};\n\nendmodule"}
{"task_id": 19, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);\n\nreg [15:0] stage1_data_a;\nreg [15:0] stage1_data_b;\nreg [1:0] stage1_opcode;\n\nreg [15:0] stage2_data_a;\nreg [15:0] stage2_data_b;\nreg [31:0] stage2_result;\nreg [1:0] stage2_opcode;\n\nreg [31:0] stage3_result;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        stage1_data_a <= 16'b0;\n        stage1_data_b <= 16'b0;\n        stage1_opcode <= 2'b0;\n        stage2_data_a <= 16'b0;\n        stage2_data_b <= 16'b0;\n        stage2_opcode <= 2'b0;\n        stage3_result <= 32'b0;\n    end else begin\n        stage1_data_a <= data_a;\n        stage1_data_b <= data_b;\n        stage1_opcode <= opcode;\n        stage2_data_a <= stage1_data_a;\n        stage2_data_b <= stage1_data_b;\n        stage2_opcode <= stage1_opcode;\n        stage3_result <= stage2_result;\n    end\nend\n\nalways @(posedge clk) begin\n    if (stage2_opcode == 2'b00) begin\n        stage2_result <= stage2_data_a + stage2_data_b;\n    end else if (stage2_opcode == 2'b01) begin\n        stage2_result <= stage2_data_a - stage2_data_b;\n    end else if (stage2_opcode == 2'b10) begin\n        stage2_result <= stage2_data_a * stage2_data_b;\n    end\nend\n\nassign result = stage3_result;\n\nendmodule"}
{"task_id": 27, "response": "module tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);\n\n    // Submodules\n    adder u_adder (.clk(clk), .a(a), .b(b), .result(result));\n    subtractor u_subtractor (.clk(clk), .a(a), .b(b), .result(result));\n    multiplier u_multiplier (.clk(clk), .a(a), .b(b), .result(result));\n\n    // Mode Decoder\n    always @(posedge clk) begin\n        case (mode)\n            2'b00: result <= u_adder.result;\n            2'b01: result <= u_subtractor.result;\n            2'b10: result <= u_multiplier.result;\n            default: result <= 16'b0;\n        endcase\n    end\n\nendmodule\n\nmodule adder(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a + b;\n    end\n\nendmodule\n\nmodule subtractor(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a - b;\n    end\n\nendmodule\n\nmodule multiplier(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a * b;\n    end\n\nendmodule"}
{"task_id": 5, "response": "module arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\nreg [15:0] data_out_stage1, data_out_stage2, data_out_stage3, data_out_stage4, data_out_stage5;\n\n// Input stage\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out_stage1 <= 16'b0;\n    end else begin\n        data_out_stage1 <= data_in;\n    end\nend\n\n// Add stage\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out_stage2 <= 16'b0;\n    end else begin\n        data_out_stage2 <= data_out_stage1 + 16'h1;\n    end\nend\n\n// Multiply stage\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out_stage3 <= 16'b0;\n    end else begin\n        data_out_stage3 <= data_out_stage2 * 16'h2;\n    end\nend\n\n// Subtract stage\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out_stage4 <= 16'b0;\n    end else begin\n        data_out_stage4 <= data_out_stage3 - 16'h3;\n    end\nend\n\n// Output stage\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out_stage5 <= 16'b0;\n    end else begin\n        data_out_stage5 <= data_out_stage4;\n    end\nend\n\nassign data_out = data_out_stage5;\n\nendmodule"}
{"task_id": 5, "response": "module arithmetic_pipeline5(\n    input clk,\n    input rst,\n    input [15:0] data_in,\n    output [15:0] data_out\n);\n\nreg [15:0] data_in_stage1, data_in_stage2, data_in_stage3, data_in_stage4, data_in_stage5;\nreg [15:0] data_out_stage1, data_out_stage2, data_out_stage3, data_out_stage4, data_out_stage5;\n\nalways @(posedge clk) begin\n    if (rst) begin\n        data_in_stage1 <= 16'b0;\n        data_in_stage2 <= 16'b0;\n        data_in_stage3 <= 16'b0;\n        data_in_stage4 <= 16'b0;\n        data_in_stage5 <= 16'b0;\n    end else begin\n        data_in_stage1 <= data_in;\n        data_in_stage2 <= data_in_stage1;\n        data_in_stage3 <= data_in_stage2;\n        data_in_stage4 <= data_in_stage3;\n        data_in_stage5 <= data_in_stage4;\n    end\nend\n\nalways @(posedge clk) begin\n    if (rst) begin\n        data_out_stage1 <= 16'b0;\n        data_out_stage2 <= 16'b0;\n        data_out_stage3 <= 16'b0;\n        data_out_stage4 <= 16'b0;\n        data_out_stage5 <= 16'b0;\n    end else begin\n        data_out_stage1 <= data_in_stage1 + 16'h1;\n        data_out_stage2 <= data_out_stage1;\n        data_out_stage3 <= data_out_stage2;\n        data_out_stage4 <= data_out_stage3;\n        data_out_stage5 <= data_out_stage4;\n    end\nend\n\nassign data_out = data_out_stage5;\n\nendmodule"}
{"task_id": 27, "response": "module tri_op_pe(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    input [1:0] mode,\n    output reg [15:0] result\n);\n\n    wire [15:0] u_adder_result;\n    wire [15:0] u_subtractor_result;\n    wire [15:0] u_multiplier_result;\n\n    // Adder Submodule\n    adder u_adder (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .result(u_adder_result)\n    );\n\n    // Subtractor Submodule\n    subtractor u_subtractor (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .result(u_subtractor_result)\n    );\n\n    // Multiplier Submodule\n    multiplier u_multiplier (\n        .clk(clk),\n        .a(a),\n        .b(b),\n        .result(u_multiplier_result)\n    );\n\n    // Mode Decoder\n    always @(posedge clk) begin\n        case (mode)\n            2'b00: result <= u_adder_result;\n            2'b01: result <= u_subtractor_result;\n            2'b10: result <= u_multiplier_result;\n            default: result <= 16'h0000;\n        endcase\n    end\n\nendmodule\n\n// Adder Submodule\nmodule adder(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a + b;\n    end\n\nendmodule\n\n// Subtractor Submodule\nmodule subtractor(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a - b;\n    end\n\nendmodule\n\n// Multiplier Submodule\nmodule multiplier(\n    input clk,\n    input [15:0] a,\n    input [15:0] b,\n    output reg [15:0] result\n);\n\n    always @(posedge clk) begin\n        result <= a * b;\n    end\n\nendmodule"}
{"task_id": 19, "response": "module arith_pipeline3(\n    input clk,\n    input rst,\n    input [15:0] data_a,\n    input [15:0] data_b,\n    input [1:0] opcode,\n    output [31:0] result\n);\n\nreg [15:0] stage1_data_a;\nreg [15:0] stage1_data_b;\nreg [1:0] stage1_opcode;\nreg [15:0] stage2_data_a;\nreg [15:0] stage2_data_b;\nreg [1:0] stage2_opcode;\nreg [31:0] stage3_result;\n\nreg [31:0] stage1_result;\nreg [31:0] stage2_result;\n\nwire [31:0] stage1_result_wire;\nwire [31:0] stage2_result_wire;\n\nwire [31:0] stage3_result_wire;\n\n// stage1\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        stage1_data_a <= 0;\n        stage1_data_b <= 0;\n        stage1_opcode <= 0;\n    end else begin\n        stage1_data_a <= data_a;\n        stage1_data_b <= data_b;\n        stage1_opcode <= opcode;\n    end\nend\n\n// stage2\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        stage2_data_a <= 0;\n        stage2_data_b <= 0;\n        stage2_opcode <= 0;\n    end else begin\n        stage2_data_a <= stage1_result_wire;\n        stage2_data_b <= stage1_result_wire;\n        stage2_opcode <= stage1_opcode;\n    end\nend\n\n// stage3\nalways @(posedge clk or posedge rst) begin\n    if (rst) begin\n        stage3_result <= 0;\n    end else begin\n        stage3_result <= stage2_result_wire;\n    end\nend\n\nassign stage1_result_wire = (stage1_opcode == 2'b00) ? (stage1_data_a + stage1_data_b) :\n                          (stage1_opcode == 2'b01) ? (stage1_data_a - stage1_data_b) :\n                          (stage1_opcode == 2'b10) ? (stage1_data_a * stage1_data_b) :\n                          0;\n\nassign stage2_result_wire = (stage2_opcode == 2'b00) ? (stage2_data_a + stage2_data_b) :\n                          (stage2_opcode == 2'b01) ? (stage2_data_a - stage2_data_b) :\n                          (stage2_opcode == 2'b10) ? (stage2_data_a * stage2_data_b) :\n                          0;\n\nassign result = stage3_result;\n\nendmodule"}
{"task_id": 11, "response": "module hybrid_adder_32bit (\n    input wire [31:0] a,\n    input wire [31:0] b,\n    input wire Cin,\n    output wire [31:0] y,\n    output wire Co\n);\n\n    wire [15:0] c1;\n    wire [7:0] c2;\n    wire [3:0] c3;\n\n    // Carry look-ahead adder for the higher bits\n    wire [15:0] sum_16;\n    wire [15:0] c1_16;\n    wire [15:0] c2_16;\n    wire [15:0] c3_16;\n    wire [15:0] c4_16;\n    wire [15:0] c5_16;\n    wire [15:0] c6_16;\n    wire [15:0] c7_16;\n    wire [15:0] c8_16;\n    wire [15:0] c9_16;\n    wire [15:0] c10_16;\n    wire [15:0] c11_16;\n    wire [15:0] c12_16;\n    wire [15:0] c13_16;\n    wire [15:0] c14_16;\n    wire [15:0] c15_16;\n    wire [15:0] c16_16;\n\n    // Ripple carry adder for the lower bits\n    wire [7:0] sum_8;\n    wire [7:0] c1_8;\n    wire [7:0] c2_8;\n    wire [7:0] c3_8;\n    wire [7:0] c4_8;\n    wire [7:0] c5_8;\n    wire [7:0] c6_8;\n    wire [7:0] c7_8;\n\n    // Carry propagation\n    wire [15:0] c1_16_1;\n    wire [15:0] c2_16_1;\n    wire [15:0] c3_16_1;\n    wire [15:0] c4_16_1;\n    wire [15:0] c5_16_1;\n    wire [15:0] c6_16_1;\n    wire [15:0] c7_16_1;\n    wire [15:0] c8_16_1;\n    wire [15:0] c9_16_1;\n    wire [15:0] c10_16_1;\n    wire [15:0] c11_16_1;\n    wire [15:0] c12_16_1;\n    wire [15:0] c13_16_1;\n    wire [15:0] c14_16_1;\n    wire [15:0] c15_16_1;\n    wire [15:0] c16_16_1;\n    wire [7:0] c1_8_1;\n    wire [7:0] c2_8_1;\n    wire [7:0] c3_8_1;\n    wire [7:0] c4_8_1;\n    wire [7:0] c5_8_1;\n    wire [7:0] c6_8_1;\n    wire [7:0] c7_8_1;\n\n    // Carry look-ahead adder for the higher bits\n    assign {c1_16, y[15:0]} = a[15:0] + b[15:0] + Cin;\n    assign {c2_16, c1_16_1} = c1_16[15:0] + c1_16[15:0];\n    assign {c3_16, c2_16_1} = c2_16[15:0] + c2_16[15:0];\n    assign {c4_"}
{"task_id": 28, "response": "always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            take_branch <= 1'b0;\n        end else begin\n            case (branch_type)\n                2'b00: take_branch <= condition_flags[0];\n                2'b01: take_branch <= ~condition_flags[0];\n                2'b10: take_branch <= condition_flags[1];\n                2'b11: take_branch <= ~condition_flags[1];\n                default: take_branch <= 1'b0;\n            endcase\n        end\n    end\n\nendmodule"}
{"task_id": 12, "response": "// PE instantiation\n    pe pe0 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[0]),\n        .b(b[0]),\n        .sum(sum[0])\n    );\n    pe pe1 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[1]),\n        .b(b[1]),\n        .sum(sum[1])\n    );\n    pe pe2 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[2]),\n        .b(b[2]),\n        .sum(sum[2])\n    );\n    pe pe3 (\n        .clk(clk),\n        .rst(rst),\n        .a(a[3]),\n        .b(b[3]),\n        .sum(sum[3])\n    );\n\nendmodule"}
{"task_id": 20, "response": "wire [31:0] csr_data_out;\n\n    // CSR register\n    reg [31:0] csr_reg;\n\n    // Read/Write enable signals\n    wire csr_read_en;\n    wire csr_write_en;\n\n    // Output signals\n    wire csr_interrupt_en;\n\n    // Assign output signals\n    assign data_out = csr_data_out;\n    assign interrupt_en = csr_interrupt_en;\n\n    // Assign read/write enable signals\n    assign csr_read_en = read_en;\n    assign csr_write_en = write_en;\n\n    // Reset CSR register\n    always @(posedge clk or negedge rst) begin\n        if (~rst) begin\n            csr_reg <= 32'h0000_0000;\n        end else begin\n            if (csr_write_en) begin\n                csr_reg <= data_in;\n            end\n        end\n    end\n\n    // Output signals\n    assign csr_data_out = csr_reg;\n    assign csr_interrupt_en = csr_reg[1];\n\nendmodule"}
{"task_id": 28, "response": "always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            take_branch <= 1'b0;\n        end else begin\n            case (branch_type)\n                2'b00: take_branch <= condition_flags[0] & condition_flags[1];\n                2'b01: take_branch <= condition_flags[0] | condition_flags[1];\n                2'b10: take_branch <= condition_flags[2] & condition_flags[1];\n                2'b11: take_branch <= condition_flags[2] | condition_flags[1];\n                default: take_branch <= 1'b0;\n            endcase\n        end\n    end\nendmodule"}
{"task_id": 6, "response": "wire [31:0] bs1_out, bs2_out, bs3_out;\n\n    // Byte shifter 1\n    byte_shifter bs1 (\n        .data_in(data_in),\n        .shift(shift[1:0]),\n        .data_out(bs1_out)\n    );\n\n    // Byte shifter 2\n    byte_shifter bs2 (\n        .data_in(bs1_out),\n        .shift(shift[1:0]),\n        .data_out(bs2_out)\n    );\n\n    // Byte shifter 3\n    byte_shifter bs3 (\n        .data_in(bs2_out),\n        .shift(shift[1:0]),\n        .data_out(bs3_out)\n    );\n\n    // Multiplexer\n    always @(*) begin\n        case (shift)\n            2'b00: data_out = bs1_out;\n            2'b01: data_out = bs2_out;\n            2'b10: data_out = bs3_out;\n            2'b11: data_out = {bs3_out[7:0], bs3_out[31:8]};\n            default: data_out = 32'b0;\n        endcase\n    end\nendmodule\n\nmodule byte_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);\n    always @(*) begin\n        case (shift)\n            2'b00: data_out = {data_in[7:0], data_in[31:8]};\n            2'b01: data_out = {data_in[15:0], data_in[31:16]};\n            2'b10: data_out = {data_in[23:0], data_in[31:24]};\n            2'b11: data_out = {data_in[31:0], data_in[31:32]};\n            default: data_out = 32'b0;\n        endcase\n    end\nendmodule"}
{"task_id": 20, "response": "wire [31:0] csr_data_out;\n\n    // CSR register submodule\n    reg [31:0] csr_reg;\n    always @(posedge clk) begin\n        if (rst == 1'b0) begin\n            csr_reg <= 32'h0000_0000;\n        end else if (write_en == 1'b1) begin\n            csr_reg <= data_in;\n        end\n    end\n\n    assign csr_data_out = csr_reg;\n\n    // Interrupt enable signal\n    assign interrupt_en = csr_reg[31];\n\n    // Output data\n    assign data_out = csr_data_out;\n\nendmodule"}
{"task_id": 12, "response": "// PE module\n    reg [7:0] pe_sum[3:0];\n    always @(posedge clk) begin\n        if (rst) begin\n            pe_sum[0] <= 8'd0;\n            pe_sum[1] <= 8'd0;\n            pe_sum[2] <= 8'd0;\n            pe_sum[3] <= 8'd0;\n        end else begin\n            pe_sum[0] <= a[0] + b[0];\n            pe_sum[1] <= a[1] + b[1];\n            pe_sum[2] <= a[2] + b[2];\n            pe_sum[3] <= a[3] + b[3];\n        end\n    end\n    assign sum[0] = pe_sum[0];\n    assign sum[1] = pe_sum[1];\n    assign sum[2] = pe_sum[2];\n    assign sum[3] = pe_sum[3];\nendmodule"}
{"task_id": 29, "response": "wire [3:0] data_in_weighted;\nwire [9:0] data_out_weighted;\nwire [3:0] enable_r;\n\nassign enable_r = enable ? data_in : 4'b0000;\n\nassign data_out_weighted = {data_in_weighted[3], data_in_weighted[3:1]} +\n                           {data_in_weighted[2], data_in_weighted[2:0]} +\n                           {data_in_weighted[1], data_in_weighted[1:0]} +\n                           {data_in_weighted[0], data_in_weighted[0:0]};\n\nassign data_out = data_out_weighted;\n\nassign ready = enable_r[3];\n\nassign data_in_weighted = {data_in[3], data_in[3:1]} +\n                         {data_in[2], data_in[2:0]} +\n                         {data_in[1], data_in[1:0]} +\n                         {data_in[0], data_in[0:0]};\n\nendmodule"}
{"task_id": 6, "response": "wire [31:0] bs1_out, bs2_out, bs3_out;\n    wire [1:0] select;\n\n    byte_shifter bs1 (\n        .data_in(data_in),\n        .shift(2'b00),\n        .data_out(bs1_out)\n    );\n\n    byte_shifter bs2 (\n        .data_in(bs1_out),\n        .shift(shift[1:0]),\n        .data_out(bs2_out)\n    );\n\n    byte_shifter bs3 (\n        .data_in(bs2_out),\n        .shift(shift[1:0]),\n        .data_out(bs3_out)\n    );\n\n    always @(*) begin\n        select = shift[1:0];\n        case (select)\n            2'b00: data_out = bs1_out;\n            2'b01: data_out = {bs2_out[7:0], bs1_out[31:8]};\n            2'b10: data_out = {bs3_out[15:0], bs2_out[31:16]};\n            2'b11: data_out = {bs3_out[23:0], bs3_out[31:24]};\n            default: data_out = 32'b0;\n        endcase\n    end\nendmodule\n\nmodule byte_shifter (\n    input [31:0] data_in,\n    input [1:0] shift,\n    output reg [31:0] data_out\n);\n    always @(*) begin\n        data_out = data_in << shift;\n    end\nendmodule"}
{"task_id": 13, "response": "module dual_mode_subtractor(A, B, mode, Result, Overflow);\ninput [31:0] A, B;\ninput mode;\noutput [31:0] Result;\noutput Overflow;\n\nwire [31:0] unsigned_subtractor_output;\nwire [31:0] twos_complement_subtractor_output;\n\nsubtractor_32bit_unsigned unsigned_subtractor(\n    .A(A),\n    .B(B),\n    .Result(unsigned_subtractor_output)\n);\n\nsubtractor_32bit_twos_complement twos_complement_subtractor(\n    .A(A),\n    .B(B),\n    .Result(twos_complement_subtractor_output)\n);\n\nassign Result = (mode) ? twos_complement_subtractor_output : unsigned_subtractor_output;\nassign Overflow = (mode) ? 1'b0 : 1'b0;\n\nendmodule\n\nmodule subtractor_32bit_unsigned(A, B, Result);\ninput [31:0] A, B;\noutput [31:0] Result;\n\nassign Result = A - B;\n\nendmodule\n\nmodule subtractor_32bit_twos_complement(A, B, Result);\ninput [31:0] A, B;\noutput [31:0] Result;\n\nassign Result = A - B;\n\nendmodule"}
{"task_id": 29, "response": "wire               ready_i;\n    reg                ready_r;\n    reg  [9:0]         data_out_r;\n\n    // Input Weighting Module\n    wire [3:0] weighted_data;\n    assign weighted_data[0] = data_in[0];\n    assign weighted_data[1] = data_in[0] + data_in[1];\n    assign weighted_data[2] = data_in[1] + data_in[2];\n    assign weighted_data[3] = data_in[2] + data_in[3];\n\n    // Accumulation Control Module\n    reg [1:0] count;\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            count <= 2'b00;\n        end else begin\n            if (enable) begin\n                count <= count + 1;\n            end\n        end\n    end\n\n    // Output Module\n    always @(posedge clk or negedge rst_n) begin\n        if (~rst_n) begin\n            ready_r <= 1'b0;\n            data_out_r <= 10'b0;\n        end else begin\n            if (count == 2'b11) begin\n                ready_r <= 1'b1;\n                data_out_r <= weighted_data[3] + weighted_data[2] + weighted_data[1] + weighted_data[0];\n            end else begin\n                ready_r <= 1'b0;\n                data_out_r <= data_out_r;\n            end\n        end\n    end\n\n    assign ready = ready_r;\n    assign data_out = data_out_r;\n\nendmodule"}
{"task_id": 13, "response": "module dual_mode_subtractor(A, B, mode, Result, Overflow);\ninput [31:0] A, B;\ninput mode;\noutput [31:0] Result;\noutput Overflow;\n\nwire [31:0] unsigned_subtractor_output;\nwire [31:0] twos_complement_subtractor_output;\n\nsubtractor_32bit_unsigned unsigned_subtractor(\n    .A(A),\n    .B(B),\n    .Result(unsigned_subtractor_output),\n    .Overflow()\n);\n\nsubtractor_32bit_twos_complement twos_complement_subtractor(\n    .A(A),\n    .B(B),\n    .Result(twos_complement_subtractor_output),\n    .Overflow()\n);\n\nassign Result = (mode) ? twos_complement_subtractor_output : unsigned_subtractor_output;\n\nendmodule\n\nmodule subtractor_32bit_unsigned(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] Result,\n    output Overflow\n);\n\nwire [31:0] temp_result;\n\nassign {Overflow, temp_result} = A - B;\nassign Result = temp_result;\n\nendmodule\n\nmodule subtractor_32bit_twos_complement(\n    input [31:0] A,\n    input [31:0] B,\n    output [31:0] Result,\n    output Overflow\n);\n\nwire [31:0] temp_result;\n\nassign {Overflow, temp_result} = A - B;\nassign Result = temp_result;\n\nendmodule"}
